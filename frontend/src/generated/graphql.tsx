import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  jsonb: any;
  numeric: any;
  timestamptz: any;
  uuid: any;
};


/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Boolean']>;
  readonly _gt?: Maybe<Scalars['Boolean']>;
  readonly _gte?: Maybe<Scalars['Boolean']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Boolean']>;
  readonly _lte?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Scalars['Boolean']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
};

export type ConfirmInvitationOutput = {
  readonly __typename?: 'ConfirmInvitationOutput';
  readonly confSlug?: Maybe<Scalars['String']>;
  readonly ok: Scalars['String'];
};

export type CreateItemRoomOutput = {
  readonly __typename?: 'CreateItemRoomOutput';
  readonly message?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId?: Maybe<Scalars['String']>;
};

export type CreateRoomDmOutput = {
  readonly __typename?: 'CreateRoomDmOutput';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "Email" */
export type Email = {
  readonly __typename?: 'Email';
  readonly createdAt: Scalars['timestamptz'];
  readonly emailAddress: Scalars['String'];
  readonly htmlContents: Scalars['String'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Registrant_Invitation>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents: Scalars['String'];
  readonly reason: Scalars['String'];
  readonly recipientName?: Maybe<Scalars['String']>;
  readonly retriesCount: Scalars['Int'];
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregated selection of "Email" */
export type Email_Aggregate = {
  readonly __typename?: 'Email_aggregate';
  readonly aggregate?: Maybe<Email_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Email>;
};

/** aggregate fields of "Email" */
export type Email_Aggregate_Fields = {
  readonly __typename?: 'Email_aggregate_fields';
  readonly avg?: Maybe<Email_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Email_Max_Fields>;
  readonly min?: Maybe<Email_Min_Fields>;
  readonly stddev?: Maybe<Email_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Email_Sum_Fields>;
  readonly var_pop?: Maybe<Email_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Email_Var_Samp_Fields>;
  readonly variance?: Maybe<Email_Variance_Fields>;
};


/** aggregate fields of "Email" */
export type Email_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Email_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Email" */
export type Email_Aggregate_Order_By = {
  readonly avg?: Maybe<Email_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Email_Max_Order_By>;
  readonly min?: Maybe<Email_Min_Order_By>;
  readonly stddev?: Maybe<Email_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Email_Sum_Order_By>;
  readonly var_pop?: Maybe<Email_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Email_Var_Samp_Order_By>;
  readonly variance?: Maybe<Email_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Email" */
export type Email_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Email_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Email_On_Conflict>;
};

/** aggregate avg on columns */
export type Email_Avg_Fields = {
  readonly __typename?: 'Email_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Email" */
export type Email_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Email". All fields are combined with a logical 'AND'. */
export type Email_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Email_Bool_Exp>>;
  readonly _not?: Maybe<Email_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Email_Bool_Exp>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emailAddress?: Maybe<String_Comparison_Exp>;
  readonly htmlContents?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly invitationId?: Maybe<Uuid_Comparison_Exp>;
  readonly plainTextContents?: Maybe<String_Comparison_Exp>;
  readonly reason?: Maybe<String_Comparison_Exp>;
  readonly recipientName?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly sentAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly subject?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Email" */
export enum Email_Constraint {
  /** unique or primary key constraint */
  EmailPkey = 'Email_pkey'
}

/** input type for incrementing numeric columns in table "Email" */
export type Email_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Email" */
export type Email_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Registrant_Invitation_Obj_Rel_Insert_Input>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly recipientName?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Email_Max_Fields = {
  readonly __typename?: 'Email_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly recipientName?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Email" */
export type Email_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly recipientName?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Email_Min_Fields = {
  readonly __typename?: 'Email_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly recipientName?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Email" */
export type Email_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly recipientName?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "Email" */
export type Email_Mutation_Response = {
  readonly __typename?: 'Email_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Email>;
};

/** on conflict condition type for table "Email" */
export type Email_On_Conflict = {
  readonly constraint: Email_Constraint;
  readonly update_columns?: ReadonlyArray<Email_Update_Column>;
  readonly where?: Maybe<Email_Bool_Exp>;
};

/** Ordering options when selecting data from "Email". */
export type Email_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Registrant_Invitation_Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly recipientName?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: Email */
export type Email_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Email" */
export enum Email_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RecipientName = 'recipientName',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "Email" */
export type Email_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly recipientName?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Email_Stddev_Fields = {
  readonly __typename?: 'Email_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Email" */
export type Email_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Email_Stddev_Pop_Fields = {
  readonly __typename?: 'Email_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Email" */
export type Email_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Email_Stddev_Samp_Fields = {
  readonly __typename?: 'Email_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Email" */
export type Email_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Email_Sum_Fields = {
  readonly __typename?: 'Email_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Email" */
export type Email_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "Email" */
export enum Email_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RecipientName = 'recipientName',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** aggregate var_pop on columns */
export type Email_Var_Pop_Fields = {
  readonly __typename?: 'Email_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Email" */
export type Email_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Email_Var_Samp_Fields = {
  readonly __typename?: 'Email_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Email" */
export type Email_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Email_Variance_Fields = {
  readonly __typename?: 'Email_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Email" */
export type Email_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** columns and relationships of "FlatUnauthPermission" */
export type FlatUnauthPermission = {
  readonly __typename?: 'FlatUnauthPermission';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate = {
  readonly __typename?: 'FlatUnauthPermission_aggregate';
  readonly aggregate?: Maybe<FlatUnauthPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUnauthPermission>;
};

/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUnauthPermission_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<FlatUnauthPermission_Max_Fields>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Fields>;
};


/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUnauthPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "FlatUnauthPermission" */
export type FlatUnauthPermission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<FlatUnauthPermission_Insert_Input>;
};

/** Boolean expression to filter rows from the table "FlatUnauthPermission". All fields are combined with a logical 'AND'. */
export type FlatUnauthPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<FlatUnauthPermission_Bool_Exp>>;
  readonly _not?: Maybe<FlatUnauthPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<FlatUnauthPermission_Bool_Exp>>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "FlatUnauthPermission" */
export type FlatUnauthPermission_Insert_Input = {
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type FlatUnauthPermission_Max_Fields = {
  readonly __typename?: 'FlatUnauthPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUnauthPermission_Min_Fields = {
  readonly __typename?: 'FlatUnauthPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** Ordering options when selecting data from "FlatUnauthPermission". */
export type FlatUnauthPermission_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** select columns of table "FlatUnauthPermission" */
export enum FlatUnauthPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug'
}

/** columns and relationships of "FlatUserPermission" */
export type FlatUserPermission = {
  readonly __typename?: 'FlatUserPermission';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  /** An object relationship */
  readonly permission?: Maybe<Permissions_Permission>;
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUserPermission" */
export type FlatUserPermission_Aggregate = {
  readonly __typename?: 'FlatUserPermission_aggregate';
  readonly aggregate?: Maybe<FlatUserPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUserPermission>;
};

/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUserPermission_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<FlatUserPermission_Max_Fields>;
  readonly min?: Maybe<FlatUserPermission_Min_Fields>;
};


/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUserPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUserPermission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "FlatUserPermission" */
export type FlatUserPermission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<FlatUserPermission_Insert_Input>;
};

/** Boolean expression to filter rows from the table "FlatUserPermission". All fields are combined with a logical 'AND'. */
export type FlatUserPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<FlatUserPermission_Bool_Exp>>;
  readonly _not?: Maybe<FlatUserPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<FlatUserPermission_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly permission?: Maybe<Permissions_Permission_Bool_Exp>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly user_id?: Maybe<String_Comparison_Exp>;
};

/** input type for inserting data into table "FlatUserPermission" */
export type FlatUserPermission_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly permission?: Maybe<Permissions_Permission_Obj_Rel_Insert_Input>;
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type FlatUserPermission_Max_Fields = {
  readonly __typename?: 'FlatUserPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUserPermission_Min_Fields = {
  readonly __typename?: 'FlatUserPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** Ordering options when selecting data from "FlatUserPermission". */
export type FlatUserPermission_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly permission?: Maybe<Permissions_Permission_Order_By>;
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** select columns of table "FlatUserPermission" */
export enum FlatUserPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug',
  /** column name */
  UserId = 'user_id'
}

/** Boolean expression to compare columns of type "Float". All fields are combined with logical 'AND'. */
export type Float_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Float']>;
  readonly _gt?: Maybe<Scalars['Float']>;
  readonly _gte?: Maybe<Scalars['Float']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Float']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Float']>;
  readonly _lte?: Maybe<Scalars['Float']>;
  readonly _neq?: Maybe<Scalars['Float']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Float']>>;
};

export type GetGoogleOAuthUrlOutput = {
  readonly __typename?: 'GetGoogleOAuthUrlOutput';
  readonly url: Scalars['String'];
};

export type GetSlugOutput = {
  readonly __typename?: 'GetSlugOutput';
  readonly slug?: Maybe<Scalars['String']>;
};

export type GetUploadAgreementOutput = {
  readonly __typename?: 'GetUploadAgreementOutput';
  readonly agreementText?: Maybe<Scalars['String']>;
  readonly agreementUrl?: Maybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Int']>;
  readonly _gt?: Maybe<Scalars['Int']>;
  readonly _gte?: Maybe<Scalars['Int']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Int']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Int']>;
  readonly _lte?: Maybe<Scalars['Int']>;
  readonly _neq?: Maybe<Scalars['Int']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Int']>>;
};

export type JoinEventVonageSessionOutput = {
  readonly __typename?: 'JoinEventVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly isRecorded?: Maybe<Scalars['Boolean']>;
};

export type JoinRoomChimeSessionOutput = {
  readonly __typename?: 'JoinRoomChimeSessionOutput';
  readonly meeting?: Maybe<Scalars['jsonb']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly registrant?: Maybe<Scalars['jsonb']>;
};

export type JoinRoomVonageSessionOutput = {
  readonly __typename?: 'JoinRoomVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly isRecorded?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sessionId?: Maybe<Scalars['String']>;
};

export type MatchingPersonOutput = {
  readonly __typename?: 'MatchingPersonOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
};

export type NotifyEventEnded = {
  readonly __typename?: 'NotifyEventEnded';
  readonly ok: Scalars['Boolean'];
};

export type PresenceFlushOutput = {
  readonly __typename?: 'PresenceFlushOutput';
  readonly ok?: Maybe<Scalars['String']>;
};

export type PresenceSummaryOutput = {
  readonly __typename?: 'PresenceSummaryOutput';
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs: Scalars['Int'];
  readonly total_unique_user_ids: Scalars['Int'];
};

/** columns and relationships of "PushNotificationSubscription" */
export type PushNotificationSubscription = {
  readonly __typename?: 'PushNotificationSubscription';
  readonly auth: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  readonly endpoint: Scalars['String'];
  readonly p256dh: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly user: User;
  readonly userId: Scalars['String'];
};

/** aggregated selection of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate = {
  readonly __typename?: 'PushNotificationSubscription_aggregate';
  readonly aggregate?: Maybe<PushNotificationSubscription_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<PushNotificationSubscription>;
};

/** aggregate fields of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_Fields = {
  readonly __typename?: 'PushNotificationSubscription_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<PushNotificationSubscription_Max_Fields>;
  readonly min?: Maybe<PushNotificationSubscription_Min_Fields>;
};


/** aggregate fields of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<PushNotificationSubscription_Max_Order_By>;
  readonly min?: Maybe<PushNotificationSubscription_Min_Order_By>;
};

/** input type for inserting array relation for remote table "PushNotificationSubscription" */
export type PushNotificationSubscription_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<PushNotificationSubscription_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};

/** Boolean expression to filter rows from the table "PushNotificationSubscription". All fields are combined with a logical 'AND'. */
export type PushNotificationSubscription_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<PushNotificationSubscription_Bool_Exp>>;
  readonly _not?: Maybe<PushNotificationSubscription_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<PushNotificationSubscription_Bool_Exp>>;
  readonly auth?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpoint?: Maybe<String_Comparison_Exp>;
  readonly p256dh?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Constraint {
  /** unique or primary key constraint */
  PushNotificationSubscriptionPkey = 'PushNotificationSubscription_pkey'
}

/** input type for inserting data into table "PushNotificationSubscription" */
export type PushNotificationSubscription_Insert_Input = {
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PushNotificationSubscription_Max_Fields = {
  readonly __typename?: 'PushNotificationSubscription_max_fields';
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Max_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type PushNotificationSubscription_Min_Fields = {
  readonly __typename?: 'PushNotificationSubscription_min_fields';
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Min_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "PushNotificationSubscription" */
export type PushNotificationSubscription_Mutation_Response = {
  readonly __typename?: 'PushNotificationSubscription_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<PushNotificationSubscription>;
};

/** on conflict condition type for table "PushNotificationSubscription" */
export type PushNotificationSubscription_On_Conflict = {
  readonly constraint: PushNotificationSubscription_Constraint;
  readonly update_columns?: ReadonlyArray<PushNotificationSubscription_Update_Column>;
  readonly where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};

/** Ordering options when selecting data from "PushNotificationSubscription". */
export type PushNotificationSubscription_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: PushNotificationSubscription */
export type PushNotificationSubscription_Pk_Columns_Input = {
  readonly endpoint: Scalars['String'];
};

/** select columns of table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Select_Column {
  /** column name */
  Auth = 'auth',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  P256dh = 'p256dh',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "PushNotificationSubscription" */
export type PushNotificationSubscription_Set_Input = {
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Update_Column {
  /** column name */
  Auth = 'auth',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  P256dh = 'p256dh',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

export type RefreshYouTubeDataOutput = {
  readonly __typename?: 'RefreshYouTubeDataOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type StopEventBroadcastOutput = {
  readonly __typename?: 'StopEventBroadcastOutput';
  readonly broadcastsStopped: Scalars['Int'];
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['String']>;
  readonly _gt?: Maybe<Scalars['String']>;
  readonly _gte?: Maybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  readonly _ilike?: Maybe<Scalars['String']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  readonly _iregex?: Maybe<Scalars['String']>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  readonly _like?: Maybe<Scalars['String']>;
  readonly _lt?: Maybe<Scalars['String']>;
  readonly _lte?: Maybe<Scalars['String']>;
  readonly _neq?: Maybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  readonly _nilike?: Maybe<Scalars['String']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  readonly _niregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  readonly _nlike?: Maybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  readonly _nregex?: Maybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  readonly _nsimilar?: Maybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  readonly _regex?: Maybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  readonly _similar?: Maybe<Scalars['String']>;
};

export type SubmitGoogleOAuthCodeOutput = {
  readonly __typename?: 'SubmitGoogleOAuthCodeOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type SubmitUpdatedSubtitlesOutput = {
  readonly __typename?: 'SubmitUpdatedSubtitlesOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

export type SubmitUploadableElementOutput = {
  readonly __typename?: 'SubmitUploadableElementOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

export type ToggleVonageRecordingStateOutput = {
  readonly __typename?: 'ToggleVonageRecordingStateOutput';
  readonly allowed: Scalars['Boolean'];
  readonly recordingState: Scalars['Boolean'];
};

export type UpdateProfilePhotoResponse = {
  readonly __typename?: 'UpdateProfilePhotoResponse';
  readonly ok: Scalars['Boolean'];
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
};

/** columns and relationships of "User" */
export type User = {
  readonly __typename?: 'User';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly conferenceDemoCodes: ReadonlyArray<Conference_DemoCode>;
  /** An aggregate relationship */
  readonly conferenceDemoCodes_aggregate: Conference_DemoCode_Aggregate;
  /** An array relationship */
  readonly conferencesCreated: ReadonlyArray<Conference_Conference>;
  /** An aggregate relationship */
  readonly conferencesCreated_aggregate: Conference_Conference_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregate relationship */
  readonly emails_aggregate: Email_Aggregate;
  readonly id: Scalars['String'];
  /** An array relationship */
  readonly invitationsPendingConfirmation: ReadonlyArray<Registrant_Invitation>;
  /** An aggregate relationship */
  readonly invitationsPendingConfirmation_aggregate: Registrant_Invitation_Aggregate;
  /** An array relationship */
  readonly pushNotificationSubscriptions: ReadonlyArray<PushNotificationSubscription>;
  /** An aggregate relationship */
  readonly pushNotificationSubscriptions_aggregate: PushNotificationSubscription_Aggregate;
  /** An array relationship */
  readonly registrants: ReadonlyArray<Registrant_Registrant>;
  /** An aggregate relationship */
  readonly registrants_aggregate: Registrant_Registrant_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodes_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreatedArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreated_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserPushNotificationSubscriptionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserPushNotificationSubscriptions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};

/** aggregated selection of "User" */
export type User_Aggregate = {
  readonly __typename?: 'User_aggregate';
  readonly aggregate?: Maybe<User_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<User>;
};

/** aggregate fields of "User" */
export type User_Aggregate_Fields = {
  readonly __typename?: 'User_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<User_Max_Fields>;
  readonly min?: Maybe<User_Min_Fields>;
};


/** aggregate fields of "User" */
export type User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "User". All fields are combined with a logical 'AND'. */
export type User_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<User_Bool_Exp>>;
  readonly _not?: Maybe<User_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<User_Bool_Exp>>;
  readonly acceptedPrivacyPolicyAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly acceptedTermsAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly conferenceDemoCodes?: Maybe<Conference_DemoCode_Bool_Exp>;
  readonly conferencesCreated?: Maybe<Conference_Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly id?: Maybe<String_Comparison_Exp>;
  readonly invitationsPendingConfirmation?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly pushNotificationSubscriptions?: Maybe<PushNotificationSubscription_Bool_Exp>;
  readonly registrants?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "User" */
export enum User_Constraint {
  /** unique or primary key constraint */
  UserEmailKey = 'user_email_key',
  /** unique or primary key constraint */
  UserPkey = 'user_pkey'
}

/** input type for inserting data into table "User" */
export type User_Insert_Input = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly conferenceDemoCodes?: Maybe<Conference_DemoCode_Arr_Rel_Insert_Input>;
  readonly conferencesCreated?: Maybe<Conference_Conference_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['String']>;
  readonly invitationsPendingConfirmation?: Maybe<Registrant_Invitation_Arr_Rel_Insert_Input>;
  readonly pushNotificationSubscriptions?: Maybe<PushNotificationSubscription_Arr_Rel_Insert_Input>;
  readonly registrants?: Maybe<Registrant_Registrant_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type User_Max_Fields = {
  readonly __typename?: 'User_max_fields';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type User_Min_Fields = {
  readonly __typename?: 'User_min_fields';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "User" */
export type User_Mutation_Response = {
  readonly __typename?: 'User_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<User>;
};

/** input type for inserting object relation for remote table "User" */
export type User_Obj_Rel_Insert_Input = {
  readonly data: User_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<User_On_Conflict>;
};

/** on conflict condition type for table "User" */
export type User_On_Conflict = {
  readonly constraint: User_Constraint;
  readonly update_columns?: ReadonlyArray<User_Update_Column>;
  readonly where?: Maybe<User_Bool_Exp>;
};

/** Ordering options when selecting data from "User". */
export type User_Order_By = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Order_By>;
  readonly acceptedTermsAt?: Maybe<Order_By>;
  readonly conferenceDemoCodes_aggregate?: Maybe<Conference_DemoCode_Aggregate_Order_By>;
  readonly conferencesCreated_aggregate?: Maybe<Conference_Conference_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationsPendingConfirmation_aggregate?: Maybe<Registrant_Invitation_Aggregate_Order_By>;
  readonly pushNotificationSubscriptions_aggregate?: Maybe<PushNotificationSubscription_Aggregate_Order_By>;
  readonly registrants_aggregate?: Maybe<Registrant_Registrant_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: User */
export type User_Pk_Columns_Input = {
  readonly id: Scalars['String'];
};

/** select columns of table "User" */
export enum User_Select_Column {
  /** column name */
  AcceptedPrivacyPolicyAt = 'acceptedPrivacyPolicyAt',
  /** column name */
  AcceptedTermsAt = 'acceptedTermsAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "User" */
export type User_Set_Input = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "User" */
export enum User_Update_Column {
  /** column name */
  AcceptedPrivacyPolicyAt = 'acceptedPrivacyPolicyAt',
  /** column name */
  AcceptedTermsAt = 'acceptedTermsAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type VapidPublicKeyOutput = {
  readonly __typename?: 'VAPIDPublicKeyOutput';
  readonly key: Scalars['String'];
};

/** columns and relationships of "analytics.AppStats" */
export type Analytics_AppStats = {
  readonly __typename?: 'analytics_AppStats';
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['Int'];
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs: Scalars['Int'];
  readonly total_unique_user_ids: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "analytics.AppStats" */
export type Analytics_AppStatsPagesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate = {
  readonly __typename?: 'analytics_AppStats_aggregate';
  readonly aggregate?: Maybe<Analytics_AppStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_AppStats>;
};

/** aggregate fields of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_AppStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_AppStats_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_AppStats_Max_Fields>;
  readonly min?: Maybe<Analytics_AppStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_AppStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_AppStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_AppStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_AppStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_AppStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_AppStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_AppStats_Variance_Fields>;
};


/** aggregate fields of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Analytics_AppStats_Append_Input = {
  readonly pages?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Analytics_AppStats_Avg_Fields = {
  readonly __typename?: 'analytics_AppStats_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "analytics.AppStats". All fields are combined with a logical 'AND'. */
export type Analytics_AppStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_AppStats_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_AppStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_AppStats_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly pages?: Maybe<Jsonb_Comparison_Exp>;
  readonly total_unique_tabs?: Maybe<Int_Comparison_Exp>;
  readonly total_unique_user_ids?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.AppStats" */
export enum Analytics_AppStats_Constraint {
  /** unique or primary key constraint */
  AppStatsPkey = 'AppStats_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Analytics_AppStats_Delete_At_Path_Input = {
  readonly pages?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Analytics_AppStats_Delete_Elem_Input = {
  readonly pages?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Analytics_AppStats_Delete_Key_Input = {
  readonly pages?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "analytics.AppStats" */
export type Analytics_AppStats_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.AppStats" */
export type Analytics_AppStats_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Analytics_AppStats_Max_Fields = {
  readonly __typename?: 'analytics_AppStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Analytics_AppStats_Min_Fields = {
  readonly __typename?: 'analytics_AppStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "analytics.AppStats" */
export type Analytics_AppStats_Mutation_Response = {
  readonly __typename?: 'analytics_AppStats_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Analytics_AppStats>;
};

/** on conflict condition type for table "analytics.AppStats" */
export type Analytics_AppStats_On_Conflict = {
  readonly constraint: Analytics_AppStats_Constraint;
  readonly update_columns?: ReadonlyArray<Analytics_AppStats_Update_Column>;
  readonly where?: Maybe<Analytics_AppStats_Bool_Exp>;
};

/** Ordering options when selecting data from "analytics.AppStats". */
export type Analytics_AppStats_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly pages?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: analytics_AppStats */
export type Analytics_AppStats_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Analytics_AppStats_Prepend_Input = {
  readonly pages?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "analytics.AppStats" */
export enum Analytics_AppStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pages = 'pages',
  /** column name */
  TotalUniqueTabs = 'total_unique_tabs',
  /** column name */
  TotalUniqueUserIds = 'total_unique_user_ids',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "analytics.AppStats" */
export type Analytics_AppStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Analytics_AppStats_Stddev_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Analytics_AppStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Analytics_AppStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Analytics_AppStats_Sum_Fields = {
  readonly __typename?: 'analytics_AppStats_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
};

/** update columns of table "analytics.AppStats" */
export enum Analytics_AppStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pages = 'pages',
  /** column name */
  TotalUniqueTabs = 'total_unique_tabs',
  /** column name */
  TotalUniqueUserIds = 'total_unique_user_ids',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Analytics_AppStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_AppStats_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Analytics_AppStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_AppStats_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Analytics_AppStats_Variance_Fields = {
  readonly __typename?: 'analytics_AppStats_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "analytics.CompletedRegistrations" */
export type Analytics_CompletedRegistrations = {
  readonly __typename?: 'analytics_CompletedRegistrations';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly count?: Maybe<Scalars['bigint']>;
  readonly id?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "analytics.CompletedRegistrations" */
export type Analytics_CompletedRegistrations_Aggregate = {
  readonly __typename?: 'analytics_CompletedRegistrations_aggregate';
  readonly aggregate?: Maybe<Analytics_CompletedRegistrations_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_CompletedRegistrations>;
};

/** aggregate fields of "analytics.CompletedRegistrations" */
export type Analytics_CompletedRegistrations_Aggregate_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_aggregate_fields';
  readonly avg?: Maybe<Analytics_CompletedRegistrations_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_CompletedRegistrations_Max_Fields>;
  readonly min?: Maybe<Analytics_CompletedRegistrations_Min_Fields>;
  readonly stddev?: Maybe<Analytics_CompletedRegistrations_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_CompletedRegistrations_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_CompletedRegistrations_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_CompletedRegistrations_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_CompletedRegistrations_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_CompletedRegistrations_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_CompletedRegistrations_Variance_Fields>;
};


/** aggregate fields of "analytics.CompletedRegistrations" */
export type Analytics_CompletedRegistrations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Analytics_CompletedRegistrations_Avg_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_avg_fields';
  readonly count?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "analytics.CompletedRegistrations". All fields are combined with a logical 'AND'. */
export type Analytics_CompletedRegistrations_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_CompletedRegistrations_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly count?: Maybe<Bigint_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for inserting data into table "analytics.CompletedRegistrations" */
export type Analytics_CompletedRegistrations_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly count?: Maybe<Scalars['bigint']>;
  readonly id?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Analytics_CompletedRegistrations_Max_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_max_fields';
  readonly count?: Maybe<Scalars['bigint']>;
  readonly id?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Analytics_CompletedRegistrations_Min_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_min_fields';
  readonly count?: Maybe<Scalars['bigint']>;
  readonly id?: Maybe<Scalars['uuid']>;
};

/** input type for inserting object relation for remote table "analytics.CompletedRegistrations" */
export type Analytics_CompletedRegistrations_Obj_Rel_Insert_Input = {
  readonly data: Analytics_CompletedRegistrations_Insert_Input;
};

/** Ordering options when selecting data from "analytics.CompletedRegistrations". */
export type Analytics_CompletedRegistrations_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** select columns of table "analytics.CompletedRegistrations" */
export enum Analytics_CompletedRegistrations_Select_Column {
  /** column name */
  Count = 'count',
  /** column name */
  Id = 'id'
}

/** aggregate stddev on columns */
export type Analytics_CompletedRegistrations_Stddev_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_stddev_fields';
  readonly count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Analytics_CompletedRegistrations_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_stddev_pop_fields';
  readonly count?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Analytics_CompletedRegistrations_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_stddev_samp_fields';
  readonly count?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Analytics_CompletedRegistrations_Sum_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_sum_fields';
  readonly count?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Analytics_CompletedRegistrations_Var_Pop_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_var_pop_fields';
  readonly count?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Analytics_CompletedRegistrations_Var_Samp_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_var_samp_fields';
  readonly count?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Analytics_CompletedRegistrations_Variance_Fields = {
  readonly __typename?: 'analytics_CompletedRegistrations_variance_fields';
  readonly count?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats = {
  readonly __typename?: 'analytics_ContentElementStats';
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly element: Content_Element;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
  readonly viewCount: Scalars['Int'];
};

/** aggregated selection of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate = {
  readonly __typename?: 'analytics_ContentElementStats_aggregate';
  readonly aggregate?: Maybe<Analytics_ContentElementStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ContentElementStats>;
};

/** aggregate fields of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_ContentElementStats_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_ContentElementStats_Max_Fields>;
  readonly min?: Maybe<Analytics_ContentElementStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ContentElementStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ContentElementStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ContentElementStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ContentElementStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ContentElementStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ContentElementStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ContentElementStats_Variance_Fields>;
};


/** aggregate fields of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_ContentElementStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_ContentElementStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_ContentElementStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_ContentElementStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_ContentElementStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_ContentElementStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_ContentElementStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_ContentElementStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_ContentElementStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_ContentElementStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_ContentElementStats_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Analytics_ContentElementStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_ContentElementStats_Avg_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_avg_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Avg_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.ContentElementStats". All fields are combined with a logical 'AND'. */
export type Analytics_ContentElementStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly viewCount?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.ContentElementStats" */
export enum Analytics_ContentElementStats_Constraint {
  /** unique or primary key constraint */
  ContentElementStatsIdKey = 'ContentElementStats_id_key',
  /** unique or primary key constraint */
  ContentElementStatsPkey = 'ContentElementStats_pkey'
}

/** input type for incrementing numeric columns in table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Inc_Input = {
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Analytics_ContentElementStats_Max_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_ContentElementStats_Min_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Mutation_Response = {
  readonly __typename?: 'analytics_ContentElementStats_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Analytics_ContentElementStats>;
};

/** on conflict condition type for table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_On_Conflict = {
  readonly constraint: Analytics_ContentElementStats_Constraint;
  readonly update_columns?: ReadonlyArray<Analytics_ContentElementStats_Update_Column>;
  readonly where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};

/** Ordering options when selecting data from "analytics.ContentElementStats". */
export type Analytics_ContentElementStats_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** primary key columns input for table: analytics_ContentElementStats */
export type Analytics_ContentElementStats_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "analytics.ContentElementStats" */
export enum Analytics_ContentElementStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** input type for updating data in table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Analytics_ContentElementStats_Stddev_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_stddev_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Stddev_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ContentElementStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_stddev_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Stddev_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ContentElementStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_stddev_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Stddev_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_ContentElementStats_Sum_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_sum_fields';
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Sum_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.ContentElementStats" */
export enum Analytics_ContentElementStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** aggregate var_pop on columns */
export type Analytics_ContentElementStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_var_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Var_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_ContentElementStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_var_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Var_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_ContentElementStats_Variance_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_variance_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Variance_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats = {
  readonly __typename?: 'analytics_ContentItemStats';
  /** An object relationship */
  readonly contentGroup: Content_Item;
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly itemId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
  readonly viewCount: Scalars['Int'];
};

/** aggregated selection of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate = {
  readonly __typename?: 'analytics_ContentItemStats_aggregate';
  readonly aggregate?: Maybe<Analytics_ContentItemStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ContentItemStats>;
};

/** aggregate fields of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_ContentItemStats_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_ContentItemStats_Max_Fields>;
  readonly min?: Maybe<Analytics_ContentItemStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ContentItemStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ContentItemStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ContentItemStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ContentItemStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ContentItemStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ContentItemStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ContentItemStats_Variance_Fields>;
};


/** aggregate fields of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_ContentItemStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_ContentItemStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_ContentItemStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_ContentItemStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_ContentItemStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_ContentItemStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_ContentItemStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_ContentItemStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_ContentItemStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_ContentItemStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_ContentItemStats_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_ContentItemStats_Avg_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_avg_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Avg_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.ContentItemStats". All fields are combined with a logical 'AND'. */
export type Analytics_ContentItemStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Bool_Exp>>;
  readonly contentGroup?: Maybe<Content_Item_Bool_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly viewCount?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Constraint {
  /** unique or primary key constraint */
  ContentItemStatsIdKey = 'ContentItemStats_id_key',
  /** unique or primary key constraint */
  ContentItemStatsPkey = 'ContentItemStats_pkey'
}

/** input type for incrementing numeric columns in table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Inc_Input = {
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Insert_Input = {
  readonly contentGroup?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Analytics_ContentItemStats_Max_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_ContentItemStats_Min_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Mutation_Response = {
  readonly __typename?: 'analytics_ContentItemStats_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Analytics_ContentItemStats>;
};

/** on conflict condition type for table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_On_Conflict = {
  readonly constraint: Analytics_ContentItemStats_Constraint;
  readonly update_columns?: ReadonlyArray<Analytics_ContentItemStats_Update_Column>;
  readonly where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};

/** Ordering options when selecting data from "analytics.ContentItemStats". */
export type Analytics_ContentItemStats_Order_By = {
  readonly contentGroup?: Maybe<Content_Item_Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** primary key columns input for table: analytics_ContentItemStats */
export type Analytics_ContentItemStats_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** input type for updating data in table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Analytics_ContentItemStats_Stddev_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ContentItemStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ContentItemStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_ContentItemStats_Sum_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_sum_fields';
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Sum_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** aggregate var_pop on columns */
export type Analytics_ContentItemStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_var_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Var_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_ContentItemStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_var_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Var_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_ContentItemStats_Variance_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_variance_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Variance_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.ElementTotalViews" */
export type Analytics_ElementTotalViews = {
  readonly __typename?: 'analytics_ElementTotalViews';
  /** An object relationship */
  readonly element?: Maybe<Content_Element>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "analytics.ElementTotalViews" */
export type Analytics_ElementTotalViews_Aggregate = {
  readonly __typename?: 'analytics_ElementTotalViews_aggregate';
  readonly aggregate?: Maybe<Analytics_ElementTotalViews_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ElementTotalViews>;
};

/** aggregate fields of "analytics.ElementTotalViews" */
export type Analytics_ElementTotalViews_Aggregate_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_aggregate_fields';
  readonly avg?: Maybe<Analytics_ElementTotalViews_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_ElementTotalViews_Max_Fields>;
  readonly min?: Maybe<Analytics_ElementTotalViews_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ElementTotalViews_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ElementTotalViews_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ElementTotalViews_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ElementTotalViews_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ElementTotalViews_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ElementTotalViews_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ElementTotalViews_Variance_Fields>;
};


/** aggregate fields of "analytics.ElementTotalViews" */
export type Analytics_ElementTotalViews_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Analytics_ElementTotalViews_Avg_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_avg_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "analytics.ElementTotalViews". All fields are combined with a logical 'AND'. */
export type Analytics_ElementTotalViews_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_ElementTotalViews_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Bool_Exp>>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly totalViewCount?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for inserting data into table "analytics.ElementTotalViews" */
export type Analytics_ElementTotalViews_Insert_Input = {
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Analytics_ElementTotalViews_Max_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_max_fields';
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Analytics_ElementTotalViews_Min_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_min_fields';
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** input type for inserting object relation for remote table "analytics.ElementTotalViews" */
export type Analytics_ElementTotalViews_Obj_Rel_Insert_Input = {
  readonly data: Analytics_ElementTotalViews_Insert_Input;
};

/** Ordering options when selecting data from "analytics.ElementTotalViews". */
export type Analytics_ElementTotalViews_Order_By = {
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly totalViewCount?: Maybe<Order_By>;
};

/** select columns of table "analytics.ElementTotalViews" */
export enum Analytics_ElementTotalViews_Select_Column {
  /** column name */
  ElementId = 'elementId',
  /** column name */
  TotalViewCount = 'totalViewCount'
}

/** aggregate stddev on columns */
export type Analytics_ElementTotalViews_Stddev_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_stddev_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ElementTotalViews_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_stddev_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ElementTotalViews_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_stddev_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Analytics_ElementTotalViews_Sum_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_sum_fields';
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Analytics_ElementTotalViews_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_var_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Analytics_ElementTotalViews_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_var_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Analytics_ElementTotalViews_Variance_Fields = {
  readonly __typename?: 'analytics_ElementTotalViews_variance_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "analytics.ItemTotalViews" */
export type Analytics_ItemTotalViews = {
  readonly __typename?: 'analytics_ItemTotalViews';
  /** An object relationship */
  readonly item?: Maybe<Content_Item>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "analytics.ItemTotalViews" */
export type Analytics_ItemTotalViews_Aggregate = {
  readonly __typename?: 'analytics_ItemTotalViews_aggregate';
  readonly aggregate?: Maybe<Analytics_ItemTotalViews_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ItemTotalViews>;
};

/** aggregate fields of "analytics.ItemTotalViews" */
export type Analytics_ItemTotalViews_Aggregate_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_aggregate_fields';
  readonly avg?: Maybe<Analytics_ItemTotalViews_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_ItemTotalViews_Max_Fields>;
  readonly min?: Maybe<Analytics_ItemTotalViews_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ItemTotalViews_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ItemTotalViews_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ItemTotalViews_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ItemTotalViews_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ItemTotalViews_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ItemTotalViews_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ItemTotalViews_Variance_Fields>;
};


/** aggregate fields of "analytics.ItemTotalViews" */
export type Analytics_ItemTotalViews_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Analytics_ItemTotalViews_Avg_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_avg_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "analytics.ItemTotalViews". All fields are combined with a logical 'AND'. */
export type Analytics_ItemTotalViews_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_ItemTotalViews_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Bool_Exp>>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly totalViewCount?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for inserting data into table "analytics.ItemTotalViews" */
export type Analytics_ItemTotalViews_Insert_Input = {
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Analytics_ItemTotalViews_Max_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_max_fields';
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Analytics_ItemTotalViews_Min_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_min_fields';
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** input type for inserting object relation for remote table "analytics.ItemTotalViews" */
export type Analytics_ItemTotalViews_Obj_Rel_Insert_Input = {
  readonly data: Analytics_ItemTotalViews_Insert_Input;
};

/** Ordering options when selecting data from "analytics.ItemTotalViews". */
export type Analytics_ItemTotalViews_Order_By = {
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly totalViewCount?: Maybe<Order_By>;
};

/** select columns of table "analytics.ItemTotalViews" */
export enum Analytics_ItemTotalViews_Select_Column {
  /** column name */
  ItemId = 'itemId',
  /** column name */
  TotalViewCount = 'totalViewCount'
}

/** aggregate stddev on columns */
export type Analytics_ItemTotalViews_Stddev_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_stddev_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ItemTotalViews_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_stddev_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ItemTotalViews_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_stddev_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Analytics_ItemTotalViews_Sum_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_sum_fields';
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Analytics_ItemTotalViews_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_var_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Analytics_ItemTotalViews_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_var_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Analytics_ItemTotalViews_Variance_Fields = {
  readonly __typename?: 'analytics_ItemTotalViews_variance_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "analytics.RoomPresence" */
export type Analytics_RoomPresence = {
  readonly __typename?: 'analytics_RoomPresence';
  readonly count?: Maybe<Scalars['jsonb']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
};


/** columns and relationships of "analytics.RoomPresence" */
export type Analytics_RoomPresenceCountArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "analytics.RoomPresence" */
export type Analytics_RoomPresence_Aggregate = {
  readonly __typename?: 'analytics_RoomPresence_aggregate';
  readonly aggregate?: Maybe<Analytics_RoomPresence_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_RoomPresence>;
};

/** aggregate fields of "analytics.RoomPresence" */
export type Analytics_RoomPresence_Aggregate_Fields = {
  readonly __typename?: 'analytics_RoomPresence_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_RoomPresence_Max_Fields>;
  readonly min?: Maybe<Analytics_RoomPresence_Min_Fields>;
};


/** aggregate fields of "analytics.RoomPresence" */
export type Analytics_RoomPresence_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_RoomPresence_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.RoomPresence" */
export type Analytics_RoomPresence_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_RoomPresence_Max_Order_By>;
  readonly min?: Maybe<Analytics_RoomPresence_Min_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.RoomPresence" */
export type Analytics_RoomPresence_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_RoomPresence_Insert_Input>;
};

/** Boolean expression to filter rows from the table "analytics.RoomPresence". All fields are combined with a logical 'AND'. */
export type Analytics_RoomPresence_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_RoomPresence_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_RoomPresence_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_RoomPresence_Bool_Exp>>;
  readonly count?: Maybe<Jsonb_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
};

/** input type for inserting data into table "analytics.RoomPresence" */
export type Analytics_RoomPresence_Insert_Input = {
  readonly count?: Maybe<Scalars['jsonb']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Analytics_RoomPresence_Max_Fields = {
  readonly __typename?: 'analytics_RoomPresence_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "analytics.RoomPresence" */
export type Analytics_RoomPresence_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_RoomPresence_Min_Fields = {
  readonly __typename?: 'analytics_RoomPresence_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "analytics.RoomPresence" */
export type Analytics_RoomPresence_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** Ordering options when selecting data from "analytics.RoomPresence". */
export type Analytics_RoomPresence_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
};

/** select columns of table "analytics.RoomPresence" */
export enum Analytics_RoomPresence_Select_Column {
  /** column name */
  Count = 'count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "analytics.RoomStats" */
export type Analytics_RoomStats = {
  readonly __typename?: 'analytics_RoomStats';
  readonly created_at: Scalars['timestamptz'];
  readonly hlsViewCount: Scalars['Int'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate = {
  readonly __typename?: 'analytics_RoomStats_aggregate';
  readonly aggregate?: Maybe<Analytics_RoomStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_RoomStats>;
};

/** aggregate fields of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_RoomStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_RoomStats_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_RoomStats_Max_Fields>;
  readonly min?: Maybe<Analytics_RoomStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_RoomStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_RoomStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_RoomStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_RoomStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_RoomStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_RoomStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_RoomStats_Variance_Fields>;
};


/** aggregate fields of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_RoomStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_RoomStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_RoomStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_RoomStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_RoomStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_RoomStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_RoomStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_RoomStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_RoomStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_RoomStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.RoomStats" */
export type Analytics_RoomStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_RoomStats_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_RoomStats_Avg_Fields = {
  readonly __typename?: 'analytics_RoomStats_avg_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Avg_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.RoomStats". All fields are combined with a logical 'AND'. */
export type Analytics_RoomStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_RoomStats_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_RoomStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_RoomStats_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly hlsViewCount?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.RoomStats" */
export enum Analytics_RoomStats_Constraint {
  /** unique or primary key constraint */
  RoomStatsPkey = 'RoomStats_pkey'
}

/** input type for incrementing numeric columns in table "analytics.RoomStats" */
export type Analytics_RoomStats_Inc_Input = {
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.RoomStats" */
export type Analytics_RoomStats_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Analytics_RoomStats_Max_Fields = {
  readonly __typename?: 'analytics_RoomStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_RoomStats_Min_Fields = {
  readonly __typename?: 'analytics_RoomStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.RoomStats" */
export type Analytics_RoomStats_Mutation_Response = {
  readonly __typename?: 'analytics_RoomStats_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Analytics_RoomStats>;
};

/** on conflict condition type for table "analytics.RoomStats" */
export type Analytics_RoomStats_On_Conflict = {
  readonly constraint: Analytics_RoomStats_Constraint;
  readonly update_columns?: ReadonlyArray<Analytics_RoomStats_Update_Column>;
  readonly where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};

/** Ordering options when selecting data from "analytics.RoomStats". */
export type Analytics_RoomStats_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: analytics_RoomStats */
export type Analytics_RoomStats_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "analytics.RoomStats" */
export enum Analytics_RoomStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HlsViewCount = 'hlsViewCount',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "analytics.RoomStats" */
export type Analytics_RoomStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Analytics_RoomStats_Stddev_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_RoomStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_pop_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Pop_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_RoomStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_samp_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Samp_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_RoomStats_Sum_Fields = {
  readonly __typename?: 'analytics_RoomStats_sum_fields';
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Sum_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.RoomStats" */
export enum Analytics_RoomStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HlsViewCount = 'hlsViewCount',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Analytics_RoomStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_RoomStats_var_pop_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Var_Pop_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_RoomStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_RoomStats_var_samp_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Var_Samp_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_RoomStats_Variance_Fields = {
  readonly __typename?: 'analytics_RoomStats_variance_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Variance_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews = {
  readonly __typename?: 'analytics_mat_ElementTotalViews';
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews_Aggregate = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_aggregate';
  readonly aggregate?: Maybe<Analytics_Mat_ElementTotalViews_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_Mat_ElementTotalViews>;
};

/** aggregate fields of "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews_Aggregate_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_aggregate_fields';
  readonly avg?: Maybe<Analytics_Mat_ElementTotalViews_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_Mat_ElementTotalViews_Max_Fields>;
  readonly min?: Maybe<Analytics_Mat_ElementTotalViews_Min_Fields>;
  readonly stddev?: Maybe<Analytics_Mat_ElementTotalViews_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_Mat_ElementTotalViews_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_Mat_ElementTotalViews_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_Mat_ElementTotalViews_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_Mat_ElementTotalViews_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_Mat_ElementTotalViews_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_Mat_ElementTotalViews_Variance_Fields>;
};


/** aggregate fields of "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Analytics_Mat_ElementTotalViews_Avg_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_avg_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "analytics.mat_ElementTotalViews". All fields are combined with a logical 'AND'. */
export type Analytics_Mat_ElementTotalViews_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_Mat_ElementTotalViews_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Bool_Exp>>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly totalViewCount?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews_Inc_Input = {
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews_Insert_Input = {
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Analytics_Mat_ElementTotalViews_Max_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_max_fields';
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Analytics_Mat_ElementTotalViews_Min_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_min_fields';
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews_Mutation_Response = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Analytics_Mat_ElementTotalViews>;
};

/** Ordering options when selecting data from "analytics.mat_ElementTotalViews". */
export type Analytics_Mat_ElementTotalViews_Order_By = {
  readonly elementId?: Maybe<Order_By>;
  readonly totalViewCount?: Maybe<Order_By>;
};

/** select columns of table "analytics.mat_ElementTotalViews" */
export enum Analytics_Mat_ElementTotalViews_Select_Column {
  /** column name */
  ElementId = 'elementId',
  /** column name */
  TotalViewCount = 'totalViewCount'
}

/** input type for updating data in table "analytics.mat_ElementTotalViews" */
export type Analytics_Mat_ElementTotalViews_Set_Input = {
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Analytics_Mat_ElementTotalViews_Stddev_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_stddev_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Analytics_Mat_ElementTotalViews_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_stddev_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Analytics_Mat_ElementTotalViews_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_stddev_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Analytics_Mat_ElementTotalViews_Sum_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_sum_fields';
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Analytics_Mat_ElementTotalViews_Var_Pop_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_var_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Analytics_Mat_ElementTotalViews_Var_Samp_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_var_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Analytics_Mat_ElementTotalViews_Variance_Fields = {
  readonly __typename?: 'analytics_mat_ElementTotalViews_variance_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews = {
  readonly __typename?: 'analytics_mat_ItemTotalViews';
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews_Aggregate = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_aggregate';
  readonly aggregate?: Maybe<Analytics_Mat_ItemTotalViews_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_Mat_ItemTotalViews>;
};

/** aggregate fields of "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews_Aggregate_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_aggregate_fields';
  readonly avg?: Maybe<Analytics_Mat_ItemTotalViews_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_Mat_ItemTotalViews_Max_Fields>;
  readonly min?: Maybe<Analytics_Mat_ItemTotalViews_Min_Fields>;
  readonly stddev?: Maybe<Analytics_Mat_ItemTotalViews_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_Mat_ItemTotalViews_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_Mat_ItemTotalViews_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_Mat_ItemTotalViews_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_Mat_ItemTotalViews_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_Mat_ItemTotalViews_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_Mat_ItemTotalViews_Variance_Fields>;
};


/** aggregate fields of "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Analytics_Mat_ItemTotalViews_Avg_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_avg_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "analytics.mat_ItemTotalViews". All fields are combined with a logical 'AND'. */
export type Analytics_Mat_ItemTotalViews_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_Mat_ItemTotalViews_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Bool_Exp>>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly totalViewCount?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews_Inc_Input = {
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews_Insert_Input = {
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Analytics_Mat_ItemTotalViews_Max_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_max_fields';
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Analytics_Mat_ItemTotalViews_Min_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_min_fields';
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews_Mutation_Response = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Analytics_Mat_ItemTotalViews>;
};

/** Ordering options when selecting data from "analytics.mat_ItemTotalViews". */
export type Analytics_Mat_ItemTotalViews_Order_By = {
  readonly itemId?: Maybe<Order_By>;
  readonly totalViewCount?: Maybe<Order_By>;
};

/** select columns of table "analytics.mat_ItemTotalViews" */
export enum Analytics_Mat_ItemTotalViews_Select_Column {
  /** column name */
  ItemId = 'itemId',
  /** column name */
  TotalViewCount = 'totalViewCount'
}

/** input type for updating data in table "analytics.mat_ItemTotalViews" */
export type Analytics_Mat_ItemTotalViews_Set_Input = {
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Analytics_Mat_ItemTotalViews_Stddev_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_stddev_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Analytics_Mat_ItemTotalViews_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_stddev_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Analytics_Mat_ItemTotalViews_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_stddev_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Analytics_Mat_ItemTotalViews_Sum_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_sum_fields';
  readonly totalViewCount?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Analytics_Mat_ItemTotalViews_Var_Pop_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_var_pop_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Analytics_Mat_ItemTotalViews_Var_Samp_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_var_samp_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Analytics_Mat_ItemTotalViews_Variance_Fields = {
  readonly __typename?: 'analytics_mat_ItemTotalViews_variance_fields';
  readonly totalViewCount?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresence = {
  readonly __typename?: 'analytics_mat_RoomPresence';
  readonly count?: Maybe<Scalars['jsonb']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
};


/** columns and relationships of "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresenceCountArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresence_Aggregate = {
  readonly __typename?: 'analytics_mat_RoomPresence_aggregate';
  readonly aggregate?: Maybe<Analytics_Mat_RoomPresence_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_Mat_RoomPresence>;
};

/** aggregate fields of "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresence_Aggregate_Fields = {
  readonly __typename?: 'analytics_mat_RoomPresence_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Analytics_Mat_RoomPresence_Max_Fields>;
  readonly min?: Maybe<Analytics_Mat_RoomPresence_Min_Fields>;
};


/** aggregate fields of "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresence_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Analytics_Mat_RoomPresence_Append_Input = {
  readonly count?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "analytics.mat_RoomPresence". All fields are combined with a logical 'AND'. */
export type Analytics_Mat_RoomPresence_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Bool_Exp>>;
  readonly _not?: Maybe<Analytics_Mat_RoomPresence_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Bool_Exp>>;
  readonly count?: Maybe<Jsonb_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Analytics_Mat_RoomPresence_Delete_At_Path_Input = {
  readonly count?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Analytics_Mat_RoomPresence_Delete_Elem_Input = {
  readonly count?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Analytics_Mat_RoomPresence_Delete_Key_Input = {
  readonly count?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresence_Insert_Input = {
  readonly count?: Maybe<Scalars['jsonb']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Analytics_Mat_RoomPresence_Max_Fields = {
  readonly __typename?: 'analytics_mat_RoomPresence_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Analytics_Mat_RoomPresence_Min_Fields = {
  readonly __typename?: 'analytics_mat_RoomPresence_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresence_Mutation_Response = {
  readonly __typename?: 'analytics_mat_RoomPresence_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Analytics_Mat_RoomPresence>;
};

/** Ordering options when selecting data from "analytics.mat_RoomPresence". */
export type Analytics_Mat_RoomPresence_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Analytics_Mat_RoomPresence_Prepend_Input = {
  readonly count?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "analytics.mat_RoomPresence" */
export enum Analytics_Mat_RoomPresence_Select_Column {
  /** column name */
  Count = 'count',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "analytics.mat_RoomPresence" */
export type Analytics_Mat_RoomPresence_Set_Input = {
  readonly count?: Maybe<Scalars['jsonb']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
};


/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['bigint']>;
  readonly _gt?: Maybe<Scalars['bigint']>;
  readonly _gte?: Maybe<Scalars['bigint']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['bigint']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['bigint']>;
  readonly _lte?: Maybe<Scalars['bigint']>;
  readonly _neq?: Maybe<Scalars['bigint']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['bigint']>>;
};

/** columns and relationships of "chat.Chat" */
export type Chat_Chat = {
  readonly __typename?: 'chat_Chat';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly duplicateTo?: Maybe<Chat_Chat>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly duplicatesFrom: ReadonlyArray<Chat_Chat>;
  /** An aggregate relationship */
  readonly duplicatesFrom_aggregate: Chat_Chat_Aggregate;
  readonly enableAutoPin: Scalars['Boolean'];
  readonly enableAutoSubscribe: Scalars['Boolean'];
  readonly enableMandatoryPin: Scalars['Boolean'];
  readonly enableMandatorySubscribe: Scalars['Boolean'];
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregate relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_Item>;
  /** An aggregate relationship */
  readonly items_aggregate: Content_Item_Aggregate;
  /** An array relationship */
  readonly messages: ReadonlyArray<Chat_Message>;
  /** An aggregate relationship */
  readonly messages_aggregate: Chat_Message_Aggregate;
  /** An array relationship */
  readonly pins: ReadonlyArray<Chat_Pin>;
  /** An aggregate relationship */
  readonly pins_aggregate: Chat_Pin_Aggregate;
  /** An array relationship */
  readonly readUpToIndices: ReadonlyArray<Chat_ReadUpToIndex>;
  /** An aggregate relationship */
  readonly readUpToIndices_aggregate: Chat_ReadUpToIndex_Aggregate;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins: Scalars['Boolean'];
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregate relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  /** An array relationship */
  readonly subscriptions: ReadonlyArray<Chat_Subscription>;
  /** An aggregate relationship */
  readonly subscriptions_aggregate: Chat_Subscription_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFromArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFrom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessagesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessages_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPinsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPins_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndicesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndices_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};

/** aggregated selection of "chat.Chat" */
export type Chat_Chat_Aggregate = {
  readonly __typename?: 'chat_Chat_aggregate';
  readonly aggregate?: Maybe<Chat_Chat_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Chat>;
};

/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_Fields = {
  readonly __typename?: 'chat_Chat_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_Chat_Max_Fields>;
  readonly min?: Maybe<Chat_Chat_Min_Fields>;
};


/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Chat" */
export type Chat_Chat_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Chat_Max_Order_By>;
  readonly min?: Maybe<Chat_Chat_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Chat" */
export type Chat_Chat_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Chat_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Chat". All fields are combined with a logical 'AND'. */
export type Chat_Chat_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_Chat_Bool_Exp>>;
  readonly _not?: Maybe<Chat_Chat_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_Chat_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly duplicateTo?: Maybe<Chat_Chat_Bool_Exp>;
  readonly duplicateToId?: Maybe<Uuid_Comparison_Exp>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Bool_Exp>;
  readonly enableAutoPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableAutoSubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatoryPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatorySubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly items?: Maybe<Content_Item_Bool_Exp>;
  readonly messages?: Maybe<Chat_Message_Bool_Exp>;
  readonly pins?: Maybe<Chat_Pin_Bool_Exp>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly remoteServiceId?: Maybe<String_Comparison_Exp>;
  readonly restrictToAdmins?: Maybe<Boolean_Comparison_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly subscriptions?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Chat" */
export enum Chat_Chat_Constraint {
  /** unique or primary key constraint */
  ChatPkey = 'Chat_pkey'
}

/** input type for inserting data into table "chat.Chat" */
export type Chat_Chat_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateTo?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly items?: Maybe<Content_Item_Arr_Rel_Insert_Input>;
  readonly messages?: Maybe<Chat_Message_Arr_Rel_Insert_Input>;
  readonly pins?: Maybe<Chat_Pin_Arr_Rel_Insert_Input>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Arr_Rel_Insert_Input>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly subscriptions?: Maybe<Chat_Subscription_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Chat_Max_Fields = {
  readonly __typename?: 'chat_Chat_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Chat" */
export type Chat_Chat_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Chat_Min_Fields = {
  readonly __typename?: 'chat_Chat_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Chat" */
export type Chat_Chat_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Chat" */
export type Chat_Chat_Mutation_Response = {
  readonly __typename?: 'chat_Chat_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_Chat>;
};

/** input type for inserting object relation for remote table "chat.Chat" */
export type Chat_Chat_Obj_Rel_Insert_Input = {
  readonly data: Chat_Chat_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** on conflict condition type for table "chat.Chat" */
export type Chat_Chat_On_Conflict = {
  readonly constraint: Chat_Chat_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_Chat_Update_Column>;
  readonly where?: Maybe<Chat_Chat_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.Chat". */
export type Chat_Chat_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateTo?: Maybe<Chat_Chat_Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly duplicatesFrom_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly enableAutoPin?: Maybe<Order_By>;
  readonly enableAutoSubscribe?: Maybe<Order_By>;
  readonly enableMandatoryPin?: Maybe<Order_By>;
  readonly enableMandatorySubscribe?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_Item_Aggregate_Order_By>;
  readonly messages_aggregate?: Maybe<Chat_Message_Aggregate_Order_By>;
  readonly pins_aggregate?: Maybe<Chat_Pin_Aggregate_Order_By>;
  readonly readUpToIndices_aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly restrictToAdmins?: Maybe<Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly subscriptions_aggregate?: Maybe<Chat_Subscription_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_Chat */
export type Chat_Chat_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "chat.Chat" */
export enum Chat_Chat_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RemoteServiceId = 'remoteServiceId',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Chat" */
export type Chat_Chat_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Chat" */
export enum Chat_Chat_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RemoteServiceId = 'remoteServiceId',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "chat.Flag" */
export type Chat_Flag = {
  readonly __typename?: 'chat_Flag';
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly discussionChat?: Maybe<Chat_Chat>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly flaggedBy?: Maybe<Registrant_Registrant>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['Int'];
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageSId: Scalars['uuid'];
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type: Chat_FlagType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "chat.FlagType" */
export type Chat_FlagType = {
  readonly __typename?: 'chat_FlagType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.FlagType" */
export type Chat_FlagType_Aggregate = {
  readonly __typename?: 'chat_FlagType_aggregate';
  readonly aggregate?: Maybe<Chat_FlagType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_FlagType>;
};

/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_Fields = {
  readonly __typename?: 'chat_FlagType_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_FlagType_Max_Fields>;
  readonly min?: Maybe<Chat_FlagType_Min_Fields>;
};


/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "chat.FlagType". All fields are combined with a logical 'AND'. */
export type Chat_FlagType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_FlagType_Bool_Exp>>;
  readonly _not?: Maybe<Chat_FlagType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_FlagType_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.FlagType" */
export enum Chat_FlagType_Constraint {
  /** unique or primary key constraint */
  FlagTypePkey = 'FlagType_pkey'
}

export enum Chat_FlagType_Enum {
  /** It's abusive or harmful. */
  Abusive = 'Abusive',
  /** It contains false information and is intended to mislead readers. */
  Disinformation = 'Disinformation',
  /** It gives the wrong idea or impression. */
  Misleading = 'Misleading',
  /** It expresses intentions of self-harm or suicide. */
  RiskToLife = 'Risk_To_Life',
  /** It's spam, suspicious or annoying. */
  Spam = 'Spam'
}

/** Boolean expression to compare columns of type "chat_FlagType_enum". All fields are combined with logical 'AND'. */
export type Chat_FlagType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_FlagType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_FlagType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
};

/** input type for inserting data into table "chat.FlagType" */
export type Chat_FlagType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_FlagType_Max_Fields = {
  readonly __typename?: 'chat_FlagType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Chat_FlagType_Min_Fields = {
  readonly __typename?: 'chat_FlagType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "chat.FlagType" */
export type Chat_FlagType_Mutation_Response = {
  readonly __typename?: 'chat_FlagType_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_FlagType>;
};

/** on conflict condition type for table "chat.FlagType" */
export type Chat_FlagType_On_Conflict = {
  readonly constraint: Chat_FlagType_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_FlagType_Update_Column>;
  readonly where?: Maybe<Chat_FlagType_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.FlagType". */
export type Chat_FlagType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_FlagType */
export type Chat_FlagType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.FlagType" */
export enum Chat_FlagType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.FlagType" */
export type Chat_FlagType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.FlagType" */
export enum Chat_FlagType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Flag" */
export type Chat_Flag_Aggregate = {
  readonly __typename?: 'chat_Flag_aggregate';
  readonly aggregate?: Maybe<Chat_Flag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Flag>;
};

/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_Fields = {
  readonly __typename?: 'chat_Flag_aggregate_fields';
  readonly avg?: Maybe<Chat_Flag_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_Flag_Max_Fields>;
  readonly min?: Maybe<Chat_Flag_Min_Fields>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Flag_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Flag_Variance_Fields>;
};


/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Flag" */
export type Chat_Flag_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Flag_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Flag_Max_Order_By>;
  readonly min?: Maybe<Chat_Flag_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Flag_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Flag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Flag" */
export type Chat_Flag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Flag_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Flag_Avg_Fields = {
  readonly __typename?: 'chat_Flag_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Flag" */
export type Chat_Flag_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Flag". All fields are combined with a logical 'AND'. */
export type Chat_Flag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_Flag_Bool_Exp>>;
  readonly _not?: Maybe<Chat_Flag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_Flag_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly discussionChat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly discussionChatId?: Maybe<Uuid_Comparison_Exp>;
  readonly flaggedBy?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly flaggedById?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly notes?: Maybe<String_Comparison_Exp>;
  readonly resolution?: Maybe<String_Comparison_Exp>;
  readonly resolved_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly type?: Maybe<Chat_FlagType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Flag" */
export enum Chat_Flag_Constraint {
  /** unique or primary key constraint */
  FlagMessageSIdFlaggedByIdTypeKey = 'Flag_messageSId_flaggedById_type_key',
  /** unique or primary key constraint */
  FlagPkey = 'Flag_pkey'
}

/** input type for incrementing numeric columns in table "chat.Flag" */
export type Chat_Flag_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Flag" */
export type Chat_Flag_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedBy?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Flag_Max_Fields = {
  readonly __typename?: 'chat_Flag_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Flag" */
export type Chat_Flag_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Flag_Min_Fields = {
  readonly __typename?: 'chat_Flag_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Flag" */
export type Chat_Flag_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Flag" */
export type Chat_Flag_Mutation_Response = {
  readonly __typename?: 'chat_Flag_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_Flag>;
};

/** on conflict condition type for table "chat.Flag" */
export type Chat_Flag_On_Conflict = {
  readonly constraint: Chat_Flag_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_Flag_Update_Column>;
  readonly where?: Maybe<Chat_Flag_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.Flag". */
export type Chat_Flag_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChat?: Maybe<Chat_Chat_Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedBy?: Maybe<Registrant_Registrant_Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_Flag */
export type Chat_Flag_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** select columns of table "chat.Flag" */
export enum Chat_Flag_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Flag" */
export type Chat_Flag_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Flag_Stddev_Fields = {
  readonly __typename?: 'chat_Flag_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Flag_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Flag_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Flag_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Flag_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Flag_Sum_Fields = {
  readonly __typename?: 'chat_Flag_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Flag" */
export type Chat_Flag_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "chat.Flag" */
export enum Chat_Flag_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Flag_Var_Pop_Fields = {
  readonly __typename?: 'chat_Flag_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Flag_Var_Samp_Fields = {
  readonly __typename?: 'chat_Flag_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Flag_Variance_Fields = {
  readonly __typename?: 'chat_Flag_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Flag" */
export type Chat_Flag_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 *
 */
export type Chat_Message = {
  readonly __typename?: 'chat_Message';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicateIncoming?: Maybe<Chat_Message>;
  /** An object relationship */
  readonly duplicateOutgoing?: Maybe<Chat_Message>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregate relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['Int'];
  readonly isPinned: Scalars['Boolean'];
  readonly message: Scalars['String'];
  /** An array relationship */
  readonly reactions: ReadonlyArray<Chat_Reaction>;
  /** An aggregate relationship */
  readonly reactions_aggregate: Chat_Reaction_Aggregate;
  readonly sId: Scalars['uuid'];
  /** An object relationship */
  readonly sender?: Maybe<Registrant_Registrant>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type: Chat_MessageType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 *
 */
export type Chat_MessageDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 *
 */
export type Chat_MessageFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 *
 */
export type Chat_MessageFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 *
 */
export type Chat_MessageReactionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 *
 */
export type Chat_MessageReactions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.MessageType" */
export type Chat_MessageType = {
  readonly __typename?: 'chat_MessageType';
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.MessageType" */
export type Chat_MessageType_Aggregate = {
  readonly __typename?: 'chat_MessageType_aggregate';
  readonly aggregate?: Maybe<Chat_MessageType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_MessageType>;
};

/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_Fields = {
  readonly __typename?: 'chat_MessageType_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_MessageType_Max_Fields>;
  readonly min?: Maybe<Chat_MessageType_Min_Fields>;
};


/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "chat.MessageType". All fields are combined with a logical 'AND'. */
export type Chat_MessageType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_MessageType_Bool_Exp>>;
  readonly _not?: Maybe<Chat_MessageType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_MessageType_Bool_Exp>>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.MessageType" */
export enum Chat_MessageType_Constraint {
  /** unique or primary key constraint */
  MessageTypePkey = 'MessageType_pkey'
}

export enum Chat_MessageType_Enum {
  Answer = 'ANSWER',
  DuplicationMarker = 'DUPLICATION_MARKER',
  Emote = 'EMOTE',
  Message = 'MESSAGE',
  Poll = 'POLL',
  PollResults = 'POLL_RESULTS',
  Question = 'QUESTION'
}

/** Boolean expression to compare columns of type "chat_MessageType_enum". All fields are combined with logical 'AND'. */
export type Chat_MessageType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_MessageType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_MessageType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
};

/** input type for inserting data into table "chat.MessageType" */
export type Chat_MessageType_Insert_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_MessageType_Max_Fields = {
  readonly __typename?: 'chat_MessageType_max_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Chat_MessageType_Min_Fields = {
  readonly __typename?: 'chat_MessageType_min_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "chat.MessageType" */
export type Chat_MessageType_Mutation_Response = {
  readonly __typename?: 'chat_MessageType_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_MessageType>;
};

/** on conflict condition type for table "chat.MessageType" */
export type Chat_MessageType_On_Conflict = {
  readonly constraint: Chat_MessageType_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_MessageType_Update_Column>;
  readonly where?: Maybe<Chat_MessageType_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.MessageType". */
export type Chat_MessageType_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_MessageType */
export type Chat_MessageType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.MessageType" */
export enum Chat_MessageType_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.MessageType" */
export type Chat_MessageType_Set_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.MessageType" */
export enum Chat_MessageType_Update_Column {
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Message" */
export type Chat_Message_Aggregate = {
  readonly __typename?: 'chat_Message_aggregate';
  readonly aggregate?: Maybe<Chat_Message_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Message>;
};

/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_Fields = {
  readonly __typename?: 'chat_Message_aggregate_fields';
  readonly avg?: Maybe<Chat_Message_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_Message_Max_Fields>;
  readonly min?: Maybe<Chat_Message_Min_Fields>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Message_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Message_Variance_Fields>;
};


/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Message" */
export type Chat_Message_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Message_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Message_Max_Order_By>;
  readonly min?: Maybe<Chat_Message_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Message_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Message_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Message" */
export type Chat_Message_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Message_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Message_Avg_Fields = {
  readonly __typename?: 'chat_Message_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Message" */
export type Chat_Message_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Message". All fields are combined with a logical 'AND'. */
export type Chat_Message_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_Message_Bool_Exp>>;
  readonly _not?: Maybe<Chat_Message_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_Message_Bool_Exp>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicatedMessageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly isPinned?: Maybe<Boolean_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly reactions?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly sId?: Maybe<Uuid_Comparison_Exp>;
  readonly sender?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly systemId?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_MessageType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Message" */
export enum Chat_Message_Constraint {
  /** unique or primary key constraint */
  MessageDuplicatedMessageSIdKey = 'Message_duplicatedMessageSId_key',
  /** unique or primary key constraint */
  MessagePkey = 'Message_pkey',
  /** unique or primary key constraint */
  MessageSIdChatIdKey = 'Message_sId_chatId_key',
  /** unique or primary key constraint */
  MessageSIdKey = 'Message_sId_key',
  /** unique or primary key constraint */
  MessageSystemIdKey = 'Message_systemId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Message_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Message_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Message_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "chat.Message" */
export type Chat_Message_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Message" */
export type Chat_Message_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly reactions?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly sender?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Message_Max_Fields = {
  readonly __typename?: 'chat_Message_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Message" */
export type Chat_Message_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Message_Min_Fields = {
  readonly __typename?: 'chat_Message_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Message" */
export type Chat_Message_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Message" */
export type Chat_Message_Mutation_Response = {
  readonly __typename?: 'chat_Message_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_Message>;
};

/** input type for inserting object relation for remote table "chat.Message" */
export type Chat_Message_Obj_Rel_Insert_Input = {
  readonly data: Chat_Message_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** on conflict condition type for table "chat.Message" */
export type Chat_Message_On_Conflict = {
  readonly constraint: Chat_Message_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_Message_Update_Column>;
  readonly where?: Maybe<Chat_Message_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.Message". */
export type Chat_Message_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Order_By>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isPinned?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly reactions_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly sender?: Maybe<Registrant_Registrant_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_Message */
export type Chat_Message_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Message" */
export enum Chat_Message_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageSId = 'duplicatedMessageSId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Message" */
export type Chat_Message_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Message_Stddev_Fields = {
  readonly __typename?: 'chat_Message_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Message_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Message_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Message_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Message_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Message_Sum_Fields = {
  readonly __typename?: 'chat_Message_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Message" */
export type Chat_Message_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "chat.Message" */
export enum Chat_Message_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageSId = 'duplicatedMessageSId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Message_Var_Pop_Fields = {
  readonly __typename?: 'chat_Message_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Message" */
export type Chat_Message_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Message_Var_Samp_Fields = {
  readonly __typename?: 'chat_Message_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Message" */
export type Chat_Message_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Message_Variance_Fields = {
  readonly __typename?: 'chat_Message_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Message" */
export type Chat_Message_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/**
 * Pin a chat to the sidebar.
 *
 *
 * columns and relationships of "chat.Pin"
 *
 */
export type Chat_Pin = {
  readonly __typename?: 'chat_Pin';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly wasManuallyPinned: Scalars['Boolean'];
};

/** aggregated selection of "chat.Pin" */
export type Chat_Pin_Aggregate = {
  readonly __typename?: 'chat_Pin_aggregate';
  readonly aggregate?: Maybe<Chat_Pin_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Pin>;
};

/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_Fields = {
  readonly __typename?: 'chat_Pin_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_Pin_Max_Fields>;
  readonly min?: Maybe<Chat_Pin_Min_Fields>;
};


/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Pin" */
export type Chat_Pin_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Pin_Max_Order_By>;
  readonly min?: Maybe<Chat_Pin_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Pin" */
export type Chat_Pin_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Pin_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Pin". All fields are combined with a logical 'AND'. */
export type Chat_Pin_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_Pin_Bool_Exp>>;
  readonly _not?: Maybe<Chat_Pin_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_Pin_Bool_Exp>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly wasManuallyPinned?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Pin" */
export enum Chat_Pin_Constraint {
  /** unique or primary key constraint */
  ChatPinPkey = 'ChatPin_pkey'
}

/** input type for inserting data into table "chat.Pin" */
export type Chat_Pin_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Pin_Max_Fields = {
  readonly __typename?: 'chat_Pin_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "chat.Pin" */
export type Chat_Pin_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Pin_Min_Fields = {
  readonly __typename?: 'chat_Pin_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "chat.Pin" */
export type Chat_Pin_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Pin" */
export type Chat_Pin_Mutation_Response = {
  readonly __typename?: 'chat_Pin_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_Pin>;
};

/** on conflict condition type for table "chat.Pin" */
export type Chat_Pin_On_Conflict = {
  readonly constraint: Chat_Pin_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_Pin_Update_Column>;
  readonly where?: Maybe<Chat_Pin_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.Pin". */
export type Chat_Pin_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly wasManuallyPinned?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_Pin */
export type Chat_Pin_Pk_Columns_Input = {
  readonly chatId: Scalars['uuid'];
  readonly registrantId: Scalars['uuid'];
};

/** select columns of table "chat.Pin" */
export enum Chat_Pin_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** input type for updating data in table "chat.Pin" */
export type Chat_Pin_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Pin" */
export enum Chat_Pin_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** columns and relationships of "chat.Reaction" */
export type Chat_Reaction = {
  readonly __typename?: 'chat_Reaction';
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicate?: Maybe<Chat_Reaction>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly duplicates: ReadonlyArray<Chat_Reaction>;
  /** An aggregate relationship */
  readonly duplicates_aggregate: Chat_Reaction_Aggregate;
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageSId: Scalars['uuid'];
  readonly sId: Scalars['uuid'];
  /** An object relationship */
  readonly sender: Registrant_Registrant;
  readonly senderId: Scalars['uuid'];
  readonly symbol: Scalars['String'];
  readonly type: Chat_ReactionType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicatesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicates_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.ReactionType" */
export type Chat_ReactionType = {
  readonly __typename?: 'chat_ReactionType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate = {
  readonly __typename?: 'chat_ReactionType_aggregate';
  readonly aggregate?: Maybe<Chat_ReactionType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReactionType>;
};

/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_Fields = {
  readonly __typename?: 'chat_ReactionType_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_ReactionType_Max_Fields>;
  readonly min?: Maybe<Chat_ReactionType_Min_Fields>;
};


/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "chat.ReactionType". All fields are combined with a logical 'AND'. */
export type Chat_ReactionType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_ReactionType_Bool_Exp>>;
  readonly _not?: Maybe<Chat_ReactionType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_ReactionType_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReactionType" */
export enum Chat_ReactionType_Constraint {
  /** unique or primary key constraint */
  ReactionTypePkey = 'ReactionType_pkey'
}

export enum Chat_ReactionType_Enum {
  /** Link to a message that answers the question. */
  Answer = 'ANSWER',
  /** A plain emoji reaction */
  Emoji = 'EMOJI',
  /** A vote in a poll */
  PollChoice = 'POLL_CHOICE',
  /** Stop accepting new responses to the poll */
  PollClosed = 'POLL_CLOSED',
  /** Make the poll results visible */
  PollComplete = 'POLL_COMPLETE'
}

/** Boolean expression to compare columns of type "chat_ReactionType_enum". All fields are combined with logical 'AND'. */
export type Chat_ReactionType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_ReactionType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_ReactionType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
};

/** input type for inserting data into table "chat.ReactionType" */
export type Chat_ReactionType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_ReactionType_Max_Fields = {
  readonly __typename?: 'chat_ReactionType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Chat_ReactionType_Min_Fields = {
  readonly __typename?: 'chat_ReactionType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "chat.ReactionType" */
export type Chat_ReactionType_Mutation_Response = {
  readonly __typename?: 'chat_ReactionType_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_ReactionType>;
};

/** on conflict condition type for table "chat.ReactionType" */
export type Chat_ReactionType_On_Conflict = {
  readonly constraint: Chat_ReactionType_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_ReactionType_Update_Column>;
  readonly where?: Maybe<Chat_ReactionType_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.ReactionType". */
export type Chat_ReactionType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_ReactionType */
export type Chat_ReactionType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.ReactionType" */
export type Chat_ReactionType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Reaction" */
export type Chat_Reaction_Aggregate = {
  readonly __typename?: 'chat_Reaction_aggregate';
  readonly aggregate?: Maybe<Chat_Reaction_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Reaction>;
};

/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_Fields = {
  readonly __typename?: 'chat_Reaction_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_Reaction_Max_Fields>;
  readonly min?: Maybe<Chat_Reaction_Min_Fields>;
};


/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Reaction" */
export type Chat_Reaction_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Reaction_Max_Order_By>;
  readonly min?: Maybe<Chat_Reaction_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Reaction" */
export type Chat_Reaction_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Reaction_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Reaction". All fields are combined with a logical 'AND'. */
export type Chat_Reaction_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_Reaction_Bool_Exp>>;
  readonly _not?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_Reaction_Bool_Exp>>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicate?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly duplicateSId?: Maybe<Uuid_Comparison_Exp>;
  readonly duplicates?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly sId?: Maybe<Uuid_Comparison_Exp>;
  readonly sender?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly symbol?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_ReactionType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Reaction" */
export enum Chat_Reaction_Constraint {
  /** unique or primary key constraint */
  ReactionPkey = 'Reaction_pkey',
  /** unique or primary key constraint */
  ReactionSIdKey = 'Reaction_sId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Reaction_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Reaction_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Reaction_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "chat.Reaction" */
export type Chat_Reaction_Insert_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicate?: Maybe<Chat_Reaction_Obj_Rel_Insert_Input>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly duplicates?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly sender?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Reaction_Max_Fields = {
  readonly __typename?: 'chat_Reaction_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Reaction" */
export type Chat_Reaction_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Reaction_Min_Fields = {
  readonly __typename?: 'chat_Reaction_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Reaction" */
export type Chat_Reaction_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Reaction" */
export type Chat_Reaction_Mutation_Response = {
  readonly __typename?: 'chat_Reaction_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_Reaction>;
};

/** input type for inserting object relation for remote table "chat.Reaction" */
export type Chat_Reaction_Obj_Rel_Insert_Input = {
  readonly data: Chat_Reaction_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** on conflict condition type for table "chat.Reaction" */
export type Chat_Reaction_On_Conflict = {
  readonly constraint: Chat_Reaction_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_Reaction_Update_Column>;
  readonly where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.Reaction". */
export type Chat_Reaction_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicate?: Maybe<Chat_Reaction_Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly duplicates_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly sender?: Maybe<Registrant_Registrant_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_Reaction */
export type Chat_Reaction_Pk_Columns_Input = {
  readonly sId: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Reaction" */
export enum Chat_Reaction_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateSId = 'duplicateSId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Reaction" */
export type Chat_Reaction_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Reaction" */
export enum Chat_Reaction_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateSId = 'duplicateSId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex = {
  readonly __typename?: 'chat_ReadUpToIndex';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly messageSId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate';
  readonly aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Fields>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Fields>;
};


/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Order_By>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.ReadUpToIndex". All fields are combined with a logical 'AND'. */
export type Chat_ReadUpToIndex_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Bool_Exp>>;
  readonly _not?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Bool_Exp>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Constraint {
  /** unique or primary key constraint */
  ReadUpToIndexPkey = 'ReadUpToIndex_pkey'
}

/** input type for inserting data into table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_ReadUpToIndex_Max_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_ReadUpToIndex_Min_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Mutation_Response = {
  readonly __typename?: 'chat_ReadUpToIndex_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** on conflict condition type for table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_On_Conflict = {
  readonly constraint: Chat_ReadUpToIndex_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_ReadUpToIndex_Update_Column>;
  readonly where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.ReadUpToIndex". */
export type Chat_ReadUpToIndex_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_ReadUpToIndex */
export type Chat_ReadUpToIndex_Pk_Columns_Input = {
  readonly chatId: Scalars['uuid'];
  readonly registrantId: Scalars['uuid'];
};

/** select columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/**
 * Subscribe to chat notifications.
 *
 *
 * columns and relationships of "chat.Subscription"
 *
 */
export type Chat_Subscription = {
  readonly __typename?: 'chat_Subscription';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly wasManuallySubscribed: Scalars['Boolean'];
};

/** aggregated selection of "chat.Subscription" */
export type Chat_Subscription_Aggregate = {
  readonly __typename?: 'chat_Subscription_aggregate';
  readonly aggregate?: Maybe<Chat_Subscription_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Subscription>;
};

/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_Fields = {
  readonly __typename?: 'chat_Subscription_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Chat_Subscription_Max_Fields>;
  readonly min?: Maybe<Chat_Subscription_Min_Fields>;
};


/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Subscription" */
export type Chat_Subscription_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Subscription_Max_Order_By>;
  readonly min?: Maybe<Chat_Subscription_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Subscription" */
export type Chat_Subscription_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Subscription_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Subscription". All fields are combined with a logical 'AND'. */
export type Chat_Subscription_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Chat_Subscription_Bool_Exp>>;
  readonly _not?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Chat_Subscription_Bool_Exp>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly wasManuallySubscribed?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Subscription" */
export enum Chat_Subscription_Constraint {
  /** unique or primary key constraint */
  SubscriptionPkey = 'Subscription_pkey'
}

/** input type for inserting data into table "chat.Subscription" */
export type Chat_Subscription_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Subscription_Max_Fields = {
  readonly __typename?: 'chat_Subscription_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "chat.Subscription" */
export type Chat_Subscription_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Subscription_Min_Fields = {
  readonly __typename?: 'chat_Subscription_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "chat.Subscription" */
export type Chat_Subscription_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Subscription" */
export type Chat_Subscription_Mutation_Response = {
  readonly __typename?: 'chat_Subscription_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Chat_Subscription>;
};

/** on conflict condition type for table "chat.Subscription" */
export type Chat_Subscription_On_Conflict = {
  readonly constraint: Chat_Subscription_Constraint;
  readonly update_columns?: ReadonlyArray<Chat_Subscription_Update_Column>;
  readonly where?: Maybe<Chat_Subscription_Bool_Exp>;
};

/** Ordering options when selecting data from "chat.Subscription". */
export type Chat_Subscription_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly wasManuallySubscribed?: Maybe<Order_By>;
};

/** primary key columns input for table: chat_Subscription */
export type Chat_Subscription_Pk_Columns_Input = {
  readonly chatId: Scalars['uuid'];
  readonly registrantId: Scalars['uuid'];
};

/** select columns of table "chat.Subscription" */
export enum Chat_Subscription_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** input type for updating data in table "chat.Subscription" */
export type Chat_Subscription_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Subscription" */
export enum Chat_Subscription_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** columns and relationships of "collection.Exhibition" */
export type Collection_Exhibition = {
  readonly __typename?: 'collection_Exhibition';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly descriptiveItem?: Maybe<Content_Item>;
  readonly descriptiveItemId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_ItemExhibition>;
  /** An aggregate relationship */
  readonly items_aggregate: Content_ItemExhibition_Aggregate;
  readonly name: Scalars['String'];
  readonly priority: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "collection.Exhibition" */
export type Collection_ExhibitionItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** columns and relationships of "collection.Exhibition" */
export type Collection_ExhibitionItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};

/** aggregated selection of "collection.Exhibition" */
export type Collection_Exhibition_Aggregate = {
  readonly __typename?: 'collection_Exhibition_aggregate';
  readonly aggregate?: Maybe<Collection_Exhibition_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_Exhibition>;
};

/** aggregate fields of "collection.Exhibition" */
export type Collection_Exhibition_Aggregate_Fields = {
  readonly __typename?: 'collection_Exhibition_aggregate_fields';
  readonly avg?: Maybe<Collection_Exhibition_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Collection_Exhibition_Max_Fields>;
  readonly min?: Maybe<Collection_Exhibition_Min_Fields>;
  readonly stddev?: Maybe<Collection_Exhibition_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Collection_Exhibition_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Collection_Exhibition_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Collection_Exhibition_Sum_Fields>;
  readonly var_pop?: Maybe<Collection_Exhibition_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Collection_Exhibition_Var_Samp_Fields>;
  readonly variance?: Maybe<Collection_Exhibition_Variance_Fields>;
};


/** aggregate fields of "collection.Exhibition" */
export type Collection_Exhibition_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "collection.Exhibition" */
export type Collection_Exhibition_Aggregate_Order_By = {
  readonly avg?: Maybe<Collection_Exhibition_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Collection_Exhibition_Max_Order_By>;
  readonly min?: Maybe<Collection_Exhibition_Min_Order_By>;
  readonly stddev?: Maybe<Collection_Exhibition_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Collection_Exhibition_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Collection_Exhibition_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Collection_Exhibition_Sum_Order_By>;
  readonly var_pop?: Maybe<Collection_Exhibition_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Collection_Exhibition_Var_Samp_Order_By>;
  readonly variance?: Maybe<Collection_Exhibition_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "collection.Exhibition" */
export type Collection_Exhibition_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Collection_Exhibition_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};

/** aggregate avg on columns */
export type Collection_Exhibition_Avg_Fields = {
  readonly __typename?: 'collection_Exhibition_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "collection.Exhibition". All fields are combined with a logical 'AND'. */
export type Collection_Exhibition_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Collection_Exhibition_Bool_Exp>>;
  readonly _not?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Collection_Exhibition_Bool_Exp>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly descriptiveItem?: Maybe<Content_Item_Bool_Exp>;
  readonly descriptiveItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly items?: Maybe<Content_ItemExhibition_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "collection.Exhibition" */
export enum Collection_Exhibition_Constraint {
  /** unique or primary key constraint */
  ExhibitionNameConferenceIdFkey = 'Exhibition_name_conferenceId_fkey',
  /** unique or primary key constraint */
  ExhibitionPkey = 'Exhibition_pkey'
}

/** input type for incrementing numeric columns in table "collection.Exhibition" */
export type Collection_Exhibition_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "collection.Exhibition" */
export type Collection_Exhibition_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly descriptiveItem?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly descriptiveItemId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly items?: Maybe<Content_ItemExhibition_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Collection_Exhibition_Max_Fields = {
  readonly __typename?: 'collection_Exhibition_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly descriptiveItemId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly descriptiveItemId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Collection_Exhibition_Min_Fields = {
  readonly __typename?: 'collection_Exhibition_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly descriptiveItemId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly descriptiveItemId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "collection.Exhibition" */
export type Collection_Exhibition_Mutation_Response = {
  readonly __typename?: 'collection_Exhibition_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Collection_Exhibition>;
};

/** input type for inserting object relation for remote table "collection.Exhibition" */
export type Collection_Exhibition_Obj_Rel_Insert_Input = {
  readonly data: Collection_Exhibition_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};

/** on conflict condition type for table "collection.Exhibition" */
export type Collection_Exhibition_On_Conflict = {
  readonly constraint: Collection_Exhibition_Constraint;
  readonly update_columns?: ReadonlyArray<Collection_Exhibition_Update_Column>;
  readonly where?: Maybe<Collection_Exhibition_Bool_Exp>;
};

/** Ordering options when selecting data from "collection.Exhibition". */
export type Collection_Exhibition_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly descriptiveItem?: Maybe<Content_Item_Order_By>;
  readonly descriptiveItemId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_ItemExhibition_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: collection_Exhibition */
export type Collection_Exhibition_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "collection.Exhibition" */
export enum Collection_Exhibition_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DescriptiveItemId = 'descriptiveItemId',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "collection.Exhibition" */
export type Collection_Exhibition_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly descriptiveItemId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Collection_Exhibition_Stddev_Fields = {
  readonly __typename?: 'collection_Exhibition_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Collection_Exhibition_Stddev_Pop_Fields = {
  readonly __typename?: 'collection_Exhibition_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Collection_Exhibition_Stddev_Samp_Fields = {
  readonly __typename?: 'collection_Exhibition_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Collection_Exhibition_Sum_Fields = {
  readonly __typename?: 'collection_Exhibition_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "collection.Exhibition" */
export enum Collection_Exhibition_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DescriptiveItemId = 'descriptiveItemId',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Collection_Exhibition_Var_Pop_Fields = {
  readonly __typename?: 'collection_Exhibition_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Collection_Exhibition_Var_Samp_Fields = {
  readonly __typename?: 'collection_Exhibition_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Collection_Exhibition_Variance_Fields = {
  readonly __typename?: 'collection_Exhibition_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPerson = {
  readonly __typename?: 'collection_ProgramPerson';
  readonly accessToken: Scalars['String'];
  readonly affiliation?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<Schedule_EventProgramPerson>;
  /** An aggregate relationship */
  readonly eventPeople_aggregate: Schedule_EventProgramPerson_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly itemPeople: ReadonlyArray<Content_ItemProgramPerson>;
  /** An aggregate relationship */
  readonly itemPeople_aggregate: Content_ItemProgramPerson_Aggregate;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount: Scalars['Int'];
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};

/** columns and relationships of "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken = {
  readonly __typename?: 'collection_ProgramPersonByAccessToken';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly itemPeople: ReadonlyArray<Content_ItemProgramPersonByAccessToken>;
  /** An aggregate relationship */
  readonly itemPeople_aggregate: Content_ItemProgramPersonByAccessToken_Aggregate;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessTokenItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessTokenItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};

/** aggregated selection of "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken_Aggregate = {
  readonly __typename?: 'collection_ProgramPersonByAccessToken_aggregate';
  readonly aggregate?: Maybe<Collection_ProgramPersonByAccessToken_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_ProgramPersonByAccessToken>;
};

/** aggregate fields of "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken_Aggregate_Fields = {
  readonly __typename?: 'collection_ProgramPersonByAccessToken_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Collection_ProgramPersonByAccessToken_Max_Fields>;
  readonly min?: Maybe<Collection_ProgramPersonByAccessToken_Min_Fields>;
};


/** aggregate fields of "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "collection.ProgramPersonByAccessToken". All fields are combined with a logical 'AND'. */
export type Collection_ProgramPersonByAccessToken_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Bool_Exp>>;
  readonly _not?: Maybe<Collection_ProgramPersonByAccessToken_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Bool_Exp>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemPeople?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for inserting data into table "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemPeople?: Maybe<Content_ItemProgramPersonByAccessToken_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Collection_ProgramPersonByAccessToken_Max_Fields = {
  readonly __typename?: 'collection_ProgramPersonByAccessToken_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Collection_ProgramPersonByAccessToken_Min_Fields = {
  readonly __typename?: 'collection_ProgramPersonByAccessToken_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken_Mutation_Response = {
  readonly __typename?: 'collection_ProgramPersonByAccessToken_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Collection_ProgramPersonByAccessToken>;
};

/** input type for inserting object relation for remote table "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken_Obj_Rel_Insert_Input = {
  readonly data: Collection_ProgramPersonByAccessToken_Insert_Input;
};

/** Ordering options when selecting data from "collection.ProgramPersonByAccessToken". */
export type Collection_ProgramPersonByAccessToken_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly affiliation?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemPeople_aggregate?: Maybe<Content_ItemProgramPersonByAccessToken_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** select columns of table "collection.ProgramPersonByAccessToken" */
export enum Collection_ProgramPersonByAccessToken_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RegistrantId = 'registrantId'
}

/** input type for updating data in table "collection.ProgramPersonByAccessToken" */
export type Collection_ProgramPersonByAccessToken_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<Schedule_EventProgramPerson>;
  /** An aggregate relationship */
  readonly eventPeople_aggregate: Schedule_EventProgramPerson_Aggregate;
  readonly id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly itemPeople: ReadonlyArray<Content_ItemProgramPerson>;
  /** An aggregate relationship */
  readonly itemPeople_aggregate: Content_ItemProgramPerson_Aggregate;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessTokenEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessTokenEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessTokenItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessTokenItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};

/** aggregated selection of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Aggregate = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_aggregate';
  readonly aggregate?: Maybe<Collection_ProgramPersonWithAccessToken_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_ProgramPersonWithAccessToken>;
};

/** aggregate fields of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Aggregate_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_aggregate_fields';
  readonly avg?: Maybe<Collection_ProgramPersonWithAccessToken_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Collection_ProgramPersonWithAccessToken_Max_Fields>;
  readonly min?: Maybe<Collection_ProgramPersonWithAccessToken_Min_Fields>;
  readonly stddev?: Maybe<Collection_ProgramPersonWithAccessToken_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Collection_ProgramPersonWithAccessToken_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Collection_ProgramPersonWithAccessToken_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Collection_ProgramPersonWithAccessToken_Sum_Fields>;
  readonly var_pop?: Maybe<Collection_ProgramPersonWithAccessToken_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Collection_ProgramPersonWithAccessToken_Var_Samp_Fields>;
  readonly variance?: Maybe<Collection_ProgramPersonWithAccessToken_Variance_Fields>;
};


/** aggregate fields of "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Collection_ProgramPersonWithAccessToken_Avg_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_avg_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "collection.ProgramPersonWithAccessToken". All fields are combined with a logical 'AND'. */
export type Collection_ProgramPersonWithAccessToken_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Bool_Exp>>;
  readonly _not?: Maybe<Collection_ProgramPersonWithAccessToken_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Bool_Exp>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly submissionRequestsSentCount?: Maybe<Int_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Inc_Input = {
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Collection_ProgramPersonWithAccessToken_Max_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Collection_ProgramPersonWithAccessToken_Min_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Mutation_Response = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Collection_ProgramPersonWithAccessToken>;
};

/** input type for inserting object relation for remote table "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Obj_Rel_Insert_Input = {
  readonly data: Collection_ProgramPersonWithAccessToken_Insert_Input;
};

/** Ordering options when selecting data from "collection.ProgramPersonWithAccessToken". */
export type Collection_ProgramPersonWithAccessToken_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly affiliation?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemPeople_aggregate?: Maybe<Content_ItemProgramPerson_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** select columns of table "collection.ProgramPersonWithAccessToken" */
export enum Collection_ProgramPersonWithAccessToken_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  SubmissionRequestsSentCount = 'submissionRequestsSentCount'
}

/** input type for updating data in table "collection.ProgramPersonWithAccessToken" */
export type Collection_ProgramPersonWithAccessToken_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Collection_ProgramPersonWithAccessToken_Stddev_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_stddev_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Collection_ProgramPersonWithAccessToken_Stddev_Pop_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_stddev_pop_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Collection_ProgramPersonWithAccessToken_Stddev_Samp_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_stddev_samp_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Collection_ProgramPersonWithAccessToken_Sum_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_sum_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Collection_ProgramPersonWithAccessToken_Var_Pop_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_var_pop_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Collection_ProgramPersonWithAccessToken_Var_Samp_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_var_samp_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Collection_ProgramPersonWithAccessToken_Variance_Fields = {
  readonly __typename?: 'collection_ProgramPersonWithAccessToken_variance_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** aggregated selection of "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate = {
  readonly __typename?: 'collection_ProgramPerson_aggregate';
  readonly aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_ProgramPerson>;
};

/** aggregate fields of "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate_Fields = {
  readonly __typename?: 'collection_ProgramPerson_aggregate_fields';
  readonly avg?: Maybe<Collection_ProgramPerson_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Collection_ProgramPerson_Max_Fields>;
  readonly min?: Maybe<Collection_ProgramPerson_Min_Fields>;
  readonly stddev?: Maybe<Collection_ProgramPerson_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Collection_ProgramPerson_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Collection_ProgramPerson_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Collection_ProgramPerson_Sum_Fields>;
  readonly var_pop?: Maybe<Collection_ProgramPerson_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Collection_ProgramPerson_Var_Samp_Fields>;
  readonly variance?: Maybe<Collection_ProgramPerson_Variance_Fields>;
};


/** aggregate fields of "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate_Order_By = {
  readonly avg?: Maybe<Collection_ProgramPerson_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Collection_ProgramPerson_Max_Order_By>;
  readonly min?: Maybe<Collection_ProgramPerson_Min_Order_By>;
  readonly stddev?: Maybe<Collection_ProgramPerson_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Collection_ProgramPerson_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Collection_ProgramPerson_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Collection_ProgramPerson_Sum_Order_By>;
  readonly var_pop?: Maybe<Collection_ProgramPerson_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Collection_ProgramPerson_Var_Samp_Order_By>;
  readonly variance?: Maybe<Collection_ProgramPerson_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Collection_ProgramPerson_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};

/** aggregate avg on columns */
export type Collection_ProgramPerson_Avg_Fields = {
  readonly __typename?: 'collection_ProgramPerson_avg_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Avg_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "collection.ProgramPerson". All fields are combined with a logical 'AND'. */
export type Collection_ProgramPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Collection_ProgramPerson_Bool_Exp>>;
  readonly _not?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Collection_ProgramPerson_Bool_Exp>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly submissionRequestsSentCount?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "collection.ProgramPerson" */
export enum Collection_ProgramPerson_Constraint {
  /** unique or primary key constraint */
  ProgramPersonConferenceIdNameAffiliationKey = 'ProgramPerson_conferenceId_name_affiliation_key',
  /** unique or primary key constraint */
  ProgramPersonPkey = 'ProgramPerson_pkey',
  /** unique or primary key constraint */
  CollectionProgramPersonAccessToken = 'collection_ProgramPerson_accessToken'
}

/** input type for incrementing numeric columns in table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Inc_Input = {
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Collection_ProgramPerson_Max_Fields = {
  readonly __typename?: 'collection_ProgramPerson_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Max_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly affiliation?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Collection_ProgramPerson_Min_Fields = {
  readonly __typename?: 'collection_ProgramPerson_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Min_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly affiliation?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** response of any mutation on the table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Mutation_Response = {
  readonly __typename?: 'collection_ProgramPerson_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Collection_ProgramPerson>;
};

/** input type for inserting object relation for remote table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Obj_Rel_Insert_Input = {
  readonly data: Collection_ProgramPerson_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};

/** on conflict condition type for table "collection.ProgramPerson" */
export type Collection_ProgramPerson_On_Conflict = {
  readonly constraint: Collection_ProgramPerson_Constraint;
  readonly update_columns?: ReadonlyArray<Collection_ProgramPerson_Update_Column>;
  readonly where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};

/** Ordering options when selecting data from "collection.ProgramPerson". */
export type Collection_ProgramPerson_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly affiliation?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemPeople_aggregate?: Maybe<Content_ItemProgramPerson_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** primary key columns input for table: collection_ProgramPerson */
export type Collection_ProgramPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "collection.ProgramPerson" */
export enum Collection_ProgramPerson_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  SubmissionRequestsSentCount = 'submissionRequestsSentCount'
}

/** input type for updating data in table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Collection_ProgramPerson_Stddev_Fields = {
  readonly __typename?: 'collection_ProgramPerson_stddev_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Stddev_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Collection_ProgramPerson_Stddev_Pop_Fields = {
  readonly __typename?: 'collection_ProgramPerson_stddev_pop_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Stddev_Pop_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Collection_ProgramPerson_Stddev_Samp_Fields = {
  readonly __typename?: 'collection_ProgramPerson_stddev_samp_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Stddev_Samp_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Collection_ProgramPerson_Sum_Fields = {
  readonly __typename?: 'collection_ProgramPerson_sum_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Sum_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** update columns of table "collection.ProgramPerson" */
export enum Collection_ProgramPerson_Update_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  SubmissionRequestsSentCount = 'submissionRequestsSentCount'
}

/** aggregate var_pop on columns */
export type Collection_ProgramPerson_Var_Pop_Fields = {
  readonly __typename?: 'collection_ProgramPerson_var_pop_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Var_Pop_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Collection_ProgramPerson_Var_Samp_Fields = {
  readonly __typename?: 'collection_ProgramPerson_var_samp_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Var_Samp_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Collection_ProgramPerson_Variance_Fields = {
  readonly __typename?: 'collection_ProgramPerson_variance_fields';
  readonly submissionRequestsSentCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Variance_Order_By = {
  readonly submissionRequestsSentCount?: Maybe<Order_By>;
};

/** columns and relationships of "collection.Tag" */
export type Collection_Tag = {
  readonly __typename?: 'collection_Tag';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly eventTags: ReadonlyArray<Schedule_EventTag>;
  /** An aggregate relationship */
  readonly eventTags_aggregate: Schedule_EventTag_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly itemTags: ReadonlyArray<Content_ItemTag>;
  /** An aggregate relationship */
  readonly itemTags_aggregate: Content_ItemTag_Aggregate;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority: Scalars['Int'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagItemTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagItemTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};

/** aggregated selection of "collection.Tag" */
export type Collection_Tag_Aggregate = {
  readonly __typename?: 'collection_Tag_aggregate';
  readonly aggregate?: Maybe<Collection_Tag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_Tag>;
};

/** aggregate fields of "collection.Tag" */
export type Collection_Tag_Aggregate_Fields = {
  readonly __typename?: 'collection_Tag_aggregate_fields';
  readonly avg?: Maybe<Collection_Tag_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Collection_Tag_Max_Fields>;
  readonly min?: Maybe<Collection_Tag_Min_Fields>;
  readonly stddev?: Maybe<Collection_Tag_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Collection_Tag_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Collection_Tag_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Collection_Tag_Sum_Fields>;
  readonly var_pop?: Maybe<Collection_Tag_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Collection_Tag_Var_Samp_Fields>;
  readonly variance?: Maybe<Collection_Tag_Variance_Fields>;
};


/** aggregate fields of "collection.Tag" */
export type Collection_Tag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "collection.Tag" */
export type Collection_Tag_Aggregate_Order_By = {
  readonly avg?: Maybe<Collection_Tag_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Collection_Tag_Max_Order_By>;
  readonly min?: Maybe<Collection_Tag_Min_Order_By>;
  readonly stddev?: Maybe<Collection_Tag_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Collection_Tag_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Collection_Tag_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Collection_Tag_Sum_Order_By>;
  readonly var_pop?: Maybe<Collection_Tag_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Collection_Tag_Var_Samp_Order_By>;
  readonly variance?: Maybe<Collection_Tag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "collection.Tag" */
export type Collection_Tag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Collection_Tag_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};

/** aggregate avg on columns */
export type Collection_Tag_Avg_Fields = {
  readonly __typename?: 'collection_Tag_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "collection.Tag" */
export type Collection_Tag_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "collection.Tag". All fields are combined with a logical 'AND'. */
export type Collection_Tag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Collection_Tag_Bool_Exp>>;
  readonly _not?: Maybe<Collection_Tag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Collection_Tag_Bool_Exp>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventTags?: Maybe<Schedule_EventTag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemTags?: Maybe<Content_ItemTag_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "collection.Tag" */
export enum Collection_Tag_Constraint {
  /** unique or primary key constraint */
  TagPkey = 'Tag_pkey'
}

/** input type for incrementing numeric columns in table "collection.Tag" */
export type Collection_Tag_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "collection.Tag" */
export type Collection_Tag_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventTags?: Maybe<Schedule_EventTag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTags?: Maybe<Content_ItemTag_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Collection_Tag_Max_Fields = {
  readonly __typename?: 'collection_Tag_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "collection.Tag" */
export type Collection_Tag_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Collection_Tag_Min_Fields = {
  readonly __typename?: 'collection_Tag_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "collection.Tag" */
export type Collection_Tag_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "collection.Tag" */
export type Collection_Tag_Mutation_Response = {
  readonly __typename?: 'collection_Tag_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Collection_Tag>;
};

/** input type for inserting object relation for remote table "collection.Tag" */
export type Collection_Tag_Obj_Rel_Insert_Input = {
  readonly data: Collection_Tag_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};

/** on conflict condition type for table "collection.Tag" */
export type Collection_Tag_On_Conflict = {
  readonly constraint: Collection_Tag_Constraint;
  readonly update_columns?: ReadonlyArray<Collection_Tag_Update_Column>;
  readonly where?: Maybe<Collection_Tag_Bool_Exp>;
};

/** Ordering options when selecting data from "collection.Tag". */
export type Collection_Tag_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventTags_aggregate?: Maybe<Schedule_EventTag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemTags_aggregate?: Maybe<Content_ItemTag_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: collection_Tag */
export type Collection_Tag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "collection.Tag" */
export enum Collection_Tag_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "collection.Tag" */
export type Collection_Tag_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Collection_Tag_Stddev_Fields = {
  readonly __typename?: 'collection_Tag_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "collection.Tag" */
export type Collection_Tag_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Collection_Tag_Stddev_Pop_Fields = {
  readonly __typename?: 'collection_Tag_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "collection.Tag" */
export type Collection_Tag_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Collection_Tag_Stddev_Samp_Fields = {
  readonly __typename?: 'collection_Tag_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "collection.Tag" */
export type Collection_Tag_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Collection_Tag_Sum_Fields = {
  readonly __typename?: 'collection_Tag_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "collection.Tag" */
export type Collection_Tag_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "collection.Tag" */
export enum Collection_Tag_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Collection_Tag_Var_Pop_Fields = {
  readonly __typename?: 'collection_Tag_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "collection.Tag" */
export type Collection_Tag_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Collection_Tag_Var_Samp_Fields = {
  readonly __typename?: 'collection_Tag_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "collection.Tag" */
export type Collection_Tag_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Collection_Tag_Variance_Fields = {
  readonly __typename?: 'collection_Tag_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "collection.Tag" */
export type Collection_Tag_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

export type Collection_SearchProgramPerson_Args = {
  readonly conferenceid?: Maybe<Scalars['uuid']>;
  readonly search?: Maybe<Scalars['String']>;
};

/** columns and relationships of "conference.Conference" */
export type Conference_Conference = {
  readonly __typename?: 'conference_Conference';
  /** An array relationship */
  readonly chats: ReadonlyArray<Chat_Chat>;
  /** An aggregate relationship */
  readonly chats_aggregate: Chat_Chat_Aggregate;
  /** An object relationship */
  readonly completedRegistrationsStat?: Maybe<Analytics_CompletedRegistrations>;
  /** An array relationship */
  readonly configurations: ReadonlyArray<Conference_Configuration>;
  /** An aggregate relationship */
  readonly configurations_aggregate: Conference_Configuration_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly createdBy: Scalars['String'];
  /** An object relationship */
  readonly creator: User;
  /** An object relationship */
  readonly demoCode: Conference_DemoCode;
  readonly demoCodeId: Scalars['uuid'];
  /** An array relationship */
  readonly exhibitions: ReadonlyArray<Collection_Exhibition>;
  /** An aggregate relationship */
  readonly exhibitions_aggregate: Collection_Exhibition_Aggregate;
  /** An array relationship */
  readonly groups: ReadonlyArray<Permissions_Group>;
  /** An aggregate relationship */
  readonly groups_aggregate: Permissions_Group_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_Item>;
  /** An aggregate relationship */
  readonly items_aggregate: Content_Item_Aggregate;
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly originatingDatas: ReadonlyArray<Conference_OriginatingData>;
  /** An aggregate relationship */
  readonly originatingDatas_aggregate: Conference_OriginatingData_Aggregate;
  /** An array relationship */
  readonly programPeople: ReadonlyArray<Collection_ProgramPerson>;
  /** An aggregate relationship */
  readonly programPeople_aggregate: Collection_ProgramPerson_Aggregate;
  /** An array relationship */
  readonly publicPermissions: ReadonlyArray<FlatUnauthPermission>;
  /** An aggregate relationship */
  readonly publicPermissions_aggregate: FlatUnauthPermission_Aggregate;
  /** An array relationship */
  readonly registrants: ReadonlyArray<Registrant_Registrant>;
  /** An aggregate relationship */
  readonly registrants_aggregate: Registrant_Registrant_Aggregate;
  /** An array relationship */
  readonly roles: ReadonlyArray<Permissions_Role>;
  /** An aggregate relationship */
  readonly roles_aggregate: Permissions_Role_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregate relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  readonly shortName: Scalars['String'];
  /** An array relationship */
  readonly shufflePeriods: ReadonlyArray<Room_ShufflePeriod>;
  /** An aggregate relationship */
  readonly shufflePeriods_aggregate: Room_ShufflePeriod_Aggregate;
  readonly slug: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Collection_Tag>;
  /** An aggregate relationship */
  readonly tags_aggregate: Collection_Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly userPermissions: ReadonlyArray<FlatUserPermission>;
  /** An aggregate relationship */
  readonly userPermissions_aggregate: FlatUserPermission_Aggregate;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceChatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceChats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceConfigurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceConfigurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceExhibitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceExhibitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceOriginatingDatasArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceOriginatingDatas_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceProgramPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceProgramPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferencePublicPermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferencePublicPermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceShufflePeriodsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceShufflePeriods_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceUserPermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceUserPermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};

/** aggregated selection of "conference.Conference" */
export type Conference_Conference_Aggregate = {
  readonly __typename?: 'conference_Conference_aggregate';
  readonly aggregate?: Maybe<Conference_Conference_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_Conference>;
};

/** aggregate fields of "conference.Conference" */
export type Conference_Conference_Aggregate_Fields = {
  readonly __typename?: 'conference_Conference_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Conference_Conference_Max_Fields>;
  readonly min?: Maybe<Conference_Conference_Min_Fields>;
};


/** aggregate fields of "conference.Conference" */
export type Conference_Conference_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.Conference" */
export type Conference_Conference_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_Conference_Max_Order_By>;
  readonly min?: Maybe<Conference_Conference_Min_Order_By>;
};

/** input type for inserting array relation for remote table "conference.Conference" */
export type Conference_Conference_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_Conference_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.Conference". All fields are combined with a logical 'AND'. */
export type Conference_Conference_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Conference_Conference_Bool_Exp>>;
  readonly _not?: Maybe<Conference_Conference_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Conference_Conference_Bool_Exp>>;
  readonly chats?: Maybe<Chat_Chat_Bool_Exp>;
  readonly completedRegistrationsStat?: Maybe<Analytics_CompletedRegistrations_Bool_Exp>;
  readonly configurations?: Maybe<Conference_Configuration_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly createdBy?: Maybe<String_Comparison_Exp>;
  readonly creator?: Maybe<User_Bool_Exp>;
  readonly demoCode?: Maybe<Conference_DemoCode_Bool_Exp>;
  readonly demoCodeId?: Maybe<Uuid_Comparison_Exp>;
  readonly exhibitions?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly groups?: Maybe<Permissions_Group_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly items?: Maybe<Content_Item_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingDatas?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly publicPermissions?: Maybe<FlatUnauthPermission_Bool_Exp>;
  readonly registrants?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly roles?: Maybe<Permissions_Role_Bool_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly shortName?: Maybe<String_Comparison_Exp>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Collection_Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly userPermissions?: Maybe<FlatUserPermission_Bool_Exp>;
};

/** unique or primary key constraints on table "conference.Conference" */
export enum Conference_Conference_Constraint {
  /** unique or primary key constraint */
  ConferenceDemoCodeIdKey = 'Conference_demoCodeId_key',
  /** unique or primary key constraint */
  ConferenceNameKey = 'Conference_name_key',
  /** unique or primary key constraint */
  ConferencePkey = 'Conference_pkey',
  /** unique or primary key constraint */
  ConferenceShortNameKey = 'Conference_shortName_key',
  /** unique or primary key constraint */
  ConferenceSlugKey = 'Conference_slug_key'
}

/** input type for inserting data into table "conference.Conference" */
export type Conference_Conference_Insert_Input = {
  readonly chats?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly completedRegistrationsStat?: Maybe<Analytics_CompletedRegistrations_Obj_Rel_Insert_Input>;
  readonly configurations?: Maybe<Conference_Configuration_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly creator?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly demoCode?: Maybe<Conference_DemoCode_Obj_Rel_Insert_Input>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly exhibitions?: Maybe<Collection_Exhibition_Arr_Rel_Insert_Input>;
  readonly groups?: Maybe<Permissions_Group_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly items?: Maybe<Content_Item_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDatas?: Maybe<Conference_OriginatingData_Arr_Rel_Insert_Input>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Arr_Rel_Insert_Input>;
  readonly publicPermissions?: Maybe<FlatUnauthPermission_Arr_Rel_Insert_Input>;
  readonly registrants?: Maybe<Registrant_Registrant_Arr_Rel_Insert_Input>;
  readonly roles?: Maybe<Permissions_Role_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Arr_Rel_Insert_Input>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Collection_Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userPermissions?: Maybe<FlatUserPermission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Conference_Conference_Max_Fields = {
  readonly __typename?: 'conference_Conference_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "conference.Conference" */
export type Conference_Conference_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_Conference_Min_Fields = {
  readonly __typename?: 'conference_Conference_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "conference.Conference" */
export type Conference_Conference_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.Conference" */
export type Conference_Conference_Mutation_Response = {
  readonly __typename?: 'conference_Conference_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Conference_Conference>;
};

/** input type for inserting object relation for remote table "conference.Conference" */
export type Conference_Conference_Obj_Rel_Insert_Input = {
  readonly data: Conference_Conference_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};

/** on conflict condition type for table "conference.Conference" */
export type Conference_Conference_On_Conflict = {
  readonly constraint: Conference_Conference_Constraint;
  readonly update_columns?: ReadonlyArray<Conference_Conference_Update_Column>;
  readonly where?: Maybe<Conference_Conference_Bool_Exp>;
};

/** Ordering options when selecting data from "conference.Conference". */
export type Conference_Conference_Order_By = {
  readonly chats_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly completedRegistrationsStat?: Maybe<Analytics_CompletedRegistrations_Order_By>;
  readonly configurations_aggregate?: Maybe<Conference_Configuration_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly creator?: Maybe<User_Order_By>;
  readonly demoCode?: Maybe<Conference_DemoCode_Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly exhibitions_aggregate?: Maybe<Collection_Exhibition_Aggregate_Order_By>;
  readonly groups_aggregate?: Maybe<Permissions_Group_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_Item_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDatas_aggregate?: Maybe<Conference_OriginatingData_Aggregate_Order_By>;
  readonly programPeople_aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Order_By>;
  readonly publicPermissions_aggregate?: Maybe<FlatUnauthPermission_Aggregate_Order_By>;
  readonly registrants_aggregate?: Maybe<Registrant_Registrant_Aggregate_Order_By>;
  readonly roles_aggregate?: Maybe<Permissions_Role_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly shufflePeriods_aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Collection_Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userPermissions_aggregate?: Maybe<FlatUserPermission_Aggregate_Order_By>;
};

/** primary key columns input for table: conference_Conference */
export type Conference_Conference_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "conference.Conference" */
export enum Conference_Conference_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "conference.Conference" */
export type Conference_Conference_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "conference.Conference" */
export enum Conference_Conference_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "conference.Configuration" */
export type Conference_Configuration = {
  readonly __typename?: 'conference_Configuration';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly key: Conference_ConfigurationKey_Enum;
  readonly updatedAt: Scalars['timestamptz'];
  readonly value: Scalars['jsonb'];
};


/** columns and relationships of "conference.Configuration" */
export type Conference_ConfigurationValueArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "conference.ConfigurationKey" */
export type Conference_ConfigurationKey = {
  readonly __typename?: 'conference_ConfigurationKey';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "conference.ConfigurationKey" */
export type Conference_ConfigurationKey_Aggregate = {
  readonly __typename?: 'conference_ConfigurationKey_aggregate';
  readonly aggregate?: Maybe<Conference_ConfigurationKey_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_ConfigurationKey>;
};

/** aggregate fields of "conference.ConfigurationKey" */
export type Conference_ConfigurationKey_Aggregate_Fields = {
  readonly __typename?: 'conference_ConfigurationKey_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Conference_ConfigurationKey_Max_Fields>;
  readonly min?: Maybe<Conference_ConfigurationKey_Min_Fields>;
};


/** aggregate fields of "conference.ConfigurationKey" */
export type Conference_ConfigurationKey_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "conference.ConfigurationKey". All fields are combined with a logical 'AND'. */
export type Conference_ConfigurationKey_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Bool_Exp>>;
  readonly _not?: Maybe<Conference_ConfigurationKey_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conference.ConfigurationKey" */
export enum Conference_ConfigurationKey_Constraint {
  /** unique or primary key constraint */
  ConfigurationKeyPkey = 'ConfigurationKey_pkey'
}

export enum Conference_ConfigurationKey_Enum {
  /** A list of videos to be used as the background for title/sponsor slides. */
  BackgroundVideos = 'BACKGROUND_VIDEOS',
  /** A string representing the app version. Changing this causes the user's browsers to refresh. */
  ClowdrAppVersion = 'CLOWDR_APP_VERSION',
  /** Boolean. Disable the "Events around this content" section of the Item pages. */
  DisableNearbyEvents = 'DISABLE_NEARBY_EVENTS',
  EmailTemplateSubmissionRequest = 'EMAIL_TEMPLATE_SUBMISSION_REQUEST',
  EmailTemplateSubtitlesGenerated = 'EMAIL_TEMPLATE_SUBTITLES_GENERATED',
  /** Boolean. Whether to enable the backstage stream preview or not. */
  EnableBackstageStreamPreview = 'ENABLE_BACKSTAGE_STREAM_PREVIEW',
  /** Boolean. Whether to enable the External RTMP Broadcast feature. */
  EnableExternalRtmpBroadcast = 'ENABLE_EXTERNAL_RTMP_BROADCAST',
  /** List of S3 URLs. */
  FillerVideos = 'FILLER_VIDEOS',
  /** A string representing the full frontend host URL for the conference. If not provided, this defaults to the system configuration. */
  FrontendHost = 'FRONTEND_HOST',
  /** An image to be displayed if AWS MediaLive loses input. */
  InputLossSlate = 'INPUT_LOSS_SLATE',
  /** A string representing a valid URL for users to register for the conference. */
  RegistrationUrl = 'REGISTRATION_URL',
  /** Select different versions of the schedule view. */
  ScheduleViewVersion = 'SCHEDULE_VIEW_VERSION',
  /** String. Label for the "sponsors" in the sidebar for when a conference uses a different term. */
  SponsorsLabel = 'SPONSORS_LABEL',
  /** A string representing a valid email address for contacting the conference organisers. */
  SupportAddress = 'SUPPORT_ADDRESS',
  /** A string representing a valid email address for contacting the service hosting company for technical support related to the conference. */
  TechSupportAddress = 'TECH_SUPPORT_ADDRESS',
  /** Text of the upload agreement or a URL to one. */
  UploadAgreement = 'UPLOAD_AGREEMENT',
  /** The time in milliseconds since the UNIX epoch, as a string. */
  UploadCutoffTimestamp = 'UPLOAD_CUTOFF_TIMESTAMP'
}

/** Boolean expression to compare columns of type "conference_ConfigurationKey_enum". All fields are combined with logical 'AND'. */
export type Conference_ConfigurationKey_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Conference_ConfigurationKey_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Conference_ConfigurationKey_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Enum>>;
};

/** input type for inserting data into table "conference.ConfigurationKey" */
export type Conference_ConfigurationKey_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Conference_ConfigurationKey_Max_Fields = {
  readonly __typename?: 'conference_ConfigurationKey_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Conference_ConfigurationKey_Min_Fields = {
  readonly __typename?: 'conference_ConfigurationKey_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "conference.ConfigurationKey" */
export type Conference_ConfigurationKey_Mutation_Response = {
  readonly __typename?: 'conference_ConfigurationKey_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Conference_ConfigurationKey>;
};

/** on conflict condition type for table "conference.ConfigurationKey" */
export type Conference_ConfigurationKey_On_Conflict = {
  readonly constraint: Conference_ConfigurationKey_Constraint;
  readonly update_columns?: ReadonlyArray<Conference_ConfigurationKey_Update_Column>;
  readonly where?: Maybe<Conference_ConfigurationKey_Bool_Exp>;
};

/** Ordering options when selecting data from "conference.ConfigurationKey". */
export type Conference_ConfigurationKey_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: conference_ConfigurationKey */
export type Conference_ConfigurationKey_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "conference.ConfigurationKey" */
export enum Conference_ConfigurationKey_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "conference.ConfigurationKey" */
export type Conference_ConfigurationKey_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "conference.ConfigurationKey" */
export enum Conference_ConfigurationKey_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "conference.Configuration" */
export type Conference_Configuration_Aggregate = {
  readonly __typename?: 'conference_Configuration_aggregate';
  readonly aggregate?: Maybe<Conference_Configuration_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_Configuration>;
};

/** aggregate fields of "conference.Configuration" */
export type Conference_Configuration_Aggregate_Fields = {
  readonly __typename?: 'conference_Configuration_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Conference_Configuration_Max_Fields>;
  readonly min?: Maybe<Conference_Configuration_Min_Fields>;
};


/** aggregate fields of "conference.Configuration" */
export type Conference_Configuration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.Configuration" */
export type Conference_Configuration_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_Configuration_Max_Order_By>;
  readonly min?: Maybe<Conference_Configuration_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conference_Configuration_Append_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "conference.Configuration" */
export type Conference_Configuration_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_Configuration_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_Configuration_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.Configuration". All fields are combined with a logical 'AND'. */
export type Conference_Configuration_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Conference_Configuration_Bool_Exp>>;
  readonly _not?: Maybe<Conference_Configuration_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Conference_Configuration_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly key?: Maybe<Conference_ConfigurationKey_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly value?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "conference.Configuration" */
export enum Conference_Configuration_Constraint {
  /** unique or primary key constraint */
  ConfigurationPkey = 'Configuration_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conference_Configuration_Delete_At_Path_Input = {
  readonly value?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conference_Configuration_Delete_Elem_Input = {
  readonly value?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conference_Configuration_Delete_Key_Input = {
  readonly value?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "conference.Configuration" */
export type Conference_Configuration_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<Conference_ConfigurationKey_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Conference_Configuration_Max_Fields = {
  readonly __typename?: 'conference_Configuration_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "conference.Configuration" */
export type Conference_Configuration_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_Configuration_Min_Fields = {
  readonly __typename?: 'conference_Configuration_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "conference.Configuration" */
export type Conference_Configuration_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.Configuration" */
export type Conference_Configuration_Mutation_Response = {
  readonly __typename?: 'conference_Configuration_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Conference_Configuration>;
};

/** on conflict condition type for table "conference.Configuration" */
export type Conference_Configuration_On_Conflict = {
  readonly constraint: Conference_Configuration_Constraint;
  readonly update_columns?: ReadonlyArray<Conference_Configuration_Update_Column>;
  readonly where?: Maybe<Conference_Configuration_Bool_Exp>;
};

/** Ordering options when selecting data from "conference.Configuration". */
export type Conference_Configuration_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly value?: Maybe<Order_By>;
};

/** primary key columns input for table: conference_Configuration */
export type Conference_Configuration_Pk_Columns_Input = {
  readonly conferenceId: Scalars['uuid'];
  readonly key: Conference_ConfigurationKey_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conference_Configuration_Prepend_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "conference.Configuration" */
export enum Conference_Configuration_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "conference.Configuration" */
export type Conference_Configuration_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<Conference_ConfigurationKey_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "conference.Configuration" */
export enum Conference_Configuration_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** columns and relationships of "conference.DemoCode" */
export type Conference_DemoCode = {
  readonly __typename?: 'conference_DemoCode';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly usedBy?: Maybe<User>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregated selection of "conference.DemoCode" */
export type Conference_DemoCode_Aggregate = {
  readonly __typename?: 'conference_DemoCode_aggregate';
  readonly aggregate?: Maybe<Conference_DemoCode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_DemoCode>;
};

/** aggregate fields of "conference.DemoCode" */
export type Conference_DemoCode_Aggregate_Fields = {
  readonly __typename?: 'conference_DemoCode_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Conference_DemoCode_Max_Fields>;
  readonly min?: Maybe<Conference_DemoCode_Min_Fields>;
};


/** aggregate fields of "conference.DemoCode" */
export type Conference_DemoCode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.DemoCode" */
export type Conference_DemoCode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_DemoCode_Max_Order_By>;
  readonly min?: Maybe<Conference_DemoCode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "conference.DemoCode" */
export type Conference_DemoCode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_DemoCode_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.DemoCode". All fields are combined with a logical 'AND'. */
export type Conference_DemoCode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Conference_DemoCode_Bool_Exp>>;
  readonly _not?: Maybe<Conference_DemoCode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Conference_DemoCode_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly note?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly usedBy?: Maybe<User_Bool_Exp>;
  readonly usedById?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conference.DemoCode" */
export enum Conference_DemoCode_Constraint {
  /** unique or primary key constraint */
  DemoCodePkey = 'DemoCode_pkey'
}

/** input type for inserting data into table "conference.DemoCode" */
export type Conference_DemoCode_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedBy?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Conference_DemoCode_Max_Fields = {
  readonly __typename?: 'conference_DemoCode_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "conference.DemoCode" */
export type Conference_DemoCode_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_DemoCode_Min_Fields = {
  readonly __typename?: 'conference_DemoCode_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "conference.DemoCode" */
export type Conference_DemoCode_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.DemoCode" */
export type Conference_DemoCode_Mutation_Response = {
  readonly __typename?: 'conference_DemoCode_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Conference_DemoCode>;
};

/** input type for inserting object relation for remote table "conference.DemoCode" */
export type Conference_DemoCode_Obj_Rel_Insert_Input = {
  readonly data: Conference_DemoCode_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};

/** on conflict condition type for table "conference.DemoCode" */
export type Conference_DemoCode_On_Conflict = {
  readonly constraint: Conference_DemoCode_Constraint;
  readonly update_columns?: ReadonlyArray<Conference_DemoCode_Update_Column>;
  readonly where?: Maybe<Conference_DemoCode_Bool_Exp>;
};

/** Ordering options when selecting data from "conference.DemoCode". */
export type Conference_DemoCode_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedBy?: Maybe<User_Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** primary key columns input for table: conference_DemoCode */
export type Conference_DemoCode_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "conference.DemoCode" */
export enum Conference_DemoCode_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** input type for updating data in table "conference.DemoCode" */
export type Conference_DemoCode_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** update columns of table "conference.DemoCode" */
export enum Conference_DemoCode_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingData = {
  readonly __typename?: 'conference_OriginatingData';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  readonly elements: ReadonlyArray<Content_Element>;
  /** An aggregate relationship */
  readonly elements_aggregate: Content_Element_Aggregate;
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregate relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_Item>;
  /** An aggregate relationship */
  readonly items_aggregate: Content_Item_Aggregate;
  /** An array relationship */
  readonly programPeople: ReadonlyArray<Collection_ProgramPerson>;
  /** An aggregate relationship */
  readonly programPeople_aggregate: Collection_ProgramPerson_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregate relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  readonly sourceId: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Collection_Tag>;
  /** An aggregate relationship */
  readonly tags_aggregate: Collection_Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataElementsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataElements_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataProgramPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataProgramPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};

/** aggregated selection of "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate = {
  readonly __typename?: 'conference_OriginatingData_aggregate';
  readonly aggregate?: Maybe<Conference_OriginatingData_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_OriginatingData>;
};

/** aggregate fields of "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate_Fields = {
  readonly __typename?: 'conference_OriginatingData_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Conference_OriginatingData_Max_Fields>;
  readonly min?: Maybe<Conference_OriginatingData_Min_Fields>;
};


/** aggregate fields of "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_OriginatingData_Max_Order_By>;
  readonly min?: Maybe<Conference_OriginatingData_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conference_OriginatingData_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "conference.OriginatingData" */
export type Conference_OriginatingData_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_OriginatingData_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.OriginatingData". All fields are combined with a logical 'AND'. */
export type Conference_OriginatingData_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Conference_OriginatingData_Bool_Exp>>;
  readonly _not?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Conference_OriginatingData_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly elements?: Maybe<Content_Element_Bool_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly items?: Maybe<Content_Item_Bool_Exp>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly sourceId?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Collection_Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "conference.OriginatingData" */
export enum Conference_OriginatingData_Constraint {
  /** unique or primary key constraint */
  OriginatingDataPkey = 'OriginatingData_pkey',
  /** unique or primary key constraint */
  OriginatingDataSourceIdConferenceIdKey = 'OriginatingData_sourceId_conferenceId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conference_OriginatingData_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conference_OriginatingData_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conference_OriginatingData_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "conference.OriginatingData" */
export type Conference_OriginatingData_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly elements?: Maybe<Content_Element_Arr_Rel_Insert_Input>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly items?: Maybe<Content_Item_Arr_Rel_Insert_Input>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Collection_Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Conference_OriginatingData_Max_Fields = {
  readonly __typename?: 'conference_OriginatingData_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "conference.OriginatingData" */
export type Conference_OriginatingData_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_OriginatingData_Min_Fields = {
  readonly __typename?: 'conference_OriginatingData_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "conference.OriginatingData" */
export type Conference_OriginatingData_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.OriginatingData" */
export type Conference_OriginatingData_Mutation_Response = {
  readonly __typename?: 'conference_OriginatingData_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Conference_OriginatingData>;
};

/** input type for inserting object relation for remote table "conference.OriginatingData" */
export type Conference_OriginatingData_Obj_Rel_Insert_Input = {
  readonly data: Conference_OriginatingData_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};

/** on conflict condition type for table "conference.OriginatingData" */
export type Conference_OriginatingData_On_Conflict = {
  readonly constraint: Conference_OriginatingData_Constraint;
  readonly update_columns?: ReadonlyArray<Conference_OriginatingData_Update_Column>;
  readonly where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};

/** Ordering options when selecting data from "conference.OriginatingData". */
export type Conference_OriginatingData_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly elements_aggregate?: Maybe<Content_Element_Aggregate_Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_Item_Aggregate_Order_By>;
  readonly programPeople_aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Collection_Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: conference_OriginatingData */
export type Conference_OriginatingData_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conference_OriginatingData_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "conference.OriginatingData" */
export enum Conference_OriginatingData_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "conference.OriginatingData" */
export type Conference_OriginatingData_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "conference.OriginatingData" */
export enum Conference_OriginatingData_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "conference.PrepareJob" */
export type Conference_PrepareJob = {
  readonly __typename?: 'conference_PrepareJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly videoRenderJobs: ReadonlyArray<Video_VideoRenderJob>;
  /** An aggregate relationship */
  readonly videoRenderJobs_aggregate: Video_VideoRenderJob_Aggregate;
};


/** columns and relationships of "conference.PrepareJob" */
export type Conference_PrepareJobVideoRenderJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


/** columns and relationships of "conference.PrepareJob" */
export type Conference_PrepareJobVideoRenderJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};

/** aggregated selection of "conference.PrepareJob" */
export type Conference_PrepareJob_Aggregate = {
  readonly __typename?: 'conference_PrepareJob_aggregate';
  readonly aggregate?: Maybe<Conference_PrepareJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_PrepareJob>;
};

/** aggregate fields of "conference.PrepareJob" */
export type Conference_PrepareJob_Aggregate_Fields = {
  readonly __typename?: 'conference_PrepareJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Conference_PrepareJob_Max_Fields>;
  readonly min?: Maybe<Conference_PrepareJob_Min_Fields>;
};


/** aggregate fields of "conference.PrepareJob" */
export type Conference_PrepareJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "conference.PrepareJob". All fields are combined with a logical 'AND'. */
export type Conference_PrepareJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Conference_PrepareJob_Bool_Exp>>;
  readonly _not?: Maybe<Conference_PrepareJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Conference_PrepareJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoRenderJobs?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};

/** unique or primary key constraints on table "conference.PrepareJob" */
export enum Conference_PrepareJob_Constraint {
  /** unique or primary key constraint */
  PrepareJobPkey = 'PrepareJob_pkey'
}

/** input type for inserting data into table "conference.PrepareJob" */
export type Conference_PrepareJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoRenderJobs?: Maybe<Video_VideoRenderJob_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Conference_PrepareJob_Max_Fields = {
  readonly __typename?: 'conference_PrepareJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Conference_PrepareJob_Min_Fields = {
  readonly __typename?: 'conference_PrepareJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "conference.PrepareJob" */
export type Conference_PrepareJob_Mutation_Response = {
  readonly __typename?: 'conference_PrepareJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Conference_PrepareJob>;
};

/** input type for inserting object relation for remote table "conference.PrepareJob" */
export type Conference_PrepareJob_Obj_Rel_Insert_Input = {
  readonly data: Conference_PrepareJob_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Conference_PrepareJob_On_Conflict>;
};

/** on conflict condition type for table "conference.PrepareJob" */
export type Conference_PrepareJob_On_Conflict = {
  readonly constraint: Conference_PrepareJob_Constraint;
  readonly update_columns?: ReadonlyArray<Conference_PrepareJob_Update_Column>;
  readonly where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};

/** Ordering options when selecting data from "conference.PrepareJob". */
export type Conference_PrepareJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoRenderJobs_aggregate?: Maybe<Video_VideoRenderJob_Aggregate_Order_By>;
};

/** primary key columns input for table: conference_PrepareJob */
export type Conference_PrepareJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "conference.PrepareJob" */
export enum Conference_PrepareJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "conference.PrepareJob" */
export type Conference_PrepareJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "conference.PrepareJob" */
export enum Conference_PrepareJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "content.Element" */
export type Content_Element = {
  readonly __typename?: 'content_Element';
  readonly accessToken: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** A computed field, executes function "content.elementHasBeenSubmitted" */
  readonly hasBeenSubmitted?: Maybe<Scalars['Boolean']>;
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  /** A computed field, executes function "content.Element_itemTitle" */
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly permissionGrants: ReadonlyArray<Content_ElementPermissionGrant>;
  /** An aggregate relationship */
  readonly permissionGrants_aggregate: Content_ElementPermissionGrant_Aggregate;
  /** An array relationship */
  readonly stats: ReadonlyArray<Analytics_ContentElementStats>;
  /** An aggregate relationship */
  readonly stats_aggregate: Analytics_ContentElementStats_Aggregate;
  /** An object relationship */
  readonly totalViewsStat?: Maybe<Analytics_ElementTotalViews>;
  /** An object relationship */
  readonly type: Content_ElementType;
  readonly typeName: Content_ElementType_Enum;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly uploaders: ReadonlyArray<Content_Uploader>;
  /** A computed field, executes function "content.countUploaders" */
  readonly uploadersCount?: Maybe<Scalars['bigint']>;
  /** An aggregate relationship */
  readonly uploaders_aggregate: Content_Uploader_Aggregate;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
  /** An array relationship */
  readonly youTubeUploads: ReadonlyArray<Video_YouTubeUpload>;
  /** An aggregate relationship */
  readonly youTubeUploads_aggregate: Video_YouTubeUpload_Aggregate;
};


/** columns and relationships of "content.Element" */
export type Content_ElementDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementPermissionGrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementPermissionGrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementUploadersArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementUploaders_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementYouTubeUploadsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementYouTubeUploads_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};

/** columns and relationships of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken = {
  readonly __typename?: 'content_ElementByAccessToken';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "content.ElementByAccessToken" */
export type Content_ElementByAccessTokenDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.ElementByAccessToken" */
export type Content_ElementByAccessTokenLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Aggregate = {
  readonly __typename?: 'content_ElementByAccessToken_aggregate';
  readonly aggregate?: Maybe<Content_ElementByAccessToken_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ElementByAccessToken>;
};

/** aggregate fields of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Aggregate_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_aggregate_fields';
  readonly avg?: Maybe<Content_ElementByAccessToken_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ElementByAccessToken_Max_Fields>;
  readonly min?: Maybe<Content_ElementByAccessToken_Min_Fields>;
  readonly stddev?: Maybe<Content_ElementByAccessToken_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_ElementByAccessToken_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_ElementByAccessToken_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_ElementByAccessToken_Sum_Fields>;
  readonly var_pop?: Maybe<Content_ElementByAccessToken_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_ElementByAccessToken_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_ElementByAccessToken_Variance_Fields>;
};


/** aggregate fields of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Content_ElementByAccessToken_Avg_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_avg_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "content.ElementByAccessToken". All fields are combined with a logical 'AND'. */
export type Content_ElementByAccessToken_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Bool_Exp>>;
  readonly _not?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Bool_Exp>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemTitle?: Maybe<String_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly typeName?: Maybe<String_Comparison_Exp>;
  readonly uploadsRemaining?: Maybe<Int_Comparison_Exp>;
};

/** aggregate max on columns */
export type Content_ElementByAccessToken_Max_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Content_ElementByAccessToken_Min_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** Ordering options when selecting data from "content.ElementByAccessToken". */
export type Content_ElementByAccessToken_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemTitle?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** select columns of table "content.ElementByAccessToken" */
export enum Content_ElementByAccessToken_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  ItemTitle = 'itemTitle',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** aggregate stddev on columns */
export type Content_ElementByAccessToken_Stddev_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_stddev_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Content_ElementByAccessToken_Stddev_Pop_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_stddev_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Content_ElementByAccessToken_Stddev_Samp_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_stddev_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Content_ElementByAccessToken_Sum_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_sum_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate var_pop on columns */
export type Content_ElementByAccessToken_Var_Pop_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_var_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Content_ElementByAccessToken_Var_Samp_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_var_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Content_ElementByAccessToken_Variance_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_variance_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken = {
  readonly __typename?: 'content_ElementByPersonAccessToken';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly item?: Maybe<Content_ItemByPersonAccessToken>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessTokenDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessTokenLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Aggregate = {
  readonly __typename?: 'content_ElementByPersonAccessToken_aggregate';
  readonly aggregate?: Maybe<Content_ElementByPersonAccessToken_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ElementByPersonAccessToken>;
};

/** aggregate fields of "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Aggregate_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_aggregate_fields';
  readonly avg?: Maybe<Content_ElementByPersonAccessToken_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ElementByPersonAccessToken_Max_Fields>;
  readonly min?: Maybe<Content_ElementByPersonAccessToken_Min_Fields>;
  readonly stddev?: Maybe<Content_ElementByPersonAccessToken_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_ElementByPersonAccessToken_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_ElementByPersonAccessToken_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_ElementByPersonAccessToken_Sum_Fields>;
  readonly var_pop?: Maybe<Content_ElementByPersonAccessToken_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_ElementByPersonAccessToken_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_ElementByPersonAccessToken_Variance_Fields>;
};


/** aggregate fields of "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_ElementByPersonAccessToken_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ElementByPersonAccessToken_Max_Order_By>;
  readonly min?: Maybe<Content_ElementByPersonAccessToken_Min_Order_By>;
  readonly stddev?: Maybe<Content_ElementByPersonAccessToken_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_ElementByPersonAccessToken_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_ElementByPersonAccessToken_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_ElementByPersonAccessToken_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_ElementByPersonAccessToken_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_ElementByPersonAccessToken_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_ElementByPersonAccessToken_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Content_ElementByPersonAccessToken_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ElementByPersonAccessToken_Insert_Input>;
};

/** aggregate avg on columns */
export type Content_ElementByPersonAccessToken_Avg_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_avg_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Avg_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.ElementByPersonAccessToken". All fields are combined with a logical 'AND'. */
export type Content_ElementByPersonAccessToken_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Bool_Exp>>;
  readonly _not?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Bool_Exp>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly item?: Maybe<Content_ItemByPersonAccessToken_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly typeName?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadsRemaining?: Maybe<Int_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Content_ElementByPersonAccessToken_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly layoutData?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Content_ElementByPersonAccessToken_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Content_ElementByPersonAccessToken_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Inc_Input = {
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly item?: Maybe<Content_ItemByPersonAccessToken_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Content_ElementByPersonAccessToken_Max_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Max_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ElementByPersonAccessToken_Min_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Min_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Mutation_Response = {
  readonly __typename?: 'content_ElementByPersonAccessToken_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ElementByPersonAccessToken>;
};

/** Ordering options when selecting data from "content.ElementByPersonAccessToken". */
export type Content_ElementByPersonAccessToken_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly item?: Maybe<Content_ItemByPersonAccessToken_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Content_ElementByPersonAccessToken_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "content.ElementByPersonAccessToken" */
export enum Content_ElementByPersonAccessToken_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** input type for updating data in table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Content_ElementByPersonAccessToken_Stddev_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_stddev_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Stddev_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_ElementByPersonAccessToken_Stddev_Pop_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_stddev_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Stddev_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_ElementByPersonAccessToken_Stddev_Samp_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_stddev_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Stddev_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_ElementByPersonAccessToken_Sum_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_sum_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Sum_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Content_ElementByPersonAccessToken_Var_Pop_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_var_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Var_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_ElementByPersonAccessToken_Var_Samp_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_var_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Var_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_ElementByPersonAccessToken_Variance_Fields = {
  readonly __typename?: 'content_ElementByPersonAccessToken_variance_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.ElementByPersonAccessToken" */
export type Content_ElementByPersonAccessToken_Variance_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** columns and relationships of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant = {
  readonly __typename?: 'content_ElementPermissionGrant';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceSlug: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly entity?: Maybe<Content_Element>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly group?: Maybe<Permissions_Group>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly permissionSet: Permissions_Role;
  readonly permissionSetId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate = {
  readonly __typename?: 'content_ElementPermissionGrant_aggregate';
  readonly aggregate?: Maybe<Content_ElementPermissionGrant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ElementPermissionGrant>;
};

/** aggregate fields of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate_Fields = {
  readonly __typename?: 'content_ElementPermissionGrant_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ElementPermissionGrant_Max_Fields>;
  readonly min?: Maybe<Content_ElementPermissionGrant_Min_Fields>;
};


/** aggregate fields of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ElementPermissionGrant_Max_Order_By>;
  readonly min?: Maybe<Content_ElementPermissionGrant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ElementPermissionGrant_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_ElementPermissionGrant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.ElementPermissionGrant". All fields are combined with a logical 'AND'. */
export type Content_ElementPermissionGrant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Bool_Exp>>;
  readonly _not?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceSlug?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly entity?: Maybe<Content_Element_Bool_Exp>;
  readonly entityId?: Maybe<Uuid_Comparison_Exp>;
  readonly group?: Maybe<Permissions_Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly permissionSet?: Maybe<Permissions_Role_Bool_Exp>;
  readonly permissionSetId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ElementPermissionGrant" */
export enum Content_ElementPermissionGrant_Constraint {
  /** unique or primary key constraint */
  ElementPermissionGrantPermissionSetIdGroupIdEntityIdKey = 'ElementPermissionGrant_permissionSetId_groupId_entityId_key',
  /** unique or primary key constraint */
  ElementPermissionGrantPkey = 'ElementPermissionGrant_pkey'
}

/** input type for inserting data into table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entity?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly group?: Maybe<Permissions_Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSet?: Maybe<Permissions_Role_Obj_Rel_Insert_Input>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Content_ElementPermissionGrant_Max_Fields = {
  readonly __typename?: 'content_ElementPermissionGrant_max_fields';
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Max_Order_By = {
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ElementPermissionGrant_Min_Fields = {
  readonly __typename?: 'content_ElementPermissionGrant_min_fields';
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Min_Order_By = {
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Mutation_Response = {
  readonly __typename?: 'content_ElementPermissionGrant_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ElementPermissionGrant>;
};

/** on conflict condition type for table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_On_Conflict = {
  readonly constraint: Content_ElementPermissionGrant_Constraint;
  readonly update_columns?: ReadonlyArray<Content_ElementPermissionGrant_Update_Column>;
  readonly where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};

/** Ordering options when selecting data from "content.ElementPermissionGrant". */
export type Content_ElementPermissionGrant_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entity?: Maybe<Content_Element_Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly group?: Maybe<Permissions_Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSet?: Maybe<Permissions_Role_Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: content_ElementPermissionGrant */
export type Content_ElementPermissionGrant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.ElementPermissionGrant" */
export enum Content_ElementPermissionGrant_Select_Column {
  /** column name */
  ConferenceSlug = 'conferenceSlug',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntityId = 'entityId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionSetId = 'permissionSetId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Set_Input = {
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "content.ElementPermissionGrant" */
export enum Content_ElementPermissionGrant_Update_Column {
  /** column name */
  ConferenceSlug = 'conferenceSlug',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntityId = 'entityId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionSetId = 'permissionSetId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "content.ElementType" */
export type Content_ElementType = {
  readonly __typename?: 'content_ElementType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "content.ElementType" */
export type Content_ElementType_Aggregate = {
  readonly __typename?: 'content_ElementType_aggregate';
  readonly aggregate?: Maybe<Content_ElementType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ElementType>;
};

/** aggregate fields of "content.ElementType" */
export type Content_ElementType_Aggregate_Fields = {
  readonly __typename?: 'content_ElementType_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ElementType_Max_Fields>;
  readonly min?: Maybe<Content_ElementType_Min_Fields>;
};


/** aggregate fields of "content.ElementType" */
export type Content_ElementType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "content.ElementType". All fields are combined with a logical 'AND'. */
export type Content_ElementType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ElementType_Bool_Exp>>;
  readonly _not?: Maybe<Content_ElementType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ElementType_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ElementType" */
export enum Content_ElementType_Constraint {
  /** unique or primary key constraint */
  ElementTypePkey = 'ElementType_pkey'
}

export enum Content_ElementType_Enum {
  /** Abstract Markdown text. */
  Abstract = 'ABSTRACT',
  /** Show a summary of the currently active social and discussion rooms */
  ActiveSocialRooms = 'ACTIVE_SOCIAL_ROOMS',
  /** File for an audio clip (stored by Clowdr). */
  AudioFile = 'AUDIO_FILE',
  /** Link to an audio clip (audio is not embedded in Clowdr UI). */
  AudioLink = 'AUDIO_LINK',
  /** URL for an audio clip (audio is embedded in Clowdr UI). */
  AudioUrl = 'AUDIO_URL',
  /** List of content groups in the system. */
  ContentGroupList = 'CONTENT_GROUP_LIST',
  /** A horizontal divider */
  Divider = 'DIVIDER',
  /** Button that opens the explore program modal. Intended for use on the landing page. */
  ExploreProgramButton = 'EXPLORE_PROGRAM_BUTTON',
  /** Button that opens the explore program modal with the Schedule tab open. Intended for use on the landing page. */
  ExploreScheduleButton = 'EXPLORE_SCHEDULE_BUTTON',
  /** File for an image (stored by Clowdr). */
  ImageFile = 'IMAGE_FILE',
  /** URL to an image (embedded in Clowdr UI). */
  ImageUrl = 'IMAGE_URL',
  /** A generic URL. */
  Link = 'LINK',
  /** A URL for a link button. */
  LinkButton = 'LINK_BUTTON',
  /** Show a summary of the currently live program rooms */
  LiveProgramRooms = 'LIVE_PROGRAM_ROOMS',
  /** File for a paper (stored by Clowdr). */
  PaperFile = 'PAPER_FILE',
  /** Link for a paper (preview is not embedded in Clowdr UI). */
  PaperLink = 'PAPER_LINK',
  /** URL to a paper (preview may be embedded in Clowdr UI e.g. PDF JS viewer). */
  PaperUrl = 'PAPER_URL',
  /** File for a poster image (stored by Clowdr). */
  PosterFile = 'POSTER_FILE',
  /** URL to a poster image (embedded in Clowdr UI). */
  PosterUrl = 'POSTER_URL',
  /** Show a summary of the sponsor booths */
  SponsorBooths = 'SPONSOR_BOOTHS',
  /** General-purpose Markdown text. */
  Text = 'TEXT',
  /** Video file to be broadcast. */
  VideoBroadcast = 'VIDEO_BROADCAST',
  /** Video file for counting down to a transition in a broadcast. */
  VideoCountdown = 'VIDEO_COUNTDOWN',
  /** File for a video (stored by Clowdr). */
  VideoFile = 'VIDEO_FILE',
  /** Video file for filler loop between events/during breaks in a broadcast. */
  VideoFiller = 'VIDEO_FILLER',
  /** Link to a video (video is not embedded in Clowdr UI). */
  VideoLink = 'VIDEO_LINK',
  /** Video file to be published in advance of the conference. */
  VideoPrepublish = 'VIDEO_PREPUBLISH',
  /** Video file for sponsors filler loop between events/during breaks in a broadcast. */
  VideoSponsorsFiller = 'VIDEO_SPONSORS_FILLER',
  /** Video file for titles introducing an event during a broadcast. */
  VideoTitles = 'VIDEO_TITLES',
  /** URL for a video (video is embedded in Clowdr UI). */
  VideoUrl = 'VIDEO_URL',
  /** Schedule view for the whole conference. */
  WholeSchedule = 'WHOLE_SCHEDULE',
  /** Data for a Zoom meeting. */
  Zoom = 'ZOOM'
}

/** Boolean expression to compare columns of type "content_ElementType_enum". All fields are combined with logical 'AND'. */
export type Content_ElementType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Content_ElementType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Content_ElementType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Content_ElementType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Content_ElementType_Enum>>;
};

/** input type for inserting data into table "content.ElementType" */
export type Content_ElementType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ElementType_Max_Fields = {
  readonly __typename?: 'content_ElementType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Content_ElementType_Min_Fields = {
  readonly __typename?: 'content_ElementType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "content.ElementType" */
export type Content_ElementType_Mutation_Response = {
  readonly __typename?: 'content_ElementType_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ElementType>;
};

/** input type for inserting object relation for remote table "content.ElementType" */
export type Content_ElementType_Obj_Rel_Insert_Input = {
  readonly data: Content_ElementType_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_ElementType_On_Conflict>;
};

/** on conflict condition type for table "content.ElementType" */
export type Content_ElementType_On_Conflict = {
  readonly constraint: Content_ElementType_Constraint;
  readonly update_columns?: ReadonlyArray<Content_ElementType_Update_Column>;
  readonly where?: Maybe<Content_ElementType_Bool_Exp>;
};

/** Ordering options when selecting data from "content.ElementType". */
export type Content_ElementType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: content_ElementType */
export type Content_ElementType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "content.ElementType" */
export enum Content_ElementType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "content.ElementType" */
export type Content_ElementType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "content.ElementType" */
export enum Content_ElementType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "content.Element" */
export type Content_Element_Aggregate = {
  readonly __typename?: 'content_Element_aggregate';
  readonly aggregate?: Maybe<Content_Element_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_Element>;
};

/** aggregate fields of "content.Element" */
export type Content_Element_Aggregate_Fields = {
  readonly __typename?: 'content_Element_aggregate_fields';
  readonly avg?: Maybe<Content_Element_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_Element_Max_Fields>;
  readonly min?: Maybe<Content_Element_Min_Fields>;
  readonly stddev?: Maybe<Content_Element_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_Element_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_Element_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_Element_Sum_Fields>;
  readonly var_pop?: Maybe<Content_Element_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_Element_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_Element_Variance_Fields>;
};


/** aggregate fields of "content.Element" */
export type Content_Element_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.Element" */
export type Content_Element_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_Element_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_Element_Max_Order_By>;
  readonly min?: Maybe<Content_Element_Min_Order_By>;
  readonly stddev?: Maybe<Content_Element_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_Element_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_Element_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_Element_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_Element_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_Element_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_Element_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Content_Element_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "content.Element" */
export type Content_Element_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_Element_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_Element_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_Element_Avg_Fields = {
  readonly __typename?: 'content_Element_avg_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.Element" */
export type Content_Element_Avg_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.Element". All fields are combined with a logical 'AND'. */
export type Content_Element_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_Element_Bool_Exp>>;
  readonly _not?: Maybe<Content_Element_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_Element_Bool_Exp>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly hasBeenSubmitted?: Maybe<Boolean_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly itemTitle?: Maybe<String_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly permissionGrants?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
  readonly stats?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
  readonly totalViewsStat?: Maybe<Analytics_ElementTotalViews_Bool_Exp>;
  readonly type?: Maybe<Content_ElementType_Bool_Exp>;
  readonly typeName?: Maybe<Content_ElementType_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploaders?: Maybe<Content_Uploader_Bool_Exp>;
  readonly uploadersCount?: Maybe<Bigint_Comparison_Exp>;
  readonly uploadsRemaining?: Maybe<Int_Comparison_Exp>;
  readonly youTubeUploads?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};

/** unique or primary key constraints on table "content.Element" */
export enum Content_Element_Constraint {
  /** unique or primary key constraint */
  ElementPkey = 'Element_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Content_Element_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly layoutData?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Content_Element_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Content_Element_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "content.Element" */
export type Content_Element_Inc_Input = {
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.Element" */
export type Content_Element_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly permissionGrants?: Maybe<Content_ElementPermissionGrant_Arr_Rel_Insert_Input>;
  readonly stats?: Maybe<Analytics_ContentElementStats_Arr_Rel_Insert_Input>;
  readonly totalViewsStat?: Maybe<Analytics_ElementTotalViews_Obj_Rel_Insert_Input>;
  readonly type?: Maybe<Content_ElementType_Obj_Rel_Insert_Input>;
  readonly typeName?: Maybe<Content_ElementType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploaders?: Maybe<Content_Uploader_Arr_Rel_Insert_Input>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
  readonly youTubeUploads?: Maybe<Video_YouTubeUpload_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Content_Element_Max_Fields = {
  readonly __typename?: 'content_Element_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "content.Element" */
export type Content_Element_Max_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_Element_Min_Fields = {
  readonly __typename?: 'content_Element_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "content.Element" */
export type Content_Element_Min_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.Element" */
export type Content_Element_Mutation_Response = {
  readonly __typename?: 'content_Element_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_Element>;
};

/** input type for inserting object relation for remote table "content.Element" */
export type Content_Element_Obj_Rel_Insert_Input = {
  readonly data: Content_Element_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_Element_On_Conflict>;
};

/** on conflict condition type for table "content.Element" */
export type Content_Element_On_Conflict = {
  readonly constraint: Content_Element_Constraint;
  readonly update_columns?: ReadonlyArray<Content_Element_Update_Column>;
  readonly where?: Maybe<Content_Element_Bool_Exp>;
};

/** Ordering options when selecting data from "content.Element". */
export type Content_Element_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly hasBeenSubmitted?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly itemTitle?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly permissionGrants_aggregate?: Maybe<Content_ElementPermissionGrant_Aggregate_Order_By>;
  readonly stats_aggregate?: Maybe<Analytics_ContentElementStats_Aggregate_Order_By>;
  readonly totalViewsStat?: Maybe<Analytics_ElementTotalViews_Order_By>;
  readonly type?: Maybe<Content_ElementType_Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadersCount?: Maybe<Order_By>;
  readonly uploaders_aggregate?: Maybe<Content_Uploader_Aggregate_Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
  readonly youTubeUploads_aggregate?: Maybe<Video_YouTubeUpload_Aggregate_Order_By>;
};

/** primary key columns input for table: content_Element */
export type Content_Element_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Content_Element_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "content.Element" */
export enum Content_Element_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** input type for updating data in table "content.Element" */
export type Content_Element_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Content_ElementType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Content_Element_Stddev_Fields = {
  readonly __typename?: 'content_Element_stddev_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.Element" */
export type Content_Element_Stddev_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_Element_Stddev_Pop_Fields = {
  readonly __typename?: 'content_Element_stddev_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.Element" */
export type Content_Element_Stddev_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_Element_Stddev_Samp_Fields = {
  readonly __typename?: 'content_Element_stddev_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.Element" */
export type Content_Element_Stddev_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_Element_Sum_Fields = {
  readonly __typename?: 'content_Element_sum_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.Element" */
export type Content_Element_Sum_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** update columns of table "content.Element" */
export enum Content_Element_Update_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** aggregate var_pop on columns */
export type Content_Element_Var_Pop_Fields = {
  readonly __typename?: 'content_Element_var_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.Element" */
export type Content_Element_Var_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_Element_Var_Samp_Fields = {
  readonly __typename?: 'content_Element_var_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.Element" */
export type Content_Element_Var_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_Element_Variance_Fields = {
  readonly __typename?: 'content_Element_variance_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.Element" */
export type Content_Element_Variance_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** columns and relationships of "content.Item" */
export type Content_Item = {
  readonly __typename?: 'content_Item';
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly elements: ReadonlyArray<Content_Element>;
  /** An aggregate relationship */
  readonly elements_aggregate: Content_Element_Aggregate;
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregate relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  /** A computed field, executes function "content.itemHasUnsubmittedElements" */
  readonly hasUnsubmittedElements?: Maybe<Scalars['Boolean']>;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly itemExhibitions: ReadonlyArray<Content_ItemExhibition>;
  /** An aggregate relationship */
  readonly itemExhibitions_aggregate: Content_ItemExhibition_Aggregate;
  /** An array relationship */
  readonly itemPeople: ReadonlyArray<Content_ItemProgramPerson>;
  /** An aggregate relationship */
  readonly itemPeople_aggregate: Content_ItemProgramPerson_Aggregate;
  /** An array relationship */
  readonly itemTags: ReadonlyArray<Content_ItemTag>;
  /** An aggregate relationship */
  readonly itemTags_aggregate: Content_ItemTag_Aggregate;
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregate relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  readonly shortTitle?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly stats: ReadonlyArray<Analytics_ContentItemStats>;
  /** An aggregate relationship */
  readonly stats_aggregate: Analytics_ContentItemStats_Aggregate;
  readonly title: Scalars['String'];
  /** An object relationship */
  readonly totalViewsStat?: Maybe<Analytics_ItemTotalViews>;
  /** An object relationship */
  readonly type: Content_ItemType;
  readonly typeName: Content_ItemType_Enum;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "content.Item" */
export type Content_ItemElementsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemElements_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemExhibitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemExhibitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};

/** columns and relationships of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken = {
  readonly __typename?: 'content_ItemByPersonAccessToken';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly elements: ReadonlyArray<Content_ElementByPersonAccessToken>;
  /** An aggregate relationship */
  readonly elements_aggregate: Content_ElementByPersonAccessToken_Aggregate;
  readonly id?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly itemPeople: ReadonlyArray<Content_ItemProgramPersonByAccessToken>;
  /** An aggregate relationship */
  readonly itemPeople_aggregate: Content_ItemProgramPersonByAccessToken_Aggregate;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessTokenElementsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
};


/** columns and relationships of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessTokenElements_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
};


/** columns and relationships of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessTokenItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};


/** columns and relationships of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessTokenItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};

/** aggregated selection of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken_Aggregate = {
  readonly __typename?: 'content_ItemByPersonAccessToken_aggregate';
  readonly aggregate?: Maybe<Content_ItemByPersonAccessToken_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemByPersonAccessToken>;
};

/** aggregate fields of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken_Aggregate_Fields = {
  readonly __typename?: 'content_ItemByPersonAccessToken_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ItemByPersonAccessToken_Max_Fields>;
  readonly min?: Maybe<Content_ItemByPersonAccessToken_Min_Fields>;
};


/** aggregate fields of "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "content.ItemByPersonAccessToken". All fields are combined with a logical 'AND'. */
export type Content_ItemByPersonAccessToken_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Bool_Exp>>;
  readonly _not?: Maybe<Content_ItemByPersonAccessToken_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Bool_Exp>>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly elements?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemPeople?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly shortTitle?: Maybe<String_Comparison_Exp>;
  readonly title?: Maybe<String_Comparison_Exp>;
  readonly typeName?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** input type for inserting data into table "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken_Insert_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elements?: Maybe<Content_ElementByPersonAccessToken_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemPeople?: Maybe<Content_ItemProgramPersonByAccessToken_Arr_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Content_ItemByPersonAccessToken_Max_Fields = {
  readonly __typename?: 'content_ItemByPersonAccessToken_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Content_ItemByPersonAccessToken_Min_Fields = {
  readonly __typename?: 'content_ItemByPersonAccessToken_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken_Mutation_Response = {
  readonly __typename?: 'content_ItemByPersonAccessToken_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ItemByPersonAccessToken>;
};

/** input type for inserting object relation for remote table "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken_Obj_Rel_Insert_Input = {
  readonly data: Content_ItemByPersonAccessToken_Insert_Input;
};

/** Ordering options when selecting data from "content.ItemByPersonAccessToken". */
export type Content_ItemByPersonAccessToken_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elements_aggregate?: Maybe<Content_ElementByPersonAccessToken_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemPeople_aggregate?: Maybe<Content_ItemProgramPersonByAccessToken_Aggregate_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** select columns of table "content.ItemByPersonAccessToken" */
export enum Content_ItemByPersonAccessToken_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "content.ItemByPersonAccessToken" */
export type Content_ItemByPersonAccessToken_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** columns and relationships of "content.ItemExhibition" */
export type Content_ItemExhibition = {
  readonly __typename?: 'content_ItemExhibition';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly exhibition: Collection_Exhibition;
  readonly exhibitionId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "content.ItemExhibition" */
export type Content_ItemExhibitionLayoutArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate = {
  readonly __typename?: 'content_ItemExhibition_aggregate';
  readonly aggregate?: Maybe<Content_ItemExhibition_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemExhibition>;
};

/** aggregate fields of "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate_Fields = {
  readonly __typename?: 'content_ItemExhibition_aggregate_fields';
  readonly avg?: Maybe<Content_ItemExhibition_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ItemExhibition_Max_Fields>;
  readonly min?: Maybe<Content_ItemExhibition_Min_Fields>;
  readonly stddev?: Maybe<Content_ItemExhibition_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_ItemExhibition_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_ItemExhibition_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_ItemExhibition_Sum_Fields>;
  readonly var_pop?: Maybe<Content_ItemExhibition_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_ItemExhibition_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_ItemExhibition_Variance_Fields>;
};


/** aggregate fields of "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_ItemExhibition_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemExhibition_Max_Order_By>;
  readonly min?: Maybe<Content_ItemExhibition_Min_Order_By>;
  readonly stddev?: Maybe<Content_ItemExhibition_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_ItemExhibition_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_ItemExhibition_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_ItemExhibition_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_ItemExhibition_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_ItemExhibition_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_ItemExhibition_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Content_ItemExhibition_Append_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "content.ItemExhibition" */
export type Content_ItemExhibition_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemExhibition_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_ItemExhibition_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_ItemExhibition_Avg_Fields = {
  readonly __typename?: 'content_ItemExhibition_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.ItemExhibition". All fields are combined with a logical 'AND'. */
export type Content_ItemExhibition_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ItemExhibition_Bool_Exp>>;
  readonly _not?: Maybe<Content_ItemExhibition_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ItemExhibition_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly exhibition?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly exhibitionId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly layout?: Maybe<Jsonb_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemExhibition" */
export enum Content_ItemExhibition_Constraint {
  /** unique or primary key constraint */
  ItemExhibitionPkey = 'ItemExhibition_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Content_ItemExhibition_Delete_At_Path_Input = {
  readonly layout?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Content_ItemExhibition_Delete_Elem_Input = {
  readonly layout?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Content_ItemExhibition_Delete_Key_Input = {
  readonly layout?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "content.ItemExhibition" */
export type Content_ItemExhibition_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.ItemExhibition" */
export type Content_ItemExhibition_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibition?: Maybe<Collection_Exhibition_Obj_Rel_Insert_Input>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Content_ItemExhibition_Max_Fields = {
  readonly __typename?: 'content_ItemExhibition_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemExhibition_Min_Fields = {
  readonly __typename?: 'content_ItemExhibition_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemExhibition" */
export type Content_ItemExhibition_Mutation_Response = {
  readonly __typename?: 'content_ItemExhibition_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ItemExhibition>;
};

/** on conflict condition type for table "content.ItemExhibition" */
export type Content_ItemExhibition_On_Conflict = {
  readonly constraint: Content_ItemExhibition_Constraint;
  readonly update_columns?: ReadonlyArray<Content_ItemExhibition_Update_Column>;
  readonly where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};

/** Ordering options when selecting data from "content.ItemExhibition". */
export type Content_ItemExhibition_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly exhibition?: Maybe<Collection_Exhibition_Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly layout?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** primary key columns input for table: content_ItemExhibition */
export type Content_ItemExhibition_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Content_ItemExhibition_Prepend_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "content.ItemExhibition" */
export enum Content_ItemExhibition_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** input type for updating data in table "content.ItemExhibition" */
export type Content_ItemExhibition_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Content_ItemExhibition_Stddev_Fields = {
  readonly __typename?: 'content_ItemExhibition_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_ItemExhibition_Stddev_Pop_Fields = {
  readonly __typename?: 'content_ItemExhibition_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_ItemExhibition_Stddev_Samp_Fields = {
  readonly __typename?: 'content_ItemExhibition_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_ItemExhibition_Sum_Fields = {
  readonly __typename?: 'content_ItemExhibition_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "content.ItemExhibition" */
export enum Content_ItemExhibition_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** aggregate var_pop on columns */
export type Content_ItemExhibition_Var_Pop_Fields = {
  readonly __typename?: 'content_ItemExhibition_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_ItemExhibition_Var_Samp_Fields = {
  readonly __typename?: 'content_ItemExhibition_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_ItemExhibition_Variance_Fields = {
  readonly __typename?: 'content_ItemExhibition_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson = {
  readonly __typename?: 'content_ItemProgramPerson';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  /** A computed field, executes function "content.itemProgramPerson_HasSubmissionRequestBeenSent" */
  readonly hasSubmissionRequestBeenSent?: Maybe<Scalars['Boolean']>;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  /** An object relationship */
  readonly person: Collection_ProgramPerson;
  readonly personId: Scalars['uuid'];
  /** An object relationship */
  readonly personWithAccessToken?: Maybe<Collection_ProgramPersonWithAccessToken>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName: Scalars['String'];
};

/** columns and relationships of "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly item?: Maybe<Content_ItemByPersonAccessToken>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly person?: Maybe<Collection_ProgramPersonByAccessToken>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregated selection of "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Aggregate = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_aggregate';
  readonly aggregate?: Maybe<Content_ItemProgramPersonByAccessToken_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemProgramPersonByAccessToken>;
};

/** aggregate fields of "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Aggregate_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_aggregate_fields';
  readonly avg?: Maybe<Content_ItemProgramPersonByAccessToken_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ItemProgramPersonByAccessToken_Max_Fields>;
  readonly min?: Maybe<Content_ItemProgramPersonByAccessToken_Min_Fields>;
  readonly stddev?: Maybe<Content_ItemProgramPersonByAccessToken_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_ItemProgramPersonByAccessToken_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_ItemProgramPersonByAccessToken_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_ItemProgramPersonByAccessToken_Sum_Fields>;
  readonly var_pop?: Maybe<Content_ItemProgramPersonByAccessToken_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_ItemProgramPersonByAccessToken_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_ItemProgramPersonByAccessToken_Variance_Fields>;
};


/** aggregate fields of "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_ItemProgramPersonByAccessToken_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemProgramPersonByAccessToken_Max_Order_By>;
  readonly min?: Maybe<Content_ItemProgramPersonByAccessToken_Min_Order_By>;
  readonly stddev?: Maybe<Content_ItemProgramPersonByAccessToken_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_ItemProgramPersonByAccessToken_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_ItemProgramPersonByAccessToken_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_ItemProgramPersonByAccessToken_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_ItemProgramPersonByAccessToken_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_ItemProgramPersonByAccessToken_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_ItemProgramPersonByAccessToken_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemProgramPersonByAccessToken_Insert_Input>;
};

/** aggregate avg on columns */
export type Content_ItemProgramPersonByAccessToken_Avg_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.ItemProgramPersonByAccessToken". All fields are combined with a logical 'AND'. */
export type Content_ItemProgramPersonByAccessToken_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Bool_Exp>>;
  readonly _not?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Bool_Exp>>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly item?: Maybe<Content_ItemByPersonAccessToken_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<Collection_ProgramPersonByAccessToken_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly roleName?: Maybe<String_Comparison_Exp>;
};

/** input type for incrementing numeric columns in table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Insert_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly item?: Maybe<Content_ItemByPersonAccessToken_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<Collection_ProgramPersonByAccessToken_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ItemProgramPersonByAccessToken_Max_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemProgramPersonByAccessToken_Min_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Mutation_Response = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ItemProgramPersonByAccessToken>;
};

/** Ordering options when selecting data from "content.ItemProgramPersonByAccessToken". */
export type Content_ItemProgramPersonByAccessToken_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly item?: Maybe<Content_ItemByPersonAccessToken_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly person?: Maybe<Collection_ProgramPersonByAccessToken_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** select columns of table "content.ItemProgramPersonByAccessToken" */
export enum Content_ItemProgramPersonByAccessToken_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** input type for updating data in table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Content_ItemProgramPersonByAccessToken_Stddev_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_ItemProgramPersonByAccessToken_Stddev_Pop_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_ItemProgramPersonByAccessToken_Stddev_Samp_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_ItemProgramPersonByAccessToken_Sum_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Content_ItemProgramPersonByAccessToken_Var_Pop_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_ItemProgramPersonByAccessToken_Var_Samp_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_ItemProgramPersonByAccessToken_Variance_Fields = {
  readonly __typename?: 'content_ItemProgramPersonByAccessToken_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.ItemProgramPersonByAccessToken" */
export type Content_ItemProgramPersonByAccessToken_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregated selection of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate = {
  readonly __typename?: 'content_ItemProgramPerson_aggregate';
  readonly aggregate?: Maybe<Content_ItemProgramPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemProgramPerson>;
};

/** aggregate fields of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_aggregate_fields';
  readonly avg?: Maybe<Content_ItemProgramPerson_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ItemProgramPerson_Max_Fields>;
  readonly min?: Maybe<Content_ItemProgramPerson_Min_Fields>;
  readonly stddev?: Maybe<Content_ItemProgramPerson_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_ItemProgramPerson_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_ItemProgramPerson_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_ItemProgramPerson_Sum_Fields>;
  readonly var_pop?: Maybe<Content_ItemProgramPerson_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_ItemProgramPerson_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_ItemProgramPerson_Variance_Fields>;
};


/** aggregate fields of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_ItemProgramPerson_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemProgramPerson_Max_Order_By>;
  readonly min?: Maybe<Content_ItemProgramPerson_Min_Order_By>;
  readonly stddev?: Maybe<Content_ItemProgramPerson_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_ItemProgramPerson_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_ItemProgramPerson_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_ItemProgramPerson_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_ItemProgramPerson_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_ItemProgramPerson_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_ItemProgramPerson_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemProgramPerson_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_ItemProgramPerson_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_ItemProgramPerson_Avg_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.ItemProgramPerson". All fields are combined with a logical 'AND'. */
export type Content_ItemProgramPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Bool_Exp>>;
  readonly _not?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly hasSubmissionRequestBeenSent?: Maybe<Boolean_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly personWithAccessToken?: Maybe<Collection_ProgramPersonWithAccessToken_Bool_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly roleName?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemProgramPerson" */
export enum Content_ItemProgramPerson_Constraint {
  /** unique or primary key constraint */
  ItemProgramPersonPkey = 'ItemProgramPerson_pkey',
  /** unique or primary key constraint */
  ItemProgramPersonRoleNamePersonIdItemIdKey = 'ItemProgramPerson_roleName_personId_itemId_key'
}

/** input type for incrementing numeric columns in table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<Collection_ProgramPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly personWithAccessToken?: Maybe<Collection_ProgramPersonWithAccessToken_Obj_Rel_Insert_Input>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ItemProgramPerson_Max_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemProgramPerson_Min_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Mutation_Response = {
  readonly __typename?: 'content_ItemProgramPerson_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ItemProgramPerson>;
};

/** on conflict condition type for table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_On_Conflict = {
  readonly constraint: Content_ItemProgramPerson_Constraint;
  readonly update_columns?: ReadonlyArray<Content_ItemProgramPerson_Update_Column>;
  readonly where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};

/** Ordering options when selecting data from "content.ItemProgramPerson". */
export type Content_ItemProgramPerson_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly hasSubmissionRequestBeenSent?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly person?: Maybe<Collection_ProgramPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly personWithAccessToken?: Maybe<Collection_ProgramPersonWithAccessToken_Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** primary key columns input for table: content_ItemProgramPerson */
export type Content_ItemProgramPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.ItemProgramPerson" */
export enum Content_ItemProgramPerson_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** input type for updating data in table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Content_ItemProgramPerson_Stddev_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_ItemProgramPerson_Stddev_Pop_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_ItemProgramPerson_Stddev_Samp_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_ItemProgramPerson_Sum_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "content.ItemProgramPerson" */
export enum Content_ItemProgramPerson_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** aggregate var_pop on columns */
export type Content_ItemProgramPerson_Var_Pop_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_ItemProgramPerson_Var_Samp_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_ItemProgramPerson_Variance_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "content.ItemTag" */
export type Content_ItemTag = {
  readonly __typename?: 'content_ItemTag';
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Collection_Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "content.ItemTag" */
export type Content_ItemTag_Aggregate = {
  readonly __typename?: 'content_ItemTag_aggregate';
  readonly aggregate?: Maybe<Content_ItemTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemTag>;
};

/** aggregate fields of "content.ItemTag" */
export type Content_ItemTag_Aggregate_Fields = {
  readonly __typename?: 'content_ItemTag_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ItemTag_Max_Fields>;
  readonly min?: Maybe<Content_ItemTag_Min_Fields>;
};


/** aggregate fields of "content.ItemTag" */
export type Content_ItemTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemTag" */
export type Content_ItemTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemTag_Max_Order_By>;
  readonly min?: Maybe<Content_ItemTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.ItemTag" */
export type Content_ItemTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemTag_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_ItemTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.ItemTag". All fields are combined with a logical 'AND'. */
export type Content_ItemTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ItemTag_Bool_Exp>>;
  readonly _not?: Maybe<Content_ItemTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ItemTag_Bool_Exp>>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Collection_Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemTag" */
export enum Content_ItemTag_Constraint {
  /** unique or primary key constraint */
  ItemTagItemIdTagIdKey = 'ItemTag_itemId_tagId_key',
  /** unique or primary key constraint */
  ItemTagPkey = 'ItemTag_pkey'
}

/** input type for inserting data into table "content.ItemTag" */
export type Content_ItemTag_Insert_Input = {
  readonly id?: Maybe<Scalars['uuid']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Collection_Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Content_ItemTag_Max_Fields = {
  readonly __typename?: 'content_ItemTag_max_fields';
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "content.ItemTag" */
export type Content_ItemTag_Max_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemTag_Min_Fields = {
  readonly __typename?: 'content_ItemTag_min_fields';
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "content.ItemTag" */
export type Content_ItemTag_Min_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemTag" */
export type Content_ItemTag_Mutation_Response = {
  readonly __typename?: 'content_ItemTag_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ItemTag>;
};

/** on conflict condition type for table "content.ItemTag" */
export type Content_ItemTag_On_Conflict = {
  readonly constraint: Content_ItemTag_Constraint;
  readonly update_columns?: ReadonlyArray<Content_ItemTag_Update_Column>;
  readonly where?: Maybe<Content_ItemTag_Bool_Exp>;
};

/** Ordering options when selecting data from "content.ItemTag". */
export type Content_ItemTag_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly tag?: Maybe<Collection_Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: content_ItemTag */
export type Content_ItemTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.ItemTag" */
export enum Content_ItemTag_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "content.ItemTag" */
export type Content_ItemTag_Set_Input = {
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "content.ItemTag" */
export enum Content_ItemTag_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  TagId = 'tagId'
}

/** columns and relationships of "content.ItemType" */
export type Content_ItemType = {
  readonly __typename?: 'content_ItemType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "content.ItemType" */
export type Content_ItemType_Aggregate = {
  readonly __typename?: 'content_ItemType_aggregate';
  readonly aggregate?: Maybe<Content_ItemType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemType>;
};

/** aggregate fields of "content.ItemType" */
export type Content_ItemType_Aggregate_Fields = {
  readonly __typename?: 'content_ItemType_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_ItemType_Max_Fields>;
  readonly min?: Maybe<Content_ItemType_Min_Fields>;
};


/** aggregate fields of "content.ItemType" */
export type Content_ItemType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "content.ItemType". All fields are combined with a logical 'AND'. */
export type Content_ItemType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_ItemType_Bool_Exp>>;
  readonly _not?: Maybe<Content_ItemType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_ItemType_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemType" */
export enum Content_ItemType_Constraint {
  /** unique or primary key constraint */
  ItemTypePkey = 'ItemType_pkey'
}

export enum Content_ItemType_Enum {
  /** A demonstration. */
  Demonstration = 'DEMONSTRATION',
  /** A keynote. */
  Keynote = 'KEYNOTE',
  /** Conference main landing page. */
  LandingPage = 'LANDING_PAGE',
  /** A generic group type - use sparingly. */
  Other = 'OTHER',
  /** A paper. */
  Paper = 'PAPER',
  /** A poster. */
  Poster = 'POSTER',
  /** A presentation. */
  Presentation = 'PRESENTATION',
  /** Content representing a whole session. */
  Session = 'SESSION',
  /** A Q&A covering the whole session. */
  SessionQAndA = 'SESSION_Q_AND_A',
  /** A scheduled social. */
  Social = 'SOCIAL',
  /** A sponsor. */
  Sponsor = 'SPONSOR',
  /** A symposium. */
  Symposium = 'SYMPOSIUM',
  /** A tutorial. */
  Tutorial = 'TUTORIAL',
  /** A workshop. */
  Workshop = 'WORKSHOP'
}

/** Boolean expression to compare columns of type "content_ItemType_enum". All fields are combined with logical 'AND'. */
export type Content_ItemType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Content_ItemType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Content_ItemType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Content_ItemType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Content_ItemType_Enum>>;
};

/** input type for inserting data into table "content.ItemType" */
export type Content_ItemType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ItemType_Max_Fields = {
  readonly __typename?: 'content_ItemType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Content_ItemType_Min_Fields = {
  readonly __typename?: 'content_ItemType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "content.ItemType" */
export type Content_ItemType_Mutation_Response = {
  readonly __typename?: 'content_ItemType_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_ItemType>;
};

/** input type for inserting object relation for remote table "content.ItemType" */
export type Content_ItemType_Obj_Rel_Insert_Input = {
  readonly data: Content_ItemType_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_ItemType_On_Conflict>;
};

/** on conflict condition type for table "content.ItemType" */
export type Content_ItemType_On_Conflict = {
  readonly constraint: Content_ItemType_Constraint;
  readonly update_columns?: ReadonlyArray<Content_ItemType_Update_Column>;
  readonly where?: Maybe<Content_ItemType_Bool_Exp>;
};

/** Ordering options when selecting data from "content.ItemType". */
export type Content_ItemType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: content_ItemType */
export type Content_ItemType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "content.ItemType" */
export enum Content_ItemType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "content.ItemType" */
export type Content_ItemType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "content.ItemType" */
export enum Content_ItemType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "content.Item" */
export type Content_Item_Aggregate = {
  readonly __typename?: 'content_Item_aggregate';
  readonly aggregate?: Maybe<Content_Item_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_Item>;
};

/** aggregate fields of "content.Item" */
export type Content_Item_Aggregate_Fields = {
  readonly __typename?: 'content_Item_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_Item_Max_Fields>;
  readonly min?: Maybe<Content_Item_Min_Fields>;
};


/** aggregate fields of "content.Item" */
export type Content_Item_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.Item" */
export type Content_Item_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_Item_Max_Order_By>;
  readonly min?: Maybe<Content_Item_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.Item" */
export type Content_Item_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_Item_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_Item_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.Item". All fields are combined with a logical 'AND'. */
export type Content_Item_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_Item_Bool_Exp>>;
  readonly _not?: Maybe<Content_Item_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_Item_Bool_Exp>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly elements?: Maybe<Content_Element_Bool_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly hasUnsubmittedElements?: Maybe<Boolean_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemExhibitions?: Maybe<Content_ItemExhibition_Bool_Exp>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
  readonly itemTags?: Maybe<Content_ItemTag_Bool_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly shortTitle?: Maybe<String_Comparison_Exp>;
  readonly stats?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
  readonly title?: Maybe<String_Comparison_Exp>;
  readonly totalViewsStat?: Maybe<Analytics_ItemTotalViews_Bool_Exp>;
  readonly type?: Maybe<Content_ItemType_Bool_Exp>;
  readonly typeName?: Maybe<Content_ItemType_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.Item" */
export enum Content_Item_Constraint {
  /** unique or primary key constraint */
  ItemPkey = 'Item_pkey'
}

/** input type for inserting data into table "content.Item" */
export type Content_Item_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elements?: Maybe<Content_Element_Arr_Rel_Insert_Input>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemExhibitions?: Maybe<Content_ItemExhibition_Arr_Rel_Insert_Input>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Arr_Rel_Insert_Input>;
  readonly itemTags?: Maybe<Content_ItemTag_Arr_Rel_Insert_Input>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly stats?: Maybe<Analytics_ContentItemStats_Arr_Rel_Insert_Input>;
  readonly title?: Maybe<Scalars['String']>;
  readonly totalViewsStat?: Maybe<Analytics_ItemTotalViews_Obj_Rel_Insert_Input>;
  readonly type?: Maybe<Content_ItemType_Obj_Rel_Insert_Input>;
  readonly typeName?: Maybe<Content_ItemType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Content_Item_Max_Fields = {
  readonly __typename?: 'content_Item_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "content.Item" */
export type Content_Item_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_Item_Min_Fields = {
  readonly __typename?: 'content_Item_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "content.Item" */
export type Content_Item_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.Item" */
export type Content_Item_Mutation_Response = {
  readonly __typename?: 'content_Item_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_Item>;
};

/** input type for inserting object relation for remote table "content.Item" */
export type Content_Item_Obj_Rel_Insert_Input = {
  readonly data: Content_Item_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_Item_On_Conflict>;
};

/** on conflict condition type for table "content.Item" */
export type Content_Item_On_Conflict = {
  readonly constraint: Content_Item_Constraint;
  readonly update_columns?: ReadonlyArray<Content_Item_Update_Column>;
  readonly where?: Maybe<Content_Item_Bool_Exp>;
};

/** Ordering options when selecting data from "content.Item". */
export type Content_Item_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elements_aggregate?: Maybe<Content_Element_Aggregate_Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly hasUnsubmittedElements?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemExhibitions_aggregate?: Maybe<Content_ItemExhibition_Aggregate_Order_By>;
  readonly itemPeople_aggregate?: Maybe<Content_ItemProgramPerson_Aggregate_Order_By>;
  readonly itemTags_aggregate?: Maybe<Content_ItemTag_Aggregate_Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly stats_aggregate?: Maybe<Analytics_ContentItemStats_Aggregate_Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly totalViewsStat?: Maybe<Analytics_ItemTotalViews_Order_By>;
  readonly type?: Maybe<Content_ItemType_Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: content_Item */
export type Content_Item_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.Item" */
export enum Content_Item_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "content.Item" */
export type Content_Item_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Content_ItemType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "content.Item" */
export enum Content_Item_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "content.Uploader" */
export type Content_Uploader = {
  readonly __typename?: 'content_Uploader';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element: Content_Element;
  readonly elementId: Scalars['uuid'];
  readonly email: Scalars['String'];
  readonly emailsSentCount: Scalars['Int'];
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "content.Uploader" */
export type Content_Uploader_Aggregate = {
  readonly __typename?: 'content_Uploader_aggregate';
  readonly aggregate?: Maybe<Content_Uploader_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_Uploader>;
};

/** aggregate fields of "content.Uploader" */
export type Content_Uploader_Aggregate_Fields = {
  readonly __typename?: 'content_Uploader_aggregate_fields';
  readonly avg?: Maybe<Content_Uploader_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Content_Uploader_Max_Fields>;
  readonly min?: Maybe<Content_Uploader_Min_Fields>;
  readonly stddev?: Maybe<Content_Uploader_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_Uploader_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_Uploader_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_Uploader_Sum_Fields>;
  readonly var_pop?: Maybe<Content_Uploader_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_Uploader_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_Uploader_Variance_Fields>;
};


/** aggregate fields of "content.Uploader" */
export type Content_Uploader_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.Uploader" */
export type Content_Uploader_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_Uploader_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_Uploader_Max_Order_By>;
  readonly min?: Maybe<Content_Uploader_Min_Order_By>;
  readonly stddev?: Maybe<Content_Uploader_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_Uploader_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_Uploader_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_Uploader_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_Uploader_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_Uploader_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_Uploader_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "content.Uploader" */
export type Content_Uploader_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_Uploader_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_Uploader_Avg_Fields = {
  readonly __typename?: 'content_Uploader_avg_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.Uploader" */
export type Content_Uploader_Avg_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.Uploader". All fields are combined with a logical 'AND'. */
export type Content_Uploader_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Content_Uploader_Bool_Exp>>;
  readonly _not?: Maybe<Content_Uploader_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Content_Uploader_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emailsSentCount?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.Uploader" */
export enum Content_Uploader_Constraint {
  /** unique or primary key constraint */
  UploaderElementIdEmailKey = 'Uploader_elementId_email_key',
  /** unique or primary key constraint */
  UploaderPkey = 'Uploader_pkey'
}

/** input type for incrementing numeric columns in table "content.Uploader" */
export type Content_Uploader_Inc_Input = {
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.Uploader" */
export type Content_Uploader_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Content_Uploader_Max_Fields = {
  readonly __typename?: 'content_Uploader_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "content.Uploader" */
export type Content_Uploader_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_Uploader_Min_Fields = {
  readonly __typename?: 'content_Uploader_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "content.Uploader" */
export type Content_Uploader_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.Uploader" */
export type Content_Uploader_Mutation_Response = {
  readonly __typename?: 'content_Uploader_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Content_Uploader>;
};

/** input type for inserting object relation for remote table "content.Uploader" */
export type Content_Uploader_Obj_Rel_Insert_Input = {
  readonly data: Content_Uploader_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};

/** on conflict condition type for table "content.Uploader" */
export type Content_Uploader_On_Conflict = {
  readonly constraint: Content_Uploader_Constraint;
  readonly update_columns?: ReadonlyArray<Content_Uploader_Update_Column>;
  readonly where?: Maybe<Content_Uploader_Bool_Exp>;
};

/** Ordering options when selecting data from "content.Uploader". */
export type Content_Uploader_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: content_Uploader */
export type Content_Uploader_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.Uploader" */
export enum Content_Uploader_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "content.Uploader" */
export type Content_Uploader_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Content_Uploader_Stddev_Fields = {
  readonly __typename?: 'content_Uploader_stddev_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.Uploader" */
export type Content_Uploader_Stddev_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_Uploader_Stddev_Pop_Fields = {
  readonly __typename?: 'content_Uploader_stddev_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.Uploader" */
export type Content_Uploader_Stddev_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_Uploader_Stddev_Samp_Fields = {
  readonly __typename?: 'content_Uploader_stddev_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.Uploader" */
export type Content_Uploader_Stddev_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_Uploader_Sum_Fields = {
  readonly __typename?: 'content_Uploader_sum_fields';
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.Uploader" */
export type Content_Uploader_Sum_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** update columns of table "content.Uploader" */
export enum Content_Uploader_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Content_Uploader_Var_Pop_Fields = {
  readonly __typename?: 'content_Uploader_var_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.Uploader" */
export type Content_Uploader_Var_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_Uploader_Var_Samp_Fields = {
  readonly __typename?: 'content_Uploader_var_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.Uploader" */
export type Content_Uploader_Var_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_Uploader_Variance_Fields = {
  readonly __typename?: 'content_Uploader_variance_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.Uploader" */
export type Content_Uploader_Variance_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

export type Content_SearchItems_Args = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly search?: Maybe<Scalars['String']>;
};

/** columns and relationships of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly stackLogicalResourceId: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_ChannelStackCreateJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
};

/** aggregate fields of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_ChannelStackCreateJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_ChannelStackCreateJob_Min_Fields>;
};


/** aggregate fields of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_ChannelStackCreateJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_ChannelStackCreateJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.ChannelStackCreateJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_ChannelStackCreateJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly stackLogicalResourceId?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Constraint {
  /** unique or primary key constraint */
  ChannelStackCreateJobPkey = 'ChannelStackCreateJob_pkey',
  /** unique or primary key constraint */
  ChannelStackCreateJobStackLogicalResourceIdKey = 'ChannelStackCreateJob_stackLogicalResourceId_key'
}

/** input type for inserting data into table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_ChannelStackCreateJob_Max_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_ChannelStackCreateJob_Min_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Mutation_Response = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
};

/** input type for inserting object relation for remote table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_ChannelStackCreateJob_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_On_Conflict = {
  readonly constraint: Job_Queues_ChannelStackCreateJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.ChannelStackCreateJob". */
export type Job_Queues_ChannelStackCreateJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_ChannelStackCreateJob */
export type Job_Queues_ChannelStackCreateJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StackLogicalResourceId = 'stackLogicalResourceId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StackLogicalResourceId = 'stackLogicalResourceId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob';
  readonly cloudFormationStackArn: Scalars['String'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly mediaLiveChannelId: Scalars['String'];
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Aggregate = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_ChannelStackDeleteJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
};

/** aggregate fields of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_ChannelStackDeleteJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_ChannelStackDeleteJob_Min_Fields>;
};


/** aggregate fields of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "job_queues.ChannelStackDeleteJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_ChannelStackDeleteJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Bool_Exp>>;
  readonly cloudFormationStackArn?: Maybe<String_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.ChannelStackDeleteJob" */
export enum Job_Queues_ChannelStackDeleteJob_Constraint {
  /** unique or primary key constraint */
  ChannelStackDeleteJobPkey = 'ChannelStackDeleteJob_pkey'
}

/** input type for inserting data into table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Insert_Input = {
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_ChannelStackDeleteJob_Max_Fields = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_max_fields';
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Job_Queues_ChannelStackDeleteJob_Min_Fields = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_min_fields';
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Mutation_Response = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
};

/** on conflict condition type for table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_On_Conflict = {
  readonly constraint: Job_Queues_ChannelStackDeleteJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.ChannelStackDeleteJob". */
export type Job_Queues_ChannelStackDeleteJob_Order_By = {
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_ChannelStackDeleteJob */
export type Job_Queues_ChannelStackDeleteJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.ChannelStackDeleteJob" */
export enum Job_Queues_ChannelStackDeleteJob_Select_Column {
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Set_Input = {
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.ChannelStackDeleteJob" */
export enum Job_Queues_ChannelStackDeleteJob_Update_Column {
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob = {
  readonly __typename?: 'job_queues_ChannelStackUpdateJob';
  /** An object relationship */
  readonly channelStack: Video_ChannelStack;
  readonly channelStackId: Scalars['uuid'];
  readonly cloudFormationStackArn: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly mediaLiveChannelId: Scalars['String'];
  readonly message?: Maybe<Scalars['String']>;
  readonly newRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly newRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Aggregate = {
  readonly __typename?: 'job_queues_ChannelStackUpdateJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_ChannelStackUpdateJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_ChannelStackUpdateJob>;
};

/** aggregate fields of "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_ChannelStackUpdateJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_ChannelStackUpdateJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_ChannelStackUpdateJob_Min_Fields>;
};


/** aggregate fields of "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_ChannelStackUpdateJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_ChannelStackUpdateJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackUpdateJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.ChannelStackUpdateJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_ChannelStackUpdateJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Bool_Exp>>;
  readonly channelStack?: Maybe<Video_ChannelStack_Bool_Exp>;
  readonly channelStackId?: Maybe<Uuid_Comparison_Exp>;
  readonly cloudFormationStackArn?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly newRtmpOutputStreamKey?: Maybe<String_Comparison_Exp>;
  readonly newRtmpOutputUri?: Maybe<String_Comparison_Exp>;
  readonly oldRtmpOutputDestinationId?: Maybe<String_Comparison_Exp>;
  readonly oldRtmpOutputStreamKey?: Maybe<String_Comparison_Exp>;
  readonly oldRtmpOutputUri?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.ChannelStackUpdateJob" */
export enum Job_Queues_ChannelStackUpdateJob_Constraint {
  /** unique or primary key constraint */
  ChannelStackUpdateJobPkey = 'ChannelStackUpdateJob_pkey'
}

/** input type for inserting data into table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Insert_Input = {
  readonly channelStack?: Maybe<Video_ChannelStack_Obj_Rel_Insert_Input>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly newRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly newRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_ChannelStackUpdateJob_Max_Fields = {
  readonly __typename?: 'job_queues_ChannelStackUpdateJob_max_fields';
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly newRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly newRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Max_Order_By = {
  readonly channelStackId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly newRtmpOutputStreamKey?: Maybe<Order_By>;
  readonly newRtmpOutputUri?: Maybe<Order_By>;
  readonly oldRtmpOutputDestinationId?: Maybe<Order_By>;
  readonly oldRtmpOutputStreamKey?: Maybe<Order_By>;
  readonly oldRtmpOutputUri?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_ChannelStackUpdateJob_Min_Fields = {
  readonly __typename?: 'job_queues_ChannelStackUpdateJob_min_fields';
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly newRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly newRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Min_Order_By = {
  readonly channelStackId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly newRtmpOutputStreamKey?: Maybe<Order_By>;
  readonly newRtmpOutputUri?: Maybe<Order_By>;
  readonly oldRtmpOutputDestinationId?: Maybe<Order_By>;
  readonly oldRtmpOutputStreamKey?: Maybe<Order_By>;
  readonly oldRtmpOutputUri?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Mutation_Response = {
  readonly __typename?: 'job_queues_ChannelStackUpdateJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_ChannelStackUpdateJob>;
};

/** on conflict condition type for table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_On_Conflict = {
  readonly constraint: Job_Queues_ChannelStackUpdateJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.ChannelStackUpdateJob". */
export type Job_Queues_ChannelStackUpdateJob_Order_By = {
  readonly channelStack?: Maybe<Video_ChannelStack_Order_By>;
  readonly channelStackId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly newRtmpOutputStreamKey?: Maybe<Order_By>;
  readonly newRtmpOutputUri?: Maybe<Order_By>;
  readonly oldRtmpOutputDestinationId?: Maybe<Order_By>;
  readonly oldRtmpOutputStreamKey?: Maybe<Order_By>;
  readonly oldRtmpOutputUri?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_ChannelStackUpdateJob */
export type Job_Queues_ChannelStackUpdateJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.ChannelStackUpdateJob" */
export enum Job_Queues_ChannelStackUpdateJob_Select_Column {
  /** column name */
  ChannelStackId = 'channelStackId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Message = 'message',
  /** column name */
  NewRtmpOutputStreamKey = 'newRtmpOutputStreamKey',
  /** column name */
  NewRtmpOutputUri = 'newRtmpOutputUri',
  /** column name */
  OldRtmpOutputDestinationId = 'oldRtmpOutputDestinationId',
  /** column name */
  OldRtmpOutputStreamKey = 'oldRtmpOutputStreamKey',
  /** column name */
  OldRtmpOutputUri = 'oldRtmpOutputUri',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.ChannelStackUpdateJob" */
export type Job_Queues_ChannelStackUpdateJob_Set_Input = {
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly newRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly newRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly oldRtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.ChannelStackUpdateJob" */
export enum Job_Queues_ChannelStackUpdateJob_Update_Column {
  /** column name */
  ChannelStackId = 'channelStackId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Message = 'message',
  /** column name */
  NewRtmpOutputStreamKey = 'newRtmpOutputStreamKey',
  /** column name */
  NewRtmpOutputUri = 'newRtmpOutputUri',
  /** column name */
  OldRtmpOutputDestinationId = 'oldRtmpOutputDestinationId',
  /** column name */
  OldRtmpOutputStreamKey = 'oldRtmpOutputStreamKey',
  /** column name */
  OldRtmpOutputUri = 'oldRtmpOutputUri',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob = {
  readonly __typename?: 'job_queues_CombineVideosJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName: Scalars['String'];
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJobDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate = {
  readonly __typename?: 'job_queues_CombineVideosJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_CombineVideosJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_CombineVideosJob>;
};

/** aggregate fields of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_CombineVideosJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_CombineVideosJob_Min_Fields>;
};


/** aggregate fields of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CombineVideosJob_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "job_queues.CombineVideosJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_CombineVideosJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdByRegistrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly mediaConvertJobId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly outputName?: Maybe<String_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Constraint {
  /** unique or primary key constraint */
  CombineVideosJobPkey = 'CombineVideosJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_CombineVideosJob_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_CombineVideosJob_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_CombineVideosJob_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_CombineVideosJob_Max_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Job_Queues_CombineVideosJob_Min_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Mutation_Response = {
  readonly __typename?: 'job_queues_CombineVideosJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_CombineVideosJob>;
};

/** on conflict condition type for table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_On_Conflict = {
  readonly constraint: Job_Queues_CombineVideosJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_CombineVideosJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.CombineVideosJob". */
export type Job_Queues_CombineVideosJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdByRegistrantId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaConvertJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly outputName?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_CombineVideosJob */
export type Job_Queues_CombineVideosJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CombineVideosJob_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedByRegistrantId = 'createdByRegistrantId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaConvertJobId = 'mediaConvertJobId',
  /** column name */
  Message = 'message',
  /** column name */
  OutputName = 'outputName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedByRegistrantId = 'createdByRegistrantId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaConvertJobId = 'mediaConvertJobId',
  /** column name */
  Message = 'message',
  /** column name */
  OutputName = 'outputName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob = {
  readonly __typename?: 'job_queues_CustomEmailJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly htmlBody: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly registrantIds: Scalars['jsonb'];
  readonly subject: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJobRegistrantIdsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_CustomEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_CustomEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_CustomEmailJob>;
};

/** aggregate fields of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_CustomEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_CustomEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CustomEmailJob_Append_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "job_queues.CustomEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_CustomEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly htmlBody?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly registrantIds?: Maybe<Jsonb_Comparison_Exp>;
  readonly subject?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Constraint {
  /** unique or primary key constraint */
  CustomEmailJobPkey = 'CustomEmailJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_CustomEmailJob_Delete_At_Path_Input = {
  readonly registrantIds?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_CustomEmailJob_Delete_Elem_Input = {
  readonly registrantIds?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_CustomEmailJob_Delete_Key_Input = {
  readonly registrantIds?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_CustomEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Job_Queues_CustomEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_CustomEmailJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_CustomEmailJob>;
};

/** on conflict condition type for table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_CustomEmailJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_CustomEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.CustomEmailJob". */
export type Job_Queues_CustomEmailJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly htmlBody?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly registrantIds?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_CustomEmailJob */
export type Job_Queues_CustomEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CustomEmailJob_Prepend_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HtmlBody = 'htmlBody',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HtmlBody = 'htmlBody',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob = {
  readonly __typename?: 'job_queues_InvitationEmailJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly registrantIds: Scalars['jsonb'];
  readonly sendRepeat: Scalars['Boolean'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJobRegistrantIdsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_InvitationEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_InvitationEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_InvitationEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Append_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "job_queues.InvitationEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_InvitationEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly registrantIds?: Maybe<Jsonb_Comparison_Exp>;
  readonly sendRepeat?: Maybe<Boolean_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Constraint {
  /** unique or primary key constraint */
  InvitationEmailJobsPkey = 'InvitationEmailJobs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_InvitationEmailJob_Delete_At_Path_Input = {
  readonly registrantIds?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_InvitationEmailJob_Delete_Elem_Input = {
  readonly registrantIds?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_InvitationEmailJob_Delete_Key_Input = {
  readonly registrantIds?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_InvitationEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Job_Queues_InvitationEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** on conflict condition type for table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_InvitationEmailJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_InvitationEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.InvitationEmailJob". */
export type Job_Queues_InvitationEmailJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly registrantIds?: Maybe<Order_By>;
  readonly sendRepeat?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_InvitationEmailJob */
export type Job_Queues_InvitationEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Prepend_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_MediaPackageHarvestJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_MediaPackageHarvestJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_MediaPackageHarvestJob_Min_Fields>;
};


/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "job_queues.MediaPackageHarvestJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_MediaPackageHarvestJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly mediaPackageHarvestJobId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Constraint {
  /** unique or primary key constraint */
  MediaPackageHarvestJobMediaPackageHarvestJobIdKey = 'MediaPackageHarvestJob_mediaPackageHarvestJobId_key',
  /** unique or primary key constraint */
  MediaPackageHarvestJobPkey = 'MediaPackageHarvestJob_pkey'
}

/** input type for inserting data into table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_MediaPackageHarvestJob_Max_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Job_Queues_MediaPackageHarvestJob_Min_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Mutation_Response = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** on conflict condition type for table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_On_Conflict = {
  readonly constraint: Job_Queues_MediaPackageHarvestJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.MediaPackageHarvestJob". */
export type Job_Queues_MediaPackageHarvestJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_MediaPackageHarvestJob */
export type Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob = {
  readonly __typename?: 'job_queues_PublishVideoJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element: Content_Element;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly jobStatusName: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_PublishVideoJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_PublishVideoJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_PublishVideoJob_Min_Fields>;
};


/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "job_queues.PublishVideoJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_PublishVideoJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatusName?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vimeoVideoUrl?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Constraint {
  /** unique or primary key constraint */
  PublishVideoJobPkey = 'PublishVideoJob_pkey'
}

/** input type for inserting data into table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Job_Queues_PublishVideoJob_Max_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Job_Queues_PublishVideoJob_Min_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Mutation_Response = {
  readonly __typename?: 'job_queues_PublishVideoJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** on conflict condition type for table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_On_Conflict = {
  readonly constraint: Job_Queues_PublishVideoJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_PublishVideoJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.PublishVideoJob". */
export type Job_Queues_PublishVideoJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_PublishVideoJob */
export type Job_Queues_PublishVideoJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** input type for updating data in table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** update columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** columns and relationships of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob';
  readonly created_at: Scalars['timestamptz'];
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly person?: Maybe<Collection_ProgramPerson>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly processed: Scalars['Boolean'];
  readonly updated_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly uploader?: Maybe<Content_Uploader>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJobEmailTemplateArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_SubmissionRequestEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_SubmissionRequestEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_SubmissionRequestEmailJob_Append_Input = {
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "job_queues.SubmissionRequestEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_SubmissionRequestEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emailTemplate?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploader?: Maybe<Content_Uploader_Bool_Exp>;
  readonly uploaderId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Constraint {
  /** unique or primary key constraint */
  SubmissionRequestEmailJobPkey = 'SubmissionRequestEmailJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input = {
  readonly emailTemplate?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input = {
  readonly emailTemplate?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input = {
  readonly emailTemplate?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<Collection_ProgramPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploader?: Maybe<Content_Uploader_Obj_Rel_Insert_Input>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Job_Queues_SubmissionRequestEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Job_Queues_SubmissionRequestEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** response of any mutation on the table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** on conflict condition type for table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_SubmissionRequestEmailJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.SubmissionRequestEmailJob". */
export type Job_Queues_SubmissionRequestEmailJob_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly emailTemplate?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly person?: Maybe<Collection_ProgramPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploader?: Maybe<Content_Uploader_Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_SubmissionRequestEmailJob */
export type Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_SubmissionRequestEmailJob_Prepend_Input = {
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailTemplate = 'emailTemplate',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}

/** input type for updating data in table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailTemplate = 'emailTemplate',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}

/** columns and relationships of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element: Content_Element;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly registrantGoogleAccount: Registrant_GoogleAccount;
  readonly registrantGoogleAccountId: Scalars['uuid'];
  readonly retriesCount: Scalars['Int'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly videoDescription: Scalars['String'];
  readonly videoPrivacyStatus: Scalars['String'];
  readonly videoTitle: Scalars['String'];
};

/** aggregated selection of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_UploadYouTubeVideoJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
};

/** aggregate fields of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_aggregate_fields';
  readonly avg?: Maybe<Job_Queues_UploadYouTubeVideoJob_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Job_Queues_UploadYouTubeVideoJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_UploadYouTubeVideoJob_Min_Fields>;
  readonly stddev?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Job_Queues_UploadYouTubeVideoJob_Sum_Fields>;
  readonly var_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Samp_Fields>;
  readonly variance?: Maybe<Job_Queues_UploadYouTubeVideoJob_Variance_Fields>;
};


/** aggregate fields of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Job_Queues_UploadYouTubeVideoJob_Avg_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "job_queues.UploadYouTubeVideoJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_UploadYouTubeVideoJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>>;
  readonly _not?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly playlistId?: Maybe<String_Comparison_Exp>;
  readonly registrantGoogleAccount?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
  readonly registrantGoogleAccountId?: Maybe<Uuid_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoDescription?: Maybe<String_Comparison_Exp>;
  readonly videoPrivacyStatus?: Maybe<String_Comparison_Exp>;
  readonly videoTitle?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Constraint {
  /** unique or primary key constraint */
  UploadYouTubeVideoJobPkey = 'UploadYouTubeVideoJob_pkey'
}

/** input type for incrementing numeric columns in table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccount?: Maybe<Registrant_GoogleAccount_Obj_Rel_Insert_Input>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Job_Queues_UploadYouTubeVideoJob_Max_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Job_Queues_UploadYouTubeVideoJob_Min_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Mutation_Response = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
};

/** on conflict condition type for table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_On_Conflict = {
  readonly constraint: Job_Queues_UploadYouTubeVideoJob_Constraint;
  readonly update_columns?: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};

/** Ordering options when selecting data from "job_queues.UploadYouTubeVideoJob". */
export type Job_Queues_UploadYouTubeVideoJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly playlistId?: Maybe<Order_By>;
  readonly registrantGoogleAccount?: Maybe<Registrant_GoogleAccount_Order_By>;
  readonly registrantGoogleAccountId?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoDescription?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** primary key columns input for table: job_queues_UploadYouTubeVideoJob */
export type Job_Queues_UploadYouTubeVideoJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  PlaylistId = 'playlistId',
  /** column name */
  RegistrantGoogleAccountId = 'registrantGoogleAccountId',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoDescription = 'videoDescription',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** input type for updating data in table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Job_Queues_UploadYouTubeVideoJob_Sum_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** update columns of table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  PlaylistId = 'playlistId',
  /** column name */
  RegistrantGoogleAccountId = 'registrantGoogleAccountId',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoDescription = 'videoDescription',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** aggregate var_pop on columns */
export type Job_Queues_UploadYouTubeVideoJob_Var_Pop_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Job_Queues_UploadYouTubeVideoJob_Var_Samp_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Job_Queues_UploadYouTubeVideoJob_Variance_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};


/** Boolean expression to compare columns of type "jsonb". All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  /** is the column contained in the given json value */
  readonly _contained_in?: Maybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  readonly _contains?: Maybe<Scalars['jsonb']>;
  readonly _eq?: Maybe<Scalars['jsonb']>;
  readonly _gt?: Maybe<Scalars['jsonb']>;
  readonly _gte?: Maybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  readonly _has_key?: Maybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  readonly _has_keys_all?: Maybe<ReadonlyArray<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  readonly _has_keys_any?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['jsonb']>;
  readonly _lte?: Maybe<Scalars['jsonb']>;
  readonly _neq?: Maybe<Scalars['jsonb']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
};

/** mutation root */
export type Mutation_Root = {
  readonly __typename?: 'mutation_root';
  readonly createItemRoom?: Maybe<CreateItemRoomOutput>;
  readonly createRoomDm?: Maybe<CreateRoomDmOutput>;
  /** delete data from the table: "Email" */
  readonly delete_Email?: Maybe<Email_Mutation_Response>;
  /** delete single row from the table: "Email" */
  readonly delete_Email_by_pk?: Maybe<Email>;
  /** delete data from the table: "PushNotificationSubscription" */
  readonly delete_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** delete single row from the table: "PushNotificationSubscription" */
  readonly delete_PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** delete data from the table: "User" */
  readonly delete_User?: Maybe<User_Mutation_Response>;
  /** delete single row from the table: "User" */
  readonly delete_User_by_pk?: Maybe<User>;
  /** delete data from the table: "analytics.AppStats" */
  readonly delete_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** delete single row from the table: "analytics.AppStats" */
  readonly delete_analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** delete data from the table: "analytics.ContentElementStats" */
  readonly delete_analytics_ContentElementStats?: Maybe<Analytics_ContentElementStats_Mutation_Response>;
  /** delete single row from the table: "analytics.ContentElementStats" */
  readonly delete_analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** delete data from the table: "analytics.ContentItemStats" */
  readonly delete_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** delete single row from the table: "analytics.ContentItemStats" */
  readonly delete_analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** delete data from the table: "analytics.RoomStats" */
  readonly delete_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** delete single row from the table: "analytics.RoomStats" */
  readonly delete_analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** delete data from the table: "analytics.mat_ElementTotalViews" */
  readonly delete_analytics_mat_ElementTotalViews?: Maybe<Analytics_Mat_ElementTotalViews_Mutation_Response>;
  /** delete data from the table: "analytics.mat_ItemTotalViews" */
  readonly delete_analytics_mat_ItemTotalViews?: Maybe<Analytics_Mat_ItemTotalViews_Mutation_Response>;
  /** delete data from the table: "analytics.mat_RoomPresence" */
  readonly delete_analytics_mat_RoomPresence?: Maybe<Analytics_Mat_RoomPresence_Mutation_Response>;
  /** delete data from the table: "chat.Chat" */
  readonly delete_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** delete single row from the table: "chat.Chat" */
  readonly delete_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** delete data from the table: "chat.Flag" */
  readonly delete_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** delete data from the table: "chat.FlagType" */
  readonly delete_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** delete single row from the table: "chat.FlagType" */
  readonly delete_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** delete single row from the table: "chat.Flag" */
  readonly delete_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** delete data from the table: "chat.Message" */
  readonly delete_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** delete data from the table: "chat.MessageType" */
  readonly delete_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** delete single row from the table: "chat.MessageType" */
  readonly delete_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** delete single row from the table: "chat.Message" */
  readonly delete_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** delete data from the table: "chat.Pin" */
  readonly delete_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** delete single row from the table: "chat.Pin" */
  readonly delete_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** delete data from the table: "chat.Reaction" */
  readonly delete_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** delete data from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** delete single row from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** delete single row from the table: "chat.Reaction" */
  readonly delete_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** delete data from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** delete single row from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** delete data from the table: "chat.Subscription" */
  readonly delete_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** delete single row from the table: "chat.Subscription" */
  readonly delete_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** delete data from the table: "collection.Exhibition" */
  readonly delete_collection_Exhibition?: Maybe<Collection_Exhibition_Mutation_Response>;
  /** delete single row from the table: "collection.Exhibition" */
  readonly delete_collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** delete data from the table: "collection.ProgramPerson" */
  readonly delete_collection_ProgramPerson?: Maybe<Collection_ProgramPerson_Mutation_Response>;
  /** delete data from the table: "collection.ProgramPersonByAccessToken" */
  readonly delete_collection_ProgramPersonByAccessToken?: Maybe<Collection_ProgramPersonByAccessToken_Mutation_Response>;
  /** delete data from the table: "collection.ProgramPersonWithAccessToken" */
  readonly delete_collection_ProgramPersonWithAccessToken?: Maybe<Collection_ProgramPersonWithAccessToken_Mutation_Response>;
  /** delete single row from the table: "collection.ProgramPerson" */
  readonly delete_collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** delete data from the table: "collection.Tag" */
  readonly delete_collection_Tag?: Maybe<Collection_Tag_Mutation_Response>;
  /** delete single row from the table: "collection.Tag" */
  readonly delete_collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** delete data from the table: "conference.Conference" */
  readonly delete_conference_Conference?: Maybe<Conference_Conference_Mutation_Response>;
  /** delete single row from the table: "conference.Conference" */
  readonly delete_conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** delete data from the table: "conference.Configuration" */
  readonly delete_conference_Configuration?: Maybe<Conference_Configuration_Mutation_Response>;
  /** delete data from the table: "conference.ConfigurationKey" */
  readonly delete_conference_ConfigurationKey?: Maybe<Conference_ConfigurationKey_Mutation_Response>;
  /** delete single row from the table: "conference.ConfigurationKey" */
  readonly delete_conference_ConfigurationKey_by_pk?: Maybe<Conference_ConfigurationKey>;
  /** delete single row from the table: "conference.Configuration" */
  readonly delete_conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** delete data from the table: "conference.DemoCode" */
  readonly delete_conference_DemoCode?: Maybe<Conference_DemoCode_Mutation_Response>;
  /** delete single row from the table: "conference.DemoCode" */
  readonly delete_conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** delete data from the table: "conference.OriginatingData" */
  readonly delete_conference_OriginatingData?: Maybe<Conference_OriginatingData_Mutation_Response>;
  /** delete single row from the table: "conference.OriginatingData" */
  readonly delete_conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** delete data from the table: "conference.PrepareJob" */
  readonly delete_conference_PrepareJob?: Maybe<Conference_PrepareJob_Mutation_Response>;
  /** delete single row from the table: "conference.PrepareJob" */
  readonly delete_conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** delete data from the table: "content.Element" */
  readonly delete_content_Element?: Maybe<Content_Element_Mutation_Response>;
  /** delete data from the table: "content.ElementByPersonAccessToken" */
  readonly delete_content_ElementByPersonAccessToken?: Maybe<Content_ElementByPersonAccessToken_Mutation_Response>;
  /** delete data from the table: "content.ElementPermissionGrant" */
  readonly delete_content_ElementPermissionGrant?: Maybe<Content_ElementPermissionGrant_Mutation_Response>;
  /** delete single row from the table: "content.ElementPermissionGrant" */
  readonly delete_content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** delete data from the table: "content.ElementType" */
  readonly delete_content_ElementType?: Maybe<Content_ElementType_Mutation_Response>;
  /** delete single row from the table: "content.ElementType" */
  readonly delete_content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** delete single row from the table: "content.Element" */
  readonly delete_content_Element_by_pk?: Maybe<Content_Element>;
  /** delete data from the table: "content.Item" */
  readonly delete_content_Item?: Maybe<Content_Item_Mutation_Response>;
  /** delete data from the table: "content.ItemByPersonAccessToken" */
  readonly delete_content_ItemByPersonAccessToken?: Maybe<Content_ItemByPersonAccessToken_Mutation_Response>;
  /** delete data from the table: "content.ItemExhibition" */
  readonly delete_content_ItemExhibition?: Maybe<Content_ItemExhibition_Mutation_Response>;
  /** delete single row from the table: "content.ItemExhibition" */
  readonly delete_content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** delete data from the table: "content.ItemProgramPerson" */
  readonly delete_content_ItemProgramPerson?: Maybe<Content_ItemProgramPerson_Mutation_Response>;
  /** delete data from the table: "content.ItemProgramPersonByAccessToken" */
  readonly delete_content_ItemProgramPersonByAccessToken?: Maybe<Content_ItemProgramPersonByAccessToken_Mutation_Response>;
  /** delete single row from the table: "content.ItemProgramPerson" */
  readonly delete_content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** delete data from the table: "content.ItemTag" */
  readonly delete_content_ItemTag?: Maybe<Content_ItemTag_Mutation_Response>;
  /** delete single row from the table: "content.ItemTag" */
  readonly delete_content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** delete data from the table: "content.ItemType" */
  readonly delete_content_ItemType?: Maybe<Content_ItemType_Mutation_Response>;
  /** delete single row from the table: "content.ItemType" */
  readonly delete_content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** delete single row from the table: "content.Item" */
  readonly delete_content_Item_by_pk?: Maybe<Content_Item>;
  /** delete data from the table: "content.Uploader" */
  readonly delete_content_Uploader?: Maybe<Content_Uploader_Mutation_Response>;
  /** delete single row from the table: "content.Uploader" */
  readonly delete_content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** delete data from the table: "job_queues.ChannelStackCreateJob" */
  readonly delete_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.ChannelStackCreateJob" */
  readonly delete_job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** delete data from the table: "job_queues.ChannelStackDeleteJob" */
  readonly delete_job_queues_ChannelStackDeleteJob?: Maybe<Job_Queues_ChannelStackDeleteJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.ChannelStackDeleteJob" */
  readonly delete_job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** delete data from the table: "job_queues.ChannelStackUpdateJob" */
  readonly delete_job_queues_ChannelStackUpdateJob?: Maybe<Job_Queues_ChannelStackUpdateJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.ChannelStackUpdateJob" */
  readonly delete_job_queues_ChannelStackUpdateJob_by_pk?: Maybe<Job_Queues_ChannelStackUpdateJob>;
  /** delete data from the table: "job_queues.CombineVideosJob" */
  readonly delete_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.CombineVideosJob" */
  readonly delete_job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** delete data from the table: "job_queues.CustomEmailJob" */
  readonly delete_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.CustomEmailJob" */
  readonly delete_job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** delete data from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** delete data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** delete data from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** delete data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** delete data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly delete_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly delete_job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** delete data from the table: "permissions.Group" */
  readonly delete_permissions_Group?: Maybe<Permissions_Group_Mutation_Response>;
  /** delete data from the table: "permissions.GroupRegistrant" */
  readonly delete_permissions_GroupRegistrant?: Maybe<Permissions_GroupRegistrant_Mutation_Response>;
  /** delete single row from the table: "permissions.GroupRegistrant" */
  readonly delete_permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** delete data from the table: "permissions.GroupRole" */
  readonly delete_permissions_GroupRole?: Maybe<Permissions_GroupRole_Mutation_Response>;
  /** delete single row from the table: "permissions.GroupRole" */
  readonly delete_permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** delete single row from the table: "permissions.Group" */
  readonly delete_permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** delete data from the table: "permissions.Permission" */
  readonly delete_permissions_Permission?: Maybe<Permissions_Permission_Mutation_Response>;
  /** delete single row from the table: "permissions.Permission" */
  readonly delete_permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** delete data from the table: "permissions.Role" */
  readonly delete_permissions_Role?: Maybe<Permissions_Role_Mutation_Response>;
  /** delete data from the table: "permissions.RolePermission" */
  readonly delete_permissions_RolePermission?: Maybe<Permissions_RolePermission_Mutation_Response>;
  /** delete single row from the table: "permissions.RolePermission" */
  readonly delete_permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** delete single row from the table: "permissions.Role" */
  readonly delete_permissions_Role_by_pk?: Maybe<Permissions_Role>;
  /** delete data from the table: "registrant.GoogleAccount" */
  readonly delete_registrant_GoogleAccount?: Maybe<Registrant_GoogleAccount_Mutation_Response>;
  /** delete single row from the table: "registrant.GoogleAccount" */
  readonly delete_registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** delete data from the table: "registrant.Invitation" */
  readonly delete_registrant_Invitation?: Maybe<Registrant_Invitation_Mutation_Response>;
  /** delete single row from the table: "registrant.Invitation" */
  readonly delete_registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** delete data from the table: "registrant.Profile" */
  readonly delete_registrant_Profile?: Maybe<Registrant_Profile_Mutation_Response>;
  /** delete single row from the table: "registrant.Profile" */
  readonly delete_registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** delete data from the table: "registrant.Registrant" */
  readonly delete_registrant_Registrant?: Maybe<Registrant_Registrant_Mutation_Response>;
  /** delete single row from the table: "registrant.Registrant" */
  readonly delete_registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** delete data from the table: "registrant.SavedVonageRoomRecording" */
  readonly delete_registrant_SavedVonageRoomRecording?: Maybe<Registrant_SavedVonageRoomRecording_Mutation_Response>;
  /** delete single row from the table: "registrant.SavedVonageRoomRecording" */
  readonly delete_registrant_SavedVonageRoomRecording_by_pk?: Maybe<Registrant_SavedVonageRoomRecording>;
  /** delete data from the table: "room.Backend" */
  readonly delete_room_Backend?: Maybe<Room_Backend_Mutation_Response>;
  /** delete single row from the table: "room.Backend" */
  readonly delete_room_Backend_by_pk?: Maybe<Room_Backend>;
  /** delete data from the table: "room.ChimeMeeting" */
  readonly delete_room_ChimeMeeting?: Maybe<Room_ChimeMeeting_Mutation_Response>;
  /** delete single row from the table: "room.ChimeMeeting" */
  readonly delete_room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** delete data from the table: "room.ManagementMode" */
  readonly delete_room_ManagementMode?: Maybe<Room_ManagementMode_Mutation_Response>;
  /** delete single row from the table: "room.ManagementMode" */
  readonly delete_room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** delete data from the table: "room.Mode" */
  readonly delete_room_Mode?: Maybe<Room_Mode_Mutation_Response>;
  /** delete single row from the table: "room.Mode" */
  readonly delete_room_Mode_by_pk?: Maybe<Room_Mode>;
  /** delete data from the table: "room.Participant" */
  readonly delete_room_Participant?: Maybe<Room_Participant_Mutation_Response>;
  /** delete single row from the table: "room.Participant" */
  readonly delete_room_Participant_by_pk?: Maybe<Room_Participant>;
  /** delete data from the table: "room.PersonRole" */
  readonly delete_room_PersonRole?: Maybe<Room_PersonRole_Mutation_Response>;
  /** delete single row from the table: "room.PersonRole" */
  readonly delete_room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** delete data from the table: "room.Room" */
  readonly delete_room_Room?: Maybe<Room_Room_Mutation_Response>;
  /** delete data from the table: "room.RoomPerson" */
  readonly delete_room_RoomPerson?: Maybe<Room_RoomPerson_Mutation_Response>;
  /** delete single row from the table: "room.RoomPerson" */
  readonly delete_room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** delete single row from the table: "room.Room" */
  readonly delete_room_Room_by_pk?: Maybe<Room_Room>;
  /** delete data from the table: "room.ShuffleAlgorithm" */
  readonly delete_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleAlgorithm" */
  readonly delete_room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** delete data from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** delete single row from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** delete data from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** delete data from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** delete data from the table: "schedule.Continuation" */
  readonly delete_schedule_Continuation?: Maybe<Schedule_Continuation_Mutation_Response>;
  /** delete single row from the table: "schedule.Continuation" */
  readonly delete_schedule_Continuation_by_pk?: Maybe<Schedule_Continuation>;
  /** delete data from the table: "schedule.Event" */
  readonly delete_schedule_Event?: Maybe<Schedule_Event_Mutation_Response>;
  /** delete data from the table: "schedule.EventProgramPerson" */
  readonly delete_schedule_EventProgramPerson?: Maybe<Schedule_EventProgramPerson_Mutation_Response>;
  /** delete data from the table: "schedule.EventProgramPersonRole" */
  readonly delete_schedule_EventProgramPersonRole?: Maybe<Schedule_EventProgramPersonRole_Mutation_Response>;
  /** delete single row from the table: "schedule.EventProgramPersonRole" */
  readonly delete_schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** delete single row from the table: "schedule.EventProgramPerson" */
  readonly delete_schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** delete data from the table: "schedule.EventTag" */
  readonly delete_schedule_EventTag?: Maybe<Schedule_EventTag_Mutation_Response>;
  /** delete single row from the table: "schedule.EventTag" */
  readonly delete_schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** delete single row from the table: "schedule.Event" */
  readonly delete_schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** delete data from the table: "schedule.StarredEvent" */
  readonly delete_schedule_StarredEvent?: Maybe<Schedule_StarredEvent_Mutation_Response>;
  /** delete single row from the table: "schedule.StarredEvent" */
  readonly delete_schedule_StarredEvent_by_pk?: Maybe<Schedule_StarredEvent>;
  /** delete data from the table: "system.Configuration" */
  readonly delete_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** delete data from the table: "system.ConfigurationKey" */
  readonly delete_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** delete single row from the table: "system.ConfigurationKey" */
  readonly delete_system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** delete single row from the table: "system.Configuration" */
  readonly delete_system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** delete data from the table: "video.ChannelStack" */
  readonly delete_video_ChannelStack?: Maybe<Video_ChannelStack_Mutation_Response>;
  /** delete data from the table: "video.ChannelStackWithStreamKey" */
  readonly delete_video_ChannelStackWithStreamKey?: Maybe<Video_ChannelStackWithStreamKey_Mutation_Response>;
  /** delete single row from the table: "video.ChannelStack" */
  readonly delete_video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** delete data from the table: "video.EventParticipantStream" */
  readonly delete_video_EventParticipantStream?: Maybe<Video_EventParticipantStream_Mutation_Response>;
  /** delete single row from the table: "video.EventParticipantStream" */
  readonly delete_video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** delete data from the table: "video.EventVonageSession" */
  readonly delete_video_EventVonageSession?: Maybe<Video_EventVonageSession_Mutation_Response>;
  /** delete single row from the table: "video.EventVonageSession" */
  readonly delete_video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** delete data from the table: "video.ImmediateSwitch" */
  readonly delete_video_ImmediateSwitch?: Maybe<Video_ImmediateSwitch_Mutation_Response>;
  /** delete single row from the table: "video.ImmediateSwitch" */
  readonly delete_video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** delete data from the table: "video.InputType" */
  readonly delete_video_InputType?: Maybe<Video_InputType_Mutation_Response>;
  /** delete single row from the table: "video.InputType" */
  readonly delete_video_InputType_by_pk?: Maybe<Video_InputType>;
  /** delete data from the table: "video.JobStatus" */
  readonly delete_video_JobStatus?: Maybe<Video_JobStatus_Mutation_Response>;
  /** delete single row from the table: "video.JobStatus" */
  readonly delete_video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** delete data from the table: "video.MediaLiveChannelStatus" */
  readonly delete_video_MediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Mutation_Response>;
  /** delete single row from the table: "video.MediaLiveChannelStatus" */
  readonly delete_video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** delete data from the table: "video.RoomRtmpOutput" */
  readonly delete_video_RoomRtmpOutput?: Maybe<Video_RoomRtmpOutput_Mutation_Response>;
  /** delete single row from the table: "video.RoomRtmpOutput" */
  readonly delete_video_RoomRtmpOutput_by_pk?: Maybe<Video_RoomRtmpOutput>;
  /** delete data from the table: "video.RtmpInput" */
  readonly delete_video_RtmpInput?: Maybe<Video_RtmpInput_Mutation_Response>;
  /** delete single row from the table: "video.RtmpInput" */
  readonly delete_video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** delete data from the table: "video.TranscriptionJob" */
  readonly delete_video_TranscriptionJob?: Maybe<Video_TranscriptionJob_Mutation_Response>;
  /** delete single row from the table: "video.TranscriptionJob" */
  readonly delete_video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** delete data from the table: "video.VideoRenderJob" */
  readonly delete_video_VideoRenderJob?: Maybe<Video_VideoRenderJob_Mutation_Response>;
  /** delete single row from the table: "video.VideoRenderJob" */
  readonly delete_video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** delete data from the table: "video.VonageRoomRecording" */
  readonly delete_video_VonageRoomRecording?: Maybe<Video_VonageRoomRecording_Mutation_Response>;
  /** delete single row from the table: "video.VonageRoomRecording" */
  readonly delete_video_VonageRoomRecording_by_pk?: Maybe<Video_VonageRoomRecording>;
  /** delete data from the table: "video.YouTubeUpload" */
  readonly delete_video_YouTubeUpload?: Maybe<Video_YouTubeUpload_Mutation_Response>;
  /** delete single row from the table: "video.YouTubeUpload" */
  readonly delete_video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
  readonly getGoogleOAuthUrl?: Maybe<GetGoogleOAuthUrlOutput>;
  /** insert data into the table: "Email" */
  readonly insert_Email?: Maybe<Email_Mutation_Response>;
  /** insert a single row into the table: "Email" */
  readonly insert_Email_one?: Maybe<Email>;
  /** insert data into the table: "PushNotificationSubscription" */
  readonly insert_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** insert a single row into the table: "PushNotificationSubscription" */
  readonly insert_PushNotificationSubscription_one?: Maybe<PushNotificationSubscription>;
  /** insert data into the table: "User" */
  readonly insert_User?: Maybe<User_Mutation_Response>;
  /** insert a single row into the table: "User" */
  readonly insert_User_one?: Maybe<User>;
  /** insert data into the table: "analytics.AppStats" */
  readonly insert_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.AppStats" */
  readonly insert_analytics_AppStats_one?: Maybe<Analytics_AppStats>;
  /** insert data into the table: "analytics.ContentElementStats" */
  readonly insert_analytics_ContentElementStats?: Maybe<Analytics_ContentElementStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.ContentElementStats" */
  readonly insert_analytics_ContentElementStats_one?: Maybe<Analytics_ContentElementStats>;
  /** insert data into the table: "analytics.ContentItemStats" */
  readonly insert_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.ContentItemStats" */
  readonly insert_analytics_ContentItemStats_one?: Maybe<Analytics_ContentItemStats>;
  /** insert data into the table: "analytics.RoomStats" */
  readonly insert_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.RoomStats" */
  readonly insert_analytics_RoomStats_one?: Maybe<Analytics_RoomStats>;
  /** insert data into the table: "analytics.mat_ElementTotalViews" */
  readonly insert_analytics_mat_ElementTotalViews?: Maybe<Analytics_Mat_ElementTotalViews_Mutation_Response>;
  /** insert a single row into the table: "analytics.mat_ElementTotalViews" */
  readonly insert_analytics_mat_ElementTotalViews_one?: Maybe<Analytics_Mat_ElementTotalViews>;
  /** insert data into the table: "analytics.mat_ItemTotalViews" */
  readonly insert_analytics_mat_ItemTotalViews?: Maybe<Analytics_Mat_ItemTotalViews_Mutation_Response>;
  /** insert a single row into the table: "analytics.mat_ItemTotalViews" */
  readonly insert_analytics_mat_ItemTotalViews_one?: Maybe<Analytics_Mat_ItemTotalViews>;
  /** insert data into the table: "analytics.mat_RoomPresence" */
  readonly insert_analytics_mat_RoomPresence?: Maybe<Analytics_Mat_RoomPresence_Mutation_Response>;
  /** insert a single row into the table: "analytics.mat_RoomPresence" */
  readonly insert_analytics_mat_RoomPresence_one?: Maybe<Analytics_Mat_RoomPresence>;
  /** insert data into the table: "chat.Chat" */
  readonly insert_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** insert a single row into the table: "chat.Chat" */
  readonly insert_chat_Chat_one?: Maybe<Chat_Chat>;
  /** insert data into the table: "chat.Flag" */
  readonly insert_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** insert data into the table: "chat.FlagType" */
  readonly insert_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** insert a single row into the table: "chat.FlagType" */
  readonly insert_chat_FlagType_one?: Maybe<Chat_FlagType>;
  /** insert a single row into the table: "chat.Flag" */
  readonly insert_chat_Flag_one?: Maybe<Chat_Flag>;
  /** insert data into the table: "chat.Message" */
  readonly insert_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** insert data into the table: "chat.MessageType" */
  readonly insert_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** insert a single row into the table: "chat.MessageType" */
  readonly insert_chat_MessageType_one?: Maybe<Chat_MessageType>;
  /** insert a single row into the table: "chat.Message" */
  readonly insert_chat_Message_one?: Maybe<Chat_Message>;
  /** insert data into the table: "chat.Pin" */
  readonly insert_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** insert a single row into the table: "chat.Pin" */
  readonly insert_chat_Pin_one?: Maybe<Chat_Pin>;
  /** insert data into the table: "chat.Reaction" */
  readonly insert_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** insert data into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** insert a single row into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType_one?: Maybe<Chat_ReactionType>;
  /** insert a single row into the table: "chat.Reaction" */
  readonly insert_chat_Reaction_one?: Maybe<Chat_Reaction>;
  /** insert data into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** insert a single row into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex_one?: Maybe<Chat_ReadUpToIndex>;
  /** insert data into the table: "chat.Subscription" */
  readonly insert_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** insert a single row into the table: "chat.Subscription" */
  readonly insert_chat_Subscription_one?: Maybe<Chat_Subscription>;
  /** insert data into the table: "collection.Exhibition" */
  readonly insert_collection_Exhibition?: Maybe<Collection_Exhibition_Mutation_Response>;
  /** insert a single row into the table: "collection.Exhibition" */
  readonly insert_collection_Exhibition_one?: Maybe<Collection_Exhibition>;
  /** insert data into the table: "collection.ProgramPerson" */
  readonly insert_collection_ProgramPerson?: Maybe<Collection_ProgramPerson_Mutation_Response>;
  /** insert data into the table: "collection.ProgramPersonByAccessToken" */
  readonly insert_collection_ProgramPersonByAccessToken?: Maybe<Collection_ProgramPersonByAccessToken_Mutation_Response>;
  /** insert a single row into the table: "collection.ProgramPersonByAccessToken" */
  readonly insert_collection_ProgramPersonByAccessToken_one?: Maybe<Collection_ProgramPersonByAccessToken>;
  /** insert data into the table: "collection.ProgramPersonWithAccessToken" */
  readonly insert_collection_ProgramPersonWithAccessToken?: Maybe<Collection_ProgramPersonWithAccessToken_Mutation_Response>;
  /** insert a single row into the table: "collection.ProgramPersonWithAccessToken" */
  readonly insert_collection_ProgramPersonWithAccessToken_one?: Maybe<Collection_ProgramPersonWithAccessToken>;
  /** insert a single row into the table: "collection.ProgramPerson" */
  readonly insert_collection_ProgramPerson_one?: Maybe<Collection_ProgramPerson>;
  /** insert data into the table: "collection.Tag" */
  readonly insert_collection_Tag?: Maybe<Collection_Tag_Mutation_Response>;
  /** insert a single row into the table: "collection.Tag" */
  readonly insert_collection_Tag_one?: Maybe<Collection_Tag>;
  /** insert data into the table: "conference.Conference" */
  readonly insert_conference_Conference?: Maybe<Conference_Conference_Mutation_Response>;
  /** insert a single row into the table: "conference.Conference" */
  readonly insert_conference_Conference_one?: Maybe<Conference_Conference>;
  /** insert data into the table: "conference.Configuration" */
  readonly insert_conference_Configuration?: Maybe<Conference_Configuration_Mutation_Response>;
  /** insert data into the table: "conference.ConfigurationKey" */
  readonly insert_conference_ConfigurationKey?: Maybe<Conference_ConfigurationKey_Mutation_Response>;
  /** insert a single row into the table: "conference.ConfigurationKey" */
  readonly insert_conference_ConfigurationKey_one?: Maybe<Conference_ConfigurationKey>;
  /** insert a single row into the table: "conference.Configuration" */
  readonly insert_conference_Configuration_one?: Maybe<Conference_Configuration>;
  /** insert data into the table: "conference.DemoCode" */
  readonly insert_conference_DemoCode?: Maybe<Conference_DemoCode_Mutation_Response>;
  /** insert a single row into the table: "conference.DemoCode" */
  readonly insert_conference_DemoCode_one?: Maybe<Conference_DemoCode>;
  /** insert data into the table: "conference.OriginatingData" */
  readonly insert_conference_OriginatingData?: Maybe<Conference_OriginatingData_Mutation_Response>;
  /** insert a single row into the table: "conference.OriginatingData" */
  readonly insert_conference_OriginatingData_one?: Maybe<Conference_OriginatingData>;
  /** insert data into the table: "conference.PrepareJob" */
  readonly insert_conference_PrepareJob?: Maybe<Conference_PrepareJob_Mutation_Response>;
  /** insert a single row into the table: "conference.PrepareJob" */
  readonly insert_conference_PrepareJob_one?: Maybe<Conference_PrepareJob>;
  /** insert data into the table: "content.Element" */
  readonly insert_content_Element?: Maybe<Content_Element_Mutation_Response>;
  /** insert data into the table: "content.ElementByPersonAccessToken" */
  readonly insert_content_ElementByPersonAccessToken?: Maybe<Content_ElementByPersonAccessToken_Mutation_Response>;
  /** insert a single row into the table: "content.ElementByPersonAccessToken" */
  readonly insert_content_ElementByPersonAccessToken_one?: Maybe<Content_ElementByPersonAccessToken>;
  /** insert data into the table: "content.ElementPermissionGrant" */
  readonly insert_content_ElementPermissionGrant?: Maybe<Content_ElementPermissionGrant_Mutation_Response>;
  /** insert a single row into the table: "content.ElementPermissionGrant" */
  readonly insert_content_ElementPermissionGrant_one?: Maybe<Content_ElementPermissionGrant>;
  /** insert data into the table: "content.ElementType" */
  readonly insert_content_ElementType?: Maybe<Content_ElementType_Mutation_Response>;
  /** insert a single row into the table: "content.ElementType" */
  readonly insert_content_ElementType_one?: Maybe<Content_ElementType>;
  /** insert a single row into the table: "content.Element" */
  readonly insert_content_Element_one?: Maybe<Content_Element>;
  /** insert data into the table: "content.Item" */
  readonly insert_content_Item?: Maybe<Content_Item_Mutation_Response>;
  /** insert data into the table: "content.ItemByPersonAccessToken" */
  readonly insert_content_ItemByPersonAccessToken?: Maybe<Content_ItemByPersonAccessToken_Mutation_Response>;
  /** insert a single row into the table: "content.ItemByPersonAccessToken" */
  readonly insert_content_ItemByPersonAccessToken_one?: Maybe<Content_ItemByPersonAccessToken>;
  /** insert data into the table: "content.ItemExhibition" */
  readonly insert_content_ItemExhibition?: Maybe<Content_ItemExhibition_Mutation_Response>;
  /** insert a single row into the table: "content.ItemExhibition" */
  readonly insert_content_ItemExhibition_one?: Maybe<Content_ItemExhibition>;
  /** insert data into the table: "content.ItemProgramPerson" */
  readonly insert_content_ItemProgramPerson?: Maybe<Content_ItemProgramPerson_Mutation_Response>;
  /** insert data into the table: "content.ItemProgramPersonByAccessToken" */
  readonly insert_content_ItemProgramPersonByAccessToken?: Maybe<Content_ItemProgramPersonByAccessToken_Mutation_Response>;
  /** insert a single row into the table: "content.ItemProgramPersonByAccessToken" */
  readonly insert_content_ItemProgramPersonByAccessToken_one?: Maybe<Content_ItemProgramPersonByAccessToken>;
  /** insert a single row into the table: "content.ItemProgramPerson" */
  readonly insert_content_ItemProgramPerson_one?: Maybe<Content_ItemProgramPerson>;
  /** insert data into the table: "content.ItemTag" */
  readonly insert_content_ItemTag?: Maybe<Content_ItemTag_Mutation_Response>;
  /** insert a single row into the table: "content.ItemTag" */
  readonly insert_content_ItemTag_one?: Maybe<Content_ItemTag>;
  /** insert data into the table: "content.ItemType" */
  readonly insert_content_ItemType?: Maybe<Content_ItemType_Mutation_Response>;
  /** insert a single row into the table: "content.ItemType" */
  readonly insert_content_ItemType_one?: Maybe<Content_ItemType>;
  /** insert a single row into the table: "content.Item" */
  readonly insert_content_Item_one?: Maybe<Content_Item>;
  /** insert data into the table: "content.Uploader" */
  readonly insert_content_Uploader?: Maybe<Content_Uploader_Mutation_Response>;
  /** insert a single row into the table: "content.Uploader" */
  readonly insert_content_Uploader_one?: Maybe<Content_Uploader>;
  /** insert data into the table: "job_queues.ChannelStackCreateJob" */
  readonly insert_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.ChannelStackCreateJob" */
  readonly insert_job_queues_ChannelStackCreateJob_one?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** insert data into the table: "job_queues.ChannelStackDeleteJob" */
  readonly insert_job_queues_ChannelStackDeleteJob?: Maybe<Job_Queues_ChannelStackDeleteJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.ChannelStackDeleteJob" */
  readonly insert_job_queues_ChannelStackDeleteJob_one?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** insert data into the table: "job_queues.ChannelStackUpdateJob" */
  readonly insert_job_queues_ChannelStackUpdateJob?: Maybe<Job_Queues_ChannelStackUpdateJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.ChannelStackUpdateJob" */
  readonly insert_job_queues_ChannelStackUpdateJob_one?: Maybe<Job_Queues_ChannelStackUpdateJob>;
  /** insert data into the table: "job_queues.CombineVideosJob" */
  readonly insert_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.CombineVideosJob" */
  readonly insert_job_queues_CombineVideosJob_one?: Maybe<Job_Queues_CombineVideosJob>;
  /** insert data into the table: "job_queues.CustomEmailJob" */
  readonly insert_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.CustomEmailJob" */
  readonly insert_job_queues_CustomEmailJob_one?: Maybe<Job_Queues_CustomEmailJob>;
  /** insert data into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob_one?: Maybe<Job_Queues_InvitationEmailJob>;
  /** insert data into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob_one?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** insert data into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob_one?: Maybe<Job_Queues_PublishVideoJob>;
  /** insert data into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob_one?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** insert data into the table: "job_queues.UploadYouTubeVideoJob" */
  readonly insert_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.UploadYouTubeVideoJob" */
  readonly insert_job_queues_UploadYouTubeVideoJob_one?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** insert data into the table: "permissions.Group" */
  readonly insert_permissions_Group?: Maybe<Permissions_Group_Mutation_Response>;
  /** insert data into the table: "permissions.GroupRegistrant" */
  readonly insert_permissions_GroupRegistrant?: Maybe<Permissions_GroupRegistrant_Mutation_Response>;
  /** insert a single row into the table: "permissions.GroupRegistrant" */
  readonly insert_permissions_GroupRegistrant_one?: Maybe<Permissions_GroupRegistrant>;
  /** insert data into the table: "permissions.GroupRole" */
  readonly insert_permissions_GroupRole?: Maybe<Permissions_GroupRole_Mutation_Response>;
  /** insert a single row into the table: "permissions.GroupRole" */
  readonly insert_permissions_GroupRole_one?: Maybe<Permissions_GroupRole>;
  /** insert a single row into the table: "permissions.Group" */
  readonly insert_permissions_Group_one?: Maybe<Permissions_Group>;
  /** insert data into the table: "permissions.Permission" */
  readonly insert_permissions_Permission?: Maybe<Permissions_Permission_Mutation_Response>;
  /** insert a single row into the table: "permissions.Permission" */
  readonly insert_permissions_Permission_one?: Maybe<Permissions_Permission>;
  /** insert data into the table: "permissions.Role" */
  readonly insert_permissions_Role?: Maybe<Permissions_Role_Mutation_Response>;
  /** insert data into the table: "permissions.RolePermission" */
  readonly insert_permissions_RolePermission?: Maybe<Permissions_RolePermission_Mutation_Response>;
  /** insert a single row into the table: "permissions.RolePermission" */
  readonly insert_permissions_RolePermission_one?: Maybe<Permissions_RolePermission>;
  /** insert a single row into the table: "permissions.Role" */
  readonly insert_permissions_Role_one?: Maybe<Permissions_Role>;
  /** insert data into the table: "registrant.GoogleAccount" */
  readonly insert_registrant_GoogleAccount?: Maybe<Registrant_GoogleAccount_Mutation_Response>;
  /** insert a single row into the table: "registrant.GoogleAccount" */
  readonly insert_registrant_GoogleAccount_one?: Maybe<Registrant_GoogleAccount>;
  /** insert data into the table: "registrant.Invitation" */
  readonly insert_registrant_Invitation?: Maybe<Registrant_Invitation_Mutation_Response>;
  /** insert a single row into the table: "registrant.Invitation" */
  readonly insert_registrant_Invitation_one?: Maybe<Registrant_Invitation>;
  /** insert data into the table: "registrant.Profile" */
  readonly insert_registrant_Profile?: Maybe<Registrant_Profile_Mutation_Response>;
  /** insert a single row into the table: "registrant.Profile" */
  readonly insert_registrant_Profile_one?: Maybe<Registrant_Profile>;
  /** insert data into the table: "registrant.Registrant" */
  readonly insert_registrant_Registrant?: Maybe<Registrant_Registrant_Mutation_Response>;
  /** insert a single row into the table: "registrant.Registrant" */
  readonly insert_registrant_Registrant_one?: Maybe<Registrant_Registrant>;
  /** insert data into the table: "registrant.SavedVonageRoomRecording" */
  readonly insert_registrant_SavedVonageRoomRecording?: Maybe<Registrant_SavedVonageRoomRecording_Mutation_Response>;
  /** insert a single row into the table: "registrant.SavedVonageRoomRecording" */
  readonly insert_registrant_SavedVonageRoomRecording_one?: Maybe<Registrant_SavedVonageRoomRecording>;
  /** insert data into the table: "room.Backend" */
  readonly insert_room_Backend?: Maybe<Room_Backend_Mutation_Response>;
  /** insert a single row into the table: "room.Backend" */
  readonly insert_room_Backend_one?: Maybe<Room_Backend>;
  /** insert data into the table: "room.ChimeMeeting" */
  readonly insert_room_ChimeMeeting?: Maybe<Room_ChimeMeeting_Mutation_Response>;
  /** insert a single row into the table: "room.ChimeMeeting" */
  readonly insert_room_ChimeMeeting_one?: Maybe<Room_ChimeMeeting>;
  /** insert data into the table: "room.ManagementMode" */
  readonly insert_room_ManagementMode?: Maybe<Room_ManagementMode_Mutation_Response>;
  /** insert a single row into the table: "room.ManagementMode" */
  readonly insert_room_ManagementMode_one?: Maybe<Room_ManagementMode>;
  /** insert data into the table: "room.Mode" */
  readonly insert_room_Mode?: Maybe<Room_Mode_Mutation_Response>;
  /** insert a single row into the table: "room.Mode" */
  readonly insert_room_Mode_one?: Maybe<Room_Mode>;
  /** insert data into the table: "room.Participant" */
  readonly insert_room_Participant?: Maybe<Room_Participant_Mutation_Response>;
  /** insert a single row into the table: "room.Participant" */
  readonly insert_room_Participant_one?: Maybe<Room_Participant>;
  /** insert data into the table: "room.PersonRole" */
  readonly insert_room_PersonRole?: Maybe<Room_PersonRole_Mutation_Response>;
  /** insert a single row into the table: "room.PersonRole" */
  readonly insert_room_PersonRole_one?: Maybe<Room_PersonRole>;
  /** insert data into the table: "room.Room" */
  readonly insert_room_Room?: Maybe<Room_Room_Mutation_Response>;
  /** insert data into the table: "room.RoomPerson" */
  readonly insert_room_RoomPerson?: Maybe<Room_RoomPerson_Mutation_Response>;
  /** insert a single row into the table: "room.RoomPerson" */
  readonly insert_room_RoomPerson_one?: Maybe<Room_RoomPerson>;
  /** insert a single row into the table: "room.Room" */
  readonly insert_room_Room_one?: Maybe<Room_Room>;
  /** insert data into the table: "room.ShuffleAlgorithm" */
  readonly insert_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleAlgorithm" */
  readonly insert_room_ShuffleAlgorithm_one?: Maybe<Room_ShuffleAlgorithm>;
  /** insert data into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** insert a single row into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod_one?: Maybe<Room_ShufflePeriod>;
  /** insert data into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry_one?: Maybe<Room_ShuffleQueueEntry>;
  /** insert data into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom_one?: Maybe<Room_ShuffleRoom>;
  /** insert data into the table: "schedule.Continuation" */
  readonly insert_schedule_Continuation?: Maybe<Schedule_Continuation_Mutation_Response>;
  /** insert a single row into the table: "schedule.Continuation" */
  readonly insert_schedule_Continuation_one?: Maybe<Schedule_Continuation>;
  /** insert data into the table: "schedule.Event" */
  readonly insert_schedule_Event?: Maybe<Schedule_Event_Mutation_Response>;
  /** insert data into the table: "schedule.EventProgramPerson" */
  readonly insert_schedule_EventProgramPerson?: Maybe<Schedule_EventProgramPerson_Mutation_Response>;
  /** insert data into the table: "schedule.EventProgramPersonRole" */
  readonly insert_schedule_EventProgramPersonRole?: Maybe<Schedule_EventProgramPersonRole_Mutation_Response>;
  /** insert a single row into the table: "schedule.EventProgramPersonRole" */
  readonly insert_schedule_EventProgramPersonRole_one?: Maybe<Schedule_EventProgramPersonRole>;
  /** insert a single row into the table: "schedule.EventProgramPerson" */
  readonly insert_schedule_EventProgramPerson_one?: Maybe<Schedule_EventProgramPerson>;
  /** insert data into the table: "schedule.EventTag" */
  readonly insert_schedule_EventTag?: Maybe<Schedule_EventTag_Mutation_Response>;
  /** insert a single row into the table: "schedule.EventTag" */
  readonly insert_schedule_EventTag_one?: Maybe<Schedule_EventTag>;
  /** insert a single row into the table: "schedule.Event" */
  readonly insert_schedule_Event_one?: Maybe<Schedule_Event>;
  /** insert data into the table: "schedule.StarredEvent" */
  readonly insert_schedule_StarredEvent?: Maybe<Schedule_StarredEvent_Mutation_Response>;
  /** insert a single row into the table: "schedule.StarredEvent" */
  readonly insert_schedule_StarredEvent_one?: Maybe<Schedule_StarredEvent>;
  /** insert data into the table: "system.Configuration" */
  readonly insert_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** insert data into the table: "system.ConfigurationKey" */
  readonly insert_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** insert a single row into the table: "system.ConfigurationKey" */
  readonly insert_system_ConfigurationKey_one?: Maybe<System_ConfigurationKey>;
  /** insert a single row into the table: "system.Configuration" */
  readonly insert_system_Configuration_one?: Maybe<System_Configuration>;
  /** insert data into the table: "video.ChannelStack" */
  readonly insert_video_ChannelStack?: Maybe<Video_ChannelStack_Mutation_Response>;
  /** insert data into the table: "video.ChannelStackWithStreamKey" */
  readonly insert_video_ChannelStackWithStreamKey?: Maybe<Video_ChannelStackWithStreamKey_Mutation_Response>;
  /** insert a single row into the table: "video.ChannelStackWithStreamKey" */
  readonly insert_video_ChannelStackWithStreamKey_one?: Maybe<Video_ChannelStackWithStreamKey>;
  /** insert a single row into the table: "video.ChannelStack" */
  readonly insert_video_ChannelStack_one?: Maybe<Video_ChannelStack>;
  /** insert data into the table: "video.EventParticipantStream" */
  readonly insert_video_EventParticipantStream?: Maybe<Video_EventParticipantStream_Mutation_Response>;
  /** insert a single row into the table: "video.EventParticipantStream" */
  readonly insert_video_EventParticipantStream_one?: Maybe<Video_EventParticipantStream>;
  /** insert data into the table: "video.EventVonageSession" */
  readonly insert_video_EventVonageSession?: Maybe<Video_EventVonageSession_Mutation_Response>;
  /** insert a single row into the table: "video.EventVonageSession" */
  readonly insert_video_EventVonageSession_one?: Maybe<Video_EventVonageSession>;
  /** insert data into the table: "video.ImmediateSwitch" */
  readonly insert_video_ImmediateSwitch?: Maybe<Video_ImmediateSwitch_Mutation_Response>;
  /** insert a single row into the table: "video.ImmediateSwitch" */
  readonly insert_video_ImmediateSwitch_one?: Maybe<Video_ImmediateSwitch>;
  /** insert data into the table: "video.InputType" */
  readonly insert_video_InputType?: Maybe<Video_InputType_Mutation_Response>;
  /** insert a single row into the table: "video.InputType" */
  readonly insert_video_InputType_one?: Maybe<Video_InputType>;
  /** insert data into the table: "video.JobStatus" */
  readonly insert_video_JobStatus?: Maybe<Video_JobStatus_Mutation_Response>;
  /** insert a single row into the table: "video.JobStatus" */
  readonly insert_video_JobStatus_one?: Maybe<Video_JobStatus>;
  /** insert data into the table: "video.MediaLiveChannelStatus" */
  readonly insert_video_MediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Mutation_Response>;
  /** insert a single row into the table: "video.MediaLiveChannelStatus" */
  readonly insert_video_MediaLiveChannelStatus_one?: Maybe<Video_MediaLiveChannelStatus>;
  /** insert data into the table: "video.RoomRtmpOutput" */
  readonly insert_video_RoomRtmpOutput?: Maybe<Video_RoomRtmpOutput_Mutation_Response>;
  /** insert a single row into the table: "video.RoomRtmpOutput" */
  readonly insert_video_RoomRtmpOutput_one?: Maybe<Video_RoomRtmpOutput>;
  /** insert data into the table: "video.RtmpInput" */
  readonly insert_video_RtmpInput?: Maybe<Video_RtmpInput_Mutation_Response>;
  /** insert a single row into the table: "video.RtmpInput" */
  readonly insert_video_RtmpInput_one?: Maybe<Video_RtmpInput>;
  /** insert data into the table: "video.TranscriptionJob" */
  readonly insert_video_TranscriptionJob?: Maybe<Video_TranscriptionJob_Mutation_Response>;
  /** insert a single row into the table: "video.TranscriptionJob" */
  readonly insert_video_TranscriptionJob_one?: Maybe<Video_TranscriptionJob>;
  /** insert data into the table: "video.VideoRenderJob" */
  readonly insert_video_VideoRenderJob?: Maybe<Video_VideoRenderJob_Mutation_Response>;
  /** insert a single row into the table: "video.VideoRenderJob" */
  readonly insert_video_VideoRenderJob_one?: Maybe<Video_VideoRenderJob>;
  /** insert data into the table: "video.VonageRoomRecording" */
  readonly insert_video_VonageRoomRecording?: Maybe<Video_VonageRoomRecording_Mutation_Response>;
  /** insert a single row into the table: "video.VonageRoomRecording" */
  readonly insert_video_VonageRoomRecording_one?: Maybe<Video_VonageRoomRecording>;
  /** insert data into the table: "video.YouTubeUpload" */
  readonly insert_video_YouTubeUpload?: Maybe<Video_YouTubeUpload_Mutation_Response>;
  /** insert a single row into the table: "video.YouTubeUpload" */
  readonly insert_video_YouTubeUpload_one?: Maybe<Video_YouTubeUpload>;
  readonly invitationConfirmCurrent?: Maybe<ConfirmInvitationOutput>;
  readonly joinEventVonageSession?: Maybe<JoinEventVonageSessionOutput>;
  readonly joinRoomChimeSession?: Maybe<JoinRoomChimeSessionOutput>;
  readonly joinRoomVonageSession?: Maybe<JoinRoomVonageSessionOutput>;
  readonly notifyEventEnded: NotifyEventEnded;
  readonly presence_Flush: PresenceFlushOutput;
  readonly refreshYouTubeData?: Maybe<RefreshYouTubeDataOutput>;
  readonly stopEventBroadcast?: Maybe<StopEventBroadcastOutput>;
  readonly submitGoogleOAuthCode?: Maybe<SubmitGoogleOAuthCodeOutput>;
  readonly submitUploadableElement?: Maybe<SubmitUploadableElementOutput>;
  readonly toggleVonageRecordingState?: Maybe<ToggleVonageRecordingStateOutput>;
  readonly updateProfilePhoto?: Maybe<UpdateProfilePhotoResponse>;
  readonly updateSubtitles?: Maybe<SubmitUpdatedSubtitlesOutput>;
  /** update data of the table: "Email" */
  readonly update_Email?: Maybe<Email_Mutation_Response>;
  /** update single row of the table: "Email" */
  readonly update_Email_by_pk?: Maybe<Email>;
  /** update data of the table: "PushNotificationSubscription" */
  readonly update_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** update single row of the table: "PushNotificationSubscription" */
  readonly update_PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** update data of the table: "User" */
  readonly update_User?: Maybe<User_Mutation_Response>;
  /** update single row of the table: "User" */
  readonly update_User_by_pk?: Maybe<User>;
  /** update data of the table: "analytics.AppStats" */
  readonly update_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** update single row of the table: "analytics.AppStats" */
  readonly update_analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** update data of the table: "analytics.ContentElementStats" */
  readonly update_analytics_ContentElementStats?: Maybe<Analytics_ContentElementStats_Mutation_Response>;
  /** update single row of the table: "analytics.ContentElementStats" */
  readonly update_analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** update data of the table: "analytics.ContentItemStats" */
  readonly update_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** update single row of the table: "analytics.ContentItemStats" */
  readonly update_analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** update data of the table: "analytics.RoomStats" */
  readonly update_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** update single row of the table: "analytics.RoomStats" */
  readonly update_analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** update data of the table: "analytics.mat_ElementTotalViews" */
  readonly update_analytics_mat_ElementTotalViews?: Maybe<Analytics_Mat_ElementTotalViews_Mutation_Response>;
  /** update data of the table: "analytics.mat_ItemTotalViews" */
  readonly update_analytics_mat_ItemTotalViews?: Maybe<Analytics_Mat_ItemTotalViews_Mutation_Response>;
  /** update data of the table: "analytics.mat_RoomPresence" */
  readonly update_analytics_mat_RoomPresence?: Maybe<Analytics_Mat_RoomPresence_Mutation_Response>;
  /** update data of the table: "chat.Chat" */
  readonly update_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** update single row of the table: "chat.Chat" */
  readonly update_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** update data of the table: "chat.Flag" */
  readonly update_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** update data of the table: "chat.FlagType" */
  readonly update_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** update single row of the table: "chat.FlagType" */
  readonly update_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** update single row of the table: "chat.Flag" */
  readonly update_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** update data of the table: "chat.Message" */
  readonly update_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** update data of the table: "chat.MessageType" */
  readonly update_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** update single row of the table: "chat.MessageType" */
  readonly update_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** update single row of the table: "chat.Message" */
  readonly update_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** update data of the table: "chat.Pin" */
  readonly update_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** update single row of the table: "chat.Pin" */
  readonly update_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** update data of the table: "chat.Reaction" */
  readonly update_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** update data of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** update single row of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** update single row of the table: "chat.Reaction" */
  readonly update_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** update data of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** update single row of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** update data of the table: "chat.Subscription" */
  readonly update_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** update single row of the table: "chat.Subscription" */
  readonly update_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** update data of the table: "collection.Exhibition" */
  readonly update_collection_Exhibition?: Maybe<Collection_Exhibition_Mutation_Response>;
  /** update single row of the table: "collection.Exhibition" */
  readonly update_collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** update data of the table: "collection.ProgramPerson" */
  readonly update_collection_ProgramPerson?: Maybe<Collection_ProgramPerson_Mutation_Response>;
  /** update data of the table: "collection.ProgramPersonByAccessToken" */
  readonly update_collection_ProgramPersonByAccessToken?: Maybe<Collection_ProgramPersonByAccessToken_Mutation_Response>;
  /** update data of the table: "collection.ProgramPersonWithAccessToken" */
  readonly update_collection_ProgramPersonWithAccessToken?: Maybe<Collection_ProgramPersonWithAccessToken_Mutation_Response>;
  /** update single row of the table: "collection.ProgramPerson" */
  readonly update_collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** update data of the table: "collection.Tag" */
  readonly update_collection_Tag?: Maybe<Collection_Tag_Mutation_Response>;
  /** update single row of the table: "collection.Tag" */
  readonly update_collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** update data of the table: "conference.Conference" */
  readonly update_conference_Conference?: Maybe<Conference_Conference_Mutation_Response>;
  /** update single row of the table: "conference.Conference" */
  readonly update_conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** update data of the table: "conference.Configuration" */
  readonly update_conference_Configuration?: Maybe<Conference_Configuration_Mutation_Response>;
  /** update data of the table: "conference.ConfigurationKey" */
  readonly update_conference_ConfigurationKey?: Maybe<Conference_ConfigurationKey_Mutation_Response>;
  /** update single row of the table: "conference.ConfigurationKey" */
  readonly update_conference_ConfigurationKey_by_pk?: Maybe<Conference_ConfigurationKey>;
  /** update single row of the table: "conference.Configuration" */
  readonly update_conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** update data of the table: "conference.DemoCode" */
  readonly update_conference_DemoCode?: Maybe<Conference_DemoCode_Mutation_Response>;
  /** update single row of the table: "conference.DemoCode" */
  readonly update_conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** update data of the table: "conference.OriginatingData" */
  readonly update_conference_OriginatingData?: Maybe<Conference_OriginatingData_Mutation_Response>;
  /** update single row of the table: "conference.OriginatingData" */
  readonly update_conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** update data of the table: "conference.PrepareJob" */
  readonly update_conference_PrepareJob?: Maybe<Conference_PrepareJob_Mutation_Response>;
  /** update single row of the table: "conference.PrepareJob" */
  readonly update_conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** update data of the table: "content.Element" */
  readonly update_content_Element?: Maybe<Content_Element_Mutation_Response>;
  /** update data of the table: "content.ElementByPersonAccessToken" */
  readonly update_content_ElementByPersonAccessToken?: Maybe<Content_ElementByPersonAccessToken_Mutation_Response>;
  /** update data of the table: "content.ElementPermissionGrant" */
  readonly update_content_ElementPermissionGrant?: Maybe<Content_ElementPermissionGrant_Mutation_Response>;
  /** update single row of the table: "content.ElementPermissionGrant" */
  readonly update_content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** update data of the table: "content.ElementType" */
  readonly update_content_ElementType?: Maybe<Content_ElementType_Mutation_Response>;
  /** update single row of the table: "content.ElementType" */
  readonly update_content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** update single row of the table: "content.Element" */
  readonly update_content_Element_by_pk?: Maybe<Content_Element>;
  /** update data of the table: "content.Item" */
  readonly update_content_Item?: Maybe<Content_Item_Mutation_Response>;
  /** update data of the table: "content.ItemByPersonAccessToken" */
  readonly update_content_ItemByPersonAccessToken?: Maybe<Content_ItemByPersonAccessToken_Mutation_Response>;
  /** update data of the table: "content.ItemExhibition" */
  readonly update_content_ItemExhibition?: Maybe<Content_ItemExhibition_Mutation_Response>;
  /** update single row of the table: "content.ItemExhibition" */
  readonly update_content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** update data of the table: "content.ItemProgramPerson" */
  readonly update_content_ItemProgramPerson?: Maybe<Content_ItemProgramPerson_Mutation_Response>;
  /** update data of the table: "content.ItemProgramPersonByAccessToken" */
  readonly update_content_ItemProgramPersonByAccessToken?: Maybe<Content_ItemProgramPersonByAccessToken_Mutation_Response>;
  /** update single row of the table: "content.ItemProgramPerson" */
  readonly update_content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** update data of the table: "content.ItemTag" */
  readonly update_content_ItemTag?: Maybe<Content_ItemTag_Mutation_Response>;
  /** update single row of the table: "content.ItemTag" */
  readonly update_content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** update data of the table: "content.ItemType" */
  readonly update_content_ItemType?: Maybe<Content_ItemType_Mutation_Response>;
  /** update single row of the table: "content.ItemType" */
  readonly update_content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** update single row of the table: "content.Item" */
  readonly update_content_Item_by_pk?: Maybe<Content_Item>;
  /** update data of the table: "content.Uploader" */
  readonly update_content_Uploader?: Maybe<Content_Uploader_Mutation_Response>;
  /** update single row of the table: "content.Uploader" */
  readonly update_content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** update data of the table: "job_queues.ChannelStackCreateJob" */
  readonly update_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** update single row of the table: "job_queues.ChannelStackCreateJob" */
  readonly update_job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** update data of the table: "job_queues.ChannelStackDeleteJob" */
  readonly update_job_queues_ChannelStackDeleteJob?: Maybe<Job_Queues_ChannelStackDeleteJob_Mutation_Response>;
  /** update single row of the table: "job_queues.ChannelStackDeleteJob" */
  readonly update_job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** update data of the table: "job_queues.ChannelStackUpdateJob" */
  readonly update_job_queues_ChannelStackUpdateJob?: Maybe<Job_Queues_ChannelStackUpdateJob_Mutation_Response>;
  /** update single row of the table: "job_queues.ChannelStackUpdateJob" */
  readonly update_job_queues_ChannelStackUpdateJob_by_pk?: Maybe<Job_Queues_ChannelStackUpdateJob>;
  /** update data of the table: "job_queues.CombineVideosJob" */
  readonly update_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** update single row of the table: "job_queues.CombineVideosJob" */
  readonly update_job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** update data of the table: "job_queues.CustomEmailJob" */
  readonly update_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.CustomEmailJob" */
  readonly update_job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** update data of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** update data of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** update single row of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** update data of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** update single row of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** update data of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** update data of the table: "job_queues.UploadYouTubeVideoJob" */
  readonly update_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** update single row of the table: "job_queues.UploadYouTubeVideoJob" */
  readonly update_job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** update data of the table: "permissions.Group" */
  readonly update_permissions_Group?: Maybe<Permissions_Group_Mutation_Response>;
  /** update data of the table: "permissions.GroupRegistrant" */
  readonly update_permissions_GroupRegistrant?: Maybe<Permissions_GroupRegistrant_Mutation_Response>;
  /** update single row of the table: "permissions.GroupRegistrant" */
  readonly update_permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** update data of the table: "permissions.GroupRole" */
  readonly update_permissions_GroupRole?: Maybe<Permissions_GroupRole_Mutation_Response>;
  /** update single row of the table: "permissions.GroupRole" */
  readonly update_permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** update single row of the table: "permissions.Group" */
  readonly update_permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** update data of the table: "permissions.Permission" */
  readonly update_permissions_Permission?: Maybe<Permissions_Permission_Mutation_Response>;
  /** update single row of the table: "permissions.Permission" */
  readonly update_permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** update data of the table: "permissions.Role" */
  readonly update_permissions_Role?: Maybe<Permissions_Role_Mutation_Response>;
  /** update data of the table: "permissions.RolePermission" */
  readonly update_permissions_RolePermission?: Maybe<Permissions_RolePermission_Mutation_Response>;
  /** update single row of the table: "permissions.RolePermission" */
  readonly update_permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** update single row of the table: "permissions.Role" */
  readonly update_permissions_Role_by_pk?: Maybe<Permissions_Role>;
  /** update data of the table: "registrant.GoogleAccount" */
  readonly update_registrant_GoogleAccount?: Maybe<Registrant_GoogleAccount_Mutation_Response>;
  /** update single row of the table: "registrant.GoogleAccount" */
  readonly update_registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** update data of the table: "registrant.Invitation" */
  readonly update_registrant_Invitation?: Maybe<Registrant_Invitation_Mutation_Response>;
  /** update single row of the table: "registrant.Invitation" */
  readonly update_registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** update data of the table: "registrant.Profile" */
  readonly update_registrant_Profile?: Maybe<Registrant_Profile_Mutation_Response>;
  /** update single row of the table: "registrant.Profile" */
  readonly update_registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** update data of the table: "registrant.Registrant" */
  readonly update_registrant_Registrant?: Maybe<Registrant_Registrant_Mutation_Response>;
  /** update single row of the table: "registrant.Registrant" */
  readonly update_registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** update data of the table: "registrant.SavedVonageRoomRecording" */
  readonly update_registrant_SavedVonageRoomRecording?: Maybe<Registrant_SavedVonageRoomRecording_Mutation_Response>;
  /** update single row of the table: "registrant.SavedVonageRoomRecording" */
  readonly update_registrant_SavedVonageRoomRecording_by_pk?: Maybe<Registrant_SavedVonageRoomRecording>;
  /** update data of the table: "room.Backend" */
  readonly update_room_Backend?: Maybe<Room_Backend_Mutation_Response>;
  /** update single row of the table: "room.Backend" */
  readonly update_room_Backend_by_pk?: Maybe<Room_Backend>;
  /** update data of the table: "room.ChimeMeeting" */
  readonly update_room_ChimeMeeting?: Maybe<Room_ChimeMeeting_Mutation_Response>;
  /** update single row of the table: "room.ChimeMeeting" */
  readonly update_room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** update data of the table: "room.ManagementMode" */
  readonly update_room_ManagementMode?: Maybe<Room_ManagementMode_Mutation_Response>;
  /** update single row of the table: "room.ManagementMode" */
  readonly update_room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** update data of the table: "room.Mode" */
  readonly update_room_Mode?: Maybe<Room_Mode_Mutation_Response>;
  /** update single row of the table: "room.Mode" */
  readonly update_room_Mode_by_pk?: Maybe<Room_Mode>;
  /** update data of the table: "room.Participant" */
  readonly update_room_Participant?: Maybe<Room_Participant_Mutation_Response>;
  /** update single row of the table: "room.Participant" */
  readonly update_room_Participant_by_pk?: Maybe<Room_Participant>;
  /** update data of the table: "room.PersonRole" */
  readonly update_room_PersonRole?: Maybe<Room_PersonRole_Mutation_Response>;
  /** update single row of the table: "room.PersonRole" */
  readonly update_room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** update data of the table: "room.Room" */
  readonly update_room_Room?: Maybe<Room_Room_Mutation_Response>;
  /** update data of the table: "room.RoomPerson" */
  readonly update_room_RoomPerson?: Maybe<Room_RoomPerson_Mutation_Response>;
  /** update single row of the table: "room.RoomPerson" */
  readonly update_room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** update single row of the table: "room.Room" */
  readonly update_room_Room_by_pk?: Maybe<Room_Room>;
  /** update data of the table: "room.ShuffleAlgorithm" */
  readonly update_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** update single row of the table: "room.ShuffleAlgorithm" */
  readonly update_room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** update data of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** update single row of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** update data of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** update single row of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** update data of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** update single row of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** update data of the table: "schedule.Continuation" */
  readonly update_schedule_Continuation?: Maybe<Schedule_Continuation_Mutation_Response>;
  /** update single row of the table: "schedule.Continuation" */
  readonly update_schedule_Continuation_by_pk?: Maybe<Schedule_Continuation>;
  /** update data of the table: "schedule.Event" */
  readonly update_schedule_Event?: Maybe<Schedule_Event_Mutation_Response>;
  /** update data of the table: "schedule.EventProgramPerson" */
  readonly update_schedule_EventProgramPerson?: Maybe<Schedule_EventProgramPerson_Mutation_Response>;
  /** update data of the table: "schedule.EventProgramPersonRole" */
  readonly update_schedule_EventProgramPersonRole?: Maybe<Schedule_EventProgramPersonRole_Mutation_Response>;
  /** update single row of the table: "schedule.EventProgramPersonRole" */
  readonly update_schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** update single row of the table: "schedule.EventProgramPerson" */
  readonly update_schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** update data of the table: "schedule.EventTag" */
  readonly update_schedule_EventTag?: Maybe<Schedule_EventTag_Mutation_Response>;
  /** update single row of the table: "schedule.EventTag" */
  readonly update_schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** update single row of the table: "schedule.Event" */
  readonly update_schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** update data of the table: "schedule.StarredEvent" */
  readonly update_schedule_StarredEvent?: Maybe<Schedule_StarredEvent_Mutation_Response>;
  /** update single row of the table: "schedule.StarredEvent" */
  readonly update_schedule_StarredEvent_by_pk?: Maybe<Schedule_StarredEvent>;
  /** update data of the table: "system.Configuration" */
  readonly update_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** update data of the table: "system.ConfigurationKey" */
  readonly update_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** update single row of the table: "system.ConfigurationKey" */
  readonly update_system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** update single row of the table: "system.Configuration" */
  readonly update_system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** update data of the table: "video.ChannelStack" */
  readonly update_video_ChannelStack?: Maybe<Video_ChannelStack_Mutation_Response>;
  /** update data of the table: "video.ChannelStackWithStreamKey" */
  readonly update_video_ChannelStackWithStreamKey?: Maybe<Video_ChannelStackWithStreamKey_Mutation_Response>;
  /** update single row of the table: "video.ChannelStack" */
  readonly update_video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** update data of the table: "video.EventParticipantStream" */
  readonly update_video_EventParticipantStream?: Maybe<Video_EventParticipantStream_Mutation_Response>;
  /** update single row of the table: "video.EventParticipantStream" */
  readonly update_video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** update data of the table: "video.EventVonageSession" */
  readonly update_video_EventVonageSession?: Maybe<Video_EventVonageSession_Mutation_Response>;
  /** update single row of the table: "video.EventVonageSession" */
  readonly update_video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** update data of the table: "video.ImmediateSwitch" */
  readonly update_video_ImmediateSwitch?: Maybe<Video_ImmediateSwitch_Mutation_Response>;
  /** update single row of the table: "video.ImmediateSwitch" */
  readonly update_video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** update data of the table: "video.InputType" */
  readonly update_video_InputType?: Maybe<Video_InputType_Mutation_Response>;
  /** update single row of the table: "video.InputType" */
  readonly update_video_InputType_by_pk?: Maybe<Video_InputType>;
  /** update data of the table: "video.JobStatus" */
  readonly update_video_JobStatus?: Maybe<Video_JobStatus_Mutation_Response>;
  /** update single row of the table: "video.JobStatus" */
  readonly update_video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** update data of the table: "video.MediaLiveChannelStatus" */
  readonly update_video_MediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Mutation_Response>;
  /** update single row of the table: "video.MediaLiveChannelStatus" */
  readonly update_video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** update data of the table: "video.RoomRtmpOutput" */
  readonly update_video_RoomRtmpOutput?: Maybe<Video_RoomRtmpOutput_Mutation_Response>;
  /** update single row of the table: "video.RoomRtmpOutput" */
  readonly update_video_RoomRtmpOutput_by_pk?: Maybe<Video_RoomRtmpOutput>;
  /** update data of the table: "video.RtmpInput" */
  readonly update_video_RtmpInput?: Maybe<Video_RtmpInput_Mutation_Response>;
  /** update single row of the table: "video.RtmpInput" */
  readonly update_video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** update data of the table: "video.TranscriptionJob" */
  readonly update_video_TranscriptionJob?: Maybe<Video_TranscriptionJob_Mutation_Response>;
  /** update single row of the table: "video.TranscriptionJob" */
  readonly update_video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** update data of the table: "video.VideoRenderJob" */
  readonly update_video_VideoRenderJob?: Maybe<Video_VideoRenderJob_Mutation_Response>;
  /** update single row of the table: "video.VideoRenderJob" */
  readonly update_video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** update data of the table: "video.VonageRoomRecording" */
  readonly update_video_VonageRoomRecording?: Maybe<Video_VonageRoomRecording_Mutation_Response>;
  /** update single row of the table: "video.VonageRoomRecording" */
  readonly update_video_VonageRoomRecording_by_pk?: Maybe<Video_VonageRoomRecording>;
  /** update data of the table: "video.YouTubeUpload" */
  readonly update_video_YouTubeUpload?: Maybe<Video_YouTubeUpload_Mutation_Response>;
  /** update single row of the table: "video.YouTubeUpload" */
  readonly update_video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
};


/** mutation root */
export type Mutation_RootCreateItemRoomArgs = {
  conferenceId: Scalars['uuid'];
  itemId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCreateRoomDmArgs = {
  conferenceId: Scalars['uuid'];
  registrantIds: ReadonlyArray<Maybe<Scalars['uuid']>>;
};


/** mutation root */
export type Mutation_RootDelete_EmailArgs = {
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Email_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_PushNotificationSubscriptionArgs = {
  where: PushNotificationSubscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_UserArgs = {
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_By_PkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_AppStatsArgs = {
  where: Analytics_AppStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentElementStatsArgs = {
  where: Analytics_ContentElementStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentElementStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentItemStatsArgs = {
  where: Analytics_ContentItemStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentItemStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_RoomStatsArgs = {
  where: Analytics_RoomStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_RoomStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_Mat_ElementTotalViewsArgs = {
  where: Analytics_Mat_ElementTotalViews_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_Mat_ItemTotalViewsArgs = {
  where: Analytics_Mat_ItemTotalViews_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_Mat_RoomPresenceArgs = {
  where: Analytics_Mat_RoomPresence_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ChatArgs = {
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagArgs = {
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagTypeArgs = {
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageArgs = {
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageTypeArgs = {
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_PinArgs = {
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Pin_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionArgs = {
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionTypeArgs = {
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndexArgs = {
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndex_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_SubscriptionArgs = {
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Subscription_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Collection_ExhibitionArgs = {
  where: Collection_Exhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_Exhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Collection_ProgramPersonArgs = {
  where: Collection_ProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_ProgramPersonByAccessTokenArgs = {
  where: Collection_ProgramPersonByAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_ProgramPersonWithAccessTokenArgs = {
  where: Collection_ProgramPersonWithAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_ProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Collection_TagArgs = {
  where: Collection_Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_ConferenceArgs = {
  where: Conference_Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_ConfigurationArgs = {
  where: Conference_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_ConfigurationKeyArgs = {
  where: Conference_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_Configuration_By_PkArgs = {
  conferenceId: Scalars['uuid'];
  key: Conference_ConfigurationKey_Enum;
};


/** mutation root */
export type Mutation_RootDelete_Conference_DemoCodeArgs = {
  where: Conference_DemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_DemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_OriginatingDataArgs = {
  where: Conference_OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_PrepareJobArgs = {
  where: Conference_PrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_PrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementArgs = {
  where: Content_Element_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementByPersonAccessTokenArgs = {
  where: Content_ElementByPersonAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementPermissionGrantArgs = {
  where: Content_ElementPermissionGrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementTypeArgs = {
  where: Content_ElementType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Content_Element_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemArgs = {
  where: Content_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemByPersonAccessTokenArgs = {
  where: Content_ItemByPersonAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemExhibitionArgs = {
  where: Content_ItemExhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemExhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemProgramPersonArgs = {
  where: Content_ItemProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemProgramPersonByAccessTokenArgs = {
  where: Content_ItemProgramPersonByAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemTagArgs = {
  where: Content_ItemTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemTypeArgs = {
  where: Content_ItemType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Content_Item_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_UploaderArgs = {
  where: Content_Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackCreateJobArgs = {
  where: Job_Queues_ChannelStackCreateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackDeleteJobArgs = {
  where: Job_Queues_ChannelStackDeleteJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackDeleteJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackUpdateJobArgs = {
  where: Job_Queues_ChannelStackUpdateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackUpdateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CombineVideosJobArgs = {
  where: Job_Queues_CombineVideosJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CustomEmailJobArgs = {
  where: Job_Queues_CustomEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJobArgs = {
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJobArgs = {
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJobArgs = {
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJobArgs = {
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_UploadYouTubeVideoJobArgs = {
  where: Job_Queues_UploadYouTubeVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupArgs = {
  where: Permissions_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRegistrantArgs = {
  where: Permissions_GroupRegistrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRegistrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRoleArgs = {
  where: Permissions_GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_PermissionArgs = {
  where: Permissions_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_Permission_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_RoleArgs = {
  where: Permissions_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_RolePermissionArgs = {
  where: Permissions_RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_GoogleAccountArgs = {
  where: Registrant_GoogleAccount_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_GoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_InvitationArgs = {
  where: Registrant_Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_ProfileArgs = {
  where: Registrant_Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_Profile_By_PkArgs = {
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_RegistrantArgs = {
  where: Registrant_Registrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_Registrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_SavedVonageRoomRecordingArgs = {
  where: Registrant_SavedVonageRoomRecording_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_SavedVonageRoomRecording_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_BackendArgs = {
  where: Room_Backend_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_Backend_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ChimeMeetingArgs = {
  where: Room_ChimeMeeting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ManagementModeArgs = {
  where: Room_ManagementMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ManagementMode_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ModeArgs = {
  where: Room_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_Mode_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ParticipantArgs = {
  where: Room_Participant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_PersonRoleArgs = {
  where: Room_PersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_PersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomArgs = {
  where: Room_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomPersonArgs = {
  where: Room_RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleAlgorithmArgs = {
  where: Room_ShuffleAlgorithm_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriodArgs = {
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntryArgs = {
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoomArgs = {
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_ContinuationArgs = {
  where: Schedule_Continuation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_Continuation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventArgs = {
  where: Schedule_Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPersonArgs = {
  where: Schedule_EventProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPersonRoleArgs = {
  where: Schedule_EventProgramPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventTagArgs = {
  where: Schedule_EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_StarredEventArgs = {
  where: Schedule_StarredEvent_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_StarredEvent_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationArgs = {
  where: System_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationKeyArgs = {
  where: System_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_System_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};


/** mutation root */
export type Mutation_RootDelete_Video_ChannelStackArgs = {
  where: Video_ChannelStack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_ChannelStackWithStreamKeyArgs = {
  where: Video_ChannelStackWithStreamKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_ChannelStack_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_EventParticipantStreamArgs = {
  where: Video_EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_EventVonageSessionArgs = {
  where: Video_EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_ImmediateSwitchArgs = {
  where: Video_ImmediateSwitch_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_ImmediateSwitch_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_InputTypeArgs = {
  where: Video_InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_InputType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Video_JobStatusArgs = {
  where: Video_JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Video_MediaLiveChannelStatusArgs = {
  where: Video_MediaLiveChannelStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_MediaLiveChannelStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_RoomRtmpOutputArgs = {
  where: Video_RoomRtmpOutput_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_RoomRtmpOutput_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_RtmpInputArgs = {
  where: Video_RtmpInput_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_RtmpInput_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Video_TranscriptionJobArgs = {
  where: Video_TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_VideoRenderJobArgs = {
  where: Video_VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_VonageRoomRecordingArgs = {
  where: Video_VonageRoomRecording_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_VonageRoomRecording_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_YouTubeUploadArgs = {
  where: Video_YouTubeUpload_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_YouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootGetGoogleOAuthUrlArgs = {
  registrantId: Scalars['uuid'];
  scopes: ReadonlyArray<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootInsert_EmailArgs = {
  objects: ReadonlyArray<Email_Insert_Input>;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Email_OneArgs = {
  object: Email_Insert_Input;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PushNotificationSubscriptionArgs = {
  objects: ReadonlyArray<PushNotificationSubscription_Insert_Input>;
  on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PushNotificationSubscription_OneArgs = {
  object: PushNotificationSubscription_Insert_Input;
  on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserArgs = {
  objects: ReadonlyArray<User_Insert_Input>;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OneArgs = {
  object: User_Insert_Input;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_AppStatsArgs = {
  objects: ReadonlyArray<Analytics_AppStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_AppStats_OneArgs = {
  object: Analytics_AppStats_Insert_Input;
  on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentElementStatsArgs = {
  objects: ReadonlyArray<Analytics_ContentElementStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_ContentElementStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentElementStats_OneArgs = {
  object: Analytics_ContentElementStats_Insert_Input;
  on_conflict?: Maybe<Analytics_ContentElementStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentItemStatsArgs = {
  objects: ReadonlyArray<Analytics_ContentItemStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentItemStats_OneArgs = {
  object: Analytics_ContentItemStats_Insert_Input;
  on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_RoomStatsArgs = {
  objects: ReadonlyArray<Analytics_RoomStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_RoomStats_OneArgs = {
  object: Analytics_RoomStats_Insert_Input;
  on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_Mat_ElementTotalViewsArgs = {
  objects: ReadonlyArray<Analytics_Mat_ElementTotalViews_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_Mat_ElementTotalViews_OneArgs = {
  object: Analytics_Mat_ElementTotalViews_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_Mat_ItemTotalViewsArgs = {
  objects: ReadonlyArray<Analytics_Mat_ItemTotalViews_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_Mat_ItemTotalViews_OneArgs = {
  object: Analytics_Mat_ItemTotalViews_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_Mat_RoomPresenceArgs = {
  objects: ReadonlyArray<Analytics_Mat_RoomPresence_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_Mat_RoomPresence_OneArgs = {
  object: Analytics_Mat_RoomPresence_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ChatArgs = {
  objects: ReadonlyArray<Chat_Chat_Insert_Input>;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Chat_OneArgs = {
  object: Chat_Chat_Insert_Input;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagArgs = {
  objects: ReadonlyArray<Chat_Flag_Insert_Input>;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagTypeArgs = {
  objects: ReadonlyArray<Chat_FlagType_Insert_Input>;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagType_OneArgs = {
  object: Chat_FlagType_Insert_Input;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Flag_OneArgs = {
  object: Chat_Flag_Insert_Input;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageArgs = {
  objects: ReadonlyArray<Chat_Message_Insert_Input>;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageTypeArgs = {
  objects: ReadonlyArray<Chat_MessageType_Insert_Input>;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageType_OneArgs = {
  object: Chat_MessageType_Insert_Input;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Message_OneArgs = {
  object: Chat_Message_Insert_Input;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_PinArgs = {
  objects: ReadonlyArray<Chat_Pin_Insert_Input>;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Pin_OneArgs = {
  object: Chat_Pin_Insert_Input;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionArgs = {
  objects: ReadonlyArray<Chat_Reaction_Insert_Input>;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionTypeArgs = {
  objects: ReadonlyArray<Chat_ReactionType_Insert_Input>;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionType_OneArgs = {
  object: Chat_ReactionType_Insert_Input;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Reaction_OneArgs = {
  object: Chat_Reaction_Insert_Input;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndexArgs = {
  objects: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndex_OneArgs = {
  object: Chat_ReadUpToIndex_Insert_Input;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_SubscriptionArgs = {
  objects: ReadonlyArray<Chat_Subscription_Insert_Input>;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Subscription_OneArgs = {
  object: Chat_Subscription_Insert_Input;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ExhibitionArgs = {
  objects: ReadonlyArray<Collection_Exhibition_Insert_Input>;
  on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_Exhibition_OneArgs = {
  object: Collection_Exhibition_Insert_Input;
  on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPersonArgs = {
  objects: ReadonlyArray<Collection_ProgramPerson_Insert_Input>;
  on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPersonByAccessTokenArgs = {
  objects: ReadonlyArray<Collection_ProgramPersonByAccessToken_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPersonByAccessToken_OneArgs = {
  object: Collection_ProgramPersonByAccessToken_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPersonWithAccessTokenArgs = {
  objects: ReadonlyArray<Collection_ProgramPersonWithAccessToken_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPersonWithAccessToken_OneArgs = {
  object: Collection_ProgramPersonWithAccessToken_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPerson_OneArgs = {
  object: Collection_ProgramPerson_Insert_Input;
  on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_TagArgs = {
  objects: ReadonlyArray<Collection_Tag_Insert_Input>;
  on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_Tag_OneArgs = {
  object: Collection_Tag_Insert_Input;
  on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_ConferenceArgs = {
  objects: ReadonlyArray<Conference_Conference_Insert_Input>;
  on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_Conference_OneArgs = {
  object: Conference_Conference_Insert_Input;
  on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_ConfigurationArgs = {
  objects: ReadonlyArray<Conference_Configuration_Insert_Input>;
  on_conflict?: Maybe<Conference_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_ConfigurationKeyArgs = {
  objects: ReadonlyArray<Conference_ConfigurationKey_Insert_Input>;
  on_conflict?: Maybe<Conference_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_ConfigurationKey_OneArgs = {
  object: Conference_ConfigurationKey_Insert_Input;
  on_conflict?: Maybe<Conference_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_Configuration_OneArgs = {
  object: Conference_Configuration_Insert_Input;
  on_conflict?: Maybe<Conference_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_DemoCodeArgs = {
  objects: ReadonlyArray<Conference_DemoCode_Insert_Input>;
  on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_DemoCode_OneArgs = {
  object: Conference_DemoCode_Insert_Input;
  on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_OriginatingDataArgs = {
  objects: ReadonlyArray<Conference_OriginatingData_Insert_Input>;
  on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_OriginatingData_OneArgs = {
  object: Conference_OriginatingData_Insert_Input;
  on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_PrepareJobArgs = {
  objects: ReadonlyArray<Conference_PrepareJob_Insert_Input>;
  on_conflict?: Maybe<Conference_PrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_PrepareJob_OneArgs = {
  object: Conference_PrepareJob_Insert_Input;
  on_conflict?: Maybe<Conference_PrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementArgs = {
  objects: ReadonlyArray<Content_Element_Insert_Input>;
  on_conflict?: Maybe<Content_Element_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementByPersonAccessTokenArgs = {
  objects: ReadonlyArray<Content_ElementByPersonAccessToken_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementByPersonAccessToken_OneArgs = {
  object: Content_ElementByPersonAccessToken_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementPermissionGrantArgs = {
  objects: ReadonlyArray<Content_ElementPermissionGrant_Insert_Input>;
  on_conflict?: Maybe<Content_ElementPermissionGrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementPermissionGrant_OneArgs = {
  object: Content_ElementPermissionGrant_Insert_Input;
  on_conflict?: Maybe<Content_ElementPermissionGrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementTypeArgs = {
  objects: ReadonlyArray<Content_ElementType_Insert_Input>;
  on_conflict?: Maybe<Content_ElementType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementType_OneArgs = {
  object: Content_ElementType_Insert_Input;
  on_conflict?: Maybe<Content_ElementType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_Element_OneArgs = {
  object: Content_Element_Insert_Input;
  on_conflict?: Maybe<Content_Element_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemArgs = {
  objects: ReadonlyArray<Content_Item_Insert_Input>;
  on_conflict?: Maybe<Content_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemByPersonAccessTokenArgs = {
  objects: ReadonlyArray<Content_ItemByPersonAccessToken_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemByPersonAccessToken_OneArgs = {
  object: Content_ItemByPersonAccessToken_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemExhibitionArgs = {
  objects: ReadonlyArray<Content_ItemExhibition_Insert_Input>;
  on_conflict?: Maybe<Content_ItemExhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemExhibition_OneArgs = {
  object: Content_ItemExhibition_Insert_Input;
  on_conflict?: Maybe<Content_ItemExhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemProgramPersonArgs = {
  objects: ReadonlyArray<Content_ItemProgramPerson_Insert_Input>;
  on_conflict?: Maybe<Content_ItemProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemProgramPersonByAccessTokenArgs = {
  objects: ReadonlyArray<Content_ItemProgramPersonByAccessToken_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemProgramPersonByAccessToken_OneArgs = {
  object: Content_ItemProgramPersonByAccessToken_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemProgramPerson_OneArgs = {
  object: Content_ItemProgramPerson_Insert_Input;
  on_conflict?: Maybe<Content_ItemProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemTagArgs = {
  objects: ReadonlyArray<Content_ItemTag_Insert_Input>;
  on_conflict?: Maybe<Content_ItemTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemTag_OneArgs = {
  object: Content_ItemTag_Insert_Input;
  on_conflict?: Maybe<Content_ItemTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemTypeArgs = {
  objects: ReadonlyArray<Content_ItemType_Insert_Input>;
  on_conflict?: Maybe<Content_ItemType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemType_OneArgs = {
  object: Content_ItemType_Insert_Input;
  on_conflict?: Maybe<Content_ItemType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_Item_OneArgs = {
  object: Content_Item_Insert_Input;
  on_conflict?: Maybe<Content_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_UploaderArgs = {
  objects: ReadonlyArray<Content_Uploader_Insert_Input>;
  on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_Uploader_OneArgs = {
  object: Content_Uploader_Insert_Input;
  on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackCreateJobArgs = {
  objects: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackCreateJob_OneArgs = {
  object: Job_Queues_ChannelStackCreateJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackDeleteJobArgs = {
  objects: ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_ChannelStackDeleteJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackDeleteJob_OneArgs = {
  object: Job_Queues_ChannelStackDeleteJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_ChannelStackDeleteJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackUpdateJobArgs = {
  objects: ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_ChannelStackUpdateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackUpdateJob_OneArgs = {
  object: Job_Queues_ChannelStackUpdateJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_ChannelStackUpdateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CombineVideosJobArgs = {
  objects: ReadonlyArray<Job_Queues_CombineVideosJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CombineVideosJob_OneArgs = {
  object: Job_Queues_CombineVideosJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CustomEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_CustomEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CustomEmailJob_OneArgs = {
  object: Job_Queues_CustomEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_InvitationEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJob_OneArgs = {
  object: Job_Queues_InvitationEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJobArgs = {
  objects: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJob_OneArgs = {
  object: Job_Queues_MediaPackageHarvestJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJobArgs = {
  objects: ReadonlyArray<Job_Queues_PublishVideoJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJob_OneArgs = {
  object: Job_Queues_PublishVideoJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJob_OneArgs = {
  object: Job_Queues_SubmissionRequestEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_UploadYouTubeVideoJobArgs = {
  objects: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_UploadYouTubeVideoJob_OneArgs = {
  object: Job_Queues_UploadYouTubeVideoJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupArgs = {
  objects: ReadonlyArray<Permissions_Group_Insert_Input>;
  on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRegistrantArgs = {
  objects: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input>;
  on_conflict?: Maybe<Permissions_GroupRegistrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRegistrant_OneArgs = {
  object: Permissions_GroupRegistrant_Insert_Input;
  on_conflict?: Maybe<Permissions_GroupRegistrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRoleArgs = {
  objects: ReadonlyArray<Permissions_GroupRole_Insert_Input>;
  on_conflict?: Maybe<Permissions_GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRole_OneArgs = {
  object: Permissions_GroupRole_Insert_Input;
  on_conflict?: Maybe<Permissions_GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_Group_OneArgs = {
  object: Permissions_Group_Insert_Input;
  on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_PermissionArgs = {
  objects: ReadonlyArray<Permissions_Permission_Insert_Input>;
  on_conflict?: Maybe<Permissions_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_Permission_OneArgs = {
  object: Permissions_Permission_Insert_Input;
  on_conflict?: Maybe<Permissions_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_RoleArgs = {
  objects: ReadonlyArray<Permissions_Role_Insert_Input>;
  on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_RolePermissionArgs = {
  objects: ReadonlyArray<Permissions_RolePermission_Insert_Input>;
  on_conflict?: Maybe<Permissions_RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_RolePermission_OneArgs = {
  object: Permissions_RolePermission_Insert_Input;
  on_conflict?: Maybe<Permissions_RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_Role_OneArgs = {
  object: Permissions_Role_Insert_Input;
  on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_GoogleAccountArgs = {
  objects: ReadonlyArray<Registrant_GoogleAccount_Insert_Input>;
  on_conflict?: Maybe<Registrant_GoogleAccount_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_GoogleAccount_OneArgs = {
  object: Registrant_GoogleAccount_Insert_Input;
  on_conflict?: Maybe<Registrant_GoogleAccount_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_InvitationArgs = {
  objects: ReadonlyArray<Registrant_Invitation_Insert_Input>;
  on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_Invitation_OneArgs = {
  object: Registrant_Invitation_Insert_Input;
  on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_ProfileArgs = {
  objects: ReadonlyArray<Registrant_Profile_Insert_Input>;
  on_conflict?: Maybe<Registrant_Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_Profile_OneArgs = {
  object: Registrant_Profile_Insert_Input;
  on_conflict?: Maybe<Registrant_Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_RegistrantArgs = {
  objects: ReadonlyArray<Registrant_Registrant_Insert_Input>;
  on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_Registrant_OneArgs = {
  object: Registrant_Registrant_Insert_Input;
  on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_SavedVonageRoomRecordingArgs = {
  objects: ReadonlyArray<Registrant_SavedVonageRoomRecording_Insert_Input>;
  on_conflict?: Maybe<Registrant_SavedVonageRoomRecording_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_SavedVonageRoomRecording_OneArgs = {
  object: Registrant_SavedVonageRoomRecording_Insert_Input;
  on_conflict?: Maybe<Registrant_SavedVonageRoomRecording_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_BackendArgs = {
  objects: ReadonlyArray<Room_Backend_Insert_Input>;
  on_conflict?: Maybe<Room_Backend_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Backend_OneArgs = {
  object: Room_Backend_Insert_Input;
  on_conflict?: Maybe<Room_Backend_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ChimeMeetingArgs = {
  objects: ReadonlyArray<Room_ChimeMeeting_Insert_Input>;
  on_conflict?: Maybe<Room_ChimeMeeting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ChimeMeeting_OneArgs = {
  object: Room_ChimeMeeting_Insert_Input;
  on_conflict?: Maybe<Room_ChimeMeeting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ManagementModeArgs = {
  objects: ReadonlyArray<Room_ManagementMode_Insert_Input>;
  on_conflict?: Maybe<Room_ManagementMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ManagementMode_OneArgs = {
  object: Room_ManagementMode_Insert_Input;
  on_conflict?: Maybe<Room_ManagementMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ModeArgs = {
  objects: ReadonlyArray<Room_Mode_Insert_Input>;
  on_conflict?: Maybe<Room_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Mode_OneArgs = {
  object: Room_Mode_Insert_Input;
  on_conflict?: Maybe<Room_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ParticipantArgs = {
  objects: ReadonlyArray<Room_Participant_Insert_Input>;
  on_conflict?: Maybe<Room_Participant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Participant_OneArgs = {
  object: Room_Participant_Insert_Input;
  on_conflict?: Maybe<Room_Participant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_PersonRoleArgs = {
  objects: ReadonlyArray<Room_PersonRole_Insert_Input>;
  on_conflict?: Maybe<Room_PersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_PersonRole_OneArgs = {
  object: Room_PersonRole_Insert_Input;
  on_conflict?: Maybe<Room_PersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomArgs = {
  objects: ReadonlyArray<Room_Room_Insert_Input>;
  on_conflict?: Maybe<Room_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomPersonArgs = {
  objects: ReadonlyArray<Room_RoomPerson_Insert_Input>;
  on_conflict?: Maybe<Room_RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomPerson_OneArgs = {
  object: Room_RoomPerson_Insert_Input;
  on_conflict?: Maybe<Room_RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Room_OneArgs = {
  object: Room_Room_Insert_Input;
  on_conflict?: Maybe<Room_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleAlgorithmArgs = {
  objects: ReadonlyArray<Room_ShuffleAlgorithm_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleAlgorithm_OneArgs = {
  object: Room_ShuffleAlgorithm_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriodArgs = {
  objects: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriod_OneArgs = {
  object: Room_ShufflePeriod_Insert_Input;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntryArgs = {
  objects: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntry_OneArgs = {
  object: Room_ShuffleQueueEntry_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoomArgs = {
  objects: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoom_OneArgs = {
  object: Room_ShuffleRoom_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_ContinuationArgs = {
  objects: ReadonlyArray<Schedule_Continuation_Insert_Input>;
  on_conflict?: Maybe<Schedule_Continuation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_Continuation_OneArgs = {
  object: Schedule_Continuation_Insert_Input;
  on_conflict?: Maybe<Schedule_Continuation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventArgs = {
  objects: ReadonlyArray<Schedule_Event_Insert_Input>;
  on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPersonArgs = {
  objects: ReadonlyArray<Schedule_EventProgramPerson_Insert_Input>;
  on_conflict?: Maybe<Schedule_EventProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPersonRoleArgs = {
  objects: ReadonlyArray<Schedule_EventProgramPersonRole_Insert_Input>;
  on_conflict?: Maybe<Schedule_EventProgramPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPersonRole_OneArgs = {
  object: Schedule_EventProgramPersonRole_Insert_Input;
  on_conflict?: Maybe<Schedule_EventProgramPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPerson_OneArgs = {
  object: Schedule_EventProgramPerson_Insert_Input;
  on_conflict?: Maybe<Schedule_EventProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventTagArgs = {
  objects: ReadonlyArray<Schedule_EventTag_Insert_Input>;
  on_conflict?: Maybe<Schedule_EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventTag_OneArgs = {
  object: Schedule_EventTag_Insert_Input;
  on_conflict?: Maybe<Schedule_EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_Event_OneArgs = {
  object: Schedule_Event_Insert_Input;
  on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_StarredEventArgs = {
  objects: ReadonlyArray<Schedule_StarredEvent_Insert_Input>;
  on_conflict?: Maybe<Schedule_StarredEvent_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_StarredEvent_OneArgs = {
  object: Schedule_StarredEvent_Insert_Input;
  on_conflict?: Maybe<Schedule_StarredEvent_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationArgs = {
  objects: ReadonlyArray<System_Configuration_Insert_Input>;
  on_conflict?: Maybe<System_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationKeyArgs = {
  objects: ReadonlyArray<System_ConfigurationKey_Insert_Input>;
  on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationKey_OneArgs = {
  object: System_ConfigurationKey_Insert_Input;
  on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_Configuration_OneArgs = {
  object: System_Configuration_Insert_Input;
  on_conflict?: Maybe<System_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ChannelStackArgs = {
  objects: ReadonlyArray<Video_ChannelStack_Insert_Input>;
  on_conflict?: Maybe<Video_ChannelStack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ChannelStackWithStreamKeyArgs = {
  objects: ReadonlyArray<Video_ChannelStackWithStreamKey_Insert_Input>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ChannelStackWithStreamKey_OneArgs = {
  object: Video_ChannelStackWithStreamKey_Insert_Input;
};


/** mutation root */
export type Mutation_RootInsert_Video_ChannelStack_OneArgs = {
  object: Video_ChannelStack_Insert_Input;
  on_conflict?: Maybe<Video_ChannelStack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventParticipantStreamArgs = {
  objects: ReadonlyArray<Video_EventParticipantStream_Insert_Input>;
  on_conflict?: Maybe<Video_EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventParticipantStream_OneArgs = {
  object: Video_EventParticipantStream_Insert_Input;
  on_conflict?: Maybe<Video_EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventVonageSessionArgs = {
  objects: ReadonlyArray<Video_EventVonageSession_Insert_Input>;
  on_conflict?: Maybe<Video_EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventVonageSession_OneArgs = {
  object: Video_EventVonageSession_Insert_Input;
  on_conflict?: Maybe<Video_EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ImmediateSwitchArgs = {
  objects: ReadonlyArray<Video_ImmediateSwitch_Insert_Input>;
  on_conflict?: Maybe<Video_ImmediateSwitch_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ImmediateSwitch_OneArgs = {
  object: Video_ImmediateSwitch_Insert_Input;
  on_conflict?: Maybe<Video_ImmediateSwitch_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_InputTypeArgs = {
  objects: ReadonlyArray<Video_InputType_Insert_Input>;
  on_conflict?: Maybe<Video_InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_InputType_OneArgs = {
  object: Video_InputType_Insert_Input;
  on_conflict?: Maybe<Video_InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_JobStatusArgs = {
  objects: ReadonlyArray<Video_JobStatus_Insert_Input>;
  on_conflict?: Maybe<Video_JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_JobStatus_OneArgs = {
  object: Video_JobStatus_Insert_Input;
  on_conflict?: Maybe<Video_JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_MediaLiveChannelStatusArgs = {
  objects: ReadonlyArray<Video_MediaLiveChannelStatus_Insert_Input>;
  on_conflict?: Maybe<Video_MediaLiveChannelStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_MediaLiveChannelStatus_OneArgs = {
  object: Video_MediaLiveChannelStatus_Insert_Input;
  on_conflict?: Maybe<Video_MediaLiveChannelStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_RoomRtmpOutputArgs = {
  objects: ReadonlyArray<Video_RoomRtmpOutput_Insert_Input>;
  on_conflict?: Maybe<Video_RoomRtmpOutput_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_RoomRtmpOutput_OneArgs = {
  object: Video_RoomRtmpOutput_Insert_Input;
  on_conflict?: Maybe<Video_RoomRtmpOutput_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_RtmpInputArgs = {
  objects: ReadonlyArray<Video_RtmpInput_Insert_Input>;
  on_conflict?: Maybe<Video_RtmpInput_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_RtmpInput_OneArgs = {
  object: Video_RtmpInput_Insert_Input;
  on_conflict?: Maybe<Video_RtmpInput_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_TranscriptionJobArgs = {
  objects: ReadonlyArray<Video_TranscriptionJob_Insert_Input>;
  on_conflict?: Maybe<Video_TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_TranscriptionJob_OneArgs = {
  object: Video_TranscriptionJob_Insert_Input;
  on_conflict?: Maybe<Video_TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_VideoRenderJobArgs = {
  objects: ReadonlyArray<Video_VideoRenderJob_Insert_Input>;
  on_conflict?: Maybe<Video_VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_VideoRenderJob_OneArgs = {
  object: Video_VideoRenderJob_Insert_Input;
  on_conflict?: Maybe<Video_VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_VonageRoomRecordingArgs = {
  objects: ReadonlyArray<Video_VonageRoomRecording_Insert_Input>;
  on_conflict?: Maybe<Video_VonageRoomRecording_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_VonageRoomRecording_OneArgs = {
  object: Video_VonageRoomRecording_Insert_Input;
  on_conflict?: Maybe<Video_VonageRoomRecording_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_YouTubeUploadArgs = {
  objects: ReadonlyArray<Video_YouTubeUpload_Insert_Input>;
  on_conflict?: Maybe<Video_YouTubeUpload_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_YouTubeUpload_OneArgs = {
  object: Video_YouTubeUpload_Insert_Input;
  on_conflict?: Maybe<Video_YouTubeUpload_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInvitationConfirmCurrentArgs = {
  inviteCode: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinEventVonageSessionArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinRoomChimeSessionArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinRoomVonageSessionArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootNotifyEventEndedArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootRefreshYouTubeDataArgs = {
  registrantGoogleAccountId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootStopEventBroadcastArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootSubmitGoogleOAuthCodeArgs = {
  code: Scalars['String'];
  state: Scalars['String'];
};


/** mutation root */
export type Mutation_RootSubmitUploadableElementArgs = {
  data: Scalars['jsonb'];
  magicToken: Scalars['String'];
};


/** mutation root */
export type Mutation_RootToggleVonageRecordingStateArgs = {
  recordingActive: Scalars['Boolean'];
  vonageSessionId: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdateProfilePhotoArgs = {
  registrantId: Scalars['uuid'];
  s3URL?: Maybe<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootUpdateSubtitlesArgs = {
  elementId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdate_EmailArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Email_By_PkArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  pk_columns: Email_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PushNotificationSubscriptionArgs = {
  _set?: Maybe<PushNotificationSubscription_Set_Input>;
  where: PushNotificationSubscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_PushNotificationSubscription_By_PkArgs = {
  _set?: Maybe<PushNotificationSubscription_Set_Input>;
  pk_columns: PushNotificationSubscription_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UserArgs = {
  _set?: Maybe<User_Set_Input>;
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_By_PkArgs = {
  _set?: Maybe<User_Set_Input>;
  pk_columns: User_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_AppStatsArgs = {
  _append?: Maybe<Analytics_AppStats_Append_Input>;
  _delete_at_path?: Maybe<Analytics_AppStats_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Analytics_AppStats_Delete_Elem_Input>;
  _delete_key?: Maybe<Analytics_AppStats_Delete_Key_Input>;
  _inc?: Maybe<Analytics_AppStats_Inc_Input>;
  _prepend?: Maybe<Analytics_AppStats_Prepend_Input>;
  _set?: Maybe<Analytics_AppStats_Set_Input>;
  where: Analytics_AppStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_AppStats_By_PkArgs = {
  _append?: Maybe<Analytics_AppStats_Append_Input>;
  _delete_at_path?: Maybe<Analytics_AppStats_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Analytics_AppStats_Delete_Elem_Input>;
  _delete_key?: Maybe<Analytics_AppStats_Delete_Key_Input>;
  _inc?: Maybe<Analytics_AppStats_Inc_Input>;
  _prepend?: Maybe<Analytics_AppStats_Prepend_Input>;
  _set?: Maybe<Analytics_AppStats_Set_Input>;
  pk_columns: Analytics_AppStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentElementStatsArgs = {
  _inc?: Maybe<Analytics_ContentElementStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentElementStats_Set_Input>;
  where: Analytics_ContentElementStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentElementStats_By_PkArgs = {
  _inc?: Maybe<Analytics_ContentElementStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentElementStats_Set_Input>;
  pk_columns: Analytics_ContentElementStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentItemStatsArgs = {
  _inc?: Maybe<Analytics_ContentItemStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentItemStats_Set_Input>;
  where: Analytics_ContentItemStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentItemStats_By_PkArgs = {
  _inc?: Maybe<Analytics_ContentItemStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentItemStats_Set_Input>;
  pk_columns: Analytics_ContentItemStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_RoomStatsArgs = {
  _inc?: Maybe<Analytics_RoomStats_Inc_Input>;
  _set?: Maybe<Analytics_RoomStats_Set_Input>;
  where: Analytics_RoomStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_RoomStats_By_PkArgs = {
  _inc?: Maybe<Analytics_RoomStats_Inc_Input>;
  _set?: Maybe<Analytics_RoomStats_Set_Input>;
  pk_columns: Analytics_RoomStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_Mat_ElementTotalViewsArgs = {
  _inc?: Maybe<Analytics_Mat_ElementTotalViews_Inc_Input>;
  _set?: Maybe<Analytics_Mat_ElementTotalViews_Set_Input>;
  where: Analytics_Mat_ElementTotalViews_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_Mat_ItemTotalViewsArgs = {
  _inc?: Maybe<Analytics_Mat_ItemTotalViews_Inc_Input>;
  _set?: Maybe<Analytics_Mat_ItemTotalViews_Set_Input>;
  where: Analytics_Mat_ItemTotalViews_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_Mat_RoomPresenceArgs = {
  _append?: Maybe<Analytics_Mat_RoomPresence_Append_Input>;
  _delete_at_path?: Maybe<Analytics_Mat_RoomPresence_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Analytics_Mat_RoomPresence_Delete_Elem_Input>;
  _delete_key?: Maybe<Analytics_Mat_RoomPresence_Delete_Key_Input>;
  _prepend?: Maybe<Analytics_Mat_RoomPresence_Prepend_Input>;
  _set?: Maybe<Analytics_Mat_RoomPresence_Set_Input>;
  where: Analytics_Mat_RoomPresence_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ChatArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Chat_By_PkArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  pk_columns: Chat_Chat_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagTypeArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagType_By_PkArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  pk_columns: Chat_FlagType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Flag_By_PkArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  pk_columns: Chat_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageTypeArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageType_By_PkArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  pk_columns: Chat_MessageType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Message_By_PkArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  pk_columns: Chat_Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_PinArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Pin_By_PkArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  pk_columns: Chat_Pin_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionTypeArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionType_By_PkArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  pk_columns: Chat_ReactionType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Reaction_By_PkArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  pk_columns: Chat_Reaction_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndexArgs = {
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndex_By_PkArgs = {
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  pk_columns: Chat_ReadUpToIndex_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_SubscriptionArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Subscription_By_PkArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  pk_columns: Chat_Subscription_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ExhibitionArgs = {
  _inc?: Maybe<Collection_Exhibition_Inc_Input>;
  _set?: Maybe<Collection_Exhibition_Set_Input>;
  where: Collection_Exhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_Exhibition_By_PkArgs = {
  _inc?: Maybe<Collection_Exhibition_Inc_Input>;
  _set?: Maybe<Collection_Exhibition_Set_Input>;
  pk_columns: Collection_Exhibition_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ProgramPersonArgs = {
  _inc?: Maybe<Collection_ProgramPerson_Inc_Input>;
  _set?: Maybe<Collection_ProgramPerson_Set_Input>;
  where: Collection_ProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ProgramPersonByAccessTokenArgs = {
  _set?: Maybe<Collection_ProgramPersonByAccessToken_Set_Input>;
  where: Collection_ProgramPersonByAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ProgramPersonWithAccessTokenArgs = {
  _inc?: Maybe<Collection_ProgramPersonWithAccessToken_Inc_Input>;
  _set?: Maybe<Collection_ProgramPersonWithAccessToken_Set_Input>;
  where: Collection_ProgramPersonWithAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ProgramPerson_By_PkArgs = {
  _inc?: Maybe<Collection_ProgramPerson_Inc_Input>;
  _set?: Maybe<Collection_ProgramPerson_Set_Input>;
  pk_columns: Collection_ProgramPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_TagArgs = {
  _inc?: Maybe<Collection_Tag_Inc_Input>;
  _set?: Maybe<Collection_Tag_Set_Input>;
  where: Collection_Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_Tag_By_PkArgs = {
  _inc?: Maybe<Collection_Tag_Inc_Input>;
  _set?: Maybe<Collection_Tag_Set_Input>;
  pk_columns: Collection_Tag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_ConferenceArgs = {
  _set?: Maybe<Conference_Conference_Set_Input>;
  where: Conference_Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_Conference_By_PkArgs = {
  _set?: Maybe<Conference_Conference_Set_Input>;
  pk_columns: Conference_Conference_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_ConfigurationArgs = {
  _append?: Maybe<Conference_Configuration_Append_Input>;
  _delete_at_path?: Maybe<Conference_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<Conference_Configuration_Prepend_Input>;
  _set?: Maybe<Conference_Configuration_Set_Input>;
  where: Conference_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_ConfigurationKeyArgs = {
  _set?: Maybe<Conference_ConfigurationKey_Set_Input>;
  where: Conference_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_ConfigurationKey_By_PkArgs = {
  _set?: Maybe<Conference_ConfigurationKey_Set_Input>;
  pk_columns: Conference_ConfigurationKey_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_Configuration_By_PkArgs = {
  _append?: Maybe<Conference_Configuration_Append_Input>;
  _delete_at_path?: Maybe<Conference_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<Conference_Configuration_Prepend_Input>;
  _set?: Maybe<Conference_Configuration_Set_Input>;
  pk_columns: Conference_Configuration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_DemoCodeArgs = {
  _set?: Maybe<Conference_DemoCode_Set_Input>;
  where: Conference_DemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_DemoCode_By_PkArgs = {
  _set?: Maybe<Conference_DemoCode_Set_Input>;
  pk_columns: Conference_DemoCode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_OriginatingDataArgs = {
  _append?: Maybe<Conference_OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<Conference_OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<Conference_OriginatingData_Prepend_Input>;
  _set?: Maybe<Conference_OriginatingData_Set_Input>;
  where: Conference_OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_OriginatingData_By_PkArgs = {
  _append?: Maybe<Conference_OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<Conference_OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<Conference_OriginatingData_Prepend_Input>;
  _set?: Maybe<Conference_OriginatingData_Set_Input>;
  pk_columns: Conference_OriginatingData_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_PrepareJobArgs = {
  _set?: Maybe<Conference_PrepareJob_Set_Input>;
  where: Conference_PrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_PrepareJob_By_PkArgs = {
  _set?: Maybe<Conference_PrepareJob_Set_Input>;
  pk_columns: Conference_PrepareJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementArgs = {
  _append?: Maybe<Content_Element_Append_Input>;
  _delete_at_path?: Maybe<Content_Element_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_Element_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_Element_Delete_Key_Input>;
  _inc?: Maybe<Content_Element_Inc_Input>;
  _prepend?: Maybe<Content_Element_Prepend_Input>;
  _set?: Maybe<Content_Element_Set_Input>;
  where: Content_Element_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementByPersonAccessTokenArgs = {
  _append?: Maybe<Content_ElementByPersonAccessToken_Append_Input>;
  _delete_at_path?: Maybe<Content_ElementByPersonAccessToken_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_ElementByPersonAccessToken_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_ElementByPersonAccessToken_Delete_Key_Input>;
  _inc?: Maybe<Content_ElementByPersonAccessToken_Inc_Input>;
  _prepend?: Maybe<Content_ElementByPersonAccessToken_Prepend_Input>;
  _set?: Maybe<Content_ElementByPersonAccessToken_Set_Input>;
  where: Content_ElementByPersonAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementPermissionGrantArgs = {
  _set?: Maybe<Content_ElementPermissionGrant_Set_Input>;
  where: Content_ElementPermissionGrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementPermissionGrant_By_PkArgs = {
  _set?: Maybe<Content_ElementPermissionGrant_Set_Input>;
  pk_columns: Content_ElementPermissionGrant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementTypeArgs = {
  _set?: Maybe<Content_ElementType_Set_Input>;
  where: Content_ElementType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementType_By_PkArgs = {
  _set?: Maybe<Content_ElementType_Set_Input>;
  pk_columns: Content_ElementType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_Element_By_PkArgs = {
  _append?: Maybe<Content_Element_Append_Input>;
  _delete_at_path?: Maybe<Content_Element_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_Element_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_Element_Delete_Key_Input>;
  _inc?: Maybe<Content_Element_Inc_Input>;
  _prepend?: Maybe<Content_Element_Prepend_Input>;
  _set?: Maybe<Content_Element_Set_Input>;
  pk_columns: Content_Element_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemArgs = {
  _set?: Maybe<Content_Item_Set_Input>;
  where: Content_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemByPersonAccessTokenArgs = {
  _set?: Maybe<Content_ItemByPersonAccessToken_Set_Input>;
  where: Content_ItemByPersonAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemExhibitionArgs = {
  _append?: Maybe<Content_ItemExhibition_Append_Input>;
  _delete_at_path?: Maybe<Content_ItemExhibition_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_ItemExhibition_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_ItemExhibition_Delete_Key_Input>;
  _inc?: Maybe<Content_ItemExhibition_Inc_Input>;
  _prepend?: Maybe<Content_ItemExhibition_Prepend_Input>;
  _set?: Maybe<Content_ItemExhibition_Set_Input>;
  where: Content_ItemExhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemExhibition_By_PkArgs = {
  _append?: Maybe<Content_ItemExhibition_Append_Input>;
  _delete_at_path?: Maybe<Content_ItemExhibition_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_ItemExhibition_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_ItemExhibition_Delete_Key_Input>;
  _inc?: Maybe<Content_ItemExhibition_Inc_Input>;
  _prepend?: Maybe<Content_ItemExhibition_Prepend_Input>;
  _set?: Maybe<Content_ItemExhibition_Set_Input>;
  pk_columns: Content_ItemExhibition_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemProgramPersonArgs = {
  _inc?: Maybe<Content_ItemProgramPerson_Inc_Input>;
  _set?: Maybe<Content_ItemProgramPerson_Set_Input>;
  where: Content_ItemProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemProgramPersonByAccessTokenArgs = {
  _inc?: Maybe<Content_ItemProgramPersonByAccessToken_Inc_Input>;
  _set?: Maybe<Content_ItemProgramPersonByAccessToken_Set_Input>;
  where: Content_ItemProgramPersonByAccessToken_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemProgramPerson_By_PkArgs = {
  _inc?: Maybe<Content_ItemProgramPerson_Inc_Input>;
  _set?: Maybe<Content_ItemProgramPerson_Set_Input>;
  pk_columns: Content_ItemProgramPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemTagArgs = {
  _set?: Maybe<Content_ItemTag_Set_Input>;
  where: Content_ItemTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemTag_By_PkArgs = {
  _set?: Maybe<Content_ItemTag_Set_Input>;
  pk_columns: Content_ItemTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemTypeArgs = {
  _set?: Maybe<Content_ItemType_Set_Input>;
  where: Content_ItemType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemType_By_PkArgs = {
  _set?: Maybe<Content_ItemType_Set_Input>;
  pk_columns: Content_ItemType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_Item_By_PkArgs = {
  _set?: Maybe<Content_Item_Set_Input>;
  pk_columns: Content_Item_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_UploaderArgs = {
  _inc?: Maybe<Content_Uploader_Inc_Input>;
  _set?: Maybe<Content_Uploader_Set_Input>;
  where: Content_Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_Uploader_By_PkArgs = {
  _inc?: Maybe<Content_Uploader_Inc_Input>;
  _set?: Maybe<Content_Uploader_Set_Input>;
  pk_columns: Content_Uploader_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackCreateJobArgs = {
  _set?: Maybe<Job_Queues_ChannelStackCreateJob_Set_Input>;
  where: Job_Queues_ChannelStackCreateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackCreateJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_ChannelStackCreateJob_Set_Input>;
  pk_columns: Job_Queues_ChannelStackCreateJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackDeleteJobArgs = {
  _set?: Maybe<Job_Queues_ChannelStackDeleteJob_Set_Input>;
  where: Job_Queues_ChannelStackDeleteJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackDeleteJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_ChannelStackDeleteJob_Set_Input>;
  pk_columns: Job_Queues_ChannelStackDeleteJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackUpdateJobArgs = {
  _set?: Maybe<Job_Queues_ChannelStackUpdateJob_Set_Input>;
  where: Job_Queues_ChannelStackUpdateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackUpdateJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_ChannelStackUpdateJob_Set_Input>;
  pk_columns: Job_Queues_ChannelStackUpdateJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CombineVideosJobArgs = {
  _append?: Maybe<Job_Queues_CombineVideosJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CombineVideosJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CombineVideosJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CombineVideosJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CombineVideosJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CombineVideosJob_Set_Input>;
  where: Job_Queues_CombineVideosJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CombineVideosJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_CombineVideosJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CombineVideosJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CombineVideosJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CombineVideosJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CombineVideosJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CombineVideosJob_Set_Input>;
  pk_columns: Job_Queues_CombineVideosJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CustomEmailJobArgs = {
  _append?: Maybe<Job_Queues_CustomEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CustomEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CustomEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CustomEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CustomEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CustomEmailJob_Set_Input>;
  where: Job_Queues_CustomEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CustomEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_CustomEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CustomEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CustomEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CustomEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CustomEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CustomEmailJob_Set_Input>;
  pk_columns: Job_Queues_CustomEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJobArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  pk_columns: Job_Queues_InvitationEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJobArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  pk_columns: Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJobArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  pk_columns: Job_Queues_PublishVideoJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJobArgs = {
  _append?: Maybe<Job_Queues_SubmissionRequestEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_SubmissionRequestEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_SubmissionRequestEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_SubmissionRequestEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  pk_columns: Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_UploadYouTubeVideoJobArgs = {
  _inc?: Maybe<Job_Queues_UploadYouTubeVideoJob_Inc_Input>;
  _set?: Maybe<Job_Queues_UploadYouTubeVideoJob_Set_Input>;
  where: Job_Queues_UploadYouTubeVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  _inc?: Maybe<Job_Queues_UploadYouTubeVideoJob_Inc_Input>;
  _set?: Maybe<Job_Queues_UploadYouTubeVideoJob_Set_Input>;
  pk_columns: Job_Queues_UploadYouTubeVideoJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupArgs = {
  _set?: Maybe<Permissions_Group_Set_Input>;
  where: Permissions_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRegistrantArgs = {
  _set?: Maybe<Permissions_GroupRegistrant_Set_Input>;
  where: Permissions_GroupRegistrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRegistrant_By_PkArgs = {
  _set?: Maybe<Permissions_GroupRegistrant_Set_Input>;
  pk_columns: Permissions_GroupRegistrant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRoleArgs = {
  _set?: Maybe<Permissions_GroupRole_Set_Input>;
  where: Permissions_GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRole_By_PkArgs = {
  _set?: Maybe<Permissions_GroupRole_Set_Input>;
  pk_columns: Permissions_GroupRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_Group_By_PkArgs = {
  _set?: Maybe<Permissions_Group_Set_Input>;
  pk_columns: Permissions_Group_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_PermissionArgs = {
  _set?: Maybe<Permissions_Permission_Set_Input>;
  where: Permissions_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_Permission_By_PkArgs = {
  _set?: Maybe<Permissions_Permission_Set_Input>;
  pk_columns: Permissions_Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_RoleArgs = {
  _set?: Maybe<Permissions_Role_Set_Input>;
  where: Permissions_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_RolePermissionArgs = {
  _set?: Maybe<Permissions_RolePermission_Set_Input>;
  where: Permissions_RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_RolePermission_By_PkArgs = {
  _set?: Maybe<Permissions_RolePermission_Set_Input>;
  pk_columns: Permissions_RolePermission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_Role_By_PkArgs = {
  _set?: Maybe<Permissions_Role_Set_Input>;
  pk_columns: Permissions_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_GoogleAccountArgs = {
  _append?: Maybe<Registrant_GoogleAccount_Append_Input>;
  _delete_at_path?: Maybe<Registrant_GoogleAccount_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_GoogleAccount_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_GoogleAccount_Delete_Key_Input>;
  _prepend?: Maybe<Registrant_GoogleAccount_Prepend_Input>;
  _set?: Maybe<Registrant_GoogleAccount_Set_Input>;
  where: Registrant_GoogleAccount_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_GoogleAccount_By_PkArgs = {
  _append?: Maybe<Registrant_GoogleAccount_Append_Input>;
  _delete_at_path?: Maybe<Registrant_GoogleAccount_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_GoogleAccount_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_GoogleAccount_Delete_Key_Input>;
  _prepend?: Maybe<Registrant_GoogleAccount_Prepend_Input>;
  _set?: Maybe<Registrant_GoogleAccount_Set_Input>;
  pk_columns: Registrant_GoogleAccount_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_InvitationArgs = {
  _set?: Maybe<Registrant_Invitation_Set_Input>;
  where: Registrant_Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_Invitation_By_PkArgs = {
  _set?: Maybe<Registrant_Invitation_Set_Input>;
  pk_columns: Registrant_Invitation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_ProfileArgs = {
  _append?: Maybe<Registrant_Profile_Append_Input>;
  _delete_at_path?: Maybe<Registrant_Profile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_Profile_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_Profile_Delete_Key_Input>;
  _inc?: Maybe<Registrant_Profile_Inc_Input>;
  _prepend?: Maybe<Registrant_Profile_Prepend_Input>;
  _set?: Maybe<Registrant_Profile_Set_Input>;
  where: Registrant_Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_Profile_By_PkArgs = {
  _append?: Maybe<Registrant_Profile_Append_Input>;
  _delete_at_path?: Maybe<Registrant_Profile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_Profile_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_Profile_Delete_Key_Input>;
  _inc?: Maybe<Registrant_Profile_Inc_Input>;
  _prepend?: Maybe<Registrant_Profile_Prepend_Input>;
  _set?: Maybe<Registrant_Profile_Set_Input>;
  pk_columns: Registrant_Profile_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_RegistrantArgs = {
  _set?: Maybe<Registrant_Registrant_Set_Input>;
  where: Registrant_Registrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_Registrant_By_PkArgs = {
  _set?: Maybe<Registrant_Registrant_Set_Input>;
  pk_columns: Registrant_Registrant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_SavedVonageRoomRecordingArgs = {
  _set?: Maybe<Registrant_SavedVonageRoomRecording_Set_Input>;
  where: Registrant_SavedVonageRoomRecording_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_SavedVonageRoomRecording_By_PkArgs = {
  _set?: Maybe<Registrant_SavedVonageRoomRecording_Set_Input>;
  pk_columns: Registrant_SavedVonageRoomRecording_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_BackendArgs = {
  _set?: Maybe<Room_Backend_Set_Input>;
  where: Room_Backend_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Backend_By_PkArgs = {
  _set?: Maybe<Room_Backend_Set_Input>;
  pk_columns: Room_Backend_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ChimeMeetingArgs = {
  _append?: Maybe<Room_ChimeMeeting_Append_Input>;
  _delete_at_path?: Maybe<Room_ChimeMeeting_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Room_ChimeMeeting_Delete_Elem_Input>;
  _delete_key?: Maybe<Room_ChimeMeeting_Delete_Key_Input>;
  _prepend?: Maybe<Room_ChimeMeeting_Prepend_Input>;
  _set?: Maybe<Room_ChimeMeeting_Set_Input>;
  where: Room_ChimeMeeting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ChimeMeeting_By_PkArgs = {
  _append?: Maybe<Room_ChimeMeeting_Append_Input>;
  _delete_at_path?: Maybe<Room_ChimeMeeting_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Room_ChimeMeeting_Delete_Elem_Input>;
  _delete_key?: Maybe<Room_ChimeMeeting_Delete_Key_Input>;
  _prepend?: Maybe<Room_ChimeMeeting_Prepend_Input>;
  _set?: Maybe<Room_ChimeMeeting_Set_Input>;
  pk_columns: Room_ChimeMeeting_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ManagementModeArgs = {
  _set?: Maybe<Room_ManagementMode_Set_Input>;
  where: Room_ManagementMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ManagementMode_By_PkArgs = {
  _set?: Maybe<Room_ManagementMode_Set_Input>;
  pk_columns: Room_ManagementMode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ModeArgs = {
  _set?: Maybe<Room_Mode_Set_Input>;
  where: Room_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Mode_By_PkArgs = {
  _set?: Maybe<Room_Mode_Set_Input>;
  pk_columns: Room_Mode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ParticipantArgs = {
  _set?: Maybe<Room_Participant_Set_Input>;
  where: Room_Participant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Participant_By_PkArgs = {
  _set?: Maybe<Room_Participant_Set_Input>;
  pk_columns: Room_Participant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_PersonRoleArgs = {
  _set?: Maybe<Room_PersonRole_Set_Input>;
  where: Room_PersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_PersonRole_By_PkArgs = {
  _set?: Maybe<Room_PersonRole_Set_Input>;
  pk_columns: Room_PersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomArgs = {
  _inc?: Maybe<Room_Room_Inc_Input>;
  _set?: Maybe<Room_Room_Set_Input>;
  where: Room_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomPersonArgs = {
  _set?: Maybe<Room_RoomPerson_Set_Input>;
  where: Room_RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomPerson_By_PkArgs = {
  _set?: Maybe<Room_RoomPerson_Set_Input>;
  pk_columns: Room_RoomPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Room_By_PkArgs = {
  _inc?: Maybe<Room_Room_Inc_Input>;
  _set?: Maybe<Room_Room_Set_Input>;
  pk_columns: Room_Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleAlgorithmArgs = {
  _set?: Maybe<Room_ShuffleAlgorithm_Set_Input>;
  where: Room_ShuffleAlgorithm_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleAlgorithm_By_PkArgs = {
  _set?: Maybe<Room_ShuffleAlgorithm_Set_Input>;
  pk_columns: Room_ShuffleAlgorithm_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriodArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriod_By_PkArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  pk_columns: Room_ShufflePeriod_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntryArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntry_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  pk_columns: Room_ShuffleQueueEntry_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoomArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoom_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  pk_columns: Room_ShuffleRoom_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_ContinuationArgs = {
  _append?: Maybe<Schedule_Continuation_Append_Input>;
  _delete_at_path?: Maybe<Schedule_Continuation_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Schedule_Continuation_Delete_Elem_Input>;
  _delete_key?: Maybe<Schedule_Continuation_Delete_Key_Input>;
  _inc?: Maybe<Schedule_Continuation_Inc_Input>;
  _prepend?: Maybe<Schedule_Continuation_Prepend_Input>;
  _set?: Maybe<Schedule_Continuation_Set_Input>;
  where: Schedule_Continuation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_Continuation_By_PkArgs = {
  _append?: Maybe<Schedule_Continuation_Append_Input>;
  _delete_at_path?: Maybe<Schedule_Continuation_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Schedule_Continuation_Delete_Elem_Input>;
  _delete_key?: Maybe<Schedule_Continuation_Delete_Key_Input>;
  _inc?: Maybe<Schedule_Continuation_Inc_Input>;
  _prepend?: Maybe<Schedule_Continuation_Prepend_Input>;
  _set?: Maybe<Schedule_Continuation_Set_Input>;
  pk_columns: Schedule_Continuation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventArgs = {
  _inc?: Maybe<Schedule_Event_Inc_Input>;
  _set?: Maybe<Schedule_Event_Set_Input>;
  where: Schedule_Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPersonArgs = {
  _set?: Maybe<Schedule_EventProgramPerson_Set_Input>;
  where: Schedule_EventProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPersonRoleArgs = {
  _set?: Maybe<Schedule_EventProgramPersonRole_Set_Input>;
  where: Schedule_EventProgramPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPersonRole_By_PkArgs = {
  _set?: Maybe<Schedule_EventProgramPersonRole_Set_Input>;
  pk_columns: Schedule_EventProgramPersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPerson_By_PkArgs = {
  _set?: Maybe<Schedule_EventProgramPerson_Set_Input>;
  pk_columns: Schedule_EventProgramPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventTagArgs = {
  _set?: Maybe<Schedule_EventTag_Set_Input>;
  where: Schedule_EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventTag_By_PkArgs = {
  _set?: Maybe<Schedule_EventTag_Set_Input>;
  pk_columns: Schedule_EventTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_Event_By_PkArgs = {
  _inc?: Maybe<Schedule_Event_Inc_Input>;
  _set?: Maybe<Schedule_Event_Set_Input>;
  pk_columns: Schedule_Event_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_StarredEventArgs = {
  _set?: Maybe<Schedule_StarredEvent_Set_Input>;
  where: Schedule_StarredEvent_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_StarredEvent_By_PkArgs = {
  _set?: Maybe<Schedule_StarredEvent_Set_Input>;
  pk_columns: Schedule_StarredEvent_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationArgs = {
  _append?: Maybe<System_Configuration_Append_Input>;
  _delete_at_path?: Maybe<System_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<System_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<System_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<System_Configuration_Prepend_Input>;
  _set?: Maybe<System_Configuration_Set_Input>;
  where: System_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationKeyArgs = {
  _set?: Maybe<System_ConfigurationKey_Set_Input>;
  where: System_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationKey_By_PkArgs = {
  _set?: Maybe<System_ConfigurationKey_Set_Input>;
  pk_columns: System_ConfigurationKey_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_System_Configuration_By_PkArgs = {
  _append?: Maybe<System_Configuration_Append_Input>;
  _delete_at_path?: Maybe<System_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<System_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<System_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<System_Configuration_Prepend_Input>;
  _set?: Maybe<System_Configuration_Set_Input>;
  pk_columns: System_Configuration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ChannelStackArgs = {
  _set?: Maybe<Video_ChannelStack_Set_Input>;
  where: Video_ChannelStack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ChannelStackWithStreamKeyArgs = {
  _set?: Maybe<Video_ChannelStackWithStreamKey_Set_Input>;
  where: Video_ChannelStackWithStreamKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ChannelStack_By_PkArgs = {
  _set?: Maybe<Video_ChannelStack_Set_Input>;
  pk_columns: Video_ChannelStack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventParticipantStreamArgs = {
  _set?: Maybe<Video_EventParticipantStream_Set_Input>;
  where: Video_EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventParticipantStream_By_PkArgs = {
  _set?: Maybe<Video_EventParticipantStream_Set_Input>;
  pk_columns: Video_EventParticipantStream_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventVonageSessionArgs = {
  _append?: Maybe<Video_EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<Video_EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<Video_EventVonageSession_Prepend_Input>;
  _set?: Maybe<Video_EventVonageSession_Set_Input>;
  where: Video_EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventVonageSession_By_PkArgs = {
  _append?: Maybe<Video_EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<Video_EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<Video_EventVonageSession_Prepend_Input>;
  _set?: Maybe<Video_EventVonageSession_Set_Input>;
  pk_columns: Video_EventVonageSession_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ImmediateSwitchArgs = {
  _append?: Maybe<Video_ImmediateSwitch_Append_Input>;
  _delete_at_path?: Maybe<Video_ImmediateSwitch_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_ImmediateSwitch_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_ImmediateSwitch_Delete_Key_Input>;
  _prepend?: Maybe<Video_ImmediateSwitch_Prepend_Input>;
  _set?: Maybe<Video_ImmediateSwitch_Set_Input>;
  where: Video_ImmediateSwitch_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ImmediateSwitch_By_PkArgs = {
  _append?: Maybe<Video_ImmediateSwitch_Append_Input>;
  _delete_at_path?: Maybe<Video_ImmediateSwitch_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_ImmediateSwitch_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_ImmediateSwitch_Delete_Key_Input>;
  _prepend?: Maybe<Video_ImmediateSwitch_Prepend_Input>;
  _set?: Maybe<Video_ImmediateSwitch_Set_Input>;
  pk_columns: Video_ImmediateSwitch_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_InputTypeArgs = {
  _set?: Maybe<Video_InputType_Set_Input>;
  where: Video_InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_InputType_By_PkArgs = {
  _set?: Maybe<Video_InputType_Set_Input>;
  pk_columns: Video_InputType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_JobStatusArgs = {
  _set?: Maybe<Video_JobStatus_Set_Input>;
  where: Video_JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_JobStatus_By_PkArgs = {
  _set?: Maybe<Video_JobStatus_Set_Input>;
  pk_columns: Video_JobStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_MediaLiveChannelStatusArgs = {
  _inc?: Maybe<Video_MediaLiveChannelStatus_Inc_Input>;
  _set?: Maybe<Video_MediaLiveChannelStatus_Set_Input>;
  where: Video_MediaLiveChannelStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_MediaLiveChannelStatus_By_PkArgs = {
  _inc?: Maybe<Video_MediaLiveChannelStatus_Inc_Input>;
  _set?: Maybe<Video_MediaLiveChannelStatus_Set_Input>;
  pk_columns: Video_MediaLiveChannelStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_RoomRtmpOutputArgs = {
  _set?: Maybe<Video_RoomRtmpOutput_Set_Input>;
  where: Video_RoomRtmpOutput_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_RoomRtmpOutput_By_PkArgs = {
  _set?: Maybe<Video_RoomRtmpOutput_Set_Input>;
  pk_columns: Video_RoomRtmpOutput_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_RtmpInputArgs = {
  _set?: Maybe<Video_RtmpInput_Set_Input>;
  where: Video_RtmpInput_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_RtmpInput_By_PkArgs = {
  _set?: Maybe<Video_RtmpInput_Set_Input>;
  pk_columns: Video_RtmpInput_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_TranscriptionJobArgs = {
  _set?: Maybe<Video_TranscriptionJob_Set_Input>;
  where: Video_TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_TranscriptionJob_By_PkArgs = {
  _set?: Maybe<Video_TranscriptionJob_Set_Input>;
  pk_columns: Video_TranscriptionJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_VideoRenderJobArgs = {
  _append?: Maybe<Video_VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<Video_VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<Video_VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<Video_VideoRenderJob_Prepend_Input>;
  _set?: Maybe<Video_VideoRenderJob_Set_Input>;
  where: Video_VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_VideoRenderJob_By_PkArgs = {
  _append?: Maybe<Video_VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<Video_VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<Video_VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<Video_VideoRenderJob_Prepend_Input>;
  _set?: Maybe<Video_VideoRenderJob_Set_Input>;
  pk_columns: Video_VideoRenderJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_VonageRoomRecordingArgs = {
  _set?: Maybe<Video_VonageRoomRecording_Set_Input>;
  where: Video_VonageRoomRecording_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_VonageRoomRecording_By_PkArgs = {
  _set?: Maybe<Video_VonageRoomRecording_Set_Input>;
  pk_columns: Video_VonageRoomRecording_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_YouTubeUploadArgs = {
  _set?: Maybe<Video_YouTubeUpload_Set_Input>;
  where: Video_YouTubeUpload_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_YouTubeUpload_By_PkArgs = {
  _set?: Maybe<Video_YouTubeUpload_Set_Input>;
  pk_columns: Video_YouTubeUpload_Pk_Columns_Input;
};


/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['numeric']>;
  readonly _gt?: Maybe<Scalars['numeric']>;
  readonly _gte?: Maybe<Scalars['numeric']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['numeric']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['numeric']>;
  readonly _lte?: Maybe<Scalars['numeric']>;
  readonly _neq?: Maybe<Scalars['numeric']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['numeric']>>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "permissions.Group" */
export type Permissions_Group = {
  readonly __typename?: 'permissions_Group';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly enabled: Scalars['Boolean'];
  /** An array relationship */
  readonly groupRegistrants: ReadonlyArray<Permissions_GroupRegistrant>;
  /** An aggregate relationship */
  readonly groupRegistrants_aggregate: Permissions_GroupRegistrant_Aggregate;
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<Permissions_GroupRole>;
  /** An aggregate relationship */
  readonly groupRoles_aggregate: Permissions_GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly includeUnauthenticated: Scalars['Boolean'];
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};

/** columns and relationships of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant = {
  readonly __typename?: 'permissions_GroupRegistrant';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Permissions_Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate = {
  readonly __typename?: 'permissions_GroupRegistrant_aggregate';
  readonly aggregate?: Maybe<Permissions_GroupRegistrant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_GroupRegistrant>;
};

/** aggregate fields of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate_Fields = {
  readonly __typename?: 'permissions_GroupRegistrant_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Permissions_GroupRegistrant_Max_Fields>;
  readonly min?: Maybe<Permissions_GroupRegistrant_Min_Fields>;
};


/** aggregate fields of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_GroupRegistrant_Max_Order_By>;
  readonly min?: Maybe<Permissions_GroupRegistrant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_GroupRegistrant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.GroupRegistrant". All fields are combined with a logical 'AND'. */
export type Permissions_GroupRegistrant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Bool_Exp>>;
  readonly _not?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Bool_Exp>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Permissions_Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.GroupRegistrant" */
export enum Permissions_GroupRegistrant_Constraint {
  /** unique or primary key constraint */
  GroupRegistrantGroupIdRegistrantIdKey = 'GroupRegistrant_groupId_registrantId_key',
  /** unique or primary key constraint */
  GroupRegistrantPkey = 'GroupRegistrant_pkey'
}

/** input type for inserting data into table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Permissions_Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_GroupRegistrant_Max_Fields = {
  readonly __typename?: 'permissions_GroupRegistrant_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_GroupRegistrant_Min_Fields = {
  readonly __typename?: 'permissions_GroupRegistrant_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Mutation_Response = {
  readonly __typename?: 'permissions_GroupRegistrant_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Permissions_GroupRegistrant>;
};

/** on conflict condition type for table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_On_Conflict = {
  readonly constraint: Permissions_GroupRegistrant_Constraint;
  readonly update_columns?: ReadonlyArray<Permissions_GroupRegistrant_Update_Column>;
  readonly where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};

/** Ordering options when selecting data from "permissions.GroupRegistrant". */
export type Permissions_GroupRegistrant_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Permissions_Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: permissions_GroupRegistrant */
export type Permissions_GroupRegistrant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.GroupRegistrant" */
export enum Permissions_GroupRegistrant_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.GroupRegistrant" */
export enum Permissions_GroupRegistrant_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "permissions.GroupRole" */
export type Permissions_GroupRole = {
  readonly __typename?: 'permissions_GroupRole';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Permissions_Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly role: Permissions_Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate = {
  readonly __typename?: 'permissions_GroupRole_aggregate';
  readonly aggregate?: Maybe<Permissions_GroupRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_GroupRole>;
};

/** aggregate fields of "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate_Fields = {
  readonly __typename?: 'permissions_GroupRole_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Permissions_GroupRole_Max_Fields>;
  readonly min?: Maybe<Permissions_GroupRole_Min_Fields>;
};


/** aggregate fields of "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_GroupRole_Max_Order_By>;
  readonly min?: Maybe<Permissions_GroupRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.GroupRole" */
export type Permissions_GroupRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_GroupRole_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_GroupRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.GroupRole". All fields are combined with a logical 'AND'. */
export type Permissions_GroupRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Permissions_GroupRole_Bool_Exp>>;
  readonly _not?: Maybe<Permissions_GroupRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Permissions_GroupRole_Bool_Exp>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Permissions_Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly role?: Maybe<Permissions_Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.GroupRole" */
export enum Permissions_GroupRole_Constraint {
  /** unique or primary key constraint */
  GroupRoleGroupIdRoleIdKey = 'GroupRole_groupId_roleId_key',
  /** unique or primary key constraint */
  GroupRolePkey = 'GroupRole_pkey'
}

/** input type for inserting data into table "permissions.GroupRole" */
export type Permissions_GroupRole_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Permissions_Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly role?: Maybe<Permissions_Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_GroupRole_Max_Fields = {
  readonly __typename?: 'permissions_GroupRole_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.GroupRole" */
export type Permissions_GroupRole_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_GroupRole_Min_Fields = {
  readonly __typename?: 'permissions_GroupRole_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.GroupRole" */
export type Permissions_GroupRole_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.GroupRole" */
export type Permissions_GroupRole_Mutation_Response = {
  readonly __typename?: 'permissions_GroupRole_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Permissions_GroupRole>;
};

/** on conflict condition type for table "permissions.GroupRole" */
export type Permissions_GroupRole_On_Conflict = {
  readonly constraint: Permissions_GroupRole_Constraint;
  readonly update_columns?: ReadonlyArray<Permissions_GroupRole_Update_Column>;
  readonly where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};

/** Ordering options when selecting data from "permissions.GroupRole". */
export type Permissions_GroupRole_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Permissions_Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly role?: Maybe<Permissions_Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: permissions_GroupRole */
export type Permissions_GroupRole_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.GroupRole" */
export enum Permissions_GroupRole_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.GroupRole" */
export type Permissions_GroupRole_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.GroupRole" */
export enum Permissions_GroupRole_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "permissions.Group" */
export type Permissions_Group_Aggregate = {
  readonly __typename?: 'permissions_Group_aggregate';
  readonly aggregate?: Maybe<Permissions_Group_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_Group>;
};

/** aggregate fields of "permissions.Group" */
export type Permissions_Group_Aggregate_Fields = {
  readonly __typename?: 'permissions_Group_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Permissions_Group_Max_Fields>;
  readonly min?: Maybe<Permissions_Group_Min_Fields>;
};


/** aggregate fields of "permissions.Group" */
export type Permissions_Group_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.Group" */
export type Permissions_Group_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_Group_Max_Order_By>;
  readonly min?: Maybe<Permissions_Group_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.Group" */
export type Permissions_Group_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_Group_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.Group". All fields are combined with a logical 'AND'. */
export type Permissions_Group_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Permissions_Group_Bool_Exp>>;
  readonly _not?: Maybe<Permissions_Group_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Permissions_Group_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly enabled?: Maybe<Boolean_Comparison_Exp>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly includeUnauthenticated?: Maybe<Boolean_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.Group" */
export enum Permissions_Group_Constraint {
  /** unique or primary key constraint */
  GroupConferenceIdNameKey = 'Group_conferenceId_name_key',
  /** unique or primary key constraint */
  GroupPkey = 'Group_pkey'
}

/** input type for inserting data into table "permissions.Group" */
export type Permissions_Group_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Arr_Rel_Insert_Input>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_Group_Max_Fields = {
  readonly __typename?: 'permissions_Group_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.Group" */
export type Permissions_Group_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_Group_Min_Fields = {
  readonly __typename?: 'permissions_Group_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.Group" */
export type Permissions_Group_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.Group" */
export type Permissions_Group_Mutation_Response = {
  readonly __typename?: 'permissions_Group_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Permissions_Group>;
};

/** input type for inserting object relation for remote table "permissions.Group" */
export type Permissions_Group_Obj_Rel_Insert_Input = {
  readonly data: Permissions_Group_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};

/** on conflict condition type for table "permissions.Group" */
export type Permissions_Group_On_Conflict = {
  readonly constraint: Permissions_Group_Constraint;
  readonly update_columns?: ReadonlyArray<Permissions_Group_Update_Column>;
  readonly where?: Maybe<Permissions_Group_Bool_Exp>;
};

/** Ordering options when selecting data from "permissions.Group". */
export type Permissions_Group_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly enabled?: Maybe<Order_By>;
  readonly groupRegistrants_aggregate?: Maybe<Permissions_GroupRegistrant_Aggregate_Order_By>;
  readonly groupRoles_aggregate?: Maybe<Permissions_GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly includeUnauthenticated?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: permissions_Group */
export type Permissions_Group_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.Group" */
export enum Permissions_Group_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.Group" */
export type Permissions_Group_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.Group" */
export enum Permissions_Group_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "permissions.Permission" */
export type Permissions_Permission = {
  readonly __typename?: 'permissions_Permission';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<Permissions_RolePermission>;
  /** An aggregate relationship */
  readonly rolePermissions_aggregate: Permissions_RolePermission_Aggregate;
};


/** columns and relationships of "permissions.Permission" */
export type Permissions_PermissionRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** columns and relationships of "permissions.Permission" */
export type Permissions_PermissionRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** aggregated selection of "permissions.Permission" */
export type Permissions_Permission_Aggregate = {
  readonly __typename?: 'permissions_Permission_aggregate';
  readonly aggregate?: Maybe<Permissions_Permission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_Permission>;
};

/** aggregate fields of "permissions.Permission" */
export type Permissions_Permission_Aggregate_Fields = {
  readonly __typename?: 'permissions_Permission_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Permissions_Permission_Max_Fields>;
  readonly min?: Maybe<Permissions_Permission_Min_Fields>;
};


/** aggregate fields of "permissions.Permission" */
export type Permissions_Permission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "permissions.Permission". All fields are combined with a logical 'AND'. */
export type Permissions_Permission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Permissions_Permission_Bool_Exp>>;
  readonly _not?: Maybe<Permissions_Permission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Permissions_Permission_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** unique or primary key constraints on table "permissions.Permission" */
export enum Permissions_Permission_Constraint {
  /** unique or primary key constraint */
  PermissionPkey = 'Permission_pkey'
}

export enum Permissions_Permission_Enum {
  /** Manage (create/update/delete) conference attendees. */
  ConferenceManageAttendees = 'CONFERENCE_MANAGE_ATTENDEES',
  /** Manage Content tables. */
  ConferenceManageContent = 'CONFERENCE_MANAGE_CONTENT',
  /** Manage groups of a conference. */
  ConferenceManageGroups = 'CONFERENCE_MANAGE_GROUPS',
  /** Manage (update only) conference name, short name and slug. */
  ConferenceManageName = 'CONFERENCE_MANAGE_NAME',
  /** Manage roles of a conference. */
  ConferenceManageRoles = 'CONFERENCE_MANAGE_ROLES',
  /** Manage Schedule tables. */
  ConferenceManageSchedule = 'CONFERENCE_MANAGE_SCHEDULE',
  /** Manage shuffle periods. */
  ConferenceManageShuffle = 'CONFERENCE_MANAGE_SHUFFLE',
  /** Moderate (update only) conference attendees. */
  ConferenceModerateAttendees = 'CONFERENCE_MODERATE_ATTENDEES',
  /** View the conference. */
  ConferenceView = 'CONFERENCE_VIEW',
  /** View conference attendees. */
  ConferenceViewAttendees = 'CONFERENCE_VIEW_ATTENDEES'
}

/** Boolean expression to compare columns of type "permissions_Permission_enum". All fields are combined with logical 'AND'. */
export type Permissions_Permission_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Permissions_Permission_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Permissions_Permission_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Permissions_Permission_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Permissions_Permission_Enum>>;
};

/** input type for inserting data into table "permissions.Permission" */
export type Permissions_Permission_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Permissions_Permission_Max_Fields = {
  readonly __typename?: 'permissions_Permission_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Permissions_Permission_Min_Fields = {
  readonly __typename?: 'permissions_Permission_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "permissions.Permission" */
export type Permissions_Permission_Mutation_Response = {
  readonly __typename?: 'permissions_Permission_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Permissions_Permission>;
};

/** input type for inserting object relation for remote table "permissions.Permission" */
export type Permissions_Permission_Obj_Rel_Insert_Input = {
  readonly data: Permissions_Permission_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_Permission_On_Conflict>;
};

/** on conflict condition type for table "permissions.Permission" */
export type Permissions_Permission_On_Conflict = {
  readonly constraint: Permissions_Permission_Constraint;
  readonly update_columns?: ReadonlyArray<Permissions_Permission_Update_Column>;
  readonly where?: Maybe<Permissions_Permission_Bool_Exp>;
};

/** Ordering options when selecting data from "permissions.Permission". */
export type Permissions_Permission_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<Permissions_RolePermission_Aggregate_Order_By>;
};

/** primary key columns input for table: permissions_Permission */
export type Permissions_Permission_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "permissions.Permission" */
export enum Permissions_Permission_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "permissions.Permission" */
export type Permissions_Permission_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "permissions.Permission" */
export enum Permissions_Permission_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "permissions.Role" */
export type Permissions_Role = {
  readonly __typename?: 'permissions_Role';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<Permissions_GroupRole>;
  /** An aggregate relationship */
  readonly groupRoles_aggregate: Permissions_GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<Permissions_RolePermission>;
  /** An aggregate relationship */
  readonly rolePermissions_aggregate: Permissions_RolePermission_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** columns and relationships of "permissions.RolePermission" */
export type Permissions_RolePermission = {
  readonly __typename?: 'permissions_RolePermission';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly permission: Permissions_Permission;
  readonly permissionName: Permissions_Permission_Enum;
  /** An object relationship */
  readonly role: Permissions_Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate = {
  readonly __typename?: 'permissions_RolePermission_aggregate';
  readonly aggregate?: Maybe<Permissions_RolePermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_RolePermission>;
};

/** aggregate fields of "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate_Fields = {
  readonly __typename?: 'permissions_RolePermission_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Permissions_RolePermission_Max_Fields>;
  readonly min?: Maybe<Permissions_RolePermission_Min_Fields>;
};


/** aggregate fields of "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_RolePermission_Max_Order_By>;
  readonly min?: Maybe<Permissions_RolePermission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.RolePermission" */
export type Permissions_RolePermission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_RolePermission_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_RolePermission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.RolePermission". All fields are combined with a logical 'AND'. */
export type Permissions_RolePermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Permissions_RolePermission_Bool_Exp>>;
  readonly _not?: Maybe<Permissions_RolePermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Permissions_RolePermission_Bool_Exp>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly permission?: Maybe<Permissions_Permission_Bool_Exp>;
  readonly permissionName?: Maybe<Permissions_Permission_Enum_Comparison_Exp>;
  readonly role?: Maybe<Permissions_Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.RolePermission" */
export enum Permissions_RolePermission_Constraint {
  /** unique or primary key constraint */
  RolePermissionPkey = 'RolePermission_pkey',
  /** unique or primary key constraint */
  RolePermissionRoleIdPermissionKey = 'RolePermission_roleId_permission_key'
}

/** input type for inserting data into table "permissions.RolePermission" */
export type Permissions_RolePermission_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permission?: Maybe<Permissions_Permission_Obj_Rel_Insert_Input>;
  readonly permissionName?: Maybe<Permissions_Permission_Enum>;
  readonly role?: Maybe<Permissions_Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_RolePermission_Max_Fields = {
  readonly __typename?: 'permissions_RolePermission_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.RolePermission" */
export type Permissions_RolePermission_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_RolePermission_Min_Fields = {
  readonly __typename?: 'permissions_RolePermission_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.RolePermission" */
export type Permissions_RolePermission_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.RolePermission" */
export type Permissions_RolePermission_Mutation_Response = {
  readonly __typename?: 'permissions_RolePermission_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Permissions_RolePermission>;
};

/** on conflict condition type for table "permissions.RolePermission" */
export type Permissions_RolePermission_On_Conflict = {
  readonly constraint: Permissions_RolePermission_Constraint;
  readonly update_columns?: ReadonlyArray<Permissions_RolePermission_Update_Column>;
  readonly where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** Ordering options when selecting data from "permissions.RolePermission". */
export type Permissions_RolePermission_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permission?: Maybe<Permissions_Permission_Order_By>;
  readonly permissionName?: Maybe<Order_By>;
  readonly role?: Maybe<Permissions_Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: permissions_RolePermission */
export type Permissions_RolePermission_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.RolePermission" */
export enum Permissions_RolePermission_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.RolePermission" */
export type Permissions_RolePermission_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionName?: Maybe<Permissions_Permission_Enum>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.RolePermission" */
export enum Permissions_RolePermission_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "permissions.Role" */
export type Permissions_Role_Aggregate = {
  readonly __typename?: 'permissions_Role_aggregate';
  readonly aggregate?: Maybe<Permissions_Role_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_Role>;
};

/** aggregate fields of "permissions.Role" */
export type Permissions_Role_Aggregate_Fields = {
  readonly __typename?: 'permissions_Role_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Permissions_Role_Max_Fields>;
  readonly min?: Maybe<Permissions_Role_Min_Fields>;
};


/** aggregate fields of "permissions.Role" */
export type Permissions_Role_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.Role" */
export type Permissions_Role_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_Role_Max_Order_By>;
  readonly min?: Maybe<Permissions_Role_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.Role" */
export type Permissions_Role_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_Role_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.Role". All fields are combined with a logical 'AND'. */
export type Permissions_Role_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Permissions_Role_Bool_Exp>>;
  readonly _not?: Maybe<Permissions_Role_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Permissions_Role_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.Role" */
export enum Permissions_Role_Constraint {
  /** unique or primary key constraint */
  RoleConferenceNameKey = 'Role_conference_name_key',
  /** unique or primary key constraint */
  RolePkey = 'Role_pkey'
}

/** input type for inserting data into table "permissions.Role" */
export type Permissions_Role_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_Role_Max_Fields = {
  readonly __typename?: 'permissions_Role_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.Role" */
export type Permissions_Role_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_Role_Min_Fields = {
  readonly __typename?: 'permissions_Role_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.Role" */
export type Permissions_Role_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.Role" */
export type Permissions_Role_Mutation_Response = {
  readonly __typename?: 'permissions_Role_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Permissions_Role>;
};

/** input type for inserting object relation for remote table "permissions.Role" */
export type Permissions_Role_Obj_Rel_Insert_Input = {
  readonly data: Permissions_Role_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};

/** on conflict condition type for table "permissions.Role" */
export type Permissions_Role_On_Conflict = {
  readonly constraint: Permissions_Role_Constraint;
  readonly update_columns?: ReadonlyArray<Permissions_Role_Update_Column>;
  readonly where?: Maybe<Permissions_Role_Bool_Exp>;
};

/** Ordering options when selecting data from "permissions.Role". */
export type Permissions_Role_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupRoles_aggregate?: Maybe<Permissions_GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<Permissions_RolePermission_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: permissions_Role */
export type Permissions_Role_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.Role" */
export enum Permissions_Role_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.Role" */
export type Permissions_Role_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.Role" */
export enum Permissions_Role_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type Query_Root = {
  readonly __typename?: 'query_root';
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription: ReadonlyArray<PushNotificationSubscription>;
  /** fetch aggregated fields from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription_aggregate: PushNotificationSubscription_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" using primary key columns */
  readonly PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "analytics.AppStats" */
  readonly analytics_AppStats: ReadonlyArray<Analytics_AppStats>;
  /** fetch aggregated fields from the table: "analytics.AppStats" */
  readonly analytics_AppStats_aggregate: Analytics_AppStats_Aggregate;
  /** fetch data from the table: "analytics.AppStats" using primary key columns */
  readonly analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** fetch data from the table: "analytics.CompletedRegistrations" */
  readonly analytics_CompletedRegistrations: ReadonlyArray<Analytics_CompletedRegistrations>;
  /** fetch aggregated fields from the table: "analytics.CompletedRegistrations" */
  readonly analytics_CompletedRegistrations_aggregate: Analytics_CompletedRegistrations_Aggregate;
  /** fetch data from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats: ReadonlyArray<Analytics_ContentElementStats>;
  /** fetch aggregated fields from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats_aggregate: Analytics_ContentElementStats_Aggregate;
  /** fetch data from the table: "analytics.ContentElementStats" using primary key columns */
  readonly analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** fetch data from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats: ReadonlyArray<Analytics_ContentItemStats>;
  /** fetch aggregated fields from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats_aggregate: Analytics_ContentItemStats_Aggregate;
  /** fetch data from the table: "analytics.ContentItemStats" using primary key columns */
  readonly analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** fetch data from the table: "analytics.ElementTotalViews" */
  readonly analytics_ElementTotalViews: ReadonlyArray<Analytics_ElementTotalViews>;
  /** fetch aggregated fields from the table: "analytics.ElementTotalViews" */
  readonly analytics_ElementTotalViews_aggregate: Analytics_ElementTotalViews_Aggregate;
  /** fetch data from the table: "analytics.ItemTotalViews" */
  readonly analytics_ItemTotalViews: ReadonlyArray<Analytics_ItemTotalViews>;
  /** fetch aggregated fields from the table: "analytics.ItemTotalViews" */
  readonly analytics_ItemTotalViews_aggregate: Analytics_ItemTotalViews_Aggregate;
  /** fetch data from the table: "analytics.RoomPresence" */
  readonly analytics_RoomPresence: ReadonlyArray<Analytics_RoomPresence>;
  /** fetch aggregated fields from the table: "analytics.RoomPresence" */
  readonly analytics_RoomPresence_aggregate: Analytics_RoomPresence_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats: ReadonlyArray<Analytics_RoomStats>;
  /** fetch aggregated fields from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats_aggregate: Analytics_RoomStats_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" using primary key columns */
  readonly analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** fetch data from the table: "analytics.mat_ElementTotalViews" */
  readonly analytics_mat_ElementTotalViews: ReadonlyArray<Analytics_Mat_ElementTotalViews>;
  /** fetch aggregated fields from the table: "analytics.mat_ElementTotalViews" */
  readonly analytics_mat_ElementTotalViews_aggregate: Analytics_Mat_ElementTotalViews_Aggregate;
  /** fetch data from the table: "analytics.mat_ItemTotalViews" */
  readonly analytics_mat_ItemTotalViews: ReadonlyArray<Analytics_Mat_ItemTotalViews>;
  /** fetch aggregated fields from the table: "analytics.mat_ItemTotalViews" */
  readonly analytics_mat_ItemTotalViews_aggregate: Analytics_Mat_ItemTotalViews_Aggregate;
  /** fetch data from the table: "analytics.mat_RoomPresence" */
  readonly analytics_mat_RoomPresence: ReadonlyArray<Analytics_Mat_RoomPresence>;
  /** fetch aggregated fields from the table: "analytics.mat_RoomPresence" */
  readonly analytics_mat_RoomPresence_aggregate: Analytics_Mat_RoomPresence_Aggregate;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** fetch data from the table: "collection.Exhibition" */
  readonly collection_Exhibition: ReadonlyArray<Collection_Exhibition>;
  /** fetch aggregated fields from the table: "collection.Exhibition" */
  readonly collection_Exhibition_aggregate: Collection_Exhibition_Aggregate;
  /** fetch data from the table: "collection.Exhibition" using primary key columns */
  readonly collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** fetch data from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson: ReadonlyArray<Collection_ProgramPerson>;
  /** fetch data from the table: "collection.ProgramPersonByAccessToken" */
  readonly collection_ProgramPersonByAccessToken: ReadonlyArray<Collection_ProgramPersonByAccessToken>;
  /** fetch aggregated fields from the table: "collection.ProgramPersonByAccessToken" */
  readonly collection_ProgramPersonByAccessToken_aggregate: Collection_ProgramPersonByAccessToken_Aggregate;
  /** fetch data from the table: "collection.ProgramPersonWithAccessToken" */
  readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<Collection_ProgramPersonWithAccessToken>;
  /** fetch aggregated fields from the table: "collection.ProgramPersonWithAccessToken" */
  readonly collection_ProgramPersonWithAccessToken_aggregate: Collection_ProgramPersonWithAccessToken_Aggregate;
  /** fetch aggregated fields from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson_aggregate: Collection_ProgramPerson_Aggregate;
  /** fetch data from the table: "collection.ProgramPerson" using primary key columns */
  readonly collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** fetch data from the table: "collection.Tag" */
  readonly collection_Tag: ReadonlyArray<Collection_Tag>;
  /** fetch aggregated fields from the table: "collection.Tag" */
  readonly collection_Tag_aggregate: Collection_Tag_Aggregate;
  /** fetch data from the table: "collection.Tag" using primary key columns */
  readonly collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** execute function "collection.searchProgramPerson" which returns "collection.ProgramPerson" */
  readonly collection_searchProgramPerson: ReadonlyArray<Collection_ProgramPerson>;
  /** execute function "collection.searchProgramPerson" and query aggregates on result of table type "collection.ProgramPerson" */
  readonly collection_searchProgramPerson_aggregate: Collection_ProgramPerson_Aggregate;
  /** fetch data from the table: "conference.Conference" */
  readonly conference_Conference: ReadonlyArray<Conference_Conference>;
  /** fetch aggregated fields from the table: "conference.Conference" */
  readonly conference_Conference_aggregate: Conference_Conference_Aggregate;
  /** fetch data from the table: "conference.Conference" using primary key columns */
  readonly conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** fetch data from the table: "conference.Configuration" */
  readonly conference_Configuration: ReadonlyArray<Conference_Configuration>;
  /** fetch data from the table: "conference.ConfigurationKey" */
  readonly conference_ConfigurationKey: ReadonlyArray<Conference_ConfigurationKey>;
  /** fetch aggregated fields from the table: "conference.ConfigurationKey" */
  readonly conference_ConfigurationKey_aggregate: Conference_ConfigurationKey_Aggregate;
  /** fetch data from the table: "conference.ConfigurationKey" using primary key columns */
  readonly conference_ConfigurationKey_by_pk?: Maybe<Conference_ConfigurationKey>;
  /** fetch aggregated fields from the table: "conference.Configuration" */
  readonly conference_Configuration_aggregate: Conference_Configuration_Aggregate;
  /** fetch data from the table: "conference.Configuration" using primary key columns */
  readonly conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** fetch data from the table: "conference.DemoCode" */
  readonly conference_DemoCode: ReadonlyArray<Conference_DemoCode>;
  /** fetch aggregated fields from the table: "conference.DemoCode" */
  readonly conference_DemoCode_aggregate: Conference_DemoCode_Aggregate;
  /** fetch data from the table: "conference.DemoCode" using primary key columns */
  readonly conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** fetch data from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData: ReadonlyArray<Conference_OriginatingData>;
  /** fetch aggregated fields from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData_aggregate: Conference_OriginatingData_Aggregate;
  /** fetch data from the table: "conference.OriginatingData" using primary key columns */
  readonly conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** fetch data from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob: ReadonlyArray<Conference_PrepareJob>;
  /** fetch aggregated fields from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob_aggregate: Conference_PrepareJob_Aggregate;
  /** fetch data from the table: "conference.PrepareJob" using primary key columns */
  readonly conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** fetch data from the table: "content.Element" */
  readonly content_Element: ReadonlyArray<Content_Element>;
  /** fetch data from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken: ReadonlyArray<Content_ElementByAccessToken>;
  /** fetch aggregated fields from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken_aggregate: Content_ElementByAccessToken_Aggregate;
  /** fetch data from the table: "content.ElementByPersonAccessToken" */
  readonly content_ElementByPersonAccessToken: ReadonlyArray<Content_ElementByPersonAccessToken>;
  /** fetch aggregated fields from the table: "content.ElementByPersonAccessToken" */
  readonly content_ElementByPersonAccessToken_aggregate: Content_ElementByPersonAccessToken_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant: ReadonlyArray<Content_ElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant_aggregate: Content_ElementPermissionGrant_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" using primary key columns */
  readonly content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** fetch data from the table: "content.ElementType" */
  readonly content_ElementType: ReadonlyArray<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.ElementType" */
  readonly content_ElementType_aggregate: Content_ElementType_Aggregate;
  /** fetch data from the table: "content.ElementType" using primary key columns */
  readonly content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.Element" */
  readonly content_Element_aggregate: Content_Element_Aggregate;
  /** fetch data from the table: "content.Element" using primary key columns */
  readonly content_Element_by_pk?: Maybe<Content_Element>;
  /** fetch data from the table: "content.Item" */
  readonly content_Item: ReadonlyArray<Content_Item>;
  /** fetch data from the table: "content.ItemByPersonAccessToken" */
  readonly content_ItemByPersonAccessToken: ReadonlyArray<Content_ItemByPersonAccessToken>;
  /** fetch aggregated fields from the table: "content.ItemByPersonAccessToken" */
  readonly content_ItemByPersonAccessToken_aggregate: Content_ItemByPersonAccessToken_Aggregate;
  /** fetch data from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition: ReadonlyArray<Content_ItemExhibition>;
  /** fetch aggregated fields from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition_aggregate: Content_ItemExhibition_Aggregate;
  /** fetch data from the table: "content.ItemExhibition" using primary key columns */
  readonly content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** fetch data from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson: ReadonlyArray<Content_ItemProgramPerson>;
  /** fetch data from the table: "content.ItemProgramPersonByAccessToken" */
  readonly content_ItemProgramPersonByAccessToken: ReadonlyArray<Content_ItemProgramPersonByAccessToken>;
  /** fetch aggregated fields from the table: "content.ItemProgramPersonByAccessToken" */
  readonly content_ItemProgramPersonByAccessToken_aggregate: Content_ItemProgramPersonByAccessToken_Aggregate;
  /** fetch aggregated fields from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson_aggregate: Content_ItemProgramPerson_Aggregate;
  /** fetch data from the table: "content.ItemProgramPerson" using primary key columns */
  readonly content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** fetch data from the table: "content.ItemTag" */
  readonly content_ItemTag: ReadonlyArray<Content_ItemTag>;
  /** fetch aggregated fields from the table: "content.ItemTag" */
  readonly content_ItemTag_aggregate: Content_ItemTag_Aggregate;
  /** fetch data from the table: "content.ItemTag" using primary key columns */
  readonly content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** fetch data from the table: "content.ItemType" */
  readonly content_ItemType: ReadonlyArray<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.ItemType" */
  readonly content_ItemType_aggregate: Content_ItemType_Aggregate;
  /** fetch data from the table: "content.ItemType" using primary key columns */
  readonly content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.Item" */
  readonly content_Item_aggregate: Content_Item_Aggregate;
  /** fetch data from the table: "content.Item" using primary key columns */
  readonly content_Item_by_pk?: Maybe<Content_Item>;
  /** fetch data from the table: "content.Uploader" */
  readonly content_Uploader: ReadonlyArray<Content_Uploader>;
  /** fetch aggregated fields from the table: "content.Uploader" */
  readonly content_Uploader_aggregate: Content_Uploader_Aggregate;
  /** fetch data from the table: "content.Uploader" using primary key columns */
  readonly content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** execute function "content.searchItems" which returns "content.Item" */
  readonly content_searchItems: ReadonlyArray<Content_Item>;
  /** execute function "content.searchItems" and query aggregates on result of table type "content.Item" */
  readonly content_searchItems_aggregate: Content_Item_Aggregate;
  readonly getProgramPersonAccessToken: MatchingPersonOutput;
  readonly getSlug: GetSlugOutput;
  readonly getUploadAgreement?: Maybe<GetUploadAgreementOutput>;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" using primary key columns */
  readonly job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob_aggregate: Job_Queues_ChannelStackDeleteJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" using primary key columns */
  readonly job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** fetch data from the table: "job_queues.ChannelStackUpdateJob" */
  readonly job_queues_ChannelStackUpdateJob: ReadonlyArray<Job_Queues_ChannelStackUpdateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackUpdateJob" */
  readonly job_queues_ChannelStackUpdateJob_aggregate: Job_Queues_ChannelStackUpdateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackUpdateJob" using primary key columns */
  readonly job_queues_ChannelStackUpdateJob_by_pk?: Maybe<Job_Queues_ChannelStackUpdateJob>;
  /** fetch data from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob: ReadonlyArray<Job_Queues_CombineVideosJob>;
  /** fetch aggregated fields from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob_aggregate: Job_Queues_CombineVideosJob_Aggregate;
  /** fetch data from the table: "job_queues.CombineVideosJob" using primary key columns */
  readonly job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** fetch data from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob: ReadonlyArray<Job_Queues_CustomEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob_aggregate: Job_Queues_CustomEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.CustomEmailJob" using primary key columns */
  readonly job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob_aggregate: Job_Queues_UploadYouTubeVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" using primary key columns */
  readonly job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch data from the table: "permissions.Group" */
  readonly permissions_Group: ReadonlyArray<Permissions_Group>;
  /** fetch data from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant: ReadonlyArray<Permissions_GroupRegistrant>;
  /** fetch aggregated fields from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant_aggregate: Permissions_GroupRegistrant_Aggregate;
  /** fetch data from the table: "permissions.GroupRegistrant" using primary key columns */
  readonly permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** fetch data from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole: ReadonlyArray<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole_aggregate: Permissions_GroupRole_Aggregate;
  /** fetch data from the table: "permissions.GroupRole" using primary key columns */
  readonly permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.Group" */
  readonly permissions_Group_aggregate: Permissions_Group_Aggregate;
  /** fetch data from the table: "permissions.Group" using primary key columns */
  readonly permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** fetch data from the table: "permissions.Permission" */
  readonly permissions_Permission: ReadonlyArray<Permissions_Permission>;
  /** fetch aggregated fields from the table: "permissions.Permission" */
  readonly permissions_Permission_aggregate: Permissions_Permission_Aggregate;
  /** fetch data from the table: "permissions.Permission" using primary key columns */
  readonly permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** fetch data from the table: "permissions.Role" */
  readonly permissions_Role: ReadonlyArray<Permissions_Role>;
  /** fetch data from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission: ReadonlyArray<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission_aggregate: Permissions_RolePermission_Aggregate;
  /** fetch data from the table: "permissions.RolePermission" using primary key columns */
  readonly permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.Role" */
  readonly permissions_Role_aggregate: Permissions_Role_Aggregate;
  /** fetch data from the table: "permissions.Role" using primary key columns */
  readonly permissions_Role_by_pk?: Maybe<Permissions_Role>;
  readonly presence_Summary?: Maybe<PresenceSummaryOutput>;
  /** fetch data from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount: ReadonlyArray<Registrant_GoogleAccount>;
  /** fetch aggregated fields from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount_aggregate: Registrant_GoogleAccount_Aggregate;
  /** fetch data from the table: "registrant.GoogleAccount" using primary key columns */
  readonly registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** fetch data from the table: "registrant.Invitation" */
  readonly registrant_Invitation: ReadonlyArray<Registrant_Invitation>;
  /** fetch aggregated fields from the table: "registrant.Invitation" */
  readonly registrant_Invitation_aggregate: Registrant_Invitation_Aggregate;
  /** fetch data from the table: "registrant.Invitation" using primary key columns */
  readonly registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** fetch data from the table: "registrant.Profile" */
  readonly registrant_Profile: ReadonlyArray<Registrant_Profile>;
  /** fetch data from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges: ReadonlyArray<Registrant_ProfileBadges>;
  /** fetch aggregated fields from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges_aggregate: Registrant_ProfileBadges_Aggregate;
  /** fetch aggregated fields from the table: "registrant.Profile" */
  readonly registrant_Profile_aggregate: Registrant_Profile_Aggregate;
  /** fetch data from the table: "registrant.Profile" using primary key columns */
  readonly registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** fetch data from the table: "registrant.Registrant" */
  readonly registrant_Registrant: ReadonlyArray<Registrant_Registrant>;
  /** fetch aggregated fields from the table: "registrant.Registrant" */
  readonly registrant_Registrant_aggregate: Registrant_Registrant_Aggregate;
  /** fetch data from the table: "registrant.Registrant" using primary key columns */
  readonly registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** fetch data from the table: "registrant.SavedVonageRoomRecording" */
  readonly registrant_SavedVonageRoomRecording: ReadonlyArray<Registrant_SavedVonageRoomRecording>;
  /** fetch aggregated fields from the table: "registrant.SavedVonageRoomRecording" */
  readonly registrant_SavedVonageRoomRecording_aggregate: Registrant_SavedVonageRoomRecording_Aggregate;
  /** fetch data from the table: "registrant.SavedVonageRoomRecording" using primary key columns */
  readonly registrant_SavedVonageRoomRecording_by_pk?: Maybe<Registrant_SavedVonageRoomRecording>;
  /** fetch data from the table: "room.Backend" */
  readonly room_Backend: ReadonlyArray<Room_Backend>;
  /** fetch aggregated fields from the table: "room.Backend" */
  readonly room_Backend_aggregate: Room_Backend_Aggregate;
  /** fetch data from the table: "room.Backend" using primary key columns */
  readonly room_Backend_by_pk?: Maybe<Room_Backend>;
  /** fetch data from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting: ReadonlyArray<Room_ChimeMeeting>;
  /** fetch aggregated fields from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting_aggregate: Room_ChimeMeeting_Aggregate;
  /** fetch data from the table: "room.ChimeMeeting" using primary key columns */
  readonly room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** fetch data from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations: ReadonlyArray<Room_LivestreamDurations>;
  /** fetch aggregated fields from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations_aggregate: Room_LivestreamDurations_Aggregate;
  /** fetch data from the table: "room.ManagementMode" */
  readonly room_ManagementMode: ReadonlyArray<Room_ManagementMode>;
  /** fetch aggregated fields from the table: "room.ManagementMode" */
  readonly room_ManagementMode_aggregate: Room_ManagementMode_Aggregate;
  /** fetch data from the table: "room.ManagementMode" using primary key columns */
  readonly room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** fetch data from the table: "room.Mode" */
  readonly room_Mode: ReadonlyArray<Room_Mode>;
  /** fetch aggregated fields from the table: "room.Mode" */
  readonly room_Mode_aggregate: Room_Mode_Aggregate;
  /** fetch data from the table: "room.Mode" using primary key columns */
  readonly room_Mode_by_pk?: Maybe<Room_Mode>;
  /** fetch data from the table: "room.Participant" */
  readonly room_Participant: ReadonlyArray<Room_Participant>;
  /** fetch aggregated fields from the table: "room.Participant" */
  readonly room_Participant_aggregate: Room_Participant_Aggregate;
  /** fetch data from the table: "room.Participant" using primary key columns */
  readonly room_Participant_by_pk?: Maybe<Room_Participant>;
  /** fetch data from the table: "room.PersonRole" */
  readonly room_PersonRole: ReadonlyArray<Room_PersonRole>;
  /** fetch aggregated fields from the table: "room.PersonRole" */
  readonly room_PersonRole_aggregate: Room_PersonRole_Aggregate;
  /** fetch data from the table: "room.PersonRole" using primary key columns */
  readonly room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** fetch data from the table: "room.Room" */
  readonly room_Room: ReadonlyArray<Room_Room>;
  /** fetch data from the table: "room.RoomPerson" */
  readonly room_RoomPerson: ReadonlyArray<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.RoomPerson" */
  readonly room_RoomPerson_aggregate: Room_RoomPerson_Aggregate;
  /** fetch data from the table: "room.RoomPerson" using primary key columns */
  readonly room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.Room" */
  readonly room_Room_aggregate: Room_Room_Aggregate;
  /** fetch data from the table: "room.Room" using primary key columns */
  readonly room_Room_by_pk?: Maybe<Room_Room>;
  /** fetch data from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm: ReadonlyArray<Room_ShuffleAlgorithm>;
  /** fetch aggregated fields from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm_aggregate: Room_ShuffleAlgorithm_Aggregate;
  /** fetch data from the table: "room.ShuffleAlgorithm" using primary key columns */
  readonly room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** fetch data from the table: "schedule.Continuation" */
  readonly schedule_Continuation: ReadonlyArray<Schedule_Continuation>;
  /** fetch aggregated fields from the table: "schedule.Continuation" */
  readonly schedule_Continuation_aggregate: Schedule_Continuation_Aggregate;
  /** fetch data from the table: "schedule.Continuation" using primary key columns */
  readonly schedule_Continuation_by_pk?: Maybe<Schedule_Continuation>;
  /** fetch data from the table: "schedule.Event" */
  readonly schedule_Event: ReadonlyArray<Schedule_Event>;
  /** fetch data from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson: ReadonlyArray<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole: ReadonlyArray<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole_aggregate: Schedule_EventProgramPersonRole_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPersonRole" using primary key columns */
  readonly schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson_aggregate: Schedule_EventProgramPerson_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPerson" using primary key columns */
  readonly schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventTag" */
  readonly schedule_EventTag: ReadonlyArray<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.EventTag" */
  readonly schedule_EventTag_aggregate: Schedule_EventTag_Aggregate;
  /** fetch data from the table: "schedule.EventTag" using primary key columns */
  readonly schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.Event" */
  readonly schedule_Event_aggregate: Schedule_Event_Aggregate;
  /** fetch data from the table: "schedule.Event" using primary key columns */
  readonly schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** fetch data from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents: ReadonlyArray<Schedule_OverlappingEvents>;
  /** fetch aggregated fields from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents_aggregate: Schedule_OverlappingEvents_Aggregate;
  /** fetch data from the table: "schedule.StarredEvent" */
  readonly schedule_StarredEvent: ReadonlyArray<Schedule_StarredEvent>;
  /** fetch aggregated fields from the table: "schedule.StarredEvent" */
  readonly schedule_StarredEvent_aggregate: Schedule_StarredEvent_Aggregate;
  /** fetch data from the table: "schedule.StarredEvent" using primary key columns */
  readonly schedule_StarredEvent_by_pk?: Maybe<Schedule_StarredEvent>;
  /** execute function "schedule.searchEvents" which returns "schedule.Event" */
  readonly schedule_searchEvents: ReadonlyArray<Schedule_Event>;
  /** execute function "schedule.searchEvents" and query aggregates on result of table type "schedule.Event" */
  readonly schedule_searchEvents_aggregate: Schedule_Event_Aggregate;
  /** fetch data from the table: "system.Configuration" */
  readonly system_Configuration: ReadonlyArray<System_Configuration>;
  /** fetch data from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey: ReadonlyArray<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey_aggregate: System_ConfigurationKey_Aggregate;
  /** fetch data from the table: "system.ConfigurationKey" using primary key columns */
  readonly system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.Configuration" */
  readonly system_Configuration_aggregate: System_Configuration_Aggregate;
  /** fetch data from the table: "system.Configuration" using primary key columns */
  readonly system_Configuration_by_pk?: Maybe<System_Configuration>;
  readonly vapidPublicKey: VapidPublicKeyOutput;
  /** fetch data from the table: "video.ChannelStack" */
  readonly video_ChannelStack: ReadonlyArray<Video_ChannelStack>;
  /** fetch data from the table: "video.ChannelStackWithStreamKey" */
  readonly video_ChannelStackWithStreamKey: ReadonlyArray<Video_ChannelStackWithStreamKey>;
  /** fetch aggregated fields from the table: "video.ChannelStackWithStreamKey" */
  readonly video_ChannelStackWithStreamKey_aggregate: Video_ChannelStackWithStreamKey_Aggregate;
  /** fetch aggregated fields from the table: "video.ChannelStack" */
  readonly video_ChannelStack_aggregate: Video_ChannelStack_Aggregate;
  /** fetch data from the table: "video.ChannelStack" using primary key columns */
  readonly video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** fetch data from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream: ReadonlyArray<Video_EventParticipantStream>;
  /** fetch aggregated fields from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream_aggregate: Video_EventParticipantStream_Aggregate;
  /** fetch data from the table: "video.EventParticipantStream" using primary key columns */
  readonly video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** fetch data from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession: ReadonlyArray<Video_EventVonageSession>;
  /** fetch aggregated fields from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession_aggregate: Video_EventVonageSession_Aggregate;
  /** fetch data from the table: "video.EventVonageSession" using primary key columns */
  readonly video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** fetch data from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch: ReadonlyArray<Video_ImmediateSwitch>;
  /** fetch aggregated fields from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch_aggregate: Video_ImmediateSwitch_Aggregate;
  /** fetch data from the table: "video.ImmediateSwitch" using primary key columns */
  readonly video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** fetch data from the table: "video.InputType" */
  readonly video_InputType: ReadonlyArray<Video_InputType>;
  /** fetch aggregated fields from the table: "video.InputType" */
  readonly video_InputType_aggregate: Video_InputType_Aggregate;
  /** fetch data from the table: "video.InputType" using primary key columns */
  readonly video_InputType_by_pk?: Maybe<Video_InputType>;
  /** fetch data from the table: "video.JobStatus" */
  readonly video_JobStatus: ReadonlyArray<Video_JobStatus>;
  /** fetch aggregated fields from the table: "video.JobStatus" */
  readonly video_JobStatus_aggregate: Video_JobStatus_Aggregate;
  /** fetch data from the table: "video.JobStatus" using primary key columns */
  readonly video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** fetch data from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus: ReadonlyArray<Video_MediaLiveChannelStatus>;
  /** fetch aggregated fields from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus_aggregate: Video_MediaLiveChannelStatus_Aggregate;
  /** fetch data from the table: "video.MediaLiveChannelStatus" using primary key columns */
  readonly video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** fetch data from the table: "video.RoomRtmpOutput" */
  readonly video_RoomRtmpOutput: ReadonlyArray<Video_RoomRtmpOutput>;
  /** fetch aggregated fields from the table: "video.RoomRtmpOutput" */
  readonly video_RoomRtmpOutput_aggregate: Video_RoomRtmpOutput_Aggregate;
  /** fetch data from the table: "video.RoomRtmpOutput" using primary key columns */
  readonly video_RoomRtmpOutput_by_pk?: Maybe<Video_RoomRtmpOutput>;
  /** fetch data from the table: "video.RtmpInput" */
  readonly video_RtmpInput: ReadonlyArray<Video_RtmpInput>;
  /** fetch aggregated fields from the table: "video.RtmpInput" */
  readonly video_RtmpInput_aggregate: Video_RtmpInput_Aggregate;
  /** fetch data from the table: "video.RtmpInput" using primary key columns */
  readonly video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** fetch data from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob: ReadonlyArray<Video_TranscriptionJob>;
  /** fetch aggregated fields from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob_aggregate: Video_TranscriptionJob_Aggregate;
  /** fetch data from the table: "video.TranscriptionJob" using primary key columns */
  readonly video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** fetch data from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob: ReadonlyArray<Video_VideoRenderJob>;
  /** fetch aggregated fields from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob_aggregate: Video_VideoRenderJob_Aggregate;
  /** fetch data from the table: "video.VideoRenderJob" using primary key columns */
  readonly video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** fetch data from the table: "video.VonageRoomRecording" */
  readonly video_VonageRoomRecording: ReadonlyArray<Video_VonageRoomRecording>;
  /** fetch aggregated fields from the table: "video.VonageRoomRecording" */
  readonly video_VonageRoomRecording_aggregate: Video_VonageRoomRecording_Aggregate;
  /** fetch data from the table: "video.VonageRoomRecording" using primary key columns */
  readonly video_VonageRoomRecording_by_pk?: Maybe<Video_VonageRoomRecording>;
  /** fetch data from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload: ReadonlyArray<Video_YouTubeUpload>;
  /** fetch aggregated fields from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload_aggregate: Video_YouTubeUpload_Aggregate;
  /** fetch data from the table: "video.YouTubeUpload" using primary key columns */
  readonly video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
};


export type Query_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


export type Query_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


export type Query_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


export type Query_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


export type Query_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


export type Query_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


export type Query_RootPushNotificationSubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


export type Query_RootPushNotificationSubscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


export type Query_RootPushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


export type Query_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


export type Query_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


export type Query_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


export type Query_RootAnalytics_AppStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


export type Query_RootAnalytics_AppStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


export type Query_RootAnalytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootAnalytics_CompletedRegistrationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Order_By>>;
  where?: Maybe<Analytics_CompletedRegistrations_Bool_Exp>;
};


export type Query_RootAnalytics_CompletedRegistrations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Order_By>>;
  where?: Maybe<Analytics_CompletedRegistrations_Bool_Exp>;
};


export type Query_RootAnalytics_ContentElementStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


export type Query_RootAnalytics_ContentElementStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


export type Query_RootAnalytics_ContentElementStats_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAnalytics_ContentItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


export type Query_RootAnalytics_ContentItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


export type Query_RootAnalytics_ContentItemStats_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAnalytics_ElementTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_ElementTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_ElementTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_ElementTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_ItemTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_ItemTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_ItemTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_ItemTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_RoomPresenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_RoomPresence_Bool_Exp>;
};


export type Query_RootAnalytics_RoomPresence_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_RoomPresence_Bool_Exp>;
};


export type Query_RootAnalytics_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


export type Query_RootAnalytics_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


export type Query_RootAnalytics_RoomStats_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootAnalytics_Mat_ElementTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ElementTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_Mat_ElementTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ElementTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_Mat_ItemTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ItemTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_Mat_ItemTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ItemTotalViews_Bool_Exp>;
};


export type Query_RootAnalytics_Mat_RoomPresenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_Mat_RoomPresence_Bool_Exp>;
};


export type Query_RootAnalytics_Mat_RoomPresence_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_Mat_RoomPresence_Bool_Exp>;
};


export type Query_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


export type Query_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


export type Query_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


export type Query_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


export type Query_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


export type Query_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


export type Query_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


export type Query_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


export type Query_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


export type Query_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


export type Query_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


export type Query_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


export type Query_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


export type Query_RootChat_Pin_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


export type Query_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


export type Query_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


export type Query_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


export type Query_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


export type Query_RootChat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


export type Query_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


export type Query_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


export type Query_RootChat_ReadUpToIndex_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


export type Query_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


export type Query_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


export type Query_RootChat_Subscription_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


export type Query_RootCollection_ExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


export type Query_RootCollection_Exhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


export type Query_RootCollection_Exhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCollection_ProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Query_RootCollection_ProgramPersonByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonByAccessToken_Bool_Exp>;
};


export type Query_RootCollection_ProgramPersonByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonByAccessToken_Bool_Exp>;
};


export type Query_RootCollection_ProgramPersonWithAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonWithAccessToken_Bool_Exp>;
};


export type Query_RootCollection_ProgramPersonWithAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonWithAccessToken_Bool_Exp>;
};


export type Query_RootCollection_ProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Query_RootCollection_ProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCollection_TagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


export type Query_RootCollection_Tag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


export type Query_RootCollection_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootCollection_SearchProgramPersonArgs = {
  args: Collection_SearchProgramPerson_Args;
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Query_RootCollection_SearchProgramPerson_AggregateArgs = {
  args: Collection_SearchProgramPerson_Args;
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Query_RootConference_ConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


export type Query_RootConference_Conference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


export type Query_RootConference_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootConference_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


export type Query_RootConference_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Order_By>>;
  where?: Maybe<Conference_ConfigurationKey_Bool_Exp>;
};


export type Query_RootConference_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Order_By>>;
  where?: Maybe<Conference_ConfigurationKey_Bool_Exp>;
};


export type Query_RootConference_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootConference_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


export type Query_RootConference_Configuration_By_PkArgs = {
  conferenceId: Scalars['uuid'];
  key: Conference_ConfigurationKey_Enum;
};


export type Query_RootConference_DemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


export type Query_RootConference_DemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


export type Query_RootConference_DemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootConference_OriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


export type Query_RootConference_OriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


export type Query_RootConference_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootConference_PrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


export type Query_RootConference_PrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


export type Query_RootConference_PrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_ElementArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


export type Query_RootContent_ElementByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


export type Query_RootContent_ElementByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


export type Query_RootContent_ElementByPersonAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
};


export type Query_RootContent_ElementByPersonAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
};


export type Query_RootContent_ElementPermissionGrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


export type Query_RootContent_ElementPermissionGrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


export type Query_RootContent_ElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_ElementTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


export type Query_RootContent_ElementType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


export type Query_RootContent_ElementType_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootContent_Element_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


export type Query_RootContent_Element_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_ItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Query_RootContent_ItemByPersonAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ItemByPersonAccessToken_Bool_Exp>;
};


export type Query_RootContent_ItemByPersonAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ItemByPersonAccessToken_Bool_Exp>;
};


export type Query_RootContent_ItemExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


export type Query_RootContent_ItemExhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


export type Query_RootContent_ItemExhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_ItemProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


export type Query_RootContent_ItemProgramPersonByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};


export type Query_RootContent_ItemProgramPersonByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};


export type Query_RootContent_ItemProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


export type Query_RootContent_ItemProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_ItemTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


export type Query_RootContent_ItemTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


export type Query_RootContent_ItemTag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_ItemTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


export type Query_RootContent_ItemType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


export type Query_RootContent_ItemType_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootContent_Item_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Query_RootContent_Item_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_UploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


export type Query_RootContent_Uploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


export type Query_RootContent_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootContent_SearchItemsArgs = {
  args: Content_SearchItems_Args;
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Query_RootContent_SearchItems_AggregateArgs = {
  args: Content_SearchItems_Args;
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Query_RootGetProgramPersonAccessTokenArgs = {
  elementAccessToken: Scalars['String'];
  elementId: Scalars['uuid'];
  uploaderEmail: Scalars['String'];
};


export type Query_RootGetSlugArgs = {
  url: Scalars['String'];
};


export type Query_RootGetUploadAgreementArgs = {
  magicToken: Scalars['String'];
};


export type Query_RootJob_Queues_ChannelStackCreateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


export type Query_RootJob_Queues_ChannelStackCreateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


export type Query_RootJob_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_ChannelStackDeleteJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


export type Query_RootJob_Queues_ChannelStackDeleteJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


export type Query_RootJob_Queues_ChannelStackDeleteJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_ChannelStackUpdateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};


export type Query_RootJob_Queues_ChannelStackUpdateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};


export type Query_RootJob_Queues_ChannelStackUpdateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_CombineVideosJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


export type Query_RootJob_Queues_CombineVideosJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


export type Query_RootJob_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_CustomEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


export type Query_RootJob_Queues_CustomEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


export type Query_RootJob_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


export type Query_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


export type Query_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


export type Query_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


export type Query_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


export type Query_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


export type Query_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


export type Query_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


export type Query_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootJob_Queues_UploadYouTubeVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


export type Query_RootJob_Queues_UploadYouTubeVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


export type Query_RootJob_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPermissions_GroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


export type Query_RootPermissions_GroupRegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


export type Query_RootPermissions_GroupRegistrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


export type Query_RootPermissions_GroupRegistrant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPermissions_GroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


export type Query_RootPermissions_GroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


export type Query_RootPermissions_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPermissions_Group_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


export type Query_RootPermissions_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPermissions_PermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


export type Query_RootPermissions_Permission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


export type Query_RootPermissions_Permission_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootPermissions_RoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


export type Query_RootPermissions_RolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


export type Query_RootPermissions_RolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


export type Query_RootPermissions_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootPermissions_Role_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


export type Query_RootPermissions_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRegistrant_GoogleAccountArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


export type Query_RootRegistrant_GoogleAccount_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


export type Query_RootRegistrant_GoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRegistrant_InvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


export type Query_RootRegistrant_Invitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


export type Query_RootRegistrant_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRegistrant_ProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


export type Query_RootRegistrant_ProfileBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


export type Query_RootRegistrant_ProfileBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


export type Query_RootRegistrant_Profile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


export type Query_RootRegistrant_Profile_By_PkArgs = {
  registrantId: Scalars['uuid'];
};


export type Query_RootRegistrant_RegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


export type Query_RootRegistrant_Registrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


export type Query_RootRegistrant_Registrant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRegistrant_SavedVonageRoomRecordingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Order_By>>;
  where?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
};


export type Query_RootRegistrant_SavedVonageRoomRecording_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Order_By>>;
  where?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
};


export type Query_RootRegistrant_SavedVonageRoomRecording_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRoom_BackendArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


export type Query_RootRoom_Backend_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


export type Query_RootRoom_Backend_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootRoom_ChimeMeetingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


export type Query_RootRoom_ChimeMeeting_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


export type Query_RootRoom_ChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRoom_LivestreamDurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


export type Query_RootRoom_LivestreamDurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


export type Query_RootRoom_ManagementModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


export type Query_RootRoom_ManagementMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


export type Query_RootRoom_ManagementMode_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootRoom_ModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


export type Query_RootRoom_Mode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


export type Query_RootRoom_Mode_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootRoom_ParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


export type Query_RootRoom_Participant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


export type Query_RootRoom_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRoom_PersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


export type Query_RootRoom_PersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


export type Query_RootRoom_PersonRole_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootRoom_RoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


export type Query_RootRoom_RoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


export type Query_RootRoom_RoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


export type Query_RootRoom_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRoom_Room_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


export type Query_RootRoom_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRoom_ShuffleAlgorithmArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


export type Query_RootRoom_ShuffleAlgorithm_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


export type Query_RootRoom_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


export type Query_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


export type Query_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


export type Query_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


export type Query_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


export type Query_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


export type Query_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootSchedule_ContinuationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


export type Query_RootSchedule_Continuation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


export type Query_RootSchedule_Continuation_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSchedule_EventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Query_RootSchedule_EventProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


export type Query_RootSchedule_EventProgramPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


export type Query_RootSchedule_EventProgramPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


export type Query_RootSchedule_EventProgramPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootSchedule_EventProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


export type Query_RootSchedule_EventProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSchedule_EventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


export type Query_RootSchedule_EventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


export type Query_RootSchedule_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSchedule_Event_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Query_RootSchedule_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSchedule_OverlappingEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


export type Query_RootSchedule_OverlappingEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


export type Query_RootSchedule_StarredEventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_StarredEvent_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_StarredEvent_Order_By>>;
  where?: Maybe<Schedule_StarredEvent_Bool_Exp>;
};


export type Query_RootSchedule_StarredEvent_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_StarredEvent_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_StarredEvent_Order_By>>;
  where?: Maybe<Schedule_StarredEvent_Bool_Exp>;
};


export type Query_RootSchedule_StarredEvent_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootSchedule_SearchEventsArgs = {
  args: Schedule_SearchEvents_Args;
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Query_RootSchedule_SearchEvents_AggregateArgs = {
  args: Schedule_SearchEvents_Args;
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Query_RootSystem_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


export type Query_RootSystem_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


export type Query_RootSystem_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


export type Query_RootSystem_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootSystem_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


export type Query_RootSystem_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};


export type Query_RootVideo_ChannelStackArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


export type Query_RootVideo_ChannelStackWithStreamKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Order_By>>;
  where?: Maybe<Video_ChannelStackWithStreamKey_Bool_Exp>;
};


export type Query_RootVideo_ChannelStackWithStreamKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Order_By>>;
  where?: Maybe<Video_ChannelStackWithStreamKey_Bool_Exp>;
};


export type Query_RootVideo_ChannelStack_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


export type Query_RootVideo_ChannelStack_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_EventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


export type Query_RootVideo_EventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


export type Query_RootVideo_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_EventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


export type Query_RootVideo_EventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


export type Query_RootVideo_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_ImmediateSwitchArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


export type Query_RootVideo_ImmediateSwitch_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


export type Query_RootVideo_ImmediateSwitch_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_InputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


export type Query_RootVideo_InputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


export type Query_RootVideo_InputType_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootVideo_JobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


export type Query_RootVideo_JobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


export type Query_RootVideo_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootVideo_MediaLiveChannelStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


export type Query_RootVideo_MediaLiveChannelStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


export type Query_RootVideo_MediaLiveChannelStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_RoomRtmpOutputArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Order_By>>;
  where?: Maybe<Video_RoomRtmpOutput_Bool_Exp>;
};


export type Query_RootVideo_RoomRtmpOutput_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Order_By>>;
  where?: Maybe<Video_RoomRtmpOutput_Bool_Exp>;
};


export type Query_RootVideo_RoomRtmpOutput_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_RtmpInputArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


export type Query_RootVideo_RtmpInput_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


export type Query_RootVideo_RtmpInput_By_PkArgs = {
  name: Scalars['String'];
};


export type Query_RootVideo_TranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


export type Query_RootVideo_TranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


export type Query_RootVideo_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_VideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


export type Query_RootVideo_VideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


export type Query_RootVideo_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_VonageRoomRecordingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Order_By>>;
  where?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};


export type Query_RootVideo_VonageRoomRecording_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Order_By>>;
  where?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};


export type Query_RootVideo_VonageRoomRecording_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Query_RootVideo_YouTubeUploadArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


export type Query_RootVideo_YouTubeUpload_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


export type Query_RootVideo_YouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};

/** columns and relationships of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount = {
  readonly __typename?: 'registrant_GoogleAccount';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly googleAccountEmail: Scalars['String'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly tokenData: Scalars['jsonb'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};


/** columns and relationships of "registrant.GoogleAccount" */
export type Registrant_GoogleAccountTokenDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.GoogleAccount" */
export type Registrant_GoogleAccountYouTubeDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Aggregate = {
  readonly __typename?: 'registrant_GoogleAccount_aggregate';
  readonly aggregate?: Maybe<Registrant_GoogleAccount_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_GoogleAccount>;
};

/** aggregate fields of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Aggregate_Fields = {
  readonly __typename?: 'registrant_GoogleAccount_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Registrant_GoogleAccount_Max_Fields>;
  readonly min?: Maybe<Registrant_GoogleAccount_Min_Fields>;
};


/** aggregate fields of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Registrant_GoogleAccount_Append_Input = {
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "registrant.GoogleAccount". All fields are combined with a logical 'AND'. */
export type Registrant_GoogleAccount_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Bool_Exp>>;
  readonly _not?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly googleAccountEmail?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly tokenData?: Maybe<Jsonb_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly youTubeData?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "registrant.GoogleAccount" */
export enum Registrant_GoogleAccount_Constraint {
  /** unique or primary key constraint */
  GoogleAccountPkey = 'GoogleAccount_pkey',
  /** unique or primary key constraint */
  GoogleAccountRegistrantIdGoogleAccountEmailKey = 'GoogleAccount_registrantId_googleAccountEmail_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Registrant_GoogleAccount_Delete_At_Path_Input = {
  readonly tokenData?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly youTubeData?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Registrant_GoogleAccount_Delete_Elem_Input = {
  readonly tokenData?: Maybe<Scalars['Int']>;
  readonly youTubeData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Registrant_GoogleAccount_Delete_Key_Input = {
  readonly tokenData?: Maybe<Scalars['String']>;
  readonly youTubeData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Registrant_GoogleAccount_Max_Fields = {
  readonly __typename?: 'registrant_GoogleAccount_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Registrant_GoogleAccount_Min_Fields = {
  readonly __typename?: 'registrant_GoogleAccount_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Mutation_Response = {
  readonly __typename?: 'registrant_GoogleAccount_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Registrant_GoogleAccount>;
};

/** input type for inserting object relation for remote table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Obj_Rel_Insert_Input = {
  readonly data: Registrant_GoogleAccount_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Registrant_GoogleAccount_On_Conflict>;
};

/** on conflict condition type for table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_On_Conflict = {
  readonly constraint: Registrant_GoogleAccount_Constraint;
  readonly update_columns?: ReadonlyArray<Registrant_GoogleAccount_Update_Column>;
  readonly where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};

/** Ordering options when selecting data from "registrant.GoogleAccount". */
export type Registrant_GoogleAccount_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly googleAccountEmail?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly tokenData?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly youTubeData?: Maybe<Order_By>;
};

/** primary key columns input for table: registrant_GoogleAccount */
export type Registrant_GoogleAccount_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Registrant_GoogleAccount_Prepend_Input = {
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "registrant.GoogleAccount" */
export enum Registrant_GoogleAccount_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GoogleAccountEmail = 'googleAccountEmail',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TokenData = 'tokenData',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  YouTubeData = 'youTubeData'
}

/** input type for updating data in table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "registrant.GoogleAccount" */
export enum Registrant_GoogleAccount_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GoogleAccountEmail = 'googleAccountEmail',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TokenData = 'tokenData',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  YouTubeData = 'youTubeData'
}

/** columns and relationships of "registrant.Invitation" */
export type Registrant_Invitation = {
  readonly __typename?: 'registrant_Invitation';
  readonly conferenceId: Scalars['uuid'];
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregate relationship */
  readonly emails_aggregate: Email_Aggregate;
  /** A computed field, executes function "registrant.invitationHash" */
  readonly hash?: Maybe<Scalars['String']>;
  readonly id: Scalars['uuid'];
  readonly inviteCode: Scalars['uuid'];
  readonly invitedEmailAddress: Scalars['String'];
  readonly linkToUserId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
};


/** columns and relationships of "registrant.Invitation" */
export type Registrant_InvitationEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "registrant.Invitation" */
export type Registrant_InvitationEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};

/** aggregated selection of "registrant.Invitation" */
export type Registrant_Invitation_Aggregate = {
  readonly __typename?: 'registrant_Invitation_aggregate';
  readonly aggregate?: Maybe<Registrant_Invitation_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_Invitation>;
};

/** aggregate fields of "registrant.Invitation" */
export type Registrant_Invitation_Aggregate_Fields = {
  readonly __typename?: 'registrant_Invitation_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Registrant_Invitation_Max_Fields>;
  readonly min?: Maybe<Registrant_Invitation_Min_Fields>;
};


/** aggregate fields of "registrant.Invitation" */
export type Registrant_Invitation_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.Invitation" */
export type Registrant_Invitation_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_Invitation_Max_Order_By>;
  readonly min?: Maybe<Registrant_Invitation_Min_Order_By>;
};

/** input type for inserting array relation for remote table "registrant.Invitation" */
export type Registrant_Invitation_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_Invitation_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};

/** Boolean expression to filter rows from the table "registrant.Invitation". All fields are combined with a logical 'AND'. */
export type Registrant_Invitation_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Registrant_Invitation_Bool_Exp>>;
  readonly _not?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Registrant_Invitation_Bool_Exp>>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly confirmationCode?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly hash?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly inviteCode?: Maybe<Uuid_Comparison_Exp>;
  readonly invitedEmailAddress?: Maybe<String_Comparison_Exp>;
  readonly linkToUserId?: Maybe<String_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
};

/** unique or primary key constraints on table "registrant.Invitation" */
export enum Registrant_Invitation_Constraint {
  /** unique or primary key constraint */
  InvitationConfirmationCodeKey = 'Invitation_confirmationCode_key',
  /** unique or primary key constraint */
  InvitationInviteCodeKey = 'Invitation_inviteCode_key',
  /** unique or primary key constraint */
  InvitationInvitedEmailAddressConferenceIdKey = 'Invitation_invitedEmailAddress_conferenceId_key',
  /** unique or primary key constraint */
  InvitationPkey = 'Invitation_pkey',
  /** unique or primary key constraint */
  InvitationRegistrantIdKey = 'Invitation_registrantId_key'
}

/** input type for inserting data into table "registrant.Invitation" */
export type Registrant_Invitation_Insert_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Registrant_Invitation_Max_Fields = {
  readonly __typename?: 'registrant_Invitation_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "registrant.Invitation" */
export type Registrant_Invitation_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_Invitation_Min_Fields = {
  readonly __typename?: 'registrant_Invitation_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "registrant.Invitation" */
export type Registrant_Invitation_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "registrant.Invitation" */
export type Registrant_Invitation_Mutation_Response = {
  readonly __typename?: 'registrant_Invitation_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Registrant_Invitation>;
};

/** input type for inserting object relation for remote table "registrant.Invitation" */
export type Registrant_Invitation_Obj_Rel_Insert_Input = {
  readonly data: Registrant_Invitation_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};

/** on conflict condition type for table "registrant.Invitation" */
export type Registrant_Invitation_On_Conflict = {
  readonly constraint: Registrant_Invitation_Constraint;
  readonly update_columns?: ReadonlyArray<Registrant_Invitation_Update_Column>;
  readonly where?: Maybe<Registrant_Invitation_Bool_Exp>;
};

/** Ordering options when selecting data from "registrant.Invitation". */
export type Registrant_Invitation_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly hash?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
};

/** primary key columns input for table: registrant_Invitation */
export type Registrant_Invitation_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "registrant.Invitation" */
export enum Registrant_Invitation_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "registrant.Invitation" */
export type Registrant_Invitation_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "registrant.Invitation" */
export enum Registrant_Invitation_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "registrant.Profile" */
export type Registrant_Profile = {
  readonly __typename?: 'registrant_Profile';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at: Scalars['timestamptz'];
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited: Scalars['Boolean'];
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
  readonly website?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.Profile" */
export type Registrant_ProfileBadgesArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.Profile" */
export type Registrant_ProfilePronounsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges = {
  readonly __typename?: 'registrant_ProfileBadges';
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate = {
  readonly __typename?: 'registrant_ProfileBadges_aggregate';
  readonly aggregate?: Maybe<Registrant_ProfileBadges_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_ProfileBadges>;
};

/** aggregate fields of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate_Fields = {
  readonly __typename?: 'registrant_ProfileBadges_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Registrant_ProfileBadges_Max_Fields>;
  readonly min?: Maybe<Registrant_ProfileBadges_Min_Fields>;
};


/** aggregate fields of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_ProfileBadges_Max_Order_By>;
  readonly min?: Maybe<Registrant_ProfileBadges_Min_Order_By>;
};

/** input type for inserting array relation for remote table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_ProfileBadges_Insert_Input>;
};

/** Boolean expression to filter rows from the table "registrant.ProfileBadges". All fields are combined with a logical 'AND'. */
export type Registrant_ProfileBadges_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Bool_Exp>>;
  readonly _not?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Bool_Exp>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
};

/** input type for inserting data into table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Registrant_ProfileBadges_Max_Fields = {
  readonly __typename?: 'registrant_ProfileBadges_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_ProfileBadges_Min_Fields = {
  readonly __typename?: 'registrant_ProfileBadges_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** Ordering options when selecting data from "registrant.ProfileBadges". */
export type Registrant_ProfileBadges_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** select columns of table "registrant.ProfileBadges" */
export enum Registrant_ProfileBadges_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  Name = 'name',
  /** column name */
  RegistrantId = 'registrantId'
}

/** aggregated selection of "registrant.Profile" */
export type Registrant_Profile_Aggregate = {
  readonly __typename?: 'registrant_Profile_aggregate';
  readonly aggregate?: Maybe<Registrant_Profile_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_Profile>;
};

/** aggregate fields of "registrant.Profile" */
export type Registrant_Profile_Aggregate_Fields = {
  readonly __typename?: 'registrant_Profile_aggregate_fields';
  readonly avg?: Maybe<Registrant_Profile_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Registrant_Profile_Max_Fields>;
  readonly min?: Maybe<Registrant_Profile_Min_Fields>;
  readonly stddev?: Maybe<Registrant_Profile_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Registrant_Profile_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Registrant_Profile_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Registrant_Profile_Sum_Fields>;
  readonly var_pop?: Maybe<Registrant_Profile_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Registrant_Profile_Var_Samp_Fields>;
  readonly variance?: Maybe<Registrant_Profile_Variance_Fields>;
};


/** aggregate fields of "registrant.Profile" */
export type Registrant_Profile_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Registrant_Profile_Append_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** aggregate avg on columns */
export type Registrant_Profile_Avg_Fields = {
  readonly __typename?: 'registrant_Profile_avg_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "registrant.Profile". All fields are combined with a logical 'AND'. */
export type Registrant_Profile_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Registrant_Profile_Bool_Exp>>;
  readonly _not?: Maybe<Registrant_Profile_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Registrant_Profile_Bool_Exp>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly affiliationURL?: Maybe<String_Comparison_Exp>;
  readonly badges?: Maybe<Jsonb_Comparison_Exp>;
  readonly bio?: Maybe<String_Comparison_Exp>;
  readonly country?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly github?: Maybe<String_Comparison_Exp>;
  readonly hasBeenEdited?: Maybe<Boolean_Comparison_Exp>;
  readonly photoS3BucketName?: Maybe<String_Comparison_Exp>;
  readonly photoS3BucketRegion?: Maybe<String_Comparison_Exp>;
  readonly photoS3ObjectName?: Maybe<String_Comparison_Exp>;
  readonly photoURL_350x350?: Maybe<String_Comparison_Exp>;
  readonly photoURL_50x50?: Maybe<String_Comparison_Exp>;
  readonly pronouns?: Maybe<Jsonb_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly timezoneUTCOffset?: Maybe<Float_Comparison_Exp>;
  readonly twitter?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly website?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "registrant.Profile" */
export enum Registrant_Profile_Constraint {
  /** unique or primary key constraint */
  ProfilePkey = 'Profile_pkey',
  /** unique or primary key constraint */
  ProfileRegistrantIdKey = 'Profile_registrantId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Registrant_Profile_Delete_At_Path_Input = {
  readonly badges?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly pronouns?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Registrant_Profile_Delete_Elem_Input = {
  readonly badges?: Maybe<Scalars['Int']>;
  readonly pronouns?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Registrant_Profile_Delete_Key_Input = {
  readonly badges?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "registrant.Profile" */
export type Registrant_Profile_Inc_Input = {
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** input type for inserting data into table "registrant.Profile" */
export type Registrant_Profile_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Registrant_Profile_Max_Fields = {
  readonly __typename?: 'registrant_Profile_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Registrant_Profile_Min_Fields = {
  readonly __typename?: 'registrant_Profile_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "registrant.Profile" */
export type Registrant_Profile_Mutation_Response = {
  readonly __typename?: 'registrant_Profile_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Registrant_Profile>;
};

/** input type for inserting object relation for remote table "registrant.Profile" */
export type Registrant_Profile_Obj_Rel_Insert_Input = {
  readonly data: Registrant_Profile_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Registrant_Profile_On_Conflict>;
};

/** on conflict condition type for table "registrant.Profile" */
export type Registrant_Profile_On_Conflict = {
  readonly constraint: Registrant_Profile_Constraint;
  readonly update_columns?: ReadonlyArray<Registrant_Profile_Update_Column>;
  readonly where?: Maybe<Registrant_Profile_Bool_Exp>;
};

/** Ordering options when selecting data from "registrant.Profile". */
export type Registrant_Profile_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly badges?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly hasBeenEdited?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly pronouns?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** primary key columns input for table: registrant_Profile */
export type Registrant_Profile_Pk_Columns_Input = {
  readonly registrantId: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Registrant_Profile_Prepend_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "registrant.Profile" */
export enum Registrant_Profile_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** input type for updating data in table "registrant.Profile" */
export type Registrant_Profile_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Registrant_Profile_Stddev_Fields = {
  readonly __typename?: 'registrant_Profile_stddev_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Registrant_Profile_Stddev_Pop_Fields = {
  readonly __typename?: 'registrant_Profile_stddev_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Registrant_Profile_Stddev_Samp_Fields = {
  readonly __typename?: 'registrant_Profile_stddev_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Registrant_Profile_Sum_Fields = {
  readonly __typename?: 'registrant_Profile_sum_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** update columns of table "registrant.Profile" */
export enum Registrant_Profile_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** aggregate var_pop on columns */
export type Registrant_Profile_Var_Pop_Fields = {
  readonly __typename?: 'registrant_Profile_var_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Registrant_Profile_Var_Samp_Fields = {
  readonly __typename?: 'registrant_Profile_var_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Registrant_Profile_Variance_Fields = {
  readonly __typename?: 'registrant_Profile_variance_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "registrant.Registrant" */
export type Registrant_Registrant = {
  readonly __typename?: 'registrant_Registrant';
  /** An array relationship */
  readonly badges: ReadonlyArray<Registrant_ProfileBadges>;
  /** An aggregate relationship */
  readonly badges_aggregate: Registrant_ProfileBadges_Aggregate;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly displayName: Scalars['String'];
  /** An array relationship */
  readonly groupRegistrants: ReadonlyArray<Permissions_GroupRegistrant>;
  /** An aggregate relationship */
  readonly groupRegistrants_aggregate: Permissions_GroupRegistrant_Aggregate;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Registrant_Invitation>;
  /** A computed field, executes function "registrant.HasBeenInvited" */
  readonly inviteSent?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly profile?: Maybe<Registrant_Profile>;
  /** An array relationship */
  readonly programPeople: ReadonlyArray<Collection_ProgramPerson>;
  /** An aggregate relationship */
  readonly programPeople_aggregate: Collection_ProgramPerson_Aggregate;
  /** An array relationship */
  readonly roomParticipants: ReadonlyArray<Room_Participant>;
  /** An aggregate relationship */
  readonly roomParticipants_aggregate: Room_Participant_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantGroupRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantGroupRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantProgramPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantProgramPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantRoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantRoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};

/** aggregated selection of "registrant.Registrant" */
export type Registrant_Registrant_Aggregate = {
  readonly __typename?: 'registrant_Registrant_aggregate';
  readonly aggregate?: Maybe<Registrant_Registrant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_Registrant>;
};

/** aggregate fields of "registrant.Registrant" */
export type Registrant_Registrant_Aggregate_Fields = {
  readonly __typename?: 'registrant_Registrant_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Registrant_Registrant_Max_Fields>;
  readonly min?: Maybe<Registrant_Registrant_Min_Fields>;
};


/** aggregate fields of "registrant.Registrant" */
export type Registrant_Registrant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.Registrant" */
export type Registrant_Registrant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_Registrant_Max_Order_By>;
  readonly min?: Maybe<Registrant_Registrant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "registrant.Registrant" */
export type Registrant_Registrant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_Registrant_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "registrant.Registrant". All fields are combined with a logical 'AND'. */
export type Registrant_Registrant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Registrant_Registrant_Bool_Exp>>;
  readonly _not?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Registrant_Registrant_Bool_Exp>>;
  readonly badges?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly displayName?: Maybe<String_Comparison_Exp>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly inviteSent?: Maybe<Boolean_Comparison_Exp>;
  readonly profile?: Maybe<Registrant_Profile_Bool_Exp>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly roomParticipants?: Maybe<Room_Participant_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "registrant.Registrant" */
export enum Registrant_Registrant_Constraint {
  /** unique or primary key constraint */
  RegistrantConferenceIdUserIdKey = 'Registrant_conferenceId_userId_key',
  /** unique or primary key constraint */
  RegistrantPkey = 'Registrant_pkey'
}

/** input type for inserting data into table "registrant.Registrant" */
export type Registrant_Registrant_Insert_Input = {
  readonly badges?: Maybe<Registrant_ProfileBadges_Arr_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Registrant_Invitation_Obj_Rel_Insert_Input>;
  readonly profile?: Maybe<Registrant_Profile_Obj_Rel_Insert_Input>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Arr_Rel_Insert_Input>;
  readonly roomParticipants?: Maybe<Room_Participant_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Registrant_Registrant_Max_Fields = {
  readonly __typename?: 'registrant_Registrant_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "registrant.Registrant" */
export type Registrant_Registrant_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_Registrant_Min_Fields = {
  readonly __typename?: 'registrant_Registrant_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "registrant.Registrant" */
export type Registrant_Registrant_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "registrant.Registrant" */
export type Registrant_Registrant_Mutation_Response = {
  readonly __typename?: 'registrant_Registrant_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Registrant_Registrant>;
};

/** input type for inserting object relation for remote table "registrant.Registrant" */
export type Registrant_Registrant_Obj_Rel_Insert_Input = {
  readonly data: Registrant_Registrant_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};

/** on conflict condition type for table "registrant.Registrant" */
export type Registrant_Registrant_On_Conflict = {
  readonly constraint: Registrant_Registrant_Constraint;
  readonly update_columns?: ReadonlyArray<Registrant_Registrant_Update_Column>;
  readonly where?: Maybe<Registrant_Registrant_Bool_Exp>;
};

/** Ordering options when selecting data from "registrant.Registrant". */
export type Registrant_Registrant_Order_By = {
  readonly badges_aggregate?: Maybe<Registrant_ProfileBadges_Aggregate_Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly groupRegistrants_aggregate?: Maybe<Permissions_GroupRegistrant_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Registrant_Invitation_Order_By>;
  readonly inviteSent?: Maybe<Order_By>;
  readonly profile?: Maybe<Registrant_Profile_Order_By>;
  readonly programPeople_aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Order_By>;
  readonly roomParticipants_aggregate?: Maybe<Room_Participant_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: registrant_Registrant */
export type Registrant_Registrant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "registrant.Registrant" */
export enum Registrant_Registrant_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "registrant.Registrant" */
export type Registrant_Registrant_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "registrant.Registrant" */
export enum Registrant_Registrant_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** columns and relationships of "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording = {
  readonly __typename?: 'registrant_SavedVonageRoomRecording';
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  /** An object relationship */
  readonly recording: Video_VonageRoomRecording;
  readonly recordingId: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Aggregate = {
  readonly __typename?: 'registrant_SavedVonageRoomRecording_aggregate';
  readonly aggregate?: Maybe<Registrant_SavedVonageRoomRecording_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_SavedVonageRoomRecording>;
};

/** aggregate fields of "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Aggregate_Fields = {
  readonly __typename?: 'registrant_SavedVonageRoomRecording_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Registrant_SavedVonageRoomRecording_Max_Fields>;
  readonly min?: Maybe<Registrant_SavedVonageRoomRecording_Min_Fields>;
};


/** aggregate fields of "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_SavedVonageRoomRecording_Max_Order_By>;
  readonly min?: Maybe<Registrant_SavedVonageRoomRecording_Min_Order_By>;
};

/** input type for inserting array relation for remote table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_SavedVonageRoomRecording_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Registrant_SavedVonageRoomRecording_On_Conflict>;
};

/** Boolean expression to filter rows from the table "registrant.SavedVonageRoomRecording". All fields are combined with a logical 'AND'. */
export type Registrant_SavedVonageRoomRecording_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Bool_Exp>>;
  readonly _not?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly recording?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
  readonly recordingId?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "registrant.SavedVonageRoomRecording" */
export enum Registrant_SavedVonageRoomRecording_Constraint {
  /** unique or primary key constraint */
  SavedVonageRoomRecordingPkey = 'SavedVonageRoomRecording_pkey',
  /** unique or primary key constraint */
  SavedVonageRoomRecordingRecordingIdRegistrantIdKey = 'SavedVonageRoomRecording_recordingId_registrantId_key'
}

/** input type for inserting data into table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly recording?: Maybe<Video_VonageRoomRecording_Obj_Rel_Insert_Input>;
  readonly recordingId?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Registrant_SavedVonageRoomRecording_Max_Fields = {
  readonly __typename?: 'registrant_SavedVonageRoomRecording_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly recordingId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly recordingId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_SavedVonageRoomRecording_Min_Fields = {
  readonly __typename?: 'registrant_SavedVonageRoomRecording_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly recordingId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly recordingId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Mutation_Response = {
  readonly __typename?: 'registrant_SavedVonageRoomRecording_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Registrant_SavedVonageRoomRecording>;
};

/** on conflict condition type for table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_On_Conflict = {
  readonly constraint: Registrant_SavedVonageRoomRecording_Constraint;
  readonly update_columns?: ReadonlyArray<Registrant_SavedVonageRoomRecording_Update_Column>;
  readonly where?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
};

/** Ordering options when selecting data from "registrant.SavedVonageRoomRecording". */
export type Registrant_SavedVonageRoomRecording_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly recording?: Maybe<Video_VonageRoomRecording_Order_By>;
  readonly recordingId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: registrant_SavedVonageRoomRecording */
export type Registrant_SavedVonageRoomRecording_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "registrant.SavedVonageRoomRecording" */
export enum Registrant_SavedVonageRoomRecording_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  RecordingId = 'recordingId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "registrant.SavedVonageRoomRecording" */
export type Registrant_SavedVonageRoomRecording_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly recordingId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "registrant.SavedVonageRoomRecording" */
export enum Registrant_SavedVonageRoomRecording_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  RecordingId = 'recordingId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "room.Backend" */
export type Room_Backend = {
  readonly __typename?: 'room_Backend';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.Backend" */
export type Room_Backend_Aggregate = {
  readonly __typename?: 'room_Backend_aggregate';
  readonly aggregate?: Maybe<Room_Backend_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Backend>;
};

/** aggregate fields of "room.Backend" */
export type Room_Backend_Aggregate_Fields = {
  readonly __typename?: 'room_Backend_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_Backend_Max_Fields>;
  readonly min?: Maybe<Room_Backend_Min_Fields>;
};


/** aggregate fields of "room.Backend" */
export type Room_Backend_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "room.Backend". All fields are combined with a logical 'AND'. */
export type Room_Backend_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_Backend_Bool_Exp>>;
  readonly _not?: Maybe<Room_Backend_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_Backend_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.Backend" */
export enum Room_Backend_Constraint {
  /** unique or primary key constraint */
  VideoRoomBackendPkey = 'VideoRoomBackend_pkey'
}

export enum Room_Backend_Enum {
  /** AWS Chime SDK */
  Chime = 'CHIME',
  /** Vonage Video API */
  Vonage = 'VONAGE'
}

/** Boolean expression to compare columns of type "room_Backend_enum". All fields are combined with logical 'AND'. */
export type Room_Backend_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_Backend_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_Backend_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_Backend_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_Backend_Enum>>;
};

/** input type for inserting data into table "room.Backend" */
export type Room_Backend_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_Backend_Max_Fields = {
  readonly __typename?: 'room_Backend_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Room_Backend_Min_Fields = {
  readonly __typename?: 'room_Backend_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "room.Backend" */
export type Room_Backend_Mutation_Response = {
  readonly __typename?: 'room_Backend_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_Backend>;
};

/** on conflict condition type for table "room.Backend" */
export type Room_Backend_On_Conflict = {
  readonly constraint: Room_Backend_Constraint;
  readonly update_columns?: ReadonlyArray<Room_Backend_Update_Column>;
  readonly where?: Maybe<Room_Backend_Bool_Exp>;
};

/** Ordering options when selecting data from "room.Backend". */
export type Room_Backend_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: room_Backend */
export type Room_Backend_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.Backend" */
export enum Room_Backend_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.Backend" */
export type Room_Backend_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.Backend" */
export enum Room_Backend_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.ChimeMeeting" */
export type Room_ChimeMeeting = {
  readonly __typename?: 'room_ChimeMeeting';
  readonly chimeMeetingData: Scalars['jsonb'];
  readonly chimeMeetingId: Scalars['String'];
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "room.ChimeMeeting" */
export type Room_ChimeMeetingChimeMeetingDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "room.ChimeMeeting" */
export type Room_ChimeMeeting_Aggregate = {
  readonly __typename?: 'room_ChimeMeeting_aggregate';
  readonly aggregate?: Maybe<Room_ChimeMeeting_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ChimeMeeting>;
};

/** aggregate fields of "room.ChimeMeeting" */
export type Room_ChimeMeeting_Aggregate_Fields = {
  readonly __typename?: 'room_ChimeMeeting_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_ChimeMeeting_Max_Fields>;
  readonly min?: Maybe<Room_ChimeMeeting_Min_Fields>;
};


/** aggregate fields of "room.ChimeMeeting" */
export type Room_ChimeMeeting_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Room_ChimeMeeting_Append_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "room.ChimeMeeting". All fields are combined with a logical 'AND'. */
export type Room_ChimeMeeting_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_ChimeMeeting_Bool_Exp>>;
  readonly _not?: Maybe<Room_ChimeMeeting_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_ChimeMeeting_Bool_Exp>>;
  readonly chimeMeetingData?: Maybe<Jsonb_Comparison_Exp>;
  readonly chimeMeetingId?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ChimeMeeting" */
export enum Room_ChimeMeeting_Constraint {
  /** unique or primary key constraint */
  ChimeMeetingPkey = 'ChimeMeeting_pkey',
  /** unique or primary key constraint */
  ChimeMeetingRoomIdKey = 'ChimeMeeting_roomId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Room_ChimeMeeting_Delete_At_Path_Input = {
  readonly chimeMeetingData?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Room_ChimeMeeting_Delete_Elem_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Room_ChimeMeeting_Delete_Key_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Insert_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ChimeMeeting_Max_Fields = {
  readonly __typename?: 'room_ChimeMeeting_max_fields';
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Room_ChimeMeeting_Min_Fields = {
  readonly __typename?: 'room_ChimeMeeting_min_fields';
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Mutation_Response = {
  readonly __typename?: 'room_ChimeMeeting_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_ChimeMeeting>;
};

/** input type for inserting object relation for remote table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Obj_Rel_Insert_Input = {
  readonly data: Room_ChimeMeeting_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_ChimeMeeting_On_Conflict>;
};

/** on conflict condition type for table "room.ChimeMeeting" */
export type Room_ChimeMeeting_On_Conflict = {
  readonly constraint: Room_ChimeMeeting_Constraint;
  readonly update_columns?: ReadonlyArray<Room_ChimeMeeting_Update_Column>;
  readonly where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};

/** Ordering options when selecting data from "room.ChimeMeeting". */
export type Room_ChimeMeeting_Order_By = {
  readonly chimeMeetingData?: Maybe<Order_By>;
  readonly chimeMeetingId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: room_ChimeMeeting */
export type Room_ChimeMeeting_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Room_ChimeMeeting_Prepend_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "room.ChimeMeeting" */
export enum Room_ChimeMeeting_Select_Column {
  /** column name */
  ChimeMeetingData = 'chimeMeetingData',
  /** column name */
  ChimeMeetingId = 'chimeMeetingId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Set_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "room.ChimeMeeting" */
export enum Room_ChimeMeeting_Update_Column {
  /** column name */
  ChimeMeetingData = 'chimeMeetingData',
  /** column name */
  ChimeMeetingId = 'chimeMeetingId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "room.LivestreamDurations" */
export type Room_LivestreamDurations = {
  readonly __typename?: 'room_LivestreamDurations';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "room.LivestreamDurations" */
export type Room_LivestreamDurations_Aggregate = {
  readonly __typename?: 'room_LivestreamDurations_aggregate';
  readonly aggregate?: Maybe<Room_LivestreamDurations_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_LivestreamDurations>;
};

/** aggregate fields of "room.LivestreamDurations" */
export type Room_LivestreamDurations_Aggregate_Fields = {
  readonly __typename?: 'room_LivestreamDurations_aggregate_fields';
  readonly avg?: Maybe<Room_LivestreamDurations_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_LivestreamDurations_Max_Fields>;
  readonly min?: Maybe<Room_LivestreamDurations_Min_Fields>;
  readonly stddev?: Maybe<Room_LivestreamDurations_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_LivestreamDurations_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_LivestreamDurations_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_LivestreamDurations_Sum_Fields>;
  readonly var_pop?: Maybe<Room_LivestreamDurations_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_LivestreamDurations_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_LivestreamDurations_Variance_Fields>;
};


/** aggregate fields of "room.LivestreamDurations" */
export type Room_LivestreamDurations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Room_LivestreamDurations_Avg_Fields = {
  readonly __typename?: 'room_LivestreamDurations_avg_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "room.LivestreamDurations". All fields are combined with a logical 'AND'. */
export type Room_LivestreamDurations_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_LivestreamDurations_Bool_Exp>>;
  readonly _not?: Maybe<Room_LivestreamDurations_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_LivestreamDurations_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly sum?: Maybe<Bigint_Comparison_Exp>;
};

/** input type for inserting data into table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Room_LivestreamDurations_Max_Fields = {
  readonly __typename?: 'room_LivestreamDurations_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Room_LivestreamDurations_Min_Fields = {
  readonly __typename?: 'room_LivestreamDurations_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** input type for inserting object relation for remote table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Obj_Rel_Insert_Input = {
  readonly data: Room_LivestreamDurations_Insert_Input;
};

/** Ordering options when selecting data from "room.LivestreamDurations". */
export type Room_LivestreamDurations_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly sum?: Maybe<Order_By>;
};

/** select columns of table "room.LivestreamDurations" */
export enum Room_LivestreamDurations_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Sum = 'sum'
}

/** aggregate stddev on columns */
export type Room_LivestreamDurations_Stddev_Fields = {
  readonly __typename?: 'room_LivestreamDurations_stddev_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Room_LivestreamDurations_Stddev_Pop_Fields = {
  readonly __typename?: 'room_LivestreamDurations_stddev_pop_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Room_LivestreamDurations_Stddev_Samp_Fields = {
  readonly __typename?: 'room_LivestreamDurations_stddev_samp_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Room_LivestreamDurations_Sum_Fields = {
  readonly __typename?: 'room_LivestreamDurations_sum_fields';
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** aggregate var_pop on columns */
export type Room_LivestreamDurations_Var_Pop_Fields = {
  readonly __typename?: 'room_LivestreamDurations_var_pop_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Room_LivestreamDurations_Var_Samp_Fields = {
  readonly __typename?: 'room_LivestreamDurations_var_samp_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Room_LivestreamDurations_Variance_Fields = {
  readonly __typename?: 'room_LivestreamDurations_variance_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "room.ManagementMode" */
export type Room_ManagementMode = {
  readonly __typename?: 'room_ManagementMode';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.ManagementMode" */
export type Room_ManagementMode_Aggregate = {
  readonly __typename?: 'room_ManagementMode_aggregate';
  readonly aggregate?: Maybe<Room_ManagementMode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ManagementMode>;
};

/** aggregate fields of "room.ManagementMode" */
export type Room_ManagementMode_Aggregate_Fields = {
  readonly __typename?: 'room_ManagementMode_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_ManagementMode_Max_Fields>;
  readonly min?: Maybe<Room_ManagementMode_Min_Fields>;
};


/** aggregate fields of "room.ManagementMode" */
export type Room_ManagementMode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "room.ManagementMode". All fields are combined with a logical 'AND'. */
export type Room_ManagementMode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_ManagementMode_Bool_Exp>>;
  readonly _not?: Maybe<Room_ManagementMode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_ManagementMode_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ManagementMode" */
export enum Room_ManagementMode_Constraint {
  /** unique or primary key constraint */
  ManagementModePkey = 'ManagementMode_pkey'
}

export enum Room_ManagementMode_Enum {
  /** Room is a direct message between two attendees. No new attendees can be added. */
  Dm = 'DM',
  /** Room access is automatically controlled by the system. */
  Managed = 'MANAGED',
  /** Room is only visible to attendees who have been given access. New attendees can be added. */
  Private = 'PRIVATE',
  /** Room is visible to all attendees at the conference. */
  Public = 'PUBLIC'
}

/** Boolean expression to compare columns of type "room_ManagementMode_enum". All fields are combined with logical 'AND'. */
export type Room_ManagementMode_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_ManagementMode_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_ManagementMode_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_ManagementMode_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_ManagementMode_Enum>>;
};

/** input type for inserting data into table "room.ManagementMode" */
export type Room_ManagementMode_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_ManagementMode_Max_Fields = {
  readonly __typename?: 'room_ManagementMode_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Room_ManagementMode_Min_Fields = {
  readonly __typename?: 'room_ManagementMode_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "room.ManagementMode" */
export type Room_ManagementMode_Mutation_Response = {
  readonly __typename?: 'room_ManagementMode_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_ManagementMode>;
};

/** input type for inserting object relation for remote table "room.ManagementMode" */
export type Room_ManagementMode_Obj_Rel_Insert_Input = {
  readonly data: Room_ManagementMode_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_ManagementMode_On_Conflict>;
};

/** on conflict condition type for table "room.ManagementMode" */
export type Room_ManagementMode_On_Conflict = {
  readonly constraint: Room_ManagementMode_Constraint;
  readonly update_columns?: ReadonlyArray<Room_ManagementMode_Update_Column>;
  readonly where?: Maybe<Room_ManagementMode_Bool_Exp>;
};

/** Ordering options when selecting data from "room.ManagementMode". */
export type Room_ManagementMode_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: room_ManagementMode */
export type Room_ManagementMode_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.ManagementMode" */
export enum Room_ManagementMode_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.ManagementMode" */
export type Room_ManagementMode_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.ManagementMode" */
export enum Room_ManagementMode_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.Mode" */
export type Room_Mode = {
  readonly __typename?: 'room_Mode';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregate relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregate relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};

/** aggregated selection of "room.Mode" */
export type Room_Mode_Aggregate = {
  readonly __typename?: 'room_Mode_aggregate';
  readonly aggregate?: Maybe<Room_Mode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Mode>;
};

/** aggregate fields of "room.Mode" */
export type Room_Mode_Aggregate_Fields = {
  readonly __typename?: 'room_Mode_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_Mode_Max_Fields>;
  readonly min?: Maybe<Room_Mode_Min_Fields>;
};


/** aggregate fields of "room.Mode" */
export type Room_Mode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "room.Mode". All fields are combined with a logical 'AND'. */
export type Room_Mode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_Mode_Bool_Exp>>;
  readonly _not?: Maybe<Room_Mode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_Mode_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
};

/** unique or primary key constraints on table "room.Mode" */
export enum Room_Mode_Constraint {
  /** unique or primary key constraint */
  ModePkey = 'Mode_pkey'
}

export enum Room_Mode_Enum {
  /** An exhibition hall. */
  Exhibition = 'EXHIBITION',
  /** An empty room. */
  None = 'NONE',
  /** Pre-recorded content should be played out to attendees. The breakout and Q&A video chats may also be available to relevant users. */
  Prerecorded = 'PRERECORDED',
  /** A live presentation should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  Presentation = 'PRESENTATION',
  /** A live Q&A/discussion should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  QAndA = 'Q_AND_A',
  /** A shuffle queue. */
  Shuffle = 'SHUFFLE',
  /** Users may participate in the general video chat. */
  VideoChat = 'VIDEO_CHAT',
  /** An ordinary video from either a VIDEO_URL content element or a video uploaded to Clowdr. */
  VideoPlayer = 'VIDEO_PLAYER',
  /** Event is taking place in a Zoom room. */
  Zoom = 'ZOOM'
}

/** Boolean expression to compare columns of type "room_Mode_enum". All fields are combined with logical 'AND'. */
export type Room_Mode_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_Mode_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_Mode_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_Mode_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_Mode_Enum>>;
};

/** input type for inserting data into table "room.Mode" */
export type Room_Mode_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Room_Mode_Max_Fields = {
  readonly __typename?: 'room_Mode_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Room_Mode_Min_Fields = {
  readonly __typename?: 'room_Mode_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "room.Mode" */
export type Room_Mode_Mutation_Response = {
  readonly __typename?: 'room_Mode_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_Mode>;
};

/** input type for inserting object relation for remote table "room.Mode" */
export type Room_Mode_Obj_Rel_Insert_Input = {
  readonly data: Room_Mode_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_Mode_On_Conflict>;
};

/** on conflict condition type for table "room.Mode" */
export type Room_Mode_On_Conflict = {
  readonly constraint: Room_Mode_Constraint;
  readonly update_columns?: ReadonlyArray<Room_Mode_Update_Column>;
  readonly where?: Maybe<Room_Mode_Bool_Exp>;
};

/** Ordering options when selecting data from "room.Mode". */
export type Room_Mode_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
};

/** primary key columns input for table: room_Mode */
export type Room_Mode_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.Mode" */
export enum Room_Mode_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.Mode" */
export type Room_Mode_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.Mode" */
export enum Room_Mode_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.Participant" */
export type Room_Participant = {
  readonly __typename?: 'room_Participant';
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** aggregated selection of "room.Participant" */
export type Room_Participant_Aggregate = {
  readonly __typename?: 'room_Participant_aggregate';
  readonly aggregate?: Maybe<Room_Participant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Participant>;
};

/** aggregate fields of "room.Participant" */
export type Room_Participant_Aggregate_Fields = {
  readonly __typename?: 'room_Participant_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_Participant_Max_Fields>;
  readonly min?: Maybe<Room_Participant_Min_Fields>;
};


/** aggregate fields of "room.Participant" */
export type Room_Participant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.Participant" */
export type Room_Participant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Participant_Max_Order_By>;
  readonly min?: Maybe<Room_Participant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.Participant" */
export type Room_Participant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Participant_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_Participant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.Participant". All fields are combined with a logical 'AND'. */
export type Room_Participant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_Participant_Bool_Exp>>;
  readonly _not?: Maybe<Room_Participant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_Participant_Bool_Exp>>;
  readonly chimeRegistrantId?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.Participant" */
export enum Room_Participant_Constraint {
  /** unique or primary key constraint */
  ParticipantPkey = 'Participant_pkey',
  /** unique or primary key constraint */
  ParticipantRoomIdRegistrantIdKey = 'Participant_roomId_registrantId_key'
}

/** input type for inserting data into table "room.Participant" */
export type Room_Participant_Insert_Input = {
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_Participant_Max_Fields = {
  readonly __typename?: 'room_Participant_max_fields';
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.Participant" */
export type Room_Participant_Max_Order_By = {
  readonly chimeRegistrantId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Participant_Min_Fields = {
  readonly __typename?: 'room_Participant_min_fields';
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.Participant" */
export type Room_Participant_Min_Order_By = {
  readonly chimeRegistrantId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.Participant" */
export type Room_Participant_Mutation_Response = {
  readonly __typename?: 'room_Participant_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_Participant>;
};

/** on conflict condition type for table "room.Participant" */
export type Room_Participant_On_Conflict = {
  readonly constraint: Room_Participant_Constraint;
  readonly update_columns?: ReadonlyArray<Room_Participant_Update_Column>;
  readonly where?: Maybe<Room_Participant_Bool_Exp>;
};

/** Ordering options when selecting data from "room.Participant". */
export type Room_Participant_Order_By = {
  readonly chimeRegistrantId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** primary key columns input for table: room_Participant */
export type Room_Participant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.Participant" */
export enum Room_Participant_Select_Column {
  /** column name */
  ChimeRegistrantId = 'chimeRegistrantId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** input type for updating data in table "room.Participant" */
export type Room_Participant_Set_Input = {
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** update columns of table "room.Participant" */
export enum Room_Participant_Update_Column {
  /** column name */
  ChimeRegistrantId = 'chimeRegistrantId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** columns and relationships of "room.PersonRole" */
export type Room_PersonRole = {
  readonly __typename?: 'room_PersonRole';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.PersonRole" */
export type Room_PersonRole_Aggregate = {
  readonly __typename?: 'room_PersonRole_aggregate';
  readonly aggregate?: Maybe<Room_PersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_PersonRole>;
};

/** aggregate fields of "room.PersonRole" */
export type Room_PersonRole_Aggregate_Fields = {
  readonly __typename?: 'room_PersonRole_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_PersonRole_Max_Fields>;
  readonly min?: Maybe<Room_PersonRole_Min_Fields>;
};


/** aggregate fields of "room.PersonRole" */
export type Room_PersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "room.PersonRole". All fields are combined with a logical 'AND'. */
export type Room_PersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_PersonRole_Bool_Exp>>;
  readonly _not?: Maybe<Room_PersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_PersonRole_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.PersonRole" */
export enum Room_PersonRole_Constraint {
  /** unique or primary key constraint */
  PersonRolePkey = 'PersonRole_pkey'
}

export enum Room_PersonRole_Enum {
  /** User has control over the room. */
  Admin = 'ADMIN',
  /** User can participate in the room. */
  Participant = 'PARTICIPANT'
}

/** Boolean expression to compare columns of type "room_PersonRole_enum". All fields are combined with logical 'AND'. */
export type Room_PersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_PersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_PersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_PersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_PersonRole_Enum>>;
};

/** input type for inserting data into table "room.PersonRole" */
export type Room_PersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_PersonRole_Max_Fields = {
  readonly __typename?: 'room_PersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Room_PersonRole_Min_Fields = {
  readonly __typename?: 'room_PersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "room.PersonRole" */
export type Room_PersonRole_Mutation_Response = {
  readonly __typename?: 'room_PersonRole_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_PersonRole>;
};

/** input type for inserting object relation for remote table "room.PersonRole" */
export type Room_PersonRole_Obj_Rel_Insert_Input = {
  readonly data: Room_PersonRole_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_PersonRole_On_Conflict>;
};

/** on conflict condition type for table "room.PersonRole" */
export type Room_PersonRole_On_Conflict = {
  readonly constraint: Room_PersonRole_Constraint;
  readonly update_columns?: ReadonlyArray<Room_PersonRole_Update_Column>;
  readonly where?: Maybe<Room_PersonRole_Bool_Exp>;
};

/** Ordering options when selecting data from "room.PersonRole". */
export type Room_PersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: room_PersonRole */
export type Room_PersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.PersonRole" */
export enum Room_PersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.PersonRole" */
export type Room_PersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.PersonRole" */
export enum Room_PersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.Room" */
export type Room_Room = {
  readonly __typename?: 'room_Room';
  readonly backendName?: Maybe<Room_Backend_Enum>;
  readonly capacity?: Maybe<Scalars['Int']>;
  /** An object relationship */
  readonly channelStack?: Maybe<Video_ChannelStack>;
  /** An array relationship */
  readonly channelStackCreateJobs: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** An aggregate relationship */
  readonly channelStackCreateJobs_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** An object relationship */
  readonly channelStackWithStreamKey?: Maybe<Video_ChannelStackWithStreamKey>;
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting>;
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly currentMode: Room_Mode;
  readonly currentModeName: Room_Mode_Enum;
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregate relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly id: Scalars['uuid'];
  /** A computed field, executes function "room.IsProgramRoom" */
  readonly isProgramRoom?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly livestreamDuration?: Maybe<Room_LivestreamDurations>;
  /** An object relationship */
  readonly managementMode: Room_ManagementMode;
  readonly managementModeName: Room_ManagementMode_Enum;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingEvent?: Maybe<Schedule_Event>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingItem?: Maybe<Content_Item>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly participants: ReadonlyArray<Room_Participant>;
  /** An aggregate relationship */
  readonly participants_aggregate: Room_Participant_Aggregate;
  /** An array relationship */
  readonly presenceCounts: ReadonlyArray<Analytics_RoomPresence>;
  /** An aggregate relationship */
  readonly presenceCounts_aggregate: Analytics_RoomPresence_Aggregate;
  readonly priority: Scalars['Int'];
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly roomPeople: ReadonlyArray<Room_RoomPerson>;
  /** An aggregate relationship */
  readonly roomPeople_aggregate: Room_RoomPerson_Aggregate;
  /** An object relationship */
  readonly rtmpOutput?: Maybe<Video_RoomRtmpOutput>;
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregate relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  /** An array relationship */
  readonly stats: ReadonlyArray<Analytics_RoomStats>;
  /** An aggregate relationship */
  readonly stats_aggregate: Analytics_RoomStats_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
  /** An array relationship */
  readonly vonageRecordings: ReadonlyArray<Video_VonageRoomRecording>;
  /** An aggregate relationship */
  readonly vonageRecordings_aggregate: Video_VonageRoomRecording_Aggregate;
};


/** columns and relationships of "room.Room" */
export type Room_RoomChannelStackCreateJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomChannelStackCreateJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomPresenceCountsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_RoomPresence_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomPresenceCounts_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_RoomPresence_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomRoomPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomRoomPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomVonageRecordingsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Order_By>>;
  where?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomVonageRecordings_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Order_By>>;
  where?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};

/** columns and relationships of "room.RoomPerson" */
export type Room_RoomPerson = {
  readonly __typename?: 'room_RoomPerson';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly personRole: Room_PersonRole;
  readonly personRoleName: Room_PersonRole_Enum;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "room.RoomPerson" */
export type Room_RoomPerson_Aggregate = {
  readonly __typename?: 'room_RoomPerson_aggregate';
  readonly aggregate?: Maybe<Room_RoomPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_RoomPerson>;
};

/** aggregate fields of "room.RoomPerson" */
export type Room_RoomPerson_Aggregate_Fields = {
  readonly __typename?: 'room_RoomPerson_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_RoomPerson_Max_Fields>;
  readonly min?: Maybe<Room_RoomPerson_Min_Fields>;
};


/** aggregate fields of "room.RoomPerson" */
export type Room_RoomPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.RoomPerson" */
export type Room_RoomPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_RoomPerson_Max_Order_By>;
  readonly min?: Maybe<Room_RoomPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.RoomPerson" */
export type Room_RoomPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_RoomPerson_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_RoomPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.RoomPerson". All fields are combined with a logical 'AND'. */
export type Room_RoomPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_RoomPerson_Bool_Exp>>;
  readonly _not?: Maybe<Room_RoomPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_RoomPerson_Bool_Exp>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly personRole?: Maybe<Room_PersonRole_Bool_Exp>;
  readonly personRoleName?: Maybe<Room_PersonRole_Enum_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.RoomPerson" */
export enum Room_RoomPerson_Constraint {
  /** unique or primary key constraint */
  RoomPersonPkey = 'RoomPerson_pkey',
  /** unique or primary key constraint */
  RoomPersonRegistrantIdRoomIdKey = 'RoomPerson_registrantId_roomId_key'
}

/** input type for inserting data into table "room.RoomPerson" */
export type Room_RoomPerson_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personRole?: Maybe<Room_PersonRole_Obj_Rel_Insert_Input>;
  readonly personRoleName?: Maybe<Room_PersonRole_Enum>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_RoomPerson_Max_Fields = {
  readonly __typename?: 'room_RoomPerson_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.RoomPerson" */
export type Room_RoomPerson_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_RoomPerson_Min_Fields = {
  readonly __typename?: 'room_RoomPerson_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.RoomPerson" */
export type Room_RoomPerson_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.RoomPerson" */
export type Room_RoomPerson_Mutation_Response = {
  readonly __typename?: 'room_RoomPerson_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_RoomPerson>;
};

/** on conflict condition type for table "room.RoomPerson" */
export type Room_RoomPerson_On_Conflict = {
  readonly constraint: Room_RoomPerson_Constraint;
  readonly update_columns?: ReadonlyArray<Room_RoomPerson_Update_Column>;
  readonly where?: Maybe<Room_RoomPerson_Bool_Exp>;
};

/** Ordering options when selecting data from "room.RoomPerson". */
export type Room_RoomPerson_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personRole?: Maybe<Room_PersonRole_Order_By>;
  readonly personRoleName?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: room_RoomPerson */
export type Room_RoomPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.RoomPerson" */
export enum Room_RoomPerson_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PersonRoleName = 'personRoleName',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "room.RoomPerson" */
export type Room_RoomPerson_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personRoleName?: Maybe<Room_PersonRole_Enum>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "room.RoomPerson" */
export enum Room_RoomPerson_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PersonRoleName = 'personRoleName',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "room.Room" */
export type Room_Room_Aggregate = {
  readonly __typename?: 'room_Room_aggregate';
  readonly aggregate?: Maybe<Room_Room_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Room>;
};

/** aggregate fields of "room.Room" */
export type Room_Room_Aggregate_Fields = {
  readonly __typename?: 'room_Room_aggregate_fields';
  readonly avg?: Maybe<Room_Room_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_Room_Max_Fields>;
  readonly min?: Maybe<Room_Room_Min_Fields>;
  readonly stddev?: Maybe<Room_Room_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_Room_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_Room_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_Room_Sum_Fields>;
  readonly var_pop?: Maybe<Room_Room_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_Room_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_Room_Variance_Fields>;
};


/** aggregate fields of "room.Room" */
export type Room_Room_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.Room" */
export type Room_Room_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_Room_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Room_Max_Order_By>;
  readonly min?: Maybe<Room_Room_Min_Order_By>;
  readonly stddev?: Maybe<Room_Room_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_Room_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_Room_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_Room_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_Room_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_Room_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_Room_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.Room" */
export type Room_Room_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Room_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_Room_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_Room_Avg_Fields = {
  readonly __typename?: 'room_Room_avg_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.Room" */
export type Room_Room_Avg_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.Room". All fields are combined with a logical 'AND'. */
export type Room_Room_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_Room_Bool_Exp>>;
  readonly _not?: Maybe<Room_Room_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_Room_Bool_Exp>>;
  readonly backendName?: Maybe<Room_Backend_Enum_Comparison_Exp>;
  readonly capacity?: Maybe<Int_Comparison_Exp>;
  readonly channelStack?: Maybe<Video_ChannelStack_Bool_Exp>;
  readonly channelStackCreateJobs?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly channelStackWithStreamKey?: Maybe<Video_ChannelStackWithStreamKey_Bool_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting_Bool_Exp>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly currentMode?: Maybe<Room_Mode_Bool_Exp>;
  readonly currentModeName?: Maybe<Room_Mode_Enum_Comparison_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isProgramRoom?: Maybe<Boolean_Comparison_Exp>;
  readonly livestreamDuration?: Maybe<Room_LivestreamDurations_Bool_Exp>;
  readonly managementMode?: Maybe<Room_ManagementMode_Bool_Exp>;
  readonly managementModeName?: Maybe<Room_ManagementMode_Enum_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingEvent?: Maybe<Schedule_Event_Bool_Exp>;
  readonly originatingEventId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingItem?: Maybe<Content_Item_Bool_Exp>;
  readonly originatingItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly participants?: Maybe<Room_Participant_Bool_Exp>;
  readonly presenceCounts?: Maybe<Analytics_RoomPresence_Bool_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly publicVonageSessionId?: Maybe<String_Comparison_Exp>;
  readonly roomPeople?: Maybe<Room_RoomPerson_Bool_Exp>;
  readonly rtmpOutput?: Maybe<Video_RoomRtmpOutput_Bool_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly stats?: Maybe<Analytics_RoomStats_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageRecordings?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};

/** unique or primary key constraints on table "room.Room" */
export enum Room_Room_Constraint {
  /** unique or primary key constraint */
  RoomOriginatingEventIdKey = 'Room_originatingEventId_key',
  /** unique or primary key constraint */
  RoomPkey = 'Room_pkey'
}

/** input type for incrementing numeric columns in table "room.Room" */
export type Room_Room_Inc_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "room.Room" */
export type Room_Room_Insert_Input = {
  readonly backendName?: Maybe<Room_Backend_Enum>;
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly channelStack?: Maybe<Video_ChannelStack_Obj_Rel_Insert_Input>;
  readonly channelStackCreateJobs?: Maybe<Job_Queues_ChannelStackCreateJob_Arr_Rel_Insert_Input>;
  readonly channelStackWithStreamKey?: Maybe<Video_ChannelStackWithStreamKey_Obj_Rel_Insert_Input>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting_Obj_Rel_Insert_Input>;
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentMode?: Maybe<Room_Mode_Obj_Rel_Insert_Input>;
  readonly currentModeName?: Maybe<Room_Mode_Enum>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly livestreamDuration?: Maybe<Room_LivestreamDurations_Obj_Rel_Insert_Input>;
  readonly managementMode?: Maybe<Room_ManagementMode_Obj_Rel_Insert_Input>;
  readonly managementModeName?: Maybe<Room_ManagementMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEvent?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItem?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly participants?: Maybe<Room_Participant_Arr_Rel_Insert_Input>;
  readonly presenceCounts?: Maybe<Analytics_RoomPresence_Arr_Rel_Insert_Input>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly roomPeople?: Maybe<Room_RoomPerson_Arr_Rel_Insert_Input>;
  readonly rtmpOutput?: Maybe<Video_RoomRtmpOutput_Obj_Rel_Insert_Input>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly stats?: Maybe<Analytics_RoomStats_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly vonageRecordings?: Maybe<Video_VonageRoomRecording_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Room_Room_Max_Fields = {
  readonly __typename?: 'room_Room_max_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.Room" */
export type Room_Room_Max_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly originatingItemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Room_Min_Fields = {
  readonly __typename?: 'room_Room_min_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.Room" */
export type Room_Room_Min_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly originatingItemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.Room" */
export type Room_Room_Mutation_Response = {
  readonly __typename?: 'room_Room_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_Room>;
};

/** input type for inserting object relation for remote table "room.Room" */
export type Room_Room_Obj_Rel_Insert_Input = {
  readonly data: Room_Room_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_Room_On_Conflict>;
};

/** on conflict condition type for table "room.Room" */
export type Room_Room_On_Conflict = {
  readonly constraint: Room_Room_Constraint;
  readonly update_columns?: ReadonlyArray<Room_Room_Update_Column>;
  readonly where?: Maybe<Room_Room_Bool_Exp>;
};

/** Ordering options when selecting data from "room.Room". */
export type Room_Room_Order_By = {
  readonly backendName?: Maybe<Order_By>;
  readonly capacity?: Maybe<Order_By>;
  readonly channelStack?: Maybe<Video_ChannelStack_Order_By>;
  readonly channelStackCreateJobs_aggregate?: Maybe<Job_Queues_ChannelStackCreateJob_Aggregate_Order_By>;
  readonly channelStackWithStreamKey?: Maybe<Video_ChannelStackWithStreamKey_Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting_Order_By>;
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly currentMode?: Maybe<Room_Mode_Order_By>;
  readonly currentModeName?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isProgramRoom?: Maybe<Order_By>;
  readonly livestreamDuration?: Maybe<Room_LivestreamDurations_Order_By>;
  readonly managementMode?: Maybe<Room_ManagementMode_Order_By>;
  readonly managementModeName?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEvent?: Maybe<Schedule_Event_Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly originatingItem?: Maybe<Content_Item_Order_By>;
  readonly originatingItemId?: Maybe<Order_By>;
  readonly participants_aggregate?: Maybe<Room_Participant_Aggregate_Order_By>;
  readonly presenceCounts_aggregate?: Maybe<Analytics_RoomPresence_Aggregate_Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly roomPeople_aggregate?: Maybe<Room_RoomPerson_Aggregate_Order_By>;
  readonly rtmpOutput?: Maybe<Video_RoomRtmpOutput_Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly stats_aggregate?: Maybe<Analytics_RoomStats_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly vonageRecordings_aggregate?: Maybe<Video_VonageRoomRecording_Aggregate_Order_By>;
};

/** primary key columns input for table: room_Room */
export type Room_Room_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.Room" */
export enum Room_Room_Select_Column {
  /** column name */
  BackendName = 'backendName',
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  ManagementModeName = 'managementModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  OriginatingItemId = 'originatingItemId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.Room" */
export type Room_Room_Set_Input = {
  readonly backendName?: Maybe<Room_Backend_Enum>;
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentModeName?: Maybe<Room_Mode_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly managementModeName?: Maybe<Room_ManagementMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_Room_Stddev_Fields = {
  readonly __typename?: 'room_Room_stddev_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.Room" */
export type Room_Room_Stddev_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_Room_Stddev_Pop_Fields = {
  readonly __typename?: 'room_Room_stddev_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.Room" */
export type Room_Room_Stddev_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_Room_Stddev_Samp_Fields = {
  readonly __typename?: 'room_Room_stddev_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.Room" */
export type Room_Room_Stddev_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_Room_Sum_Fields = {
  readonly __typename?: 'room_Room_sum_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "room.Room" */
export type Room_Room_Sum_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "room.Room" */
export enum Room_Room_Update_Column {
  /** column name */
  BackendName = 'backendName',
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  ManagementModeName = 'managementModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  OriginatingItemId = 'originatingItemId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_Room_Var_Pop_Fields = {
  readonly __typename?: 'room_Room_var_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.Room" */
export type Room_Room_Var_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_Room_Var_Samp_Fields = {
  readonly __typename?: 'room_Room_var_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.Room" */
export type Room_Room_Var_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_Room_Variance_Fields = {
  readonly __typename?: 'room_Room_variance_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.Room" */
export type Room_Room_Variance_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm = {
  readonly __typename?: 'room_ShuffleAlgorithm';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate = {
  readonly __typename?: 'room_ShuffleAlgorithm_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleAlgorithm_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleAlgorithm>;
};

/** aggregate fields of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_ShuffleAlgorithm_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleAlgorithm_Min_Fields>;
};


/** aggregate fields of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "room.ShuffleAlgorithm". All fields are combined with a logical 'AND'. */
export type Room_ShuffleAlgorithm_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Bool_Exp>>;
  readonly _not?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Constraint {
  /** unique or primary key constraint */
  ShuffleAlgorithmPkey = 'ShuffleAlgorithm_pkey'
}

export enum Room_ShuffleAlgorithm_Enum {
  /** First-come, first-served with auto-created rooms. */
  Fcfs = 'fcfs',
  /** First-come, first-served with a fixed set of (manually created) rooms. Limits max participants. */
  FcfsFixedRooms = 'fcfs_fixed_rooms',
  /** No automation. Rooms and allocations controlled manually. */
  None = 'none'
}

/** Boolean expression to compare columns of type "room_ShuffleAlgorithm_enum". All fields are combined with logical 'AND'. */
export type Room_ShuffleAlgorithm_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Enum>>;
};

/** input type for inserting data into table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_ShuffleAlgorithm_Max_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Room_ShuffleAlgorithm_Min_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Mutation_Response = {
  readonly __typename?: 'room_ShuffleAlgorithm_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleAlgorithm>;
};

/** on conflict condition type for table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_On_Conflict = {
  readonly constraint: Room_ShuffleAlgorithm_Constraint;
  readonly update_columns?: ReadonlyArray<Room_ShuffleAlgorithm_Update_Column>;
  readonly where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};

/** Ordering options when selecting data from "room.ShuffleAlgorithm". */
export type Room_ShuffleAlgorithm_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: room_ShuffleAlgorithm */
export type Room_ShuffleAlgorithm_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriod = {
  readonly __typename?: 'room_ShufflePeriod';
  readonly algorithm: Room_ShuffleAlgorithm_Enum;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly endAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregate relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly id: Scalars['uuid'];
  readonly maxRegistrantsPerRoom: Scalars['Int'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly organiser: Registrant_Registrant;
  readonly organiserId: Scalars['uuid'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregate relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly roomDurationMinutes: Scalars['Int'];
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregate relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  readonly startAt: Scalars['timestamptz'];
  readonly targetRegistrantsPerRoom: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
  readonly waitRoomMaxDurationSeconds: Scalars['Int'];
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** aggregated selection of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate = {
  readonly __typename?: 'room_ShufflePeriod_aggregate';
  readonly aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShufflePeriod>;
};

/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Fields = {
  readonly __typename?: 'room_ShufflePeriod_aggregate_fields';
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_ShufflePeriod_Max_Fields>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Fields>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Fields>;
};


/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShufflePeriod_Max_Order_By>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShufflePeriod_Avg_Fields = {
  readonly __typename?: 'room_ShufflePeriod_avg_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Avg_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShufflePeriod". All fields are combined with a logical 'AND'. */
export type Room_ShufflePeriod_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_ShufflePeriod_Bool_Exp>>;
  readonly _not?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_ShufflePeriod_Bool_Exp>>;
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly maxRegistrantsPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly organiser?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly organiserId?: Maybe<Uuid_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly roomDurationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly startAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly targetRegistrantsPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Constraint {
  /** unique or primary key constraint */
  ShufflePeriodPkey = 'ShufflePeriod_pkey'
}

/** input type for incrementing numeric columns in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Inc_Input = {
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Insert_Input = {
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiser?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Room_ShufflePeriod_Max_Fields = {
  readonly __typename?: 'room_ShufflePeriod_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShufflePeriod_Min_Fields = {
  readonly __typename?: 'room_ShufflePeriod_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Mutation_Response = {
  readonly __typename?: 'room_ShufflePeriod_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_ShufflePeriod>;
};

/** input type for inserting object relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Obj_Rel_Insert_Input = {
  readonly data: Room_ShufflePeriod_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** on conflict condition type for table "room.ShufflePeriod" */
export type Room_ShufflePeriod_On_Conflict = {
  readonly constraint: Room_ShufflePeriod_Constraint;
  readonly update_columns?: ReadonlyArray<Room_ShufflePeriod_Update_Column>;
  readonly where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};

/** Ordering options when selecting data from "room.ShufflePeriod". */
export type Room_ShufflePeriod_Order_By = {
  readonly algorithm?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiser?: Maybe<Registrant_Registrant_Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** primary key columns input for table: room_ShufflePeriod */
export type Room_ShufflePeriod_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Select_Column {
  /** column name */
  Algorithm = 'algorithm',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxRegistrantsPerRoom = 'maxRegistrantsPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetRegistrantsPerRoom = 'targetRegistrantsPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** input type for updating data in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Set_Input = {
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Room_ShufflePeriod_Stddev_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShufflePeriod_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_pop_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Pop_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShufflePeriod_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_samp_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Samp_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShufflePeriod_Sum_Fields = {
  readonly __typename?: 'room_ShufflePeriod_sum_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Sum_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** update columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Update_Column {
  /** column name */
  Algorithm = 'algorithm',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxRegistrantsPerRoom = 'maxRegistrantsPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetRegistrantsPerRoom = 'targetRegistrantsPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** aggregate var_pop on columns */
export type Room_ShufflePeriod_Var_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_pop_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Pop_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShufflePeriod_Var_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_samp_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Samp_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShufflePeriod_Variance_Fields = {
  readonly __typename?: 'room_ShufflePeriod_variance_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Variance_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry = {
  readonly __typename?: 'room_ShuffleQueueEntry';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['bigint'];
  readonly isExpired: Scalars['Boolean'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  /** An object relationship */
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleQueueEntry_Avg_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_avg_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Avg_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleQueueEntry". All fields are combined with a logical 'AND'. */
export type Room_ShuffleQueueEntry_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Bool_Exp>>;
  readonly _not?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Bool_Exp>>;
  readonly allocatedShuffleRoomId?: Maybe<Int_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly isExpired?: Maybe<Boolean_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Constraint {
  /** unique or primary key constraint */
  ShuffleQueueEntryPkey = 'ShuffleQueueEntry_pkey',
  /** unique or primary key constraint */
  RoomShuffleQueueEntryIsWaiting = 'room_ShuffleQueueEntry_isWaiting'
}

/** input type for incrementing numeric columns in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Inc_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Insert_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isExpired?: Maybe<Scalars['Boolean']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Obj_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleQueueEntry_Max_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_max_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Max_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleQueueEntry_Min_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_min_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Min_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Mutation_Response = {
  readonly __typename?: 'room_ShuffleQueueEntry_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** on conflict condition type for table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_On_Conflict = {
  readonly constraint: Room_ShuffleQueueEntry_Constraint;
  readonly update_columns?: ReadonlyArray<Room_ShuffleQueueEntry_Update_Column>;
  readonly where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** Ordering options when selecting data from "room.ShuffleQueueEntry". */
export type Room_ShuffleQueueEntry_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isExpired?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: room_ShuffleQueueEntry */
export type Room_ShuffleQueueEntry_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Select_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsExpired = 'isExpired',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Set_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isExpired?: Maybe<Scalars['Boolean']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleQueueEntry_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleQueueEntry_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleQueueEntry_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleQueueEntry_Sum_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_sum_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Sum_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Update_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsExpired = 'isExpired',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleQueueEntry_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleQueueEntry_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleQueueEntry_Variance_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_variance_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Variance_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoom = {
  readonly __typename?: 'room_ShuffleRoom';
  /** An array relationship */
  readonly continuations: ReadonlyArray<Schedule_Continuation>;
  /** An aggregate relationship */
  readonly continuations_aggregate: Schedule_Continuation_Aggregate;
  readonly created_at: Scalars['timestamptz'];
  readonly durationMinutes: Scalars['Int'];
  readonly id: Scalars['bigint'];
  readonly isEnded: Scalars['Boolean'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregate relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly reshuffleUponEnd: Scalars['Boolean'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  readonly startedAt: Scalars['timestamptz'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomContinuationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomContinuations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** aggregated selection of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate = {
  readonly __typename?: 'room_ShuffleRoom_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleRoom>;
};

/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleRoom_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Room_ShuffleRoom_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleRoom_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleRoom_Avg_Fields = {
  readonly __typename?: 'room_ShuffleRoom_avg_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Avg_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleRoom". All fields are combined with a logical 'AND'. */
export type Room_ShuffleRoom_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Room_ShuffleRoom_Bool_Exp>>;
  readonly _not?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Room_ShuffleRoom_Bool_Exp>>;
  readonly continuations?: Maybe<Schedule_Continuation_Bool_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly isEnded?: Maybe<Boolean_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly reshuffleUponEnd?: Maybe<Boolean_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly startedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Constraint {
  /** unique or primary key constraint */
  ShuffleRoomPkey = 'ShuffleRoom_pkey'
}

/** input type for incrementing numeric columns in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Inc_Input = {
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Insert_Input = {
  readonly continuations?: Maybe<Schedule_Continuation_Arr_Rel_Insert_Input>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleRoom_Max_Fields = {
  readonly __typename?: 'room_ShuffleRoom_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleRoom_Min_Fields = {
  readonly __typename?: 'room_ShuffleRoom_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Mutation_Response = {
  readonly __typename?: 'room_ShuffleRoom_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleRoom>;
};

/** input type for inserting object relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleRoom_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleRoom" */
export type Room_ShuffleRoom_On_Conflict = {
  readonly constraint: Room_ShuffleRoom_Constraint;
  readonly update_columns?: ReadonlyArray<Room_ShuffleRoom_Update_Column>;
  readonly where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** Ordering options when selecting data from "room.ShuffleRoom". */
export type Room_ShuffleRoom_Order_By = {
  readonly continuations_aggregate?: Maybe<Schedule_Continuation_Aggregate_Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isEnded?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly reshuffleUponEnd?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: room_ShuffleRoom */
export type Room_ShuffleRoom_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleRoom_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleRoom_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleRoom_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleRoom_Sum_Fields = {
  readonly __typename?: 'room_ShuffleRoom_sum_fields';
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Sum_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleRoom_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleRoom_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleRoom_Variance_Fields = {
  readonly __typename?: 'room_ShuffleRoom_variance_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Variance_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/**
 * A continuation from the end of an event or shuffle room to the next thing. Enables organisers to create a guided flow for attendees. It is possible to specify multiple continuations from the same point, giving attendees a choice of where to go.
 *
 *
 * columns and relationships of "schedule.Continuation"
 *
 */
export type Schedule_Continuation = {
  readonly __typename?: 'schedule_Continuation';
  readonly colour: Scalars['String'];
  readonly defaultFor: Scalars['String'];
  readonly description: Scalars['String'];
  /** An object relationship */
  readonly event?: Maybe<Schedule_Event>;
  readonly fromEvent?: Maybe<Scalars['uuid']>;
  readonly fromShuffleQueue?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  readonly isActiveChoice: Scalars['Boolean'];
  readonly priority: Scalars['Int'];
  /** An object relationship */
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod>;
  readonly to: Scalars['jsonb'];
};


/**
 * A continuation from the end of an event or shuffle room to the next thing. Enables organisers to create a guided flow for attendees. It is possible to specify multiple continuations from the same point, giving attendees a choice of where to go.
 *
 *
 * columns and relationships of "schedule.Continuation"
 *
 */
export type Schedule_ContinuationToArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "schedule.Continuation" */
export type Schedule_Continuation_Aggregate = {
  readonly __typename?: 'schedule_Continuation_aggregate';
  readonly aggregate?: Maybe<Schedule_Continuation_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_Continuation>;
};

/** aggregate fields of "schedule.Continuation" */
export type Schedule_Continuation_Aggregate_Fields = {
  readonly __typename?: 'schedule_Continuation_aggregate_fields';
  readonly avg?: Maybe<Schedule_Continuation_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Schedule_Continuation_Max_Fields>;
  readonly min?: Maybe<Schedule_Continuation_Min_Fields>;
  readonly stddev?: Maybe<Schedule_Continuation_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Schedule_Continuation_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Schedule_Continuation_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Schedule_Continuation_Sum_Fields>;
  readonly var_pop?: Maybe<Schedule_Continuation_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Schedule_Continuation_Var_Samp_Fields>;
  readonly variance?: Maybe<Schedule_Continuation_Variance_Fields>;
};


/** aggregate fields of "schedule.Continuation" */
export type Schedule_Continuation_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.Continuation" */
export type Schedule_Continuation_Aggregate_Order_By = {
  readonly avg?: Maybe<Schedule_Continuation_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_Continuation_Max_Order_By>;
  readonly min?: Maybe<Schedule_Continuation_Min_Order_By>;
  readonly stddev?: Maybe<Schedule_Continuation_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Schedule_Continuation_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Schedule_Continuation_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Schedule_Continuation_Sum_Order_By>;
  readonly var_pop?: Maybe<Schedule_Continuation_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Schedule_Continuation_Var_Samp_Order_By>;
  readonly variance?: Maybe<Schedule_Continuation_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Schedule_Continuation_Append_Input = {
  readonly to?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "schedule.Continuation" */
export type Schedule_Continuation_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_Continuation_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Schedule_Continuation_On_Conflict>;
};

/** aggregate avg on columns */
export type Schedule_Continuation_Avg_Fields = {
  readonly __typename?: 'schedule_Continuation_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "schedule.Continuation". All fields are combined with a logical 'AND'. */
export type Schedule_Continuation_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Schedule_Continuation_Bool_Exp>>;
  readonly _not?: Maybe<Schedule_Continuation_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Schedule_Continuation_Bool_Exp>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly defaultFor?: Maybe<String_Comparison_Exp>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly fromEvent?: Maybe<Uuid_Comparison_Exp>;
  readonly fromShuffleQueue?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isActiveChoice?: Maybe<Boolean_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly to?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.Continuation" */
export enum Schedule_Continuation_Constraint {
  /** unique or primary key constraint */
  ContinuationPkey = 'Continuation_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Schedule_Continuation_Delete_At_Path_Input = {
  readonly to?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Schedule_Continuation_Delete_Elem_Input = {
  readonly to?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Schedule_Continuation_Delete_Key_Input = {
  readonly to?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "schedule.Continuation" */
export type Schedule_Continuation_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "schedule.Continuation" */
export type Schedule_Continuation_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly defaultFor?: Maybe<Scalars['String']>;
  readonly description?: Maybe<Scalars['String']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly fromEvent?: Maybe<Scalars['uuid']>;
  readonly fromShuffleQueue?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isActiveChoice?: Maybe<Scalars['Boolean']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly to?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Schedule_Continuation_Max_Fields = {
  readonly __typename?: 'schedule_Continuation_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly defaultFor?: Maybe<Scalars['String']>;
  readonly description?: Maybe<Scalars['String']>;
  readonly fromEvent?: Maybe<Scalars['uuid']>;
  readonly fromShuffleQueue?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly defaultFor?: Maybe<Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly fromEvent?: Maybe<Order_By>;
  readonly fromShuffleQueue?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_Continuation_Min_Fields = {
  readonly __typename?: 'schedule_Continuation_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly defaultFor?: Maybe<Scalars['String']>;
  readonly description?: Maybe<Scalars['String']>;
  readonly fromEvent?: Maybe<Scalars['uuid']>;
  readonly fromShuffleQueue?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly defaultFor?: Maybe<Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly fromEvent?: Maybe<Order_By>;
  readonly fromShuffleQueue?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.Continuation" */
export type Schedule_Continuation_Mutation_Response = {
  readonly __typename?: 'schedule_Continuation_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Schedule_Continuation>;
};

/** on conflict condition type for table "schedule.Continuation" */
export type Schedule_Continuation_On_Conflict = {
  readonly constraint: Schedule_Continuation_Constraint;
  readonly update_columns?: ReadonlyArray<Schedule_Continuation_Update_Column>;
  readonly where?: Maybe<Schedule_Continuation_Bool_Exp>;
};

/** Ordering options when selecting data from "schedule.Continuation". */
export type Schedule_Continuation_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly defaultFor?: Maybe<Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly fromEvent?: Maybe<Order_By>;
  readonly fromShuffleQueue?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isActiveChoice?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly to?: Maybe<Order_By>;
};

/** primary key columns input for table: schedule_Continuation */
export type Schedule_Continuation_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Schedule_Continuation_Prepend_Input = {
  readonly to?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "schedule.Continuation" */
export enum Schedule_Continuation_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  DefaultFor = 'defaultFor',
  /** column name */
  Description = 'description',
  /** column name */
  FromEvent = 'fromEvent',
  /** column name */
  FromShuffleQueue = 'fromShuffleQueue',
  /** column name */
  Id = 'id',
  /** column name */
  IsActiveChoice = 'isActiveChoice',
  /** column name */
  Priority = 'priority',
  /** column name */
  To = 'to'
}

/** input type for updating data in table "schedule.Continuation" */
export type Schedule_Continuation_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly defaultFor?: Maybe<Scalars['String']>;
  readonly description?: Maybe<Scalars['String']>;
  readonly fromEvent?: Maybe<Scalars['uuid']>;
  readonly fromShuffleQueue?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isActiveChoice?: Maybe<Scalars['Boolean']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly to?: Maybe<Scalars['jsonb']>;
};

/** aggregate stddev on columns */
export type Schedule_Continuation_Stddev_Fields = {
  readonly __typename?: 'schedule_Continuation_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Schedule_Continuation_Stddev_Pop_Fields = {
  readonly __typename?: 'schedule_Continuation_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Schedule_Continuation_Stddev_Samp_Fields = {
  readonly __typename?: 'schedule_Continuation_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Schedule_Continuation_Sum_Fields = {
  readonly __typename?: 'schedule_Continuation_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "schedule.Continuation" */
export enum Schedule_Continuation_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  DefaultFor = 'defaultFor',
  /** column name */
  Description = 'description',
  /** column name */
  FromEvent = 'fromEvent',
  /** column name */
  FromShuffleQueue = 'fromShuffleQueue',
  /** column name */
  Id = 'id',
  /** column name */
  IsActiveChoice = 'isActiveChoice',
  /** column name */
  Priority = 'priority',
  /** column name */
  To = 'to'
}

/** aggregate var_pop on columns */
export type Schedule_Continuation_Var_Pop_Fields = {
  readonly __typename?: 'schedule_Continuation_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Schedule_Continuation_Var_Samp_Fields = {
  readonly __typename?: 'schedule_Continuation_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Schedule_Continuation_Variance_Fields = {
  readonly __typename?: 'schedule_Continuation_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "schedule.Continuation" */
export type Schedule_Continuation_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "schedule.Event" */
export type Schedule_Event = {
  readonly __typename?: 'schedule_Event';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly continuations: ReadonlyArray<Schedule_Continuation>;
  /** An aggregate relationship */
  readonly continuations_aggregate: Schedule_Continuation_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly durationSeconds: Scalars['Int'];
  readonly enableRecording: Scalars['Boolean'];
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<Schedule_EventProgramPerson>;
  /** An aggregate relationship */
  readonly eventPeople_aggregate: Schedule_EventProgramPerson_Aggregate;
  /** An array relationship */
  readonly eventTags: ReadonlyArray<Schedule_EventTag>;
  /** An aggregate relationship */
  readonly eventTags_aggregate: Schedule_EventTag_Aggregate;
  /** An object relationship */
  readonly eventVonageSession?: Maybe<Video_EventVonageSession>;
  /** An object relationship */
  readonly exhibition?: Maybe<Collection_Exhibition>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  readonly intendedRoomModeName: Room_Mode_Enum;
  /** An object relationship */
  readonly item?: Maybe<Content_Item>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly participantStreams: ReadonlyArray<Video_EventParticipantStream>;
  /** An aggregate relationship */
  readonly participantStreams_aggregate: Video_EventParticipantStream_Aggregate;
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly roomMode: Room_Mode;
  /** An object relationship */
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime: Scalars['timestamptz'];
  readonly timingsUpdatedAt: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventContinuationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventContinuations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventParticipantStreamsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventParticipantStreams_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};

/** columns and relationships of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson = {
  readonly __typename?: 'schedule_EventProgramPerson';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  /** An object relationship */
  readonly eventPersonRole: Schedule_EventProgramPersonRole;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly person: Collection_ProgramPerson;
  readonly personId: Scalars['uuid'];
  readonly roleName: Schedule_EventProgramPersonRole_Enum;
  readonly updatedAt: Scalars['timestamptz'];
};

/** columns and relationships of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole = {
  readonly __typename?: 'schedule_EventProgramPersonRole';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<Schedule_EventProgramPerson>;
  /** An aggregate relationship */
  readonly eventPeople_aggregate: Schedule_EventProgramPerson_Aggregate;
  readonly name: Scalars['String'];
};


/** columns and relationships of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRoleEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRoleEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};

/** aggregated selection of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Aggregate = {
  readonly __typename?: 'schedule_EventProgramPersonRole_aggregate';
  readonly aggregate?: Maybe<Schedule_EventProgramPersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_EventProgramPersonRole>;
};

/** aggregate fields of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Aggregate_Fields = {
  readonly __typename?: 'schedule_EventProgramPersonRole_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Schedule_EventProgramPersonRole_Max_Fields>;
  readonly min?: Maybe<Schedule_EventProgramPersonRole_Min_Fields>;
};


/** aggregate fields of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "schedule.EventProgramPersonRole". All fields are combined with a logical 'AND'. */
export type Schedule_EventProgramPersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Bool_Exp>>;
  readonly _not?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.EventProgramPersonRole" */
export enum Schedule_EventProgramPersonRole_Constraint {
  /** unique or primary key constraint */
  EventProgramPersonRolePkey = 'EventProgramPersonRole_pkey'
}

export enum Schedule_EventProgramPersonRole_Enum {
  /** Chair/moderator of the event */
  Chair = 'CHAIR',
  /** Viewer who has been given access to the event (e.g. to ask a question). */
  Participant = 'PARTICIPANT',
  /** A presenter. */
  Presenter = 'PRESENTER'
}

/** Boolean expression to compare columns of type "schedule_EventProgramPersonRole_enum". All fields are combined with logical 'AND'. */
export type Schedule_EventProgramPersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Enum>>;
};

/** input type for inserting data into table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Schedule_EventProgramPersonRole_Max_Fields = {
  readonly __typename?: 'schedule_EventProgramPersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Schedule_EventProgramPersonRole_Min_Fields = {
  readonly __typename?: 'schedule_EventProgramPersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Mutation_Response = {
  readonly __typename?: 'schedule_EventProgramPersonRole_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Schedule_EventProgramPersonRole>;
};

/** input type for inserting object relation for remote table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Obj_Rel_Insert_Input = {
  readonly data: Schedule_EventProgramPersonRole_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Schedule_EventProgramPersonRole_On_Conflict>;
};

/** on conflict condition type for table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_On_Conflict = {
  readonly constraint: Schedule_EventProgramPersonRole_Constraint;
  readonly update_columns?: ReadonlyArray<Schedule_EventProgramPersonRole_Update_Column>;
  readonly where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};

/** Ordering options when selecting data from "schedule.EventProgramPersonRole". */
export type Schedule_EventProgramPersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: schedule_EventProgramPersonRole */
export type Schedule_EventProgramPersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "schedule.EventProgramPersonRole" */
export enum Schedule_EventProgramPersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "schedule.EventProgramPersonRole" */
export enum Schedule_EventProgramPersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate = {
  readonly __typename?: 'schedule_EventProgramPerson_aggregate';
  readonly aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_EventProgramPerson>;
};

/** aggregate fields of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate_Fields = {
  readonly __typename?: 'schedule_EventProgramPerson_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Schedule_EventProgramPerson_Max_Fields>;
  readonly min?: Maybe<Schedule_EventProgramPerson_Min_Fields>;
};


/** aggregate fields of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_EventProgramPerson_Max_Order_By>;
  readonly min?: Maybe<Schedule_EventProgramPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_EventProgramPerson_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Schedule_EventProgramPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "schedule.EventProgramPerson". All fields are combined with a logical 'AND'. */
export type Schedule_EventProgramPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Bool_Exp>>;
  readonly _not?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Bool_Exp>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly roleName?: Maybe<Schedule_EventProgramPersonRole_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.EventProgramPerson" */
export enum Schedule_EventProgramPerson_Constraint {
  /** unique or primary key constraint */
  EventProgramPersonEventIdPersonIdRoleNameKey = 'EventProgramPerson_eventId_personId_roleName_key',
  /** unique or primary key constraint */
  EventProgramPersonPkey = 'EventProgramPerson_pkey'
}

/** input type for inserting data into table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Obj_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<Collection_ProgramPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Schedule_EventProgramPerson_Max_Fields = {
  readonly __typename?: 'schedule_EventProgramPerson_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_EventProgramPerson_Min_Fields = {
  readonly __typename?: 'schedule_EventProgramPerson_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Mutation_Response = {
  readonly __typename?: 'schedule_EventProgramPerson_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Schedule_EventProgramPerson>;
};

/** on conflict condition type for table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_On_Conflict = {
  readonly constraint: Schedule_EventProgramPerson_Constraint;
  readonly update_columns?: ReadonlyArray<Schedule_EventProgramPerson_Update_Column>;
  readonly where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};

/** Ordering options when selecting data from "schedule.EventProgramPerson". */
export type Schedule_EventProgramPerson_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly person?: Maybe<Collection_ProgramPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: schedule_EventProgramPerson */
export type Schedule_EventProgramPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.EventProgramPerson" */
export enum Schedule_EventProgramPerson_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "schedule.EventProgramPerson" */
export enum Schedule_EventProgramPerson_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "schedule.EventTag" */
export type Schedule_EventTag = {
  readonly __typename?: 'schedule_EventTag';
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Collection_Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "schedule.EventTag" */
export type Schedule_EventTag_Aggregate = {
  readonly __typename?: 'schedule_EventTag_aggregate';
  readonly aggregate?: Maybe<Schedule_EventTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_EventTag>;
};

/** aggregate fields of "schedule.EventTag" */
export type Schedule_EventTag_Aggregate_Fields = {
  readonly __typename?: 'schedule_EventTag_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Schedule_EventTag_Max_Fields>;
  readonly min?: Maybe<Schedule_EventTag_Min_Fields>;
};


/** aggregate fields of "schedule.EventTag" */
export type Schedule_EventTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.EventTag" */
export type Schedule_EventTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_EventTag_Max_Order_By>;
  readonly min?: Maybe<Schedule_EventTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.EventTag" */
export type Schedule_EventTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_EventTag_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Schedule_EventTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "schedule.EventTag". All fields are combined with a logical 'AND'. */
export type Schedule_EventTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Schedule_EventTag_Bool_Exp>>;
  readonly _not?: Maybe<Schedule_EventTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Schedule_EventTag_Bool_Exp>>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Collection_Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.EventTag" */
export enum Schedule_EventTag_Constraint {
  /** unique or primary key constraint */
  EventTagPkey = 'EventTag_pkey',
  /** unique or primary key constraint */
  EventTagTagIdEventIdKey = 'EventTag_tagId_eventId_key'
}

/** input type for inserting data into table "schedule.EventTag" */
export type Schedule_EventTag_Insert_Input = {
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Collection_Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Schedule_EventTag_Max_Fields = {
  readonly __typename?: 'schedule_EventTag_max_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "schedule.EventTag" */
export type Schedule_EventTag_Max_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_EventTag_Min_Fields = {
  readonly __typename?: 'schedule_EventTag_min_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "schedule.EventTag" */
export type Schedule_EventTag_Min_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.EventTag" */
export type Schedule_EventTag_Mutation_Response = {
  readonly __typename?: 'schedule_EventTag_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Schedule_EventTag>;
};

/** on conflict condition type for table "schedule.EventTag" */
export type Schedule_EventTag_On_Conflict = {
  readonly constraint: Schedule_EventTag_Constraint;
  readonly update_columns?: ReadonlyArray<Schedule_EventTag_Update_Column>;
  readonly where?: Maybe<Schedule_EventTag_Bool_Exp>;
};

/** Ordering options when selecting data from "schedule.EventTag". */
export type Schedule_EventTag_Order_By = {
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tag?: Maybe<Collection_Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: schedule_EventTag */
export type Schedule_EventTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.EventTag" */
export enum Schedule_EventTag_Select_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "schedule.EventTag" */
export type Schedule_EventTag_Set_Input = {
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "schedule.EventTag" */
export enum Schedule_EventTag_Update_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** aggregated selection of "schedule.Event" */
export type Schedule_Event_Aggregate = {
  readonly __typename?: 'schedule_Event_aggregate';
  readonly aggregate?: Maybe<Schedule_Event_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_Event>;
};

/** aggregate fields of "schedule.Event" */
export type Schedule_Event_Aggregate_Fields = {
  readonly __typename?: 'schedule_Event_aggregate_fields';
  readonly avg?: Maybe<Schedule_Event_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Schedule_Event_Max_Fields>;
  readonly min?: Maybe<Schedule_Event_Min_Fields>;
  readonly stddev?: Maybe<Schedule_Event_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Schedule_Event_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Schedule_Event_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Schedule_Event_Sum_Fields>;
  readonly var_pop?: Maybe<Schedule_Event_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Schedule_Event_Var_Samp_Fields>;
  readonly variance?: Maybe<Schedule_Event_Variance_Fields>;
};


/** aggregate fields of "schedule.Event" */
export type Schedule_Event_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.Event" */
export type Schedule_Event_Aggregate_Order_By = {
  readonly avg?: Maybe<Schedule_Event_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_Event_Max_Order_By>;
  readonly min?: Maybe<Schedule_Event_Min_Order_By>;
  readonly stddev?: Maybe<Schedule_Event_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Schedule_Event_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Schedule_Event_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Schedule_Event_Sum_Order_By>;
  readonly var_pop?: Maybe<Schedule_Event_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Schedule_Event_Var_Samp_Order_By>;
  readonly variance?: Maybe<Schedule_Event_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.Event" */
export type Schedule_Event_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_Event_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};

/** aggregate avg on columns */
export type Schedule_Event_Avg_Fields = {
  readonly __typename?: 'schedule_Event_avg_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "schedule.Event" */
export type Schedule_Event_Avg_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "schedule.Event". All fields are combined with a logical 'AND'. */
export type Schedule_Event_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Schedule_Event_Bool_Exp>>;
  readonly _not?: Maybe<Schedule_Event_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Schedule_Event_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly continuations?: Maybe<Schedule_Continuation_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationSeconds?: Maybe<Int_Comparison_Exp>;
  readonly enableRecording?: Maybe<Boolean_Comparison_Exp>;
  readonly endTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly eventTags?: Maybe<Schedule_EventTag_Bool_Exp>;
  readonly eventVonageSession?: Maybe<Video_EventVonageSession_Bool_Exp>;
  readonly exhibition?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly exhibitionId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly intendedRoomModeName?: Maybe<Room_Mode_Enum_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly participantStreams?: Maybe<Video_EventParticipantStream_Bool_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly roomMode?: Maybe<Room_Mode_Bool_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly startTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly timingsUpdatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.Event" */
export enum Schedule_Event_Constraint {
  /** unique or primary key constraint */
  EventPkey = 'Event_pkey'
}

/** input type for incrementing numeric columns in table "schedule.Event" */
export type Schedule_Event_Inc_Input = {
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "schedule.Event" */
export type Schedule_Event_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly continuations?: Maybe<Schedule_Continuation_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly enableRecording?: Maybe<Scalars['Boolean']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Arr_Rel_Insert_Input>;
  readonly eventTags?: Maybe<Schedule_EventTag_Arr_Rel_Insert_Input>;
  readonly eventVonageSession?: Maybe<Video_EventVonageSession_Obj_Rel_Insert_Input>;
  readonly exhibition?: Maybe<Collection_Exhibition_Obj_Rel_Insert_Input>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<Room_Mode_Enum>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly participantStreams?: Maybe<Video_EventParticipantStream_Arr_Rel_Insert_Input>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomMode?: Maybe<Room_Mode_Obj_Rel_Insert_Input>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly timingsUpdatedAt?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Schedule_Event_Max_Fields = {
  readonly __typename?: 'schedule_Event_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly timingsUpdatedAt?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "schedule.Event" */
export type Schedule_Event_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly timingsUpdatedAt?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_Event_Min_Fields = {
  readonly __typename?: 'schedule_Event_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly timingsUpdatedAt?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "schedule.Event" */
export type Schedule_Event_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly timingsUpdatedAt?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.Event" */
export type Schedule_Event_Mutation_Response = {
  readonly __typename?: 'schedule_Event_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Schedule_Event>;
};

/** input type for inserting object relation for remote table "schedule.Event" */
export type Schedule_Event_Obj_Rel_Insert_Input = {
  readonly data: Schedule_Event_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};

/** on conflict condition type for table "schedule.Event" */
export type Schedule_Event_On_Conflict = {
  readonly constraint: Schedule_Event_Constraint;
  readonly update_columns?: ReadonlyArray<Schedule_Event_Update_Column>;
  readonly where?: Maybe<Schedule_Event_Bool_Exp>;
};

/** Ordering options when selecting data from "schedule.Event". */
export type Schedule_Event_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly continuations_aggregate?: Maybe<Schedule_Continuation_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly enableRecording?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Order_By>;
  readonly eventTags_aggregate?: Maybe<Schedule_EventTag_Aggregate_Order_By>;
  readonly eventVonageSession?: Maybe<Video_EventVonageSession_Order_By>;
  readonly exhibition?: Maybe<Collection_Exhibition_Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly intendedRoomModeName?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly participantStreams_aggregate?: Maybe<Video_EventParticipantStream_Aggregate_Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly roomMode?: Maybe<Room_Mode_Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly timingsUpdatedAt?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: schedule_Event */
export type Schedule_Event_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.Event" */
export enum Schedule_Event_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EnableRecording = 'enableRecording',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  TimingsUpdatedAt = 'timingsUpdatedAt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "schedule.Event" */
export type Schedule_Event_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly enableRecording?: Maybe<Scalars['Boolean']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<Room_Mode_Enum>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly timingsUpdatedAt?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Schedule_Event_Stddev_Fields = {
  readonly __typename?: 'schedule_Event_stddev_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "schedule.Event" */
export type Schedule_Event_Stddev_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Schedule_Event_Stddev_Pop_Fields = {
  readonly __typename?: 'schedule_Event_stddev_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "schedule.Event" */
export type Schedule_Event_Stddev_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Schedule_Event_Stddev_Samp_Fields = {
  readonly __typename?: 'schedule_Event_stddev_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "schedule.Event" */
export type Schedule_Event_Stddev_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Schedule_Event_Sum_Fields = {
  readonly __typename?: 'schedule_Event_sum_fields';
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "schedule.Event" */
export type Schedule_Event_Sum_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** update columns of table "schedule.Event" */
export enum Schedule_Event_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EnableRecording = 'enableRecording',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  TimingsUpdatedAt = 'timingsUpdatedAt',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Schedule_Event_Var_Pop_Fields = {
  readonly __typename?: 'schedule_Event_var_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "schedule.Event" */
export type Schedule_Event_Var_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Schedule_Event_Var_Samp_Fields = {
  readonly __typename?: 'schedule_Event_var_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "schedule.Event" */
export type Schedule_Event_Var_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Schedule_Event_Variance_Fields = {
  readonly __typename?: 'schedule_Event_variance_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "schedule.Event" */
export type Schedule_Event_Variance_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents = {
  readonly __typename?: 'schedule_OverlappingEvents';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly eventX?: Maybe<Schedule_Event>;
  /** An object relationship */
  readonly eventY?: Maybe<Schedule_Event>;
  readonly xId?: Maybe<Scalars['uuid']>;
  readonly yId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Aggregate = {
  readonly __typename?: 'schedule_OverlappingEvents_aggregate';
  readonly aggregate?: Maybe<Schedule_OverlappingEvents_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_OverlappingEvents>;
};

/** aggregate fields of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Aggregate_Fields = {
  readonly __typename?: 'schedule_OverlappingEvents_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Schedule_OverlappingEvents_Max_Fields>;
  readonly min?: Maybe<Schedule_OverlappingEvents_Min_Fields>;
};


/** aggregate fields of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "schedule.OverlappingEvents". All fields are combined with a logical 'AND'. */
export type Schedule_OverlappingEvents_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Bool_Exp>>;
  readonly _not?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventX?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventY?: Maybe<Schedule_Event_Bool_Exp>;
  readonly xId?: Maybe<Uuid_Comparison_Exp>;
  readonly yId?: Maybe<Uuid_Comparison_Exp>;
};

/** aggregate max on columns */
export type Schedule_OverlappingEvents_Max_Fields = {
  readonly __typename?: 'schedule_OverlappingEvents_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly xId?: Maybe<Scalars['uuid']>;
  readonly yId?: Maybe<Scalars['uuid']>;
};

/** aggregate min on columns */
export type Schedule_OverlappingEvents_Min_Fields = {
  readonly __typename?: 'schedule_OverlappingEvents_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly xId?: Maybe<Scalars['uuid']>;
  readonly yId?: Maybe<Scalars['uuid']>;
};

/** Ordering options when selecting data from "schedule.OverlappingEvents". */
export type Schedule_OverlappingEvents_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly eventX?: Maybe<Schedule_Event_Order_By>;
  readonly eventY?: Maybe<Schedule_Event_Order_By>;
  readonly xId?: Maybe<Order_By>;
  readonly yId?: Maybe<Order_By>;
};

/** select columns of table "schedule.OverlappingEvents" */
export enum Schedule_OverlappingEvents_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  XId = 'xId',
  /** column name */
  YId = 'yId'
}

/** columns and relationships of "schedule.StarredEvent" */
export type Schedule_StarredEvent = {
  readonly __typename?: 'schedule_StarredEvent';
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly registrantId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "schedule.StarredEvent" */
export type Schedule_StarredEvent_Aggregate = {
  readonly __typename?: 'schedule_StarredEvent_aggregate';
  readonly aggregate?: Maybe<Schedule_StarredEvent_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_StarredEvent>;
};

/** aggregate fields of "schedule.StarredEvent" */
export type Schedule_StarredEvent_Aggregate_Fields = {
  readonly __typename?: 'schedule_StarredEvent_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Schedule_StarredEvent_Max_Fields>;
  readonly min?: Maybe<Schedule_StarredEvent_Min_Fields>;
};


/** aggregate fields of "schedule.StarredEvent" */
export type Schedule_StarredEvent_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_StarredEvent_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "schedule.StarredEvent". All fields are combined with a logical 'AND'. */
export type Schedule_StarredEvent_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Schedule_StarredEvent_Bool_Exp>>;
  readonly _not?: Maybe<Schedule_StarredEvent_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Schedule_StarredEvent_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.StarredEvent" */
export enum Schedule_StarredEvent_Constraint {
  /** unique or primary key constraint */
  StarredEventEventIdRegistrantIdKey = 'StarredEvent_eventId_registrantId_key',
  /** unique or primary key constraint */
  StarredEventPkey = 'StarredEvent_pkey'
}

/** input type for inserting data into table "schedule.StarredEvent" */
export type Schedule_StarredEvent_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Schedule_StarredEvent_Max_Fields = {
  readonly __typename?: 'schedule_StarredEvent_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Schedule_StarredEvent_Min_Fields = {
  readonly __typename?: 'schedule_StarredEvent_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "schedule.StarredEvent" */
export type Schedule_StarredEvent_Mutation_Response = {
  readonly __typename?: 'schedule_StarredEvent_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Schedule_StarredEvent>;
};

/** on conflict condition type for table "schedule.StarredEvent" */
export type Schedule_StarredEvent_On_Conflict = {
  readonly constraint: Schedule_StarredEvent_Constraint;
  readonly update_columns?: ReadonlyArray<Schedule_StarredEvent_Update_Column>;
  readonly where?: Maybe<Schedule_StarredEvent_Bool_Exp>;
};

/** Ordering options when selecting data from "schedule.StarredEvent". */
export type Schedule_StarredEvent_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: schedule_StarredEvent */
export type Schedule_StarredEvent_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.StarredEvent" */
export enum Schedule_StarredEvent_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "schedule.StarredEvent" */
export type Schedule_StarredEvent_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "schedule.StarredEvent" */
export enum Schedule_StarredEvent_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

export type Schedule_SearchEvents_Args = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly search?: Maybe<Scalars['String']>;
};

export type Subscription_Root = {
  readonly __typename?: 'subscription_root';
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription: ReadonlyArray<PushNotificationSubscription>;
  /** fetch aggregated fields from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription_aggregate: PushNotificationSubscription_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" using primary key columns */
  readonly PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "analytics.AppStats" */
  readonly analytics_AppStats: ReadonlyArray<Analytics_AppStats>;
  /** fetch aggregated fields from the table: "analytics.AppStats" */
  readonly analytics_AppStats_aggregate: Analytics_AppStats_Aggregate;
  /** fetch data from the table: "analytics.AppStats" using primary key columns */
  readonly analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** fetch data from the table: "analytics.CompletedRegistrations" */
  readonly analytics_CompletedRegistrations: ReadonlyArray<Analytics_CompletedRegistrations>;
  /** fetch aggregated fields from the table: "analytics.CompletedRegistrations" */
  readonly analytics_CompletedRegistrations_aggregate: Analytics_CompletedRegistrations_Aggregate;
  /** fetch data from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats: ReadonlyArray<Analytics_ContentElementStats>;
  /** fetch aggregated fields from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats_aggregate: Analytics_ContentElementStats_Aggregate;
  /** fetch data from the table: "analytics.ContentElementStats" using primary key columns */
  readonly analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** fetch data from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats: ReadonlyArray<Analytics_ContentItemStats>;
  /** fetch aggregated fields from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats_aggregate: Analytics_ContentItemStats_Aggregate;
  /** fetch data from the table: "analytics.ContentItemStats" using primary key columns */
  readonly analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** fetch data from the table: "analytics.ElementTotalViews" */
  readonly analytics_ElementTotalViews: ReadonlyArray<Analytics_ElementTotalViews>;
  /** fetch aggregated fields from the table: "analytics.ElementTotalViews" */
  readonly analytics_ElementTotalViews_aggregate: Analytics_ElementTotalViews_Aggregate;
  /** fetch data from the table: "analytics.ItemTotalViews" */
  readonly analytics_ItemTotalViews: ReadonlyArray<Analytics_ItemTotalViews>;
  /** fetch aggregated fields from the table: "analytics.ItemTotalViews" */
  readonly analytics_ItemTotalViews_aggregate: Analytics_ItemTotalViews_Aggregate;
  /** fetch data from the table: "analytics.RoomPresence" */
  readonly analytics_RoomPresence: ReadonlyArray<Analytics_RoomPresence>;
  /** fetch aggregated fields from the table: "analytics.RoomPresence" */
  readonly analytics_RoomPresence_aggregate: Analytics_RoomPresence_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats: ReadonlyArray<Analytics_RoomStats>;
  /** fetch aggregated fields from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats_aggregate: Analytics_RoomStats_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" using primary key columns */
  readonly analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** fetch data from the table: "analytics.mat_ElementTotalViews" */
  readonly analytics_mat_ElementTotalViews: ReadonlyArray<Analytics_Mat_ElementTotalViews>;
  /** fetch aggregated fields from the table: "analytics.mat_ElementTotalViews" */
  readonly analytics_mat_ElementTotalViews_aggregate: Analytics_Mat_ElementTotalViews_Aggregate;
  /** fetch data from the table: "analytics.mat_ItemTotalViews" */
  readonly analytics_mat_ItemTotalViews: ReadonlyArray<Analytics_Mat_ItemTotalViews>;
  /** fetch aggregated fields from the table: "analytics.mat_ItemTotalViews" */
  readonly analytics_mat_ItemTotalViews_aggregate: Analytics_Mat_ItemTotalViews_Aggregate;
  /** fetch data from the table: "analytics.mat_RoomPresence" */
  readonly analytics_mat_RoomPresence: ReadonlyArray<Analytics_Mat_RoomPresence>;
  /** fetch aggregated fields from the table: "analytics.mat_RoomPresence" */
  readonly analytics_mat_RoomPresence_aggregate: Analytics_Mat_RoomPresence_Aggregate;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** fetch data from the table: "collection.Exhibition" */
  readonly collection_Exhibition: ReadonlyArray<Collection_Exhibition>;
  /** fetch aggregated fields from the table: "collection.Exhibition" */
  readonly collection_Exhibition_aggregate: Collection_Exhibition_Aggregate;
  /** fetch data from the table: "collection.Exhibition" using primary key columns */
  readonly collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** fetch data from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson: ReadonlyArray<Collection_ProgramPerson>;
  /** fetch data from the table: "collection.ProgramPersonByAccessToken" */
  readonly collection_ProgramPersonByAccessToken: ReadonlyArray<Collection_ProgramPersonByAccessToken>;
  /** fetch aggregated fields from the table: "collection.ProgramPersonByAccessToken" */
  readonly collection_ProgramPersonByAccessToken_aggregate: Collection_ProgramPersonByAccessToken_Aggregate;
  /** fetch data from the table: "collection.ProgramPersonWithAccessToken" */
  readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<Collection_ProgramPersonWithAccessToken>;
  /** fetch aggregated fields from the table: "collection.ProgramPersonWithAccessToken" */
  readonly collection_ProgramPersonWithAccessToken_aggregate: Collection_ProgramPersonWithAccessToken_Aggregate;
  /** fetch aggregated fields from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson_aggregate: Collection_ProgramPerson_Aggregate;
  /** fetch data from the table: "collection.ProgramPerson" using primary key columns */
  readonly collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** fetch data from the table: "collection.Tag" */
  readonly collection_Tag: ReadonlyArray<Collection_Tag>;
  /** fetch aggregated fields from the table: "collection.Tag" */
  readonly collection_Tag_aggregate: Collection_Tag_Aggregate;
  /** fetch data from the table: "collection.Tag" using primary key columns */
  readonly collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** execute function "collection.searchProgramPerson" which returns "collection.ProgramPerson" */
  readonly collection_searchProgramPerson: ReadonlyArray<Collection_ProgramPerson>;
  /** execute function "collection.searchProgramPerson" and query aggregates on result of table type "collection.ProgramPerson" */
  readonly collection_searchProgramPerson_aggregate: Collection_ProgramPerson_Aggregate;
  /** fetch data from the table: "conference.Conference" */
  readonly conference_Conference: ReadonlyArray<Conference_Conference>;
  /** fetch aggregated fields from the table: "conference.Conference" */
  readonly conference_Conference_aggregate: Conference_Conference_Aggregate;
  /** fetch data from the table: "conference.Conference" using primary key columns */
  readonly conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** fetch data from the table: "conference.Configuration" */
  readonly conference_Configuration: ReadonlyArray<Conference_Configuration>;
  /** fetch data from the table: "conference.ConfigurationKey" */
  readonly conference_ConfigurationKey: ReadonlyArray<Conference_ConfigurationKey>;
  /** fetch aggregated fields from the table: "conference.ConfigurationKey" */
  readonly conference_ConfigurationKey_aggregate: Conference_ConfigurationKey_Aggregate;
  /** fetch data from the table: "conference.ConfigurationKey" using primary key columns */
  readonly conference_ConfigurationKey_by_pk?: Maybe<Conference_ConfigurationKey>;
  /** fetch aggregated fields from the table: "conference.Configuration" */
  readonly conference_Configuration_aggregate: Conference_Configuration_Aggregate;
  /** fetch data from the table: "conference.Configuration" using primary key columns */
  readonly conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** fetch data from the table: "conference.DemoCode" */
  readonly conference_DemoCode: ReadonlyArray<Conference_DemoCode>;
  /** fetch aggregated fields from the table: "conference.DemoCode" */
  readonly conference_DemoCode_aggregate: Conference_DemoCode_Aggregate;
  /** fetch data from the table: "conference.DemoCode" using primary key columns */
  readonly conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** fetch data from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData: ReadonlyArray<Conference_OriginatingData>;
  /** fetch aggregated fields from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData_aggregate: Conference_OriginatingData_Aggregate;
  /** fetch data from the table: "conference.OriginatingData" using primary key columns */
  readonly conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** fetch data from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob: ReadonlyArray<Conference_PrepareJob>;
  /** fetch aggregated fields from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob_aggregate: Conference_PrepareJob_Aggregate;
  /** fetch data from the table: "conference.PrepareJob" using primary key columns */
  readonly conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** fetch data from the table: "content.Element" */
  readonly content_Element: ReadonlyArray<Content_Element>;
  /** fetch data from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken: ReadonlyArray<Content_ElementByAccessToken>;
  /** fetch aggregated fields from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken_aggregate: Content_ElementByAccessToken_Aggregate;
  /** fetch data from the table: "content.ElementByPersonAccessToken" */
  readonly content_ElementByPersonAccessToken: ReadonlyArray<Content_ElementByPersonAccessToken>;
  /** fetch aggregated fields from the table: "content.ElementByPersonAccessToken" */
  readonly content_ElementByPersonAccessToken_aggregate: Content_ElementByPersonAccessToken_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant: ReadonlyArray<Content_ElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant_aggregate: Content_ElementPermissionGrant_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" using primary key columns */
  readonly content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** fetch data from the table: "content.ElementType" */
  readonly content_ElementType: ReadonlyArray<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.ElementType" */
  readonly content_ElementType_aggregate: Content_ElementType_Aggregate;
  /** fetch data from the table: "content.ElementType" using primary key columns */
  readonly content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.Element" */
  readonly content_Element_aggregate: Content_Element_Aggregate;
  /** fetch data from the table: "content.Element" using primary key columns */
  readonly content_Element_by_pk?: Maybe<Content_Element>;
  /** fetch data from the table: "content.Item" */
  readonly content_Item: ReadonlyArray<Content_Item>;
  /** fetch data from the table: "content.ItemByPersonAccessToken" */
  readonly content_ItemByPersonAccessToken: ReadonlyArray<Content_ItemByPersonAccessToken>;
  /** fetch aggregated fields from the table: "content.ItemByPersonAccessToken" */
  readonly content_ItemByPersonAccessToken_aggregate: Content_ItemByPersonAccessToken_Aggregate;
  /** fetch data from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition: ReadonlyArray<Content_ItemExhibition>;
  /** fetch aggregated fields from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition_aggregate: Content_ItemExhibition_Aggregate;
  /** fetch data from the table: "content.ItemExhibition" using primary key columns */
  readonly content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** fetch data from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson: ReadonlyArray<Content_ItemProgramPerson>;
  /** fetch data from the table: "content.ItemProgramPersonByAccessToken" */
  readonly content_ItemProgramPersonByAccessToken: ReadonlyArray<Content_ItemProgramPersonByAccessToken>;
  /** fetch aggregated fields from the table: "content.ItemProgramPersonByAccessToken" */
  readonly content_ItemProgramPersonByAccessToken_aggregate: Content_ItemProgramPersonByAccessToken_Aggregate;
  /** fetch aggregated fields from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson_aggregate: Content_ItemProgramPerson_Aggregate;
  /** fetch data from the table: "content.ItemProgramPerson" using primary key columns */
  readonly content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** fetch data from the table: "content.ItemTag" */
  readonly content_ItemTag: ReadonlyArray<Content_ItemTag>;
  /** fetch aggregated fields from the table: "content.ItemTag" */
  readonly content_ItemTag_aggregate: Content_ItemTag_Aggregate;
  /** fetch data from the table: "content.ItemTag" using primary key columns */
  readonly content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** fetch data from the table: "content.ItemType" */
  readonly content_ItemType: ReadonlyArray<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.ItemType" */
  readonly content_ItemType_aggregate: Content_ItemType_Aggregate;
  /** fetch data from the table: "content.ItemType" using primary key columns */
  readonly content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.Item" */
  readonly content_Item_aggregate: Content_Item_Aggregate;
  /** fetch data from the table: "content.Item" using primary key columns */
  readonly content_Item_by_pk?: Maybe<Content_Item>;
  /** fetch data from the table: "content.Uploader" */
  readonly content_Uploader: ReadonlyArray<Content_Uploader>;
  /** fetch aggregated fields from the table: "content.Uploader" */
  readonly content_Uploader_aggregate: Content_Uploader_Aggregate;
  /** fetch data from the table: "content.Uploader" using primary key columns */
  readonly content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** execute function "content.searchItems" which returns "content.Item" */
  readonly content_searchItems: ReadonlyArray<Content_Item>;
  /** execute function "content.searchItems" and query aggregates on result of table type "content.Item" */
  readonly content_searchItems_aggregate: Content_Item_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" using primary key columns */
  readonly job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob_aggregate: Job_Queues_ChannelStackDeleteJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" using primary key columns */
  readonly job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** fetch data from the table: "job_queues.ChannelStackUpdateJob" */
  readonly job_queues_ChannelStackUpdateJob: ReadonlyArray<Job_Queues_ChannelStackUpdateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackUpdateJob" */
  readonly job_queues_ChannelStackUpdateJob_aggregate: Job_Queues_ChannelStackUpdateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackUpdateJob" using primary key columns */
  readonly job_queues_ChannelStackUpdateJob_by_pk?: Maybe<Job_Queues_ChannelStackUpdateJob>;
  /** fetch data from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob: ReadonlyArray<Job_Queues_CombineVideosJob>;
  /** fetch aggregated fields from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob_aggregate: Job_Queues_CombineVideosJob_Aggregate;
  /** fetch data from the table: "job_queues.CombineVideosJob" using primary key columns */
  readonly job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** fetch data from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob: ReadonlyArray<Job_Queues_CustomEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob_aggregate: Job_Queues_CustomEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.CustomEmailJob" using primary key columns */
  readonly job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob_aggregate: Job_Queues_UploadYouTubeVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" using primary key columns */
  readonly job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch data from the table: "permissions.Group" */
  readonly permissions_Group: ReadonlyArray<Permissions_Group>;
  /** fetch data from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant: ReadonlyArray<Permissions_GroupRegistrant>;
  /** fetch aggregated fields from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant_aggregate: Permissions_GroupRegistrant_Aggregate;
  /** fetch data from the table: "permissions.GroupRegistrant" using primary key columns */
  readonly permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** fetch data from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole: ReadonlyArray<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole_aggregate: Permissions_GroupRole_Aggregate;
  /** fetch data from the table: "permissions.GroupRole" using primary key columns */
  readonly permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.Group" */
  readonly permissions_Group_aggregate: Permissions_Group_Aggregate;
  /** fetch data from the table: "permissions.Group" using primary key columns */
  readonly permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** fetch data from the table: "permissions.Permission" */
  readonly permissions_Permission: ReadonlyArray<Permissions_Permission>;
  /** fetch aggregated fields from the table: "permissions.Permission" */
  readonly permissions_Permission_aggregate: Permissions_Permission_Aggregate;
  /** fetch data from the table: "permissions.Permission" using primary key columns */
  readonly permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** fetch data from the table: "permissions.Role" */
  readonly permissions_Role: ReadonlyArray<Permissions_Role>;
  /** fetch data from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission: ReadonlyArray<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission_aggregate: Permissions_RolePermission_Aggregate;
  /** fetch data from the table: "permissions.RolePermission" using primary key columns */
  readonly permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.Role" */
  readonly permissions_Role_aggregate: Permissions_Role_Aggregate;
  /** fetch data from the table: "permissions.Role" using primary key columns */
  readonly permissions_Role_by_pk?: Maybe<Permissions_Role>;
  /** fetch data from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount: ReadonlyArray<Registrant_GoogleAccount>;
  /** fetch aggregated fields from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount_aggregate: Registrant_GoogleAccount_Aggregate;
  /** fetch data from the table: "registrant.GoogleAccount" using primary key columns */
  readonly registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** fetch data from the table: "registrant.Invitation" */
  readonly registrant_Invitation: ReadonlyArray<Registrant_Invitation>;
  /** fetch aggregated fields from the table: "registrant.Invitation" */
  readonly registrant_Invitation_aggregate: Registrant_Invitation_Aggregate;
  /** fetch data from the table: "registrant.Invitation" using primary key columns */
  readonly registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** fetch data from the table: "registrant.Profile" */
  readonly registrant_Profile: ReadonlyArray<Registrant_Profile>;
  /** fetch data from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges: ReadonlyArray<Registrant_ProfileBadges>;
  /** fetch aggregated fields from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges_aggregate: Registrant_ProfileBadges_Aggregate;
  /** fetch aggregated fields from the table: "registrant.Profile" */
  readonly registrant_Profile_aggregate: Registrant_Profile_Aggregate;
  /** fetch data from the table: "registrant.Profile" using primary key columns */
  readonly registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** fetch data from the table: "registrant.Registrant" */
  readonly registrant_Registrant: ReadonlyArray<Registrant_Registrant>;
  /** fetch aggregated fields from the table: "registrant.Registrant" */
  readonly registrant_Registrant_aggregate: Registrant_Registrant_Aggregate;
  /** fetch data from the table: "registrant.Registrant" using primary key columns */
  readonly registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** fetch data from the table: "registrant.SavedVonageRoomRecording" */
  readonly registrant_SavedVonageRoomRecording: ReadonlyArray<Registrant_SavedVonageRoomRecording>;
  /** fetch aggregated fields from the table: "registrant.SavedVonageRoomRecording" */
  readonly registrant_SavedVonageRoomRecording_aggregate: Registrant_SavedVonageRoomRecording_Aggregate;
  /** fetch data from the table: "registrant.SavedVonageRoomRecording" using primary key columns */
  readonly registrant_SavedVonageRoomRecording_by_pk?: Maybe<Registrant_SavedVonageRoomRecording>;
  /** fetch data from the table: "room.Backend" */
  readonly room_Backend: ReadonlyArray<Room_Backend>;
  /** fetch aggregated fields from the table: "room.Backend" */
  readonly room_Backend_aggregate: Room_Backend_Aggregate;
  /** fetch data from the table: "room.Backend" using primary key columns */
  readonly room_Backend_by_pk?: Maybe<Room_Backend>;
  /** fetch data from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting: ReadonlyArray<Room_ChimeMeeting>;
  /** fetch aggregated fields from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting_aggregate: Room_ChimeMeeting_Aggregate;
  /** fetch data from the table: "room.ChimeMeeting" using primary key columns */
  readonly room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** fetch data from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations: ReadonlyArray<Room_LivestreamDurations>;
  /** fetch aggregated fields from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations_aggregate: Room_LivestreamDurations_Aggregate;
  /** fetch data from the table: "room.ManagementMode" */
  readonly room_ManagementMode: ReadonlyArray<Room_ManagementMode>;
  /** fetch aggregated fields from the table: "room.ManagementMode" */
  readonly room_ManagementMode_aggregate: Room_ManagementMode_Aggregate;
  /** fetch data from the table: "room.ManagementMode" using primary key columns */
  readonly room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** fetch data from the table: "room.Mode" */
  readonly room_Mode: ReadonlyArray<Room_Mode>;
  /** fetch aggregated fields from the table: "room.Mode" */
  readonly room_Mode_aggregate: Room_Mode_Aggregate;
  /** fetch data from the table: "room.Mode" using primary key columns */
  readonly room_Mode_by_pk?: Maybe<Room_Mode>;
  /** fetch data from the table: "room.Participant" */
  readonly room_Participant: ReadonlyArray<Room_Participant>;
  /** fetch aggregated fields from the table: "room.Participant" */
  readonly room_Participant_aggregate: Room_Participant_Aggregate;
  /** fetch data from the table: "room.Participant" using primary key columns */
  readonly room_Participant_by_pk?: Maybe<Room_Participant>;
  /** fetch data from the table: "room.PersonRole" */
  readonly room_PersonRole: ReadonlyArray<Room_PersonRole>;
  /** fetch aggregated fields from the table: "room.PersonRole" */
  readonly room_PersonRole_aggregate: Room_PersonRole_Aggregate;
  /** fetch data from the table: "room.PersonRole" using primary key columns */
  readonly room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** fetch data from the table: "room.Room" */
  readonly room_Room: ReadonlyArray<Room_Room>;
  /** fetch data from the table: "room.RoomPerson" */
  readonly room_RoomPerson: ReadonlyArray<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.RoomPerson" */
  readonly room_RoomPerson_aggregate: Room_RoomPerson_Aggregate;
  /** fetch data from the table: "room.RoomPerson" using primary key columns */
  readonly room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.Room" */
  readonly room_Room_aggregate: Room_Room_Aggregate;
  /** fetch data from the table: "room.Room" using primary key columns */
  readonly room_Room_by_pk?: Maybe<Room_Room>;
  /** fetch data from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm: ReadonlyArray<Room_ShuffleAlgorithm>;
  /** fetch aggregated fields from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm_aggregate: Room_ShuffleAlgorithm_Aggregate;
  /** fetch data from the table: "room.ShuffleAlgorithm" using primary key columns */
  readonly room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** fetch data from the table: "schedule.Continuation" */
  readonly schedule_Continuation: ReadonlyArray<Schedule_Continuation>;
  /** fetch aggregated fields from the table: "schedule.Continuation" */
  readonly schedule_Continuation_aggregate: Schedule_Continuation_Aggregate;
  /** fetch data from the table: "schedule.Continuation" using primary key columns */
  readonly schedule_Continuation_by_pk?: Maybe<Schedule_Continuation>;
  /** fetch data from the table: "schedule.Event" */
  readonly schedule_Event: ReadonlyArray<Schedule_Event>;
  /** fetch data from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson: ReadonlyArray<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole: ReadonlyArray<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole_aggregate: Schedule_EventProgramPersonRole_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPersonRole" using primary key columns */
  readonly schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson_aggregate: Schedule_EventProgramPerson_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPerson" using primary key columns */
  readonly schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventTag" */
  readonly schedule_EventTag: ReadonlyArray<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.EventTag" */
  readonly schedule_EventTag_aggregate: Schedule_EventTag_Aggregate;
  /** fetch data from the table: "schedule.EventTag" using primary key columns */
  readonly schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.Event" */
  readonly schedule_Event_aggregate: Schedule_Event_Aggregate;
  /** fetch data from the table: "schedule.Event" using primary key columns */
  readonly schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** fetch data from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents: ReadonlyArray<Schedule_OverlappingEvents>;
  /** fetch aggregated fields from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents_aggregate: Schedule_OverlappingEvents_Aggregate;
  /** fetch data from the table: "schedule.StarredEvent" */
  readonly schedule_StarredEvent: ReadonlyArray<Schedule_StarredEvent>;
  /** fetch aggregated fields from the table: "schedule.StarredEvent" */
  readonly schedule_StarredEvent_aggregate: Schedule_StarredEvent_Aggregate;
  /** fetch data from the table: "schedule.StarredEvent" using primary key columns */
  readonly schedule_StarredEvent_by_pk?: Maybe<Schedule_StarredEvent>;
  /** execute function "schedule.searchEvents" which returns "schedule.Event" */
  readonly schedule_searchEvents: ReadonlyArray<Schedule_Event>;
  /** execute function "schedule.searchEvents" and query aggregates on result of table type "schedule.Event" */
  readonly schedule_searchEvents_aggregate: Schedule_Event_Aggregate;
  /** fetch data from the table: "system.Configuration" */
  readonly system_Configuration: ReadonlyArray<System_Configuration>;
  /** fetch data from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey: ReadonlyArray<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey_aggregate: System_ConfigurationKey_Aggregate;
  /** fetch data from the table: "system.ConfigurationKey" using primary key columns */
  readonly system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.Configuration" */
  readonly system_Configuration_aggregate: System_Configuration_Aggregate;
  /** fetch data from the table: "system.Configuration" using primary key columns */
  readonly system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** fetch data from the table: "video.ChannelStack" */
  readonly video_ChannelStack: ReadonlyArray<Video_ChannelStack>;
  /** fetch data from the table: "video.ChannelStackWithStreamKey" */
  readonly video_ChannelStackWithStreamKey: ReadonlyArray<Video_ChannelStackWithStreamKey>;
  /** fetch aggregated fields from the table: "video.ChannelStackWithStreamKey" */
  readonly video_ChannelStackWithStreamKey_aggregate: Video_ChannelStackWithStreamKey_Aggregate;
  /** fetch aggregated fields from the table: "video.ChannelStack" */
  readonly video_ChannelStack_aggregate: Video_ChannelStack_Aggregate;
  /** fetch data from the table: "video.ChannelStack" using primary key columns */
  readonly video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** fetch data from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream: ReadonlyArray<Video_EventParticipantStream>;
  /** fetch aggregated fields from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream_aggregate: Video_EventParticipantStream_Aggregate;
  /** fetch data from the table: "video.EventParticipantStream" using primary key columns */
  readonly video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** fetch data from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession: ReadonlyArray<Video_EventVonageSession>;
  /** fetch aggregated fields from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession_aggregate: Video_EventVonageSession_Aggregate;
  /** fetch data from the table: "video.EventVonageSession" using primary key columns */
  readonly video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** fetch data from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch: ReadonlyArray<Video_ImmediateSwitch>;
  /** fetch aggregated fields from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch_aggregate: Video_ImmediateSwitch_Aggregate;
  /** fetch data from the table: "video.ImmediateSwitch" using primary key columns */
  readonly video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** fetch data from the table: "video.InputType" */
  readonly video_InputType: ReadonlyArray<Video_InputType>;
  /** fetch aggregated fields from the table: "video.InputType" */
  readonly video_InputType_aggregate: Video_InputType_Aggregate;
  /** fetch data from the table: "video.InputType" using primary key columns */
  readonly video_InputType_by_pk?: Maybe<Video_InputType>;
  /** fetch data from the table: "video.JobStatus" */
  readonly video_JobStatus: ReadonlyArray<Video_JobStatus>;
  /** fetch aggregated fields from the table: "video.JobStatus" */
  readonly video_JobStatus_aggregate: Video_JobStatus_Aggregate;
  /** fetch data from the table: "video.JobStatus" using primary key columns */
  readonly video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** fetch data from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus: ReadonlyArray<Video_MediaLiveChannelStatus>;
  /** fetch aggregated fields from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus_aggregate: Video_MediaLiveChannelStatus_Aggregate;
  /** fetch data from the table: "video.MediaLiveChannelStatus" using primary key columns */
  readonly video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** fetch data from the table: "video.RoomRtmpOutput" */
  readonly video_RoomRtmpOutput: ReadonlyArray<Video_RoomRtmpOutput>;
  /** fetch aggregated fields from the table: "video.RoomRtmpOutput" */
  readonly video_RoomRtmpOutput_aggregate: Video_RoomRtmpOutput_Aggregate;
  /** fetch data from the table: "video.RoomRtmpOutput" using primary key columns */
  readonly video_RoomRtmpOutput_by_pk?: Maybe<Video_RoomRtmpOutput>;
  /** fetch data from the table: "video.RtmpInput" */
  readonly video_RtmpInput: ReadonlyArray<Video_RtmpInput>;
  /** fetch aggregated fields from the table: "video.RtmpInput" */
  readonly video_RtmpInput_aggregate: Video_RtmpInput_Aggregate;
  /** fetch data from the table: "video.RtmpInput" using primary key columns */
  readonly video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** fetch data from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob: ReadonlyArray<Video_TranscriptionJob>;
  /** fetch aggregated fields from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob_aggregate: Video_TranscriptionJob_Aggregate;
  /** fetch data from the table: "video.TranscriptionJob" using primary key columns */
  readonly video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** fetch data from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob: ReadonlyArray<Video_VideoRenderJob>;
  /** fetch aggregated fields from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob_aggregate: Video_VideoRenderJob_Aggregate;
  /** fetch data from the table: "video.VideoRenderJob" using primary key columns */
  readonly video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** fetch data from the table: "video.VonageRoomRecording" */
  readonly video_VonageRoomRecording: ReadonlyArray<Video_VonageRoomRecording>;
  /** fetch aggregated fields from the table: "video.VonageRoomRecording" */
  readonly video_VonageRoomRecording_aggregate: Video_VonageRoomRecording_Aggregate;
  /** fetch data from the table: "video.VonageRoomRecording" using primary key columns */
  readonly video_VonageRoomRecording_by_pk?: Maybe<Video_VonageRoomRecording>;
  /** fetch data from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload: ReadonlyArray<Video_YouTubeUpload>;
  /** fetch aggregated fields from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload_aggregate: Video_YouTubeUpload_Aggregate;
  /** fetch data from the table: "video.YouTubeUpload" using primary key columns */
  readonly video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
};


export type Subscription_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


export type Subscription_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


export type Subscription_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


export type Subscription_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


export type Subscription_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


export type Subscription_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


export type Subscription_RootPushNotificationSubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


export type Subscription_RootPushNotificationSubscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


export type Subscription_RootPushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


export type Subscription_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


export type Subscription_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


export type Subscription_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


export type Subscription_RootAnalytics_AppStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_AppStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootAnalytics_CompletedRegistrationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Order_By>>;
  where?: Maybe<Analytics_CompletedRegistrations_Bool_Exp>;
};


export type Subscription_RootAnalytics_CompletedRegistrations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_CompletedRegistrations_Order_By>>;
  where?: Maybe<Analytics_CompletedRegistrations_Bool_Exp>;
};


export type Subscription_RootAnalytics_ContentElementStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_ContentElementStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_ContentElementStats_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAnalytics_ContentItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_ContentItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_ContentItemStats_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAnalytics_ElementTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_ElementTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_ElementTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_ElementTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_ItemTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_ItemTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_ItemTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_ItemTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_RoomPresenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_RoomPresence_Bool_Exp>;
};


export type Subscription_RootAnalytics_RoomPresence_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_RoomPresence_Bool_Exp>;
};


export type Subscription_RootAnalytics_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


export type Subscription_RootAnalytics_RoomStats_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootAnalytics_Mat_ElementTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ElementTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_Mat_ElementTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ElementTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ElementTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_Mat_ItemTotalViewsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ItemTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_Mat_ItemTotalViews_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_ItemTotalViews_Order_By>>;
  where?: Maybe<Analytics_Mat_ItemTotalViews_Bool_Exp>;
};


export type Subscription_RootAnalytics_Mat_RoomPresenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_Mat_RoomPresence_Bool_Exp>;
};


export type Subscription_RootAnalytics_Mat_RoomPresence_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_Mat_RoomPresence_Order_By>>;
  where?: Maybe<Analytics_Mat_RoomPresence_Bool_Exp>;
};


export type Subscription_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


export type Subscription_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


export type Subscription_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


export type Subscription_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


export type Subscription_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


export type Subscription_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


export type Subscription_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


export type Subscription_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


export type Subscription_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


export type Subscription_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


export type Subscription_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


export type Subscription_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


export type Subscription_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


export type Subscription_RootChat_Pin_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


export type Subscription_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


export type Subscription_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


export type Subscription_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


export type Subscription_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


export type Subscription_RootChat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


export type Subscription_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


export type Subscription_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


export type Subscription_RootChat_ReadUpToIndex_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


export type Subscription_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


export type Subscription_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


export type Subscription_RootChat_Subscription_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


export type Subscription_RootCollection_ExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


export type Subscription_RootCollection_Exhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


export type Subscription_RootCollection_Exhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCollection_ProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Subscription_RootCollection_ProgramPersonByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonByAccessToken_Bool_Exp>;
};


export type Subscription_RootCollection_ProgramPersonByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonByAccessToken_Bool_Exp>;
};


export type Subscription_RootCollection_ProgramPersonWithAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonWithAccessToken_Bool_Exp>;
};


export type Subscription_RootCollection_ProgramPersonWithAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPersonWithAccessToken_Order_By>>;
  where?: Maybe<Collection_ProgramPersonWithAccessToken_Bool_Exp>;
};


export type Subscription_RootCollection_ProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Subscription_RootCollection_ProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCollection_TagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


export type Subscription_RootCollection_Tag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


export type Subscription_RootCollection_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootCollection_SearchProgramPersonArgs = {
  args: Collection_SearchProgramPerson_Args;
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Subscription_RootCollection_SearchProgramPerson_AggregateArgs = {
  args: Collection_SearchProgramPerson_Args;
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


export type Subscription_RootConference_ConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


export type Subscription_RootConference_Conference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


export type Subscription_RootConference_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootConference_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


export type Subscription_RootConference_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Order_By>>;
  where?: Maybe<Conference_ConfigurationKey_Bool_Exp>;
};


export type Subscription_RootConference_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_ConfigurationKey_Order_By>>;
  where?: Maybe<Conference_ConfigurationKey_Bool_Exp>;
};


export type Subscription_RootConference_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootConference_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


export type Subscription_RootConference_Configuration_By_PkArgs = {
  conferenceId: Scalars['uuid'];
  key: Conference_ConfigurationKey_Enum;
};


export type Subscription_RootConference_DemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


export type Subscription_RootConference_DemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


export type Subscription_RootConference_DemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootConference_OriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


export type Subscription_RootConference_OriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


export type Subscription_RootConference_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootConference_PrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


export type Subscription_RootConference_PrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


export type Subscription_RootConference_PrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_ElementArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


export type Subscription_RootContent_ElementByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ElementByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ElementByPersonAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ElementByPersonAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByPersonAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ElementPermissionGrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


export type Subscription_RootContent_ElementPermissionGrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


export type Subscription_RootContent_ElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_ElementTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


export type Subscription_RootContent_ElementType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


export type Subscription_RootContent_ElementType_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootContent_Element_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


export type Subscription_RootContent_Element_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_ItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Subscription_RootContent_ItemByPersonAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ItemByPersonAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ItemByPersonAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemByPersonAccessToken_Order_By>>;
  where?: Maybe<Content_ItemByPersonAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ItemExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


export type Subscription_RootContent_ItemExhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


export type Subscription_RootContent_ItemExhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_ItemProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


export type Subscription_RootContent_ItemProgramPersonByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ItemProgramPersonByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPersonByAccessToken_Order_By>>;
  where?: Maybe<Content_ItemProgramPersonByAccessToken_Bool_Exp>;
};


export type Subscription_RootContent_ItemProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


export type Subscription_RootContent_ItemProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_ItemTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


export type Subscription_RootContent_ItemTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


export type Subscription_RootContent_ItemTag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_ItemTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


export type Subscription_RootContent_ItemType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


export type Subscription_RootContent_ItemType_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootContent_Item_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Subscription_RootContent_Item_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_UploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


export type Subscription_RootContent_Uploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


export type Subscription_RootContent_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootContent_SearchItemsArgs = {
  args: Content_SearchItems_Args;
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Subscription_RootContent_SearchItems_AggregateArgs = {
  args: Content_SearchItems_Args;
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


export type Subscription_RootJob_Queues_ChannelStackCreateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_ChannelStackCreateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_ChannelStackDeleteJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_ChannelStackDeleteJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_ChannelStackDeleteJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_ChannelStackUpdateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_ChannelStackUpdateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_ChannelStackUpdateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_CombineVideosJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_CombineVideosJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_CustomEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_CustomEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootJob_Queues_UploadYouTubeVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_UploadYouTubeVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


export type Subscription_RootJob_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPermissions_GroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


export type Subscription_RootPermissions_GroupRegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


export type Subscription_RootPermissions_GroupRegistrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


export type Subscription_RootPermissions_GroupRegistrant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPermissions_GroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


export type Subscription_RootPermissions_GroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


export type Subscription_RootPermissions_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPermissions_Group_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


export type Subscription_RootPermissions_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPermissions_PermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


export type Subscription_RootPermissions_Permission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


export type Subscription_RootPermissions_Permission_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootPermissions_RoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


export type Subscription_RootPermissions_RolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


export type Subscription_RootPermissions_RolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


export type Subscription_RootPermissions_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootPermissions_Role_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


export type Subscription_RootPermissions_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRegistrant_GoogleAccountArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


export type Subscription_RootRegistrant_GoogleAccount_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


export type Subscription_RootRegistrant_GoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRegistrant_InvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


export type Subscription_RootRegistrant_Invitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


export type Subscription_RootRegistrant_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRegistrant_ProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


export type Subscription_RootRegistrant_ProfileBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


export type Subscription_RootRegistrant_ProfileBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


export type Subscription_RootRegistrant_Profile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


export type Subscription_RootRegistrant_Profile_By_PkArgs = {
  registrantId: Scalars['uuid'];
};


export type Subscription_RootRegistrant_RegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


export type Subscription_RootRegistrant_Registrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


export type Subscription_RootRegistrant_Registrant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRegistrant_SavedVonageRoomRecordingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Order_By>>;
  where?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
};


export type Subscription_RootRegistrant_SavedVonageRoomRecording_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Order_By>>;
  where?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
};


export type Subscription_RootRegistrant_SavedVonageRoomRecording_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRoom_BackendArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


export type Subscription_RootRoom_Backend_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


export type Subscription_RootRoom_Backend_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootRoom_ChimeMeetingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


export type Subscription_RootRoom_ChimeMeeting_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


export type Subscription_RootRoom_ChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRoom_LivestreamDurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


export type Subscription_RootRoom_LivestreamDurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


export type Subscription_RootRoom_ManagementModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


export type Subscription_RootRoom_ManagementMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


export type Subscription_RootRoom_ManagementMode_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootRoom_ModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


export type Subscription_RootRoom_Mode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


export type Subscription_RootRoom_Mode_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootRoom_ParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


export type Subscription_RootRoom_Participant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


export type Subscription_RootRoom_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRoom_PersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


export type Subscription_RootRoom_PersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


export type Subscription_RootRoom_PersonRole_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootRoom_RoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


export type Subscription_RootRoom_RoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


export type Subscription_RootRoom_RoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


export type Subscription_RootRoom_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRoom_Room_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


export type Subscription_RootRoom_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRoom_ShuffleAlgorithmArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


export type Subscription_RootRoom_ShuffleAlgorithm_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


export type Subscription_RootRoom_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


export type Subscription_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


export type Subscription_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


export type Subscription_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


export type Subscription_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


export type Subscription_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


export type Subscription_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootSchedule_ContinuationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


export type Subscription_RootSchedule_Continuation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Continuation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Continuation_Order_By>>;
  where?: Maybe<Schedule_Continuation_Bool_Exp>;
};


export type Subscription_RootSchedule_Continuation_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSchedule_EventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Subscription_RootSchedule_EventProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


export type Subscription_RootSchedule_EventProgramPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


export type Subscription_RootSchedule_EventProgramPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


export type Subscription_RootSchedule_EventProgramPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootSchedule_EventProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


export type Subscription_RootSchedule_EventProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSchedule_EventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


export type Subscription_RootSchedule_EventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


export type Subscription_RootSchedule_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSchedule_Event_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Subscription_RootSchedule_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSchedule_OverlappingEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


export type Subscription_RootSchedule_OverlappingEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


export type Subscription_RootSchedule_StarredEventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_StarredEvent_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_StarredEvent_Order_By>>;
  where?: Maybe<Schedule_StarredEvent_Bool_Exp>;
};


export type Subscription_RootSchedule_StarredEvent_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_StarredEvent_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_StarredEvent_Order_By>>;
  where?: Maybe<Schedule_StarredEvent_Bool_Exp>;
};


export type Subscription_RootSchedule_StarredEvent_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootSchedule_SearchEventsArgs = {
  args: Schedule_SearchEvents_Args;
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Subscription_RootSchedule_SearchEvents_AggregateArgs = {
  args: Schedule_SearchEvents_Args;
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


export type Subscription_RootSystem_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


export type Subscription_RootSystem_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


export type Subscription_RootSystem_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


export type Subscription_RootSystem_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootSystem_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


export type Subscription_RootSystem_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};


export type Subscription_RootVideo_ChannelStackArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


export type Subscription_RootVideo_ChannelStackWithStreamKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Order_By>>;
  where?: Maybe<Video_ChannelStackWithStreamKey_Bool_Exp>;
};


export type Subscription_RootVideo_ChannelStackWithStreamKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Order_By>>;
  where?: Maybe<Video_ChannelStackWithStreamKey_Bool_Exp>;
};


export type Subscription_RootVideo_ChannelStack_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


export type Subscription_RootVideo_ChannelStack_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_EventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


export type Subscription_RootVideo_EventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


export type Subscription_RootVideo_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_EventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


export type Subscription_RootVideo_EventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


export type Subscription_RootVideo_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_ImmediateSwitchArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


export type Subscription_RootVideo_ImmediateSwitch_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


export type Subscription_RootVideo_ImmediateSwitch_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_InputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


export type Subscription_RootVideo_InputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


export type Subscription_RootVideo_InputType_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootVideo_JobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


export type Subscription_RootVideo_JobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


export type Subscription_RootVideo_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootVideo_MediaLiveChannelStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


export type Subscription_RootVideo_MediaLiveChannelStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


export type Subscription_RootVideo_MediaLiveChannelStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_RoomRtmpOutputArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Order_By>>;
  where?: Maybe<Video_RoomRtmpOutput_Bool_Exp>;
};


export type Subscription_RootVideo_RoomRtmpOutput_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Order_By>>;
  where?: Maybe<Video_RoomRtmpOutput_Bool_Exp>;
};


export type Subscription_RootVideo_RoomRtmpOutput_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_RtmpInputArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


export type Subscription_RootVideo_RtmpInput_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


export type Subscription_RootVideo_RtmpInput_By_PkArgs = {
  name: Scalars['String'];
};


export type Subscription_RootVideo_TranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


export type Subscription_RootVideo_TranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


export type Subscription_RootVideo_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_VideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


export type Subscription_RootVideo_VideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


export type Subscription_RootVideo_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_VonageRoomRecordingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Order_By>>;
  where?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};


export type Subscription_RootVideo_VonageRoomRecording_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Order_By>>;
  where?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};


export type Subscription_RootVideo_VonageRoomRecording_By_PkArgs = {
  id: Scalars['uuid'];
};


export type Subscription_RootVideo_YouTubeUploadArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


export type Subscription_RootVideo_YouTubeUpload_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


export type Subscription_RootVideo_YouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};

/** columns and relationships of "system.Configuration" */
export type System_Configuration = {
  readonly __typename?: 'system_Configuration';
  readonly created_at: Scalars['timestamptz'];
  readonly key: System_ConfigurationKey_Enum;
  readonly updated_at: Scalars['timestamptz'];
  readonly value: Scalars['jsonb'];
};


/** columns and relationships of "system.Configuration" */
export type System_ConfigurationValueArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "system.ConfigurationKey" */
export type System_ConfigurationKey = {
  readonly __typename?: 'system_ConfigurationKey';
  readonly description?: Maybe<Scalars['String']>;
  readonly name: Scalars['String'];
};

/** aggregated selection of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate = {
  readonly __typename?: 'system_ConfigurationKey_aggregate';
  readonly aggregate?: Maybe<System_ConfigurationKey_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<System_ConfigurationKey>;
};

/** aggregate fields of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_Fields = {
  readonly __typename?: 'system_ConfigurationKey_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<System_ConfigurationKey_Max_Fields>;
  readonly min?: Maybe<System_ConfigurationKey_Min_Fields>;
};


/** aggregate fields of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "system.ConfigurationKey". All fields are combined with a logical 'AND'. */
export type System_ConfigurationKey_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<System_ConfigurationKey_Bool_Exp>>;
  readonly _not?: Maybe<System_ConfigurationKey_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<System_ConfigurationKey_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Constraint {
  /** unique or primary key constraint */
  ConfigurationKeyPkey = 'ConfigurationKey_pkey'
}

export enum System_ConfigurationKey_Enum {
  /** Allow-list (JSON array) of wildcard-match domains that the system should allow email to be sent to. See also NPM wildcard-match package. */
  AllowEmailsToDomains = 'ALLOW_EMAILS_TO_DOMAINS',
  /** The time of the latest revision of the host cookie policy. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  CookiePolicyLatestRevisionTimestamp = 'COOKIE_POLICY_LATEST_REVISION_TIMESTAMP',
  /** The URL to the host cookie policy. Note: If self hosting Clowdr, this must be your organisation's cookie policy - you cannot legally reuse, rely on or copy Clowdr's cookie policy. */
  CookiePolicyUrl = 'COOKIE_POLICY_URL',
  /** A string representing the full frontend host URL for the app. */
  DefaultFrontendHost = 'DEFAULT_FRONTEND_HOST',
  /** Default backend platform for video rooms */
  DefaultVideoRoomBackend = 'DEFAULT_VIDEO_ROOM_BACKEND',
  /** The name of the organisation legally responsible for hosting this instance of the Clowdr software. */
  HostOrganisationName = 'HOST_ORGANISATION_NAME',
  /** The time of the latest revision of the host Privacy Policy. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  PrivacyPolicyLatestRevisionTimestamp = 'PRIVACY_POLICY_LATEST_REVISION_TIMESTAMP',
  /** URL to the host Privacy Policy. Note: If self hosting Clowdr, this must be your organisation's privacy policy - you cannot legally reuse, rely on or copy Clowdr's privacy policy. */
  PrivacyPolicyUrl = 'PRIVACY_POLICY_URL',
  /** SendGrid API Key required for sending emails such as invites and submission requests */
  SendgridApiKey = 'SENDGRID_API_KEY',
  /** Default SendGrid Reply-To email address. */
  SendgridReplyto = 'SENDGRID_REPLYTO',
  /** Default SendGrid Sender email address. */
  SendgridSender = 'SENDGRID_SENDER',
  /** The name emails are from when sent via SendGrid. */
  SendgridSenderName = 'SENDGRID_SENDER_NAME',
  /** Contact address for people to request emails never be sent to them again. */
  StopEmailsContactEmailAddress = 'STOP_EMAILS_CONTACT_EMAIL_ADDRESS',
  /** The time of the latest revision of the host T&Cs. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  TermsLatestRevisionTimestamp = 'TERMS_LATEST_REVISION_TIMESTAMP',
  /** URL to the host T&Cs. Note: If self hosting Clowdr, this must be your organisation's terms - you cannot legally reuse, rely on or copy Clowdr's terms. */
  TermsUrl = 'TERMS_URL',
  /** VAPID keys are used for push notifications and are generated automatically by the realtime service on first use. */
  VapidPrivateKey = 'VAPID_PRIVATE_KEY',
  /** VAPID keys are used for push notifications and are generated automatically by the realtime service on first use. */
  VapidPublicKey = 'VAPID_PUBLIC_KEY'
}

/** Boolean expression to compare columns of type "system_ConfigurationKey_enum". All fields are combined with logical 'AND'. */
export type System_ConfigurationKey_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<System_ConfigurationKey_Enum>;
  readonly _in?: Maybe<ReadonlyArray<System_ConfigurationKey_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<System_ConfigurationKey_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<System_ConfigurationKey_Enum>>;
};

/** input type for inserting data into table "system.ConfigurationKey" */
export type System_ConfigurationKey_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type System_ConfigurationKey_Max_Fields = {
  readonly __typename?: 'system_ConfigurationKey_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type System_ConfigurationKey_Min_Fields = {
  readonly __typename?: 'system_ConfigurationKey_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "system.ConfigurationKey" */
export type System_ConfigurationKey_Mutation_Response = {
  readonly __typename?: 'system_ConfigurationKey_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<System_ConfigurationKey>;
};

/** on conflict condition type for table "system.ConfigurationKey" */
export type System_ConfigurationKey_On_Conflict = {
  readonly constraint: System_ConfigurationKey_Constraint;
  readonly update_columns?: ReadonlyArray<System_ConfigurationKey_Update_Column>;
  readonly where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};

/** Ordering options when selecting data from "system.ConfigurationKey". */
export type System_ConfigurationKey_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: system_ConfigurationKey */
export type System_ConfigurationKey_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "system.ConfigurationKey" */
export type System_ConfigurationKey_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "system.Configuration" */
export type System_Configuration_Aggregate = {
  readonly __typename?: 'system_Configuration_aggregate';
  readonly aggregate?: Maybe<System_Configuration_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<System_Configuration>;
};

/** aggregate fields of "system.Configuration" */
export type System_Configuration_Aggregate_Fields = {
  readonly __typename?: 'system_Configuration_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<System_Configuration_Max_Fields>;
  readonly min?: Maybe<System_Configuration_Min_Fields>;
};


/** aggregate fields of "system.Configuration" */
export type System_Configuration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type System_Configuration_Append_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "system.Configuration". All fields are combined with a logical 'AND'. */
export type System_Configuration_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<System_Configuration_Bool_Exp>>;
  readonly _not?: Maybe<System_Configuration_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<System_Configuration_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly key?: Maybe<System_ConfigurationKey_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly value?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "system.Configuration" */
export enum System_Configuration_Constraint {
  /** unique or primary key constraint */
  ConfigurationPkey = 'Configuration_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type System_Configuration_Delete_At_Path_Input = {
  readonly value?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type System_Configuration_Delete_Elem_Input = {
  readonly value?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type System_Configuration_Delete_Key_Input = {
  readonly value?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "system.Configuration" */
export type System_Configuration_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<System_ConfigurationKey_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type System_Configuration_Max_Fields = {
  readonly __typename?: 'system_Configuration_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type System_Configuration_Min_Fields = {
  readonly __typename?: 'system_Configuration_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "system.Configuration" */
export type System_Configuration_Mutation_Response = {
  readonly __typename?: 'system_Configuration_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<System_Configuration>;
};

/** on conflict condition type for table "system.Configuration" */
export type System_Configuration_On_Conflict = {
  readonly constraint: System_Configuration_Constraint;
  readonly update_columns?: ReadonlyArray<System_Configuration_Update_Column>;
  readonly where?: Maybe<System_Configuration_Bool_Exp>;
};

/** Ordering options when selecting data from "system.Configuration". */
export type System_Configuration_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly value?: Maybe<Order_By>;
};

/** primary key columns input for table: system_Configuration */
export type System_Configuration_Pk_Columns_Input = {
  readonly key: System_ConfigurationKey_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type System_Configuration_Prepend_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "system.Configuration" */
export enum System_Configuration_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "system.Configuration" */
export type System_Configuration_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<System_ConfigurationKey_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "system.Configuration" */
export enum System_Configuration_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}


/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['timestamptz']>;
  readonly _gt?: Maybe<Scalars['timestamptz']>;
  readonly _gte?: Maybe<Scalars['timestamptz']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['timestamptz']>;
  readonly _lte?: Maybe<Scalars['timestamptz']>;
  readonly _neq?: Maybe<Scalars['timestamptz']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
};


/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['uuid']>;
  readonly _gt?: Maybe<Scalars['uuid']>;
  readonly _gte?: Maybe<Scalars['uuid']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['uuid']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['uuid']>;
  readonly _lte?: Maybe<Scalars['uuid']>;
  readonly _neq?: Maybe<Scalars['uuid']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['uuid']>>;
};

/** columns and relationships of "video.ChannelStack" */
export type Video_ChannelStack = {
  readonly __typename?: 'video_ChannelStack';
  /** An object relationship */
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob>;
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly channelStackUpdateJobs: ReadonlyArray<Job_Queues_ChannelStackUpdateJob>;
  /** An aggregate relationship */
  readonly channelStackUpdateJobs_aggregate: Job_Queues_ChannelStackUpdateJob_Aggregate;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId: Scalars['String'];
  readonly cloudFrontDomain: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly endpointUri: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly loopingMp4InputAttachmentName: Scalars['String'];
  readonly mediaLiveChannelId: Scalars['String'];
  /** An object relationship */
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus>;
  readonly mediaPackageChannelId: Scalars['String'];
  readonly mp4InputAttachmentName: Scalars['String'];
  readonly mp4InputId: Scalars['String'];
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName: Scalars['String'];
  readonly rtmpAInputId: Scalars['String'];
  readonly rtmpAInputUri: Scalars['String'];
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "video.ChannelStack" */
export type Video_ChannelStackChannelStackUpdateJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};


/** columns and relationships of "video.ChannelStack" */
export type Video_ChannelStackChannelStackUpdateJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};

/** columns and relationships of "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey = {
  readonly __typename?: 'video_ChannelStackWithStreamKey';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly channelStackUpdateJobs: ReadonlyArray<Job_Queues_ChannelStackUpdateJob>;
  /** An aggregate relationship */
  readonly channelStackUpdateJobs_aggregate: Job_Queues_ChannelStackUpdateJob_Aggregate;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};


/** columns and relationships of "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKeyChannelStackUpdateJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};


/** columns and relationships of "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKeyChannelStackUpdateJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackUpdateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
};

/** aggregated selection of "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey_Aggregate = {
  readonly __typename?: 'video_ChannelStackWithStreamKey_aggregate';
  readonly aggregate?: Maybe<Video_ChannelStackWithStreamKey_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_ChannelStackWithStreamKey>;
};

/** aggregate fields of "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey_Aggregate_Fields = {
  readonly __typename?: 'video_ChannelStackWithStreamKey_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_ChannelStackWithStreamKey_Max_Fields>;
  readonly min?: Maybe<Video_ChannelStackWithStreamKey_Min_Fields>;
};


/** aggregate fields of "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "video.ChannelStackWithStreamKey". All fields are combined with a logical 'AND'. */
export type Video_ChannelStackWithStreamKey_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Bool_Exp>>;
  readonly _not?: Maybe<Video_ChannelStackWithStreamKey_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_ChannelStackWithStreamKey_Bool_Exp>>;
  readonly channelStackCreateJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly channelStackUpdateJobs?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
  readonly cloudFormationStackArn?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDistributionId?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDomain?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpointUri?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly loopingMp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
  readonly mediaPackageChannelId?: Maybe<String_Comparison_Exp>;
  readonly mp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mp4InputId?: Maybe<String_Comparison_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly rtmpAInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly rtmpAInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpAInputUri?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputUri?: Maybe<String_Comparison_Exp>;
  readonly rtmpOutputDestinationId?: Maybe<String_Comparison_Exp>;
  readonly rtmpOutputStreamKey?: Maybe<String_Comparison_Exp>;
  readonly rtmpOutputUri?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** input type for inserting data into table "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey_Insert_Input = {
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly channelStackUpdateJobs?: Maybe<Job_Queues_ChannelStackUpdateJob_Arr_Rel_Insert_Input>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Obj_Rel_Insert_Input>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_ChannelStackWithStreamKey_Max_Fields = {
  readonly __typename?: 'video_ChannelStackWithStreamKey_max_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Video_ChannelStackWithStreamKey_Min_Fields = {
  readonly __typename?: 'video_ChannelStackWithStreamKey_min_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey_Mutation_Response = {
  readonly __typename?: 'video_ChannelStackWithStreamKey_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_ChannelStackWithStreamKey>;
};

/** input type for inserting object relation for remote table "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey_Obj_Rel_Insert_Input = {
  readonly data: Video_ChannelStackWithStreamKey_Insert_Input;
};

/** Ordering options when selecting data from "video.ChannelStackWithStreamKey". */
export type Video_ChannelStackWithStreamKey_Order_By = {
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly channelStackUpdateJobs_aggregate?: Maybe<Job_Queues_ChannelStackUpdateJob_Aggregate_Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpAInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpAInputId?: Maybe<Order_By>;
  readonly rtmpAInputUri?: Maybe<Order_By>;
  readonly rtmpBInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpBInputId?: Maybe<Order_By>;
  readonly rtmpBInputUri?: Maybe<Order_By>;
  readonly rtmpOutputDestinationId?: Maybe<Order_By>;
  readonly rtmpOutputStreamKey?: Maybe<Order_By>;
  readonly rtmpOutputUri?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** select columns of table "video.ChannelStackWithStreamKey" */
export enum Video_ChannelStackWithStreamKey_Select_Column {
  /** column name */
  ChannelStackCreateJobId = 'channelStackCreateJobId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RtmpAInputAttachmentName = 'rtmpAInputAttachmentName',
  /** column name */
  RtmpAInputId = 'rtmpAInputId',
  /** column name */
  RtmpAInputUri = 'rtmpAInputUri',
  /** column name */
  RtmpBInputAttachmentName = 'rtmpBInputAttachmentName',
  /** column name */
  RtmpBInputId = 'rtmpBInputId',
  /** column name */
  RtmpBInputUri = 'rtmpBInputUri',
  /** column name */
  RtmpOutputDestinationId = 'rtmpOutputDestinationId',
  /** column name */
  RtmpOutputStreamKey = 'rtmpOutputStreamKey',
  /** column name */
  RtmpOutputUri = 'rtmpOutputUri',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "video.ChannelStackWithStreamKey" */
export type Video_ChannelStackWithStreamKey_Set_Input = {
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregated selection of "video.ChannelStack" */
export type Video_ChannelStack_Aggregate = {
  readonly __typename?: 'video_ChannelStack_aggregate';
  readonly aggregate?: Maybe<Video_ChannelStack_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_ChannelStack>;
};

/** aggregate fields of "video.ChannelStack" */
export type Video_ChannelStack_Aggregate_Fields = {
  readonly __typename?: 'video_ChannelStack_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_ChannelStack_Max_Fields>;
  readonly min?: Maybe<Video_ChannelStack_Min_Fields>;
};


/** aggregate fields of "video.ChannelStack" */
export type Video_ChannelStack_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "video.ChannelStack". All fields are combined with a logical 'AND'. */
export type Video_ChannelStack_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_ChannelStack_Bool_Exp>>;
  readonly _not?: Maybe<Video_ChannelStack_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_ChannelStack_Bool_Exp>>;
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly channelStackCreateJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly channelStackUpdateJobs?: Maybe<Job_Queues_ChannelStackUpdateJob_Bool_Exp>;
  readonly cloudFormationStackArn?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDistributionId?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDomain?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpointUri?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly loopingMp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
  readonly mediaPackageChannelId?: Maybe<String_Comparison_Exp>;
  readonly mp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mp4InputId?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly rtmpAInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly rtmpAInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpAInputUri?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputUri?: Maybe<String_Comparison_Exp>;
  readonly rtmpOutputDestinationId?: Maybe<String_Comparison_Exp>;
  readonly rtmpOutputStreamKey?: Maybe<String_Comparison_Exp>;
  readonly rtmpOutputUri?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.ChannelStack" */
export enum Video_ChannelStack_Constraint {
  /** unique or primary key constraint */
  MediaLiveChannelPkey = 'MediaLiveChannel_pkey',
  /** unique or primary key constraint */
  MediaLiveChannelRoomIdKey = 'MediaLiveChannel_roomId_key'
}

/** input type for inserting data into table "video.ChannelStack" */
export type Video_ChannelStack_Insert_Input = {
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Obj_Rel_Insert_Input>;
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly channelStackUpdateJobs?: Maybe<Job_Queues_ChannelStackUpdateJob_Arr_Rel_Insert_Input>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Obj_Rel_Insert_Input>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_ChannelStack_Max_Fields = {
  readonly __typename?: 'video_ChannelStack_max_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Video_ChannelStack_Min_Fields = {
  readonly __typename?: 'video_ChannelStack_min_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "video.ChannelStack" */
export type Video_ChannelStack_Mutation_Response = {
  readonly __typename?: 'video_ChannelStack_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_ChannelStack>;
};

/** input type for inserting object relation for remote table "video.ChannelStack" */
export type Video_ChannelStack_Obj_Rel_Insert_Input = {
  readonly data: Video_ChannelStack_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_ChannelStack_On_Conflict>;
};

/** on conflict condition type for table "video.ChannelStack" */
export type Video_ChannelStack_On_Conflict = {
  readonly constraint: Video_ChannelStack_Constraint;
  readonly update_columns?: ReadonlyArray<Video_ChannelStack_Update_Column>;
  readonly where?: Maybe<Video_ChannelStack_Bool_Exp>;
};

/** Ordering options when selecting data from "video.ChannelStack". */
export type Video_ChannelStack_Order_By = {
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Order_By>;
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly channelStackUpdateJobs_aggregate?: Maybe<Job_Queues_ChannelStackUpdateJob_Aggregate_Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpAInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpAInputId?: Maybe<Order_By>;
  readonly rtmpAInputUri?: Maybe<Order_By>;
  readonly rtmpBInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpBInputId?: Maybe<Order_By>;
  readonly rtmpBInputUri?: Maybe<Order_By>;
  readonly rtmpOutputDestinationId?: Maybe<Order_By>;
  readonly rtmpOutputStreamKey?: Maybe<Order_By>;
  readonly rtmpOutputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: video_ChannelStack */
export type Video_ChannelStack_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.ChannelStack" */
export enum Video_ChannelStack_Select_Column {
  /** column name */
  ChannelStackCreateJobId = 'channelStackCreateJobId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RtmpAInputAttachmentName = 'rtmpAInputAttachmentName',
  /** column name */
  RtmpAInputId = 'rtmpAInputId',
  /** column name */
  RtmpAInputUri = 'rtmpAInputUri',
  /** column name */
  RtmpBInputAttachmentName = 'rtmpBInputAttachmentName',
  /** column name */
  RtmpBInputId = 'rtmpBInputId',
  /** column name */
  RtmpBInputUri = 'rtmpBInputUri',
  /** column name */
  RtmpOutputDestinationId = 'rtmpOutputDestinationId',
  /** column name */
  RtmpOutputStreamKey = 'rtmpOutputStreamKey',
  /** column name */
  RtmpOutputUri = 'rtmpOutputUri',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.ChannelStack" */
export type Video_ChannelStack_Set_Input = {
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly rtmpOutputDestinationId?: Maybe<Scalars['String']>;
  readonly rtmpOutputStreamKey?: Maybe<Scalars['String']>;
  readonly rtmpOutputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "video.ChannelStack" */
export enum Video_ChannelStack_Update_Column {
  /** column name */
  ChannelStackCreateJobId = 'channelStackCreateJobId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RtmpAInputAttachmentName = 'rtmpAInputAttachmentName',
  /** column name */
  RtmpAInputId = 'rtmpAInputId',
  /** column name */
  RtmpAInputUri = 'rtmpAInputUri',
  /** column name */
  RtmpBInputAttachmentName = 'rtmpBInputAttachmentName',
  /** column name */
  RtmpBInputId = 'rtmpBInputId',
  /** column name */
  RtmpBInputUri = 'rtmpBInputUri',
  /** column name */
  RtmpOutputDestinationId = 'rtmpOutputDestinationId',
  /** column name */
  RtmpOutputStreamKey = 'rtmpOutputStreamKey',
  /** column name */
  RtmpOutputUri = 'rtmpOutputUri',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/**
 * Current streams in event Vonage sessions.
 *
 *
 * columns and relationships of "video.EventParticipantStream"
 *
 */
export type Video_EventParticipantStream = {
  readonly __typename?: 'video_EventParticipantStream';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId: Scalars['String'];
  readonly vonageStreamId: Scalars['String'];
  readonly vonageStreamType: Scalars['String'];
};

/** aggregated selection of "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate = {
  readonly __typename?: 'video_EventParticipantStream_aggregate';
  readonly aggregate?: Maybe<Video_EventParticipantStream_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_EventParticipantStream>;
};

/** aggregate fields of "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate_Fields = {
  readonly __typename?: 'video_EventParticipantStream_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_EventParticipantStream_Max_Fields>;
  readonly min?: Maybe<Video_EventParticipantStream_Min_Fields>;
};


/** aggregate fields of "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_EventParticipantStream_Max_Order_By>;
  readonly min?: Maybe<Video_EventParticipantStream_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_EventParticipantStream_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_EventParticipantStream_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.EventParticipantStream". All fields are combined with a logical 'AND'. */
export type Video_EventParticipantStream_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_EventParticipantStream_Bool_Exp>>;
  readonly _not?: Maybe<Video_EventParticipantStream_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_EventParticipantStream_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamType?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.EventParticipantStream" */
export enum Video_EventParticipantStream_Constraint {
  /** unique or primary key constraint */
  EventParticipantStreamEventIdRegistrantIdVonageStreamIdKey = 'EventParticipantStream_eventId_registrantId_vonageStreamId_key',
  /** unique or primary key constraint */
  EventParticipantStreamPkey = 'EventParticipantStream_pkey'
}

/** input type for inserting data into table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_EventParticipantStream_Max_Fields = {
  readonly __typename?: 'video_EventParticipantStream_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_EventParticipantStream_Min_Fields = {
  readonly __typename?: 'video_EventParticipantStream_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Mutation_Response = {
  readonly __typename?: 'video_EventParticipantStream_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_EventParticipantStream>;
};

/** on conflict condition type for table "video.EventParticipantStream" */
export type Video_EventParticipantStream_On_Conflict = {
  readonly constraint: Video_EventParticipantStream_Constraint;
  readonly update_columns?: ReadonlyArray<Video_EventParticipantStream_Update_Column>;
  readonly where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};

/** Ordering options when selecting data from "video.EventParticipantStream". */
export type Video_EventParticipantStream_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** primary key columns input for table: video_EventParticipantStream */
export type Video_EventParticipantStream_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.EventParticipantStream" */
export enum Video_EventParticipantStream_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** input type for updating data in table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** update columns of table "video.EventParticipantStream" */
export enum Video_EventParticipantStream_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** columns and relationships of "video.EventVonageSession" */
export type Video_EventVonageSession = {
  readonly __typename?: 'video_EventVonageSession';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly rtmpInputName: Video_RtmpInput_Enum;
  readonly sessionId: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "video.EventVonageSession" */
export type Video_EventVonageSessionLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "video.EventVonageSession" */
export type Video_EventVonageSession_Aggregate = {
  readonly __typename?: 'video_EventVonageSession_aggregate';
  readonly aggregate?: Maybe<Video_EventVonageSession_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_EventVonageSession>;
};

/** aggregate fields of "video.EventVonageSession" */
export type Video_EventVonageSession_Aggregate_Fields = {
  readonly __typename?: 'video_EventVonageSession_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_EventVonageSession_Max_Fields>;
  readonly min?: Maybe<Video_EventVonageSession_Min_Fields>;
};


/** aggregate fields of "video.EventVonageSession" */
export type Video_EventVonageSession_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Video_EventVonageSession_Append_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "video.EventVonageSession". All fields are combined with a logical 'AND'. */
export type Video_EventVonageSession_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_EventVonageSession_Bool_Exp>>;
  readonly _not?: Maybe<Video_EventVonageSession_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_EventVonageSession_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly rtmpInputName?: Maybe<Video_RtmpInput_Enum_Comparison_Exp>;
  readonly sessionId?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.EventVonageSession" */
export enum Video_EventVonageSession_Constraint {
  /** unique or primary key constraint */
  EventVonageSessionEventIdKey = 'EventVonageSession_eventId_key',
  /** unique or primary key constraint */
  EventVonageSessionPkey = 'EventVonageSession_pkey',
  /** unique or primary key constraint */
  EventVonageSessionSessionIdKey = 'EventVonageSession_sessionId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Video_EventVonageSession_Delete_At_Path_Input = {
  readonly layoutData?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Video_EventVonageSession_Delete_Elem_Input = {
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Video_EventVonageSession_Delete_Key_Input = {
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "video.EventVonageSession" */
export type Video_EventVonageSession_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly rtmpInputName?: Maybe<Video_RtmpInput_Enum>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_EventVonageSession_Max_Fields = {
  readonly __typename?: 'video_EventVonageSession_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Video_EventVonageSession_Min_Fields = {
  readonly __typename?: 'video_EventVonageSession_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "video.EventVonageSession" */
export type Video_EventVonageSession_Mutation_Response = {
  readonly __typename?: 'video_EventVonageSession_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_EventVonageSession>;
};

/** input type for inserting object relation for remote table "video.EventVonageSession" */
export type Video_EventVonageSession_Obj_Rel_Insert_Input = {
  readonly data: Video_EventVonageSession_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_EventVonageSession_On_Conflict>;
};

/** on conflict condition type for table "video.EventVonageSession" */
export type Video_EventVonageSession_On_Conflict = {
  readonly constraint: Video_EventVonageSession_Constraint;
  readonly update_columns?: ReadonlyArray<Video_EventVonageSession_Update_Column>;
  readonly where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};

/** Ordering options when selecting data from "video.EventVonageSession". */
export type Video_EventVonageSession_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly rtmpInputName?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: video_EventVonageSession */
export type Video_EventVonageSession_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Video_EventVonageSession_Prepend_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "video.EventVonageSession" */
export enum Video_EventVonageSession_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  RtmpInputName = 'rtmpInputName',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.EventVonageSession" */
export type Video_EventVonageSession_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly rtmpInputName?: Maybe<Video_RtmpInput_Enum>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "video.EventVonageSession" */
export enum Video_EventVonageSession_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  RtmpInputName = 'rtmpInputName',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch = {
  readonly __typename?: 'video_ImmediateSwitch';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly errorMessage?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly event?: Maybe<Schedule_Event>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "video.ImmediateSwitch" */
export type Video_ImmediateSwitchDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Aggregate = {
  readonly __typename?: 'video_ImmediateSwitch_aggregate';
  readonly aggregate?: Maybe<Video_ImmediateSwitch_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_ImmediateSwitch>;
};

/** aggregate fields of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Aggregate_Fields = {
  readonly __typename?: 'video_ImmediateSwitch_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_ImmediateSwitch_Max_Fields>;
  readonly min?: Maybe<Video_ImmediateSwitch_Min_Fields>;
};


/** aggregate fields of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Video_ImmediateSwitch_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "video.ImmediateSwitch". All fields are combined with a logical 'AND'. */
export type Video_ImmediateSwitch_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Bool_Exp>>;
  readonly _not?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly errorMessage?: Maybe<String_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly executedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.ImmediateSwitch" */
export enum Video_ImmediateSwitch_Constraint {
  /** unique or primary key constraint */
  ImmediateSwitchPkey = 'ImmediateSwitch_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Video_ImmediateSwitch_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Video_ImmediateSwitch_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Video_ImmediateSwitch_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_ImmediateSwitch_Max_Fields = {
  readonly __typename?: 'video_ImmediateSwitch_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Video_ImmediateSwitch_Min_Fields = {
  readonly __typename?: 'video_ImmediateSwitch_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Mutation_Response = {
  readonly __typename?: 'video_ImmediateSwitch_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_ImmediateSwitch>;
};

/** on conflict condition type for table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_On_Conflict = {
  readonly constraint: Video_ImmediateSwitch_Constraint;
  readonly update_columns?: ReadonlyArray<Video_ImmediateSwitch_Update_Column>;
  readonly where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};

/** Ordering options when selecting data from "video.ImmediateSwitch". */
export type Video_ImmediateSwitch_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly errorMessage?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly executedAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: video_ImmediateSwitch */
export type Video_ImmediateSwitch_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Video_ImmediateSwitch_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "video.ImmediateSwitch" */
export enum Video_ImmediateSwitch_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  ErrorMessage = 'errorMessage',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExecutedAt = 'executedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "video.ImmediateSwitch" */
export enum Video_ImmediateSwitch_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  ErrorMessage = 'errorMessage',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExecutedAt = 'executedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "video.InputType" */
export type Video_InputType = {
  readonly __typename?: 'video_InputType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "video.InputType" */
export type Video_InputType_Aggregate = {
  readonly __typename?: 'video_InputType_aggregate';
  readonly aggregate?: Maybe<Video_InputType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_InputType>;
};

/** aggregate fields of "video.InputType" */
export type Video_InputType_Aggregate_Fields = {
  readonly __typename?: 'video_InputType_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_InputType_Max_Fields>;
  readonly min?: Maybe<Video_InputType_Min_Fields>;
};


/** aggregate fields of "video.InputType" */
export type Video_InputType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "video.InputType". All fields are combined with a logical 'AND'. */
export type Video_InputType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_InputType_Bool_Exp>>;
  readonly _not?: Maybe<Video_InputType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_InputType_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.InputType" */
export enum Video_InputType_Constraint {
  /** unique or primary key constraint */
  InputTypeNamePkey = 'InputTypeName_pkey'
}

/** input type for inserting data into table "video.InputType" */
export type Video_InputType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_InputType_Max_Fields = {
  readonly __typename?: 'video_InputType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Video_InputType_Min_Fields = {
  readonly __typename?: 'video_InputType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "video.InputType" */
export type Video_InputType_Mutation_Response = {
  readonly __typename?: 'video_InputType_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_InputType>;
};

/** on conflict condition type for table "video.InputType" */
export type Video_InputType_On_Conflict = {
  readonly constraint: Video_InputType_Constraint;
  readonly update_columns?: ReadonlyArray<Video_InputType_Update_Column>;
  readonly where?: Maybe<Video_InputType_Bool_Exp>;
};

/** Ordering options when selecting data from "video.InputType". */
export type Video_InputType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: video_InputType */
export type Video_InputType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "video.InputType" */
export enum Video_InputType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "video.InputType" */
export type Video_InputType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "video.InputType" */
export enum Video_InputType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "video.JobStatus" */
export type Video_JobStatus = {
  readonly __typename?: 'video_JobStatus';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "video.JobStatus" */
export type Video_JobStatus_Aggregate = {
  readonly __typename?: 'video_JobStatus_aggregate';
  readonly aggregate?: Maybe<Video_JobStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_JobStatus>;
};

/** aggregate fields of "video.JobStatus" */
export type Video_JobStatus_Aggregate_Fields = {
  readonly __typename?: 'video_JobStatus_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_JobStatus_Max_Fields>;
  readonly min?: Maybe<Video_JobStatus_Min_Fields>;
};


/** aggregate fields of "video.JobStatus" */
export type Video_JobStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "video.JobStatus". All fields are combined with a logical 'AND'. */
export type Video_JobStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_JobStatus_Bool_Exp>>;
  readonly _not?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_JobStatus_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.JobStatus" */
export enum Video_JobStatus_Constraint {
  /** unique or primary key constraint */
  JobStatusPkey = 'JobStatus_pkey'
}

export enum Video_JobStatus_Enum {
  /** Job completed successfully. */
  Completed = 'COMPLETED',
  /** Job is no longer valid. */
  Expired = 'EXPIRED',
  /** Job failed during execution. */
  Failed = 'FAILED',
  /** Job is currently in progress. */
  InProgress = 'IN_PROGRESS',
  /** Job has not yet started execution. */
  New = 'NEW'
}

/** Boolean expression to compare columns of type "video_JobStatus_enum". All fields are combined with logical 'AND'. */
export type Video_JobStatus_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Video_JobStatus_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Video_JobStatus_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Video_JobStatus_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Video_JobStatus_Enum>>;
};

/** input type for inserting data into table "video.JobStatus" */
export type Video_JobStatus_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_JobStatus_Max_Fields = {
  readonly __typename?: 'video_JobStatus_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Video_JobStatus_Min_Fields = {
  readonly __typename?: 'video_JobStatus_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "video.JobStatus" */
export type Video_JobStatus_Mutation_Response = {
  readonly __typename?: 'video_JobStatus_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_JobStatus>;
};

/** input type for inserting object relation for remote table "video.JobStatus" */
export type Video_JobStatus_Obj_Rel_Insert_Input = {
  readonly data: Video_JobStatus_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_JobStatus_On_Conflict>;
};

/** on conflict condition type for table "video.JobStatus" */
export type Video_JobStatus_On_Conflict = {
  readonly constraint: Video_JobStatus_Constraint;
  readonly update_columns?: ReadonlyArray<Video_JobStatus_Update_Column>;
  readonly where?: Maybe<Video_JobStatus_Bool_Exp>;
};

/** Ordering options when selecting data from "video.JobStatus". */
export type Video_JobStatus_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: video_JobStatus */
export type Video_JobStatus_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "video.JobStatus" */
export enum Video_JobStatus_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "video.JobStatus" */
export type Video_JobStatus_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "video.JobStatus" */
export enum Video_JobStatus_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus = {
  readonly __typename?: 'video_MediaLiveChannelStatus';
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly channelStack: Video_ChannelStack;
  readonly channelStackId: Scalars['uuid'];
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly state: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Aggregate = {
  readonly __typename?: 'video_MediaLiveChannelStatus_aggregate';
  readonly aggregate?: Maybe<Video_MediaLiveChannelStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_MediaLiveChannelStatus>;
};

/** aggregate fields of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Aggregate_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_aggregate_fields';
  readonly avg?: Maybe<Video_MediaLiveChannelStatus_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_MediaLiveChannelStatus_Max_Fields>;
  readonly min?: Maybe<Video_MediaLiveChannelStatus_Min_Fields>;
  readonly stddev?: Maybe<Video_MediaLiveChannelStatus_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Video_MediaLiveChannelStatus_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Video_MediaLiveChannelStatus_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Video_MediaLiveChannelStatus_Sum_Fields>;
  readonly var_pop?: Maybe<Video_MediaLiveChannelStatus_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Video_MediaLiveChannelStatus_Var_Samp_Fields>;
  readonly variance?: Maybe<Video_MediaLiveChannelStatus_Variance_Fields>;
};


/** aggregate fields of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Video_MediaLiveChannelStatus_Avg_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_avg_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "video.MediaLiveChannelStatus". All fields are combined with a logical 'AND'. */
export type Video_MediaLiveChannelStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Bool_Exp>>;
  readonly _not?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Bool_Exp>>;
  readonly activeInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly activeInputSwitchActionName?: Maybe<String_Comparison_Exp>;
  readonly channelStack?: Maybe<Video_ChannelStack_Bool_Exp>;
  readonly channelStackId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly pipelinesRunningCount?: Maybe<Numeric_Comparison_Exp>;
  readonly state?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.MediaLiveChannelStatus" */
export enum Video_MediaLiveChannelStatus_Constraint {
  /** unique or primary key constraint */
  MediaLiveChannelStatusChannelStackIdKey = 'MediaLiveChannelStatus_channelStackId_key',
  /** unique or primary key constraint */
  MediaLiveChannelStatusPkey = 'MediaLiveChannelStatus_pkey'
}

/** input type for incrementing numeric columns in table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Inc_Input = {
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Insert_Input = {
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStack?: Maybe<Video_ChannelStack_Obj_Rel_Insert_Input>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly state?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_MediaLiveChannelStatus_Max_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_max_fields';
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly state?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate min on columns */
export type Video_MediaLiveChannelStatus_Min_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_min_fields';
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly state?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** response of any mutation on the table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Mutation_Response = {
  readonly __typename?: 'video_MediaLiveChannelStatus_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_MediaLiveChannelStatus>;
};

/** input type for inserting object relation for remote table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Obj_Rel_Insert_Input = {
  readonly data: Video_MediaLiveChannelStatus_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_MediaLiveChannelStatus_On_Conflict>;
};

/** on conflict condition type for table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_On_Conflict = {
  readonly constraint: Video_MediaLiveChannelStatus_Constraint;
  readonly update_columns?: ReadonlyArray<Video_MediaLiveChannelStatus_Update_Column>;
  readonly where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};

/** Ordering options when selecting data from "video.MediaLiveChannelStatus". */
export type Video_MediaLiveChannelStatus_Order_By = {
  readonly activeInputAttachmentName?: Maybe<Order_By>;
  readonly activeInputSwitchActionName?: Maybe<Order_By>;
  readonly channelStack?: Maybe<Video_ChannelStack_Order_By>;
  readonly channelStackId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly pipelinesRunningCount?: Maybe<Order_By>;
  readonly state?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: video_MediaLiveChannelStatus */
export type Video_MediaLiveChannelStatus_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.MediaLiveChannelStatus" */
export enum Video_MediaLiveChannelStatus_Select_Column {
  /** column name */
  ActiveInputAttachmentName = 'activeInputAttachmentName',
  /** column name */
  ActiveInputSwitchActionName = 'activeInputSwitchActionName',
  /** column name */
  ChannelStackId = 'channelStackId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PipelinesRunningCount = 'pipelinesRunningCount',
  /** column name */
  State = 'state',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Set_Input = {
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly state?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Video_MediaLiveChannelStatus_Stddev_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_stddev_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Video_MediaLiveChannelStatus_Stddev_Pop_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_stddev_pop_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Video_MediaLiveChannelStatus_Stddev_Samp_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_stddev_samp_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Video_MediaLiveChannelStatus_Sum_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_sum_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
};

/** update columns of table "video.MediaLiveChannelStatus" */
export enum Video_MediaLiveChannelStatus_Update_Column {
  /** column name */
  ActiveInputAttachmentName = 'activeInputAttachmentName',
  /** column name */
  ActiveInputSwitchActionName = 'activeInputSwitchActionName',
  /** column name */
  ChannelStackId = 'channelStackId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PipelinesRunningCount = 'pipelinesRunningCount',
  /** column name */
  State = 'state',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Video_MediaLiveChannelStatus_Var_Pop_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_var_pop_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Video_MediaLiveChannelStatus_Var_Samp_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_var_samp_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Video_MediaLiveChannelStatus_Variance_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_variance_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/**
 * Enables broadcasting of a live-stream from a room to an RTMP-capable service, such as YouTube.
 *
 *
 * columns and relationships of "video.RoomRtmpOutput"
 *
 */
export type Video_RoomRtmpOutput = {
  readonly __typename?: 'video_RoomRtmpOutput';
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly streamKey: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
  readonly url: Scalars['String'];
};

/** aggregated selection of "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_Aggregate = {
  readonly __typename?: 'video_RoomRtmpOutput_aggregate';
  readonly aggregate?: Maybe<Video_RoomRtmpOutput_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_RoomRtmpOutput>;
};

/** aggregate fields of "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_Aggregate_Fields = {
  readonly __typename?: 'video_RoomRtmpOutput_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_RoomRtmpOutput_Max_Fields>;
  readonly min?: Maybe<Video_RoomRtmpOutput_Min_Fields>;
};


/** aggregate fields of "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "video.RoomRtmpOutput". All fields are combined with a logical 'AND'. */
export type Video_RoomRtmpOutput_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Bool_Exp>>;
  readonly _not?: Maybe<Video_RoomRtmpOutput_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_RoomRtmpOutput_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly streamKey?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly url?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.RoomRtmpOutput" */
export enum Video_RoomRtmpOutput_Constraint {
  /** unique or primary key constraint */
  EventRtmpOutputPkey = 'EventRtmpOutput_pkey',
  /** unique or primary key constraint */
  RoomRtmpOutputRoomIdKey = 'RoomRtmpOutput_roomId_key'
}

/** input type for inserting data into table "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly streamKey?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly url?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_RoomRtmpOutput_Max_Fields = {
  readonly __typename?: 'video_RoomRtmpOutput_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly streamKey?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly url?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Video_RoomRtmpOutput_Min_Fields = {
  readonly __typename?: 'video_RoomRtmpOutput_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly streamKey?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly url?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_Mutation_Response = {
  readonly __typename?: 'video_RoomRtmpOutput_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_RoomRtmpOutput>;
};

/** input type for inserting object relation for remote table "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_Obj_Rel_Insert_Input = {
  readonly data: Video_RoomRtmpOutput_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_RoomRtmpOutput_On_Conflict>;
};

/** on conflict condition type for table "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_On_Conflict = {
  readonly constraint: Video_RoomRtmpOutput_Constraint;
  readonly update_columns?: ReadonlyArray<Video_RoomRtmpOutput_Update_Column>;
  readonly where?: Maybe<Video_RoomRtmpOutput_Bool_Exp>;
};

/** Ordering options when selecting data from "video.RoomRtmpOutput". */
export type Video_RoomRtmpOutput_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly streamKey?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly url?: Maybe<Order_By>;
};

/** primary key columns input for table: video_RoomRtmpOutput */
export type Video_RoomRtmpOutput_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.RoomRtmpOutput" */
export enum Video_RoomRtmpOutput_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StreamKey = 'streamKey',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Url = 'url'
}

/** input type for updating data in table "video.RoomRtmpOutput" */
export type Video_RoomRtmpOutput_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly streamKey?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly url?: Maybe<Scalars['String']>;
};

/** update columns of table "video.RoomRtmpOutput" */
export enum Video_RoomRtmpOutput_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StreamKey = 'streamKey',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Url = 'url'
}

/** columns and relationships of "video.RtmpInput" */
export type Video_RtmpInput = {
  readonly __typename?: 'video_RtmpInput';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "video.RtmpInput" */
export type Video_RtmpInput_Aggregate = {
  readonly __typename?: 'video_RtmpInput_aggregate';
  readonly aggregate?: Maybe<Video_RtmpInput_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_RtmpInput>;
};

/** aggregate fields of "video.RtmpInput" */
export type Video_RtmpInput_Aggregate_Fields = {
  readonly __typename?: 'video_RtmpInput_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_RtmpInput_Max_Fields>;
  readonly min?: Maybe<Video_RtmpInput_Min_Fields>;
};


/** aggregate fields of "video.RtmpInput" */
export type Video_RtmpInput_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "video.RtmpInput". All fields are combined with a logical 'AND'. */
export type Video_RtmpInput_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_RtmpInput_Bool_Exp>>;
  readonly _not?: Maybe<Video_RtmpInput_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_RtmpInput_Bool_Exp>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.RtmpInput" */
export enum Video_RtmpInput_Constraint {
  /** unique or primary key constraint */
  RtmpInputPkey = 'RtmpInput_pkey'
}

export enum Video_RtmpInput_Enum {
  /** The A RTMP input. */
  RtmpA = 'RTMP_A',
  /** The B RTMP input. */
  RtmpB = 'RTMP_B'
}

/** Boolean expression to compare columns of type "video_RtmpInput_enum". All fields are combined with logical 'AND'. */
export type Video_RtmpInput_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Video_RtmpInput_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Video_RtmpInput_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Video_RtmpInput_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Video_RtmpInput_Enum>>;
};

/** input type for inserting data into table "video.RtmpInput" */
export type Video_RtmpInput_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_RtmpInput_Max_Fields = {
  readonly __typename?: 'video_RtmpInput_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Video_RtmpInput_Min_Fields = {
  readonly __typename?: 'video_RtmpInput_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "video.RtmpInput" */
export type Video_RtmpInput_Mutation_Response = {
  readonly __typename?: 'video_RtmpInput_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_RtmpInput>;
};

/** on conflict condition type for table "video.RtmpInput" */
export type Video_RtmpInput_On_Conflict = {
  readonly constraint: Video_RtmpInput_Constraint;
  readonly update_columns?: ReadonlyArray<Video_RtmpInput_Update_Column>;
  readonly where?: Maybe<Video_RtmpInput_Bool_Exp>;
};

/** Ordering options when selecting data from "video.RtmpInput". */
export type Video_RtmpInput_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: video_RtmpInput */
export type Video_RtmpInput_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "video.RtmpInput" */
export enum Video_RtmpInput_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "video.RtmpInput" */
export type Video_RtmpInput_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "video.RtmpInput" */
export enum Video_RtmpInput_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "video.TranscriptionJob" */
export type Video_TranscriptionJob = {
  readonly __typename?: 'video_TranscriptionJob';
  readonly awsTranscribeJobName: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly languageCode: Scalars['String'];
  readonly transcriptionS3Url: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
  readonly videoS3Url: Scalars['String'];
};

/** aggregated selection of "video.TranscriptionJob" */
export type Video_TranscriptionJob_Aggregate = {
  readonly __typename?: 'video_TranscriptionJob_aggregate';
  readonly aggregate?: Maybe<Video_TranscriptionJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_TranscriptionJob>;
};

/** aggregate fields of "video.TranscriptionJob" */
export type Video_TranscriptionJob_Aggregate_Fields = {
  readonly __typename?: 'video_TranscriptionJob_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_TranscriptionJob_Max_Fields>;
  readonly min?: Maybe<Video_TranscriptionJob_Min_Fields>;
};


/** aggregate fields of "video.TranscriptionJob" */
export type Video_TranscriptionJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** Boolean expression to filter rows from the table "video.TranscriptionJob". All fields are combined with a logical 'AND'. */
export type Video_TranscriptionJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_TranscriptionJob_Bool_Exp>>;
  readonly _not?: Maybe<Video_TranscriptionJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_TranscriptionJob_Bool_Exp>>;
  readonly awsTranscribeJobName?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly languageCode?: Maybe<String_Comparison_Exp>;
  readonly transcriptionS3Url?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoS3Url?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.TranscriptionJob" */
export enum Video_TranscriptionJob_Constraint {
  /** unique or primary key constraint */
  TranscriptionJobAwsTranscribeJobNameKey = 'TranscriptionJob_awsTranscribeJobName_key',
  /** unique or primary key constraint */
  TranscriptionJobPkey = 'TranscriptionJob_pkey'
}

/** input type for inserting data into table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Insert_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_TranscriptionJob_Max_Fields = {
  readonly __typename?: 'video_TranscriptionJob_max_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Video_TranscriptionJob_Min_Fields = {
  readonly __typename?: 'video_TranscriptionJob_min_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Mutation_Response = {
  readonly __typename?: 'video_TranscriptionJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_TranscriptionJob>;
};

/** on conflict condition type for table "video.TranscriptionJob" */
export type Video_TranscriptionJob_On_Conflict = {
  readonly constraint: Video_TranscriptionJob_Constraint;
  readonly update_columns?: ReadonlyArray<Video_TranscriptionJob_Update_Column>;
  readonly where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};

/** Ordering options when selecting data from "video.TranscriptionJob". */
export type Video_TranscriptionJob_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** primary key columns input for table: video_TranscriptionJob */
export type Video_TranscriptionJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.TranscriptionJob" */
export enum Video_TranscriptionJob_Select_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** input type for updating data in table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Set_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** update columns of table "video.TranscriptionJob" */
export enum Video_TranscriptionJob_Update_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** columns and relationships of "video.VideoRenderJob" */
export type Video_VideoRenderJob = {
  readonly __typename?: 'video_VideoRenderJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly conferencePrepareJob: Conference_PrepareJob;
  readonly conferencePrepareJobId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly element?: Maybe<Content_Element>;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "video.VideoRenderJob" */
export type Video_VideoRenderJobDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate = {
  readonly __typename?: 'video_VideoRenderJob_aggregate';
  readonly aggregate?: Maybe<Video_VideoRenderJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_VideoRenderJob>;
};

/** aggregate fields of "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate_Fields = {
  readonly __typename?: 'video_VideoRenderJob_aggregate_fields';
  readonly avg?: Maybe<Video_VideoRenderJob_Avg_Fields>;
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_VideoRenderJob_Max_Fields>;
  readonly min?: Maybe<Video_VideoRenderJob_Min_Fields>;
  readonly stddev?: Maybe<Video_VideoRenderJob_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Video_VideoRenderJob_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Video_VideoRenderJob_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Video_VideoRenderJob_Sum_Fields>;
  readonly var_pop?: Maybe<Video_VideoRenderJob_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Video_VideoRenderJob_Var_Samp_Fields>;
  readonly variance?: Maybe<Video_VideoRenderJob_Variance_Fields>;
};


/** aggregate fields of "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate_Order_By = {
  readonly avg?: Maybe<Video_VideoRenderJob_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_VideoRenderJob_Max_Order_By>;
  readonly min?: Maybe<Video_VideoRenderJob_Min_Order_By>;
  readonly stddev?: Maybe<Video_VideoRenderJob_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Video_VideoRenderJob_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Video_VideoRenderJob_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Video_VideoRenderJob_Sum_Order_By>;
  readonly var_pop?: Maybe<Video_VideoRenderJob_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Video_VideoRenderJob_Var_Samp_Order_By>;
  readonly variance?: Maybe<Video_VideoRenderJob_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Video_VideoRenderJob_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_VideoRenderJob_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_VideoRenderJob_On_Conflict>;
};

/** aggregate avg on columns */
export type Video_VideoRenderJob_Avg_Fields = {
  readonly __typename?: 'video_VideoRenderJob_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "video.VideoRenderJob". All fields are combined with a logical 'AND'. */
export type Video_VideoRenderJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_VideoRenderJob_Bool_Exp>>;
  readonly _not?: Maybe<Video_VideoRenderJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_VideoRenderJob_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly conferencePrepareJob?: Maybe<Conference_PrepareJob_Bool_Exp>;
  readonly conferencePrepareJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.VideoRenderJob" */
export enum Video_VideoRenderJob_Constraint {
  /** unique or primary key constraint */
  VideoRenderJobPkey = 'VideoRenderJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Video_VideoRenderJob_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Scalars['String']>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Video_VideoRenderJob_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Video_VideoRenderJob_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing numeric columns in table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJob?: Maybe<Conference_PrepareJob_Obj_Rel_Insert_Input>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_VideoRenderJob_Max_Fields = {
  readonly __typename?: 'video_VideoRenderJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_VideoRenderJob_Min_Fields = {
  readonly __typename?: 'video_VideoRenderJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Mutation_Response = {
  readonly __typename?: 'video_VideoRenderJob_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_VideoRenderJob>;
};

/** on conflict condition type for table "video.VideoRenderJob" */
export type Video_VideoRenderJob_On_Conflict = {
  readonly constraint: Video_VideoRenderJob_Constraint;
  readonly update_columns?: ReadonlyArray<Video_VideoRenderJob_Update_Column>;
  readonly where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};

/** Ordering options when selecting data from "video.VideoRenderJob". */
export type Video_VideoRenderJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJob?: Maybe<Conference_PrepareJob_Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: video_VideoRenderJob */
export type Video_VideoRenderJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Video_VideoRenderJob_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "video.VideoRenderJob" */
export enum Video_VideoRenderJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Video_VideoRenderJob_Stddev_Fields = {
  readonly __typename?: 'video_VideoRenderJob_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Video_VideoRenderJob_Stddev_Pop_Fields = {
  readonly __typename?: 'video_VideoRenderJob_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Video_VideoRenderJob_Stddev_Samp_Fields = {
  readonly __typename?: 'video_VideoRenderJob_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Video_VideoRenderJob_Sum_Fields = {
  readonly __typename?: 'video_VideoRenderJob_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "video.VideoRenderJob" */
export enum Video_VideoRenderJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Video_VideoRenderJob_Var_Pop_Fields = {
  readonly __typename?: 'video_VideoRenderJob_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Video_VideoRenderJob_Var_Samp_Fields = {
  readonly __typename?: 'video_VideoRenderJob_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Video_VideoRenderJob_Variance_Fields = {
  readonly __typename?: 'video_VideoRenderJob_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** columns and relationships of "video.VonageRoomRecording" */
export type Video_VonageRoomRecording = {
  readonly __typename?: 'video_VonageRoomRecording';
  readonly created_at: Scalars['timestamptz'];
  readonly endedAt?: Maybe<Scalars['timestamptz']>;
  readonly id: Scalars['uuid'];
  readonly initiatedBy?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly initiator?: Maybe<Registrant_Registrant>;
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly s3Url?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly saves: ReadonlyArray<Registrant_SavedVonageRoomRecording>;
  /** An aggregate relationship */
  readonly saves_aggregate: Registrant_SavedVonageRoomRecording_Aggregate;
  readonly startedAt: Scalars['timestamptz'];
  readonly updated_at: Scalars['timestamptz'];
  readonly uploaded_at?: Maybe<Scalars['timestamptz']>;
  readonly vonageSessionId: Scalars['String'];
};


/** columns and relationships of "video.VonageRoomRecording" */
export type Video_VonageRoomRecordingSavesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Order_By>>;
  where?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
};


/** columns and relationships of "video.VonageRoomRecording" */
export type Video_VonageRoomRecordingSaves_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_SavedVonageRoomRecording_Order_By>>;
  where?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
};

/** aggregated selection of "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Aggregate = {
  readonly __typename?: 'video_VonageRoomRecording_aggregate';
  readonly aggregate?: Maybe<Video_VonageRoomRecording_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_VonageRoomRecording>;
};

/** aggregate fields of "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Aggregate_Fields = {
  readonly __typename?: 'video_VonageRoomRecording_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_VonageRoomRecording_Max_Fields>;
  readonly min?: Maybe<Video_VonageRoomRecording_Min_Fields>;
};


/** aggregate fields of "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_VonageRoomRecording_Max_Order_By>;
  readonly min?: Maybe<Video_VonageRoomRecording_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_VonageRoomRecording_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_VonageRoomRecording_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.VonageRoomRecording". All fields are combined with a logical 'AND'. */
export type Video_VonageRoomRecording_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Bool_Exp>>;
  readonly _not?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_VonageRoomRecording_Bool_Exp>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly initiatedBy?: Maybe<Uuid_Comparison_Exp>;
  readonly initiator?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly s3Url?: Maybe<String_Comparison_Exp>;
  readonly saves?: Maybe<Registrant_SavedVonageRoomRecording_Bool_Exp>;
  readonly startedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploaded_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageSessionId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.VonageRoomRecording" */
export enum Video_VonageRoomRecording_Constraint {
  /** unique or primary key constraint */
  VonageRoomRecordingPkey = 'VonageRoomRecording_pkey'
}

/** input type for inserting data into table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly initiatedBy?: Maybe<Scalars['uuid']>;
  readonly initiator?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly s3Url?: Maybe<Scalars['String']>;
  readonly saves?: Maybe<Registrant_SavedVonageRoomRecording_Arr_Rel_Insert_Input>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaded_at?: Maybe<Scalars['timestamptz']>;
  readonly vonageSessionId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_VonageRoomRecording_Max_Fields = {
  readonly __typename?: 'video_VonageRoomRecording_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly initiatedBy?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly s3Url?: Maybe<Scalars['String']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaded_at?: Maybe<Scalars['timestamptz']>;
  readonly vonageSessionId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly endedAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly initiatedBy?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly s3Url?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaded_at?: Maybe<Order_By>;
  readonly vonageSessionId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_VonageRoomRecording_Min_Fields = {
  readonly __typename?: 'video_VonageRoomRecording_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly initiatedBy?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly s3Url?: Maybe<Scalars['String']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaded_at?: Maybe<Scalars['timestamptz']>;
  readonly vonageSessionId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly endedAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly initiatedBy?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly s3Url?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaded_at?: Maybe<Order_By>;
  readonly vonageSessionId?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Mutation_Response = {
  readonly __typename?: 'video_VonageRoomRecording_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_VonageRoomRecording>;
};

/** input type for inserting object relation for remote table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Obj_Rel_Insert_Input = {
  readonly data: Video_VonageRoomRecording_Insert_Input;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_VonageRoomRecording_On_Conflict>;
};

/** on conflict condition type for table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_On_Conflict = {
  readonly constraint: Video_VonageRoomRecording_Constraint;
  readonly update_columns?: ReadonlyArray<Video_VonageRoomRecording_Update_Column>;
  readonly where?: Maybe<Video_VonageRoomRecording_Bool_Exp>;
};

/** Ordering options when selecting data from "video.VonageRoomRecording". */
export type Video_VonageRoomRecording_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly endedAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly initiatedBy?: Maybe<Order_By>;
  readonly initiator?: Maybe<Registrant_Registrant_Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly s3Url?: Maybe<Order_By>;
  readonly saves_aggregate?: Maybe<Registrant_SavedVonageRoomRecording_Aggregate_Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaded_at?: Maybe<Order_By>;
  readonly vonageSessionId?: Maybe<Order_By>;
};

/** primary key columns input for table: video_VonageRoomRecording */
export type Video_VonageRoomRecording_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.VonageRoomRecording" */
export enum Video_VonageRoomRecording_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  Id = 'id',
  /** column name */
  InitiatedBy = 'initiatedBy',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  S3Url = 's3Url',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploadedAt = 'uploaded_at',
  /** column name */
  VonageSessionId = 'vonageSessionId'
}

/** input type for updating data in table "video.VonageRoomRecording" */
export type Video_VonageRoomRecording_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly initiatedBy?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly s3Url?: Maybe<Scalars['String']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaded_at?: Maybe<Scalars['timestamptz']>;
  readonly vonageSessionId?: Maybe<Scalars['String']>;
};

/** update columns of table "video.VonageRoomRecording" */
export enum Video_VonageRoomRecording_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndedAt = 'endedAt',
  /** column name */
  Id = 'id',
  /** column name */
  InitiatedBy = 'initiatedBy',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  S3Url = 's3Url',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploadedAt = 'uploaded_at',
  /** column name */
  VonageSessionId = 'vonageSessionId'
}

/** columns and relationships of "video.YouTubeUpload" */
export type Video_YouTubeUpload = {
  readonly __typename?: 'video_YouTubeUpload';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element?: Maybe<Content_Element>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId: Scalars['String'];
  readonly videoPrivacyStatus: Scalars['String'];
  readonly videoStatus: Scalars['String'];
  readonly videoTitle: Scalars['String'];
};

/** aggregated selection of "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate = {
  readonly __typename?: 'video_YouTubeUpload_aggregate';
  readonly aggregate?: Maybe<Video_YouTubeUpload_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_YouTubeUpload>;
};

/** aggregate fields of "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate_Fields = {
  readonly __typename?: 'video_YouTubeUpload_aggregate_fields';
  readonly count: Scalars['Int'];
  readonly max?: Maybe<Video_YouTubeUpload_Max_Fields>;
  readonly min?: Maybe<Video_YouTubeUpload_Min_Fields>;
};


/** aggregate fields of "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_YouTubeUpload_Max_Order_By>;
  readonly min?: Maybe<Video_YouTubeUpload_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_YouTubeUpload_Insert_Input>;
  /** on conflict condition */
  readonly on_conflict?: Maybe<Video_YouTubeUpload_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.YouTubeUpload". All fields are combined with a logical 'AND'. */
export type Video_YouTubeUpload_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Video_YouTubeUpload_Bool_Exp>>;
  readonly _not?: Maybe<Video_YouTubeUpload_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Video_YouTubeUpload_Bool_Exp>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadYouTubeVideoJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly videoId?: Maybe<String_Comparison_Exp>;
  readonly videoPrivacyStatus?: Maybe<String_Comparison_Exp>;
  readonly videoStatus?: Maybe<String_Comparison_Exp>;
  readonly videoTitle?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.YouTubeUpload" */
export enum Video_YouTubeUpload_Constraint {
  /** unique or primary key constraint */
  YouTubeUploadPkey = 'YouTubeUpload_pkey',
  /** unique or primary key constraint */
  YouTubeUploadVideoIdKey = 'YouTubeUpload_videoId_key'
}

/** input type for inserting data into table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_YouTubeUpload_Max_Fields = {
  readonly __typename?: 'video_YouTubeUpload_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_YouTubeUpload_Min_Fields = {
  readonly __typename?: 'video_YouTubeUpload_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Mutation_Response = {
  readonly __typename?: 'video_YouTubeUpload_mutation_response';
  /** number of rows affected by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  readonly returning: ReadonlyArray<Video_YouTubeUpload>;
};

/** on conflict condition type for table "video.YouTubeUpload" */
export type Video_YouTubeUpload_On_Conflict = {
  readonly constraint: Video_YouTubeUpload_Constraint;
  readonly update_columns?: ReadonlyArray<Video_YouTubeUpload_Update_Column>;
  readonly where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};

/** Ordering options when selecting data from "video.YouTubeUpload". */
export type Video_YouTubeUpload_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** primary key columns input for table: video_YouTubeUpload */
export type Video_YouTubeUpload_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.YouTubeUpload" */
export enum Video_YouTubeUpload_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadYouTubeVideoJobId = 'uploadYouTubeVideoJobId',
  /** column name */
  VideoId = 'videoId',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoStatus = 'videoStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** input type for updating data in table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** update columns of table "video.YouTubeUpload" */
export enum Video_YouTubeUpload_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadYouTubeVideoJobId = 'uploadYouTubeVideoJobId',
  /** column name */
  VideoId = 'videoId',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoStatus = 'videoStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

export type GetSlugForUrlQueryVariables = Exact<{
  url: Scalars['String'];
}>;


export type GetSlugForUrlQuery = { readonly __typename?: 'query_root', readonly getSlug: { readonly __typename?: 'GetSlugOutput', readonly slug?: Maybe<string> } };

export type ChatState_SubdMessageFragment = { readonly __typename?: 'chat_Message', readonly id: number, readonly chatId: any, readonly message: string, readonly type: Chat_MessageType_Enum, readonly senderId?: Maybe<any> };

export type InitialChatState_ChatFragment = { readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string> }>, readonly nonDMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly DMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> }>, readonly pins: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly registrantId: any, readonly chatId: any, readonly wasManuallyPinned: boolean }>, readonly subscriptions: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly registrantId: any, readonly chatId: any, readonly wasManuallySubscribed: boolean }> };

export type InitialChatStateQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type InitialChatStateQuery = { readonly __typename?: 'query_root', readonly chat_Pin: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly chatId: any, readonly registrantId: any, readonly chat: { readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string> }>, readonly nonDMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly DMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> }>, readonly pins: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly registrantId: any, readonly chatId: any, readonly wasManuallyPinned: boolean }>, readonly subscriptions: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly registrantId: any, readonly chatId: any, readonly wasManuallySubscribed: boolean }> } }> };

export type SelectInitialChatStateQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type SelectInitialChatStateQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string> }>, readonly nonDMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly DMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> }>, readonly pins: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly registrantId: any, readonly chatId: any, readonly wasManuallyPinned: boolean }>, readonly subscriptions: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly registrantId: any, readonly chatId: any, readonly wasManuallySubscribed: boolean }> }> };

export type SelectInitialChatStatesQueryVariables = Exact<{
  chatIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type SelectInitialChatStatesQuery = { readonly __typename?: 'query_root', readonly chat_Chat: ReadonlyArray<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string> }>, readonly nonDMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly DMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> }>, readonly pins: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly registrantId: any, readonly chatId: any, readonly wasManuallyPinned: boolean }>, readonly subscriptions: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly registrantId: any, readonly chatId: any, readonly wasManuallySubscribed: boolean }> }> };

export type SubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type SubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Subscription?: Maybe<{ readonly __typename?: 'chat_Subscription_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly chatId: any, readonly registrantId: any }> }> };

export type UnsubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type UnsubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Subscription_by_pk?: Maybe<{ readonly __typename?: 'chat_Subscription', readonly registrantId: any, readonly chatId: any }> };

export type PinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type PinChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Pin?: Maybe<{ readonly __typename?: 'chat_Pin_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly chatId: any, readonly registrantId: any }> }> };

export type UnpinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type UnpinChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Pin_by_pk?: Maybe<{ readonly __typename?: 'chat_Pin', readonly registrantId: any, readonly chatId: any }> };

export type ChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly sId: any, readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly duplicateSId?: Maybe<any>, readonly created_at: any, readonly updated_at: any, readonly chatId: any };

export type ChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly id: number, readonly sId: any, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly reactions: ReadonlyArray<{ readonly __typename?: 'chat_Reaction', readonly sId: any, readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly duplicateSId?: Maybe<any>, readonly created_at: any, readonly updated_at: any, readonly chatId: any }> };

export type SelectMessagesPageQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  startAtIndex: Scalars['Int'];
  maxCount: Scalars['Int'];
}>;


export type SelectMessagesPageQuery = { readonly __typename?: 'query_root', readonly chat_Message: ReadonlyArray<{ readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly id: number, readonly sId: any, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly reactions: ReadonlyArray<{ readonly __typename?: 'chat_Reaction', readonly sId: any, readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly duplicateSId?: Maybe<any>, readonly created_at: any, readonly updated_at: any, readonly chatId: any }> }> };

export type ShortChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly sId: any };

export type ShortChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly sId: any, readonly duplicateSId?: Maybe<any> };

export type ChatFlagDataFragment = { readonly __typename?: 'chat_Flag', readonly discussionChatId?: Maybe<any>, readonly flaggedById?: Maybe<any>, readonly id: number, readonly messageSId: any, readonly notes?: Maybe<string>, readonly resolution?: Maybe<string>, readonly resolved_at?: Maybe<any>, readonly type: Chat_FlagType_Enum, readonly updated_at: any, readonly created_at: any };

export type InsertChatFlagMutationVariables = Exact<{
  messageSId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
  type: Chat_FlagType_Enum;
  reason: Scalars['String'];
}>;


export type InsertChatFlagMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Flag_one?: Maybe<{ readonly __typename?: 'chat_Flag', readonly discussionChatId?: Maybe<any>, readonly flaggedById?: Maybe<any>, readonly id: number, readonly messageSId: any, readonly notes?: Maybe<string>, readonly resolution?: Maybe<string>, readonly resolved_at?: Maybe<any>, readonly type: Chat_FlagType_Enum, readonly updated_at: any, readonly created_at: any }> };

export type GetChatPathQueryVariables = Exact<{
  chatId: Scalars['uuid'];
}>;


export type GetChatPathQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any }> }> };

export type ConferenceLandingPageItemQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferenceLandingPageItemQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibition: { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> } }> }> };

export type ProgramPersonDataFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } };

export type ItemElements_GetItemQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type ItemElements_GetItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibition: { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> } }> }> };

export type ElementDataFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum };

export type ItemElements_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibition: { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> } }> };

export type ItemTagDataFragment = { readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } };

export type ItemExhibitionDataFragment = { readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibition: { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> } };

export type ItemRoomEventFragment = { readonly __typename?: 'schedule_Event', readonly startTime: any, readonly exhibitionId?: Maybe<any>, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type ItemList_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }> };

export type ItemList_ItemTagDataFragment = { readonly __typename?: 'content_ItemTag', readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }> } };

export type ItemList_TagInfoFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly colour: string, readonly name: string, readonly priority: number };

export type ContentOfTagQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type ContentOfTagQuery = { readonly __typename?: 'query_root', readonly content_ItemTag: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }> } }> };

export type TagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type TagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly colour: string, readonly name: string, readonly priority: number }> };

export type GetItemQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type GetItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibition: { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> } }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly startTime: any, readonly roomId: any, readonly exhibitionId?: Maybe<any>, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly room: { readonly __typename?: 'room_Room', readonly name: string, readonly id: any } }> };

export type ItemPage_ItemRoomsFragment = { readonly __typename?: 'content_Item', readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type ItemEventFragment = { readonly __typename?: 'schedule_Event', readonly startTime: any, readonly roomId: any, readonly exhibitionId?: Maybe<any>, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly room: { readonly __typename?: 'room_Room', readonly name: string, readonly id: any } };

export type ContinuationChoices_ContinuationFragment = { readonly __typename?: 'schedule_Continuation', readonly id: any, readonly to: any, readonly defaultFor: string, readonly isActiveChoice: boolean, readonly priority: number, readonly colour: string, readonly description: string };

export type ContinuationChoices_ContinuationsQueryVariables = Exact<{
  fromId: Scalars['uuid'];
  nowStart?: Maybe<Scalars['timestamptz']>;
  nowEnd?: Maybe<Scalars['timestamptz']>;
}>;


export type ContinuationChoices_ContinuationsQuery = { readonly __typename?: 'query_root', readonly schedule_Continuation: ReadonlyArray<{ readonly __typename?: 'schedule_Continuation', readonly id: any, readonly to: any, readonly defaultFor: string, readonly isActiveChoice: boolean, readonly priority: number, readonly colour: string, readonly description: string }>, readonly room_ShufflePeriod: ReadonlyArray<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly endAt: any, readonly roomDurationMinutes: number }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly endTime?: Maybe<any> }> };

export type ContinuationChoices_RoomsQueryVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ContinuationChoices_RoomsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any }> };

export type ExhibitionItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }>, readonly events: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly roomId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }>, readonly discussionRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type ExhibitionWithContentFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly conferenceId: any, readonly descriptiveItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }> }>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly layout?: Maybe<any>, readonly priority?: Maybe<number>, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }>, readonly events: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly roomId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }>, readonly discussionRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> } }> };

export type SelectExhibitionQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type SelectExhibitionQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition_by_pk?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly conferenceId: any, readonly descriptiveItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }> }>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly layout?: Maybe<any>, readonly priority?: Maybe<number>, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum }>, readonly events: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly roomId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }>, readonly discussionRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> } }> }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly startTime: any, readonly roomId: any, readonly exhibitionId?: Maybe<any>, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly room: { readonly __typename?: 'room_Room', readonly name: string, readonly id: any } }> };

export type ExhibitionSummaryFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> };

export type SelectAllExhibitionsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllExhibitionsQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> }> };

export type RegistrantByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type RegistrantByIdQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> };

export type UpdateProfileMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  profile?: Maybe<Registrant_Profile_Set_Input>;
}>;


export type UpdateProfileMutation = { readonly __typename?: 'mutation_root', readonly update_registrant_Profile_by_pk?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> };

export type UpdateRegistrantDisplayNameMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type UpdateRegistrantDisplayNameMutation = { readonly __typename?: 'mutation_root', readonly update_registrant_Registrant_by_pk?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> };

export type SubmitProfilePhotoMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  s3URL: Scalars['String'];
}>;


export type SubmitProfilePhotoMutation = { readonly __typename?: 'mutation_root', readonly updateProfilePhoto?: Maybe<{ readonly __typename?: 'UpdateProfilePhotoResponse', readonly ok: boolean, readonly photoURL_350x350?: Maybe<string>, readonly photoURL_50x50?: Maybe<string> }> };

export type MyBackstages_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } };

export type RegistrantEventsWithBackstagesQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type RegistrantEventsWithBackstagesQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }> };

export type ProfilePage_ItemsQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type ProfilePage_ItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> }> };

export type MyRecordingsQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type MyRecordingsQuery = { readonly __typename?: 'query_root', readonly registrant_SavedVonageRoomRecording: ReadonlyArray<{ readonly __typename?: 'registrant_SavedVonageRoomRecording', readonly id: any, readonly recording: { readonly __typename?: 'video_VonageRoomRecording', readonly id: any, readonly startedAt: any, readonly endedAt?: Maybe<any>, readonly s3Url?: Maybe<string>, readonly room?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }> } }> };

export type SelectRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> };

export type SearchRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type SearchRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> };

export type Registrant_RegistrantCreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  name: Scalars['String'];
  managementModeName: Room_ManagementMode_Enum;
}>;


export type Registrant_RegistrantCreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_room_Room_one?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> }> };

export type Room_GetEventsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
  now: Scalars['timestamptz'];
  cutoff: Scalars['timestamptz'];
}>;


export type Room_GetEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriod?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly conferenceId: any, readonly endAt: any, readonly maxRegistrantsPerRoom: number, readonly name: string, readonly roomDurationMinutes: number, readonly startAt: any, readonly targetRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly queueEntries: ReadonlyArray<{ readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly registrantId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> }> }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly videoElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string }>, readonly zoomItems: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly name: string }> }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }> }> };

export type Room_EventSummaryFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriod?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly conferenceId: any, readonly endAt: any, readonly maxRegistrantsPerRoom: number, readonly name: string, readonly roomDurationMinutes: number, readonly startAt: any, readonly targetRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly queueEntries: ReadonlyArray<{ readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly registrantId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> }> }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly videoElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string }>, readonly zoomItems: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly name: string }> }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }> };

export type Room_GetDefaultVideoRoomBackendQueryVariables = Exact<{ [key: string]: never; }>;


export type Room_GetDefaultVideoRoomBackendQuery = { readonly __typename?: 'query_root', readonly system_Configuration_by_pk?: Maybe<{ readonly __typename?: 'system_Configuration', readonly value: any }> };

export type AddParticipantToRoomMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  roomId: Scalars['uuid'];
}>;


export type AddParticipantToRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_room_RoomPerson_one?: Maybe<{ readonly __typename?: 'room_RoomPerson', readonly id: any }> };

export type RoomPage_GetRoomDetailsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type RoomPage_GetRoomDetailsQuery = { readonly __typename?: 'query_root', readonly room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly publicVonageSessionId?: Maybe<string>, readonly chatId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly backendName?: Maybe<Room_Backend_Enum>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }> }>, readonly selfAdminPerson: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any }>, readonly shuffleRooms: ReadonlyArray<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly durationMinutes: number, readonly reshuffleUponEnd: boolean, readonly shufflePeriodId: any }> }> };

export type RoomPage_RoomDetailsFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly publicVonageSessionId?: Maybe<string>, readonly chatId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly backendName?: Maybe<Room_Backend_Enum>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }> }>, readonly selfAdminPerson: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any }>, readonly shuffleRooms: ReadonlyArray<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly durationMinutes: number, readonly reshuffleUponEnd: boolean, readonly shufflePeriodId: any }> };

export type RoomPage_GetRoomChannelStackQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type RoomPage_GetRoomChannelStackQuery = { readonly __typename?: 'query_root', readonly video_ChannelStack: ReadonlyArray<{ readonly __typename?: 'video_ChannelStack', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }> };

export type RoomPage_RoomChannelStackFragment = { readonly __typename?: 'video_ChannelStack', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any };

export type GetEventVonageDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageDetailsQuery = { readonly __typename?: 'query_root', readonly schedule_Event_by_pk?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly sessionId: string, readonly id: any }> }> };

export type RoomSponsorContent_GetElementsQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type RoomSponsorContent_GetElementsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any> }> }> };

export type RoomSponsorContent_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any> }> };

export type RoomSponsorContent_ElementDataFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any> };

export type GetEventParticipantStreamsSubscriptionVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventParticipantStreamsSubscription = { readonly __typename?: 'subscription_root', readonly video_EventParticipantStream: ReadonlyArray<{ readonly __typename?: 'video_EventParticipantStream', readonly id: any, readonly conferenceId: any, readonly eventId: any, readonly vonageStreamType: string, readonly vonageStreamId: string, readonly registrantId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> };

export type EventParticipantStreamDetailsFragment = { readonly __typename?: 'video_EventParticipantStream', readonly id: any, readonly conferenceId: any, readonly eventId: any, readonly vonageStreamType: string, readonly vonageStreamId: string, readonly registrantId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } };

export type ImmediateSwitch_GetElementsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type ImmediateSwitch_GetElementsQuery = { readonly __typename?: 'query_root', readonly schedule_Event_by_pk?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string }> }>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string }> } }> }> }> };

export type ImmediateSwitch_CreateMutationVariables = Exact<{
  data: Scalars['jsonb'];
  eventId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
}>;


export type ImmediateSwitch_CreateMutation = { readonly __typename?: 'mutation_root', readonly insert_video_ImmediateSwitch_one?: Maybe<{ readonly __typename?: 'video_ImmediateSwitch', readonly id: any }> };

export type UpdateEventVonageSessionLayoutMutationVariables = Exact<{
  eventVonageSessionId: Scalars['uuid'];
  layoutData: Scalars['jsonb'];
}>;


export type UpdateEventVonageSessionLayoutMutation = { readonly __typename?: 'mutation_root', readonly update_video_EventVonageSession_by_pk?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly id: any }> };

export type LiveIndicator_GetLatestQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type LiveIndicator_GetLatestQuery = { readonly __typename?: 'query_root', readonly video_ImmediateSwitch: ReadonlyArray<{ readonly __typename?: 'video_ImmediateSwitch', readonly id: any, readonly data: any, readonly executedAt?: Maybe<any> }> };

export type LiveIndicator_GetElementQueryVariables = Exact<{
  elementId: Scalars['uuid'];
}>;


export type LiveIndicator_GetElementQuery = { readonly __typename?: 'query_root', readonly content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }> };

export type EnableBackstageStreamPreviewQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type EnableBackstageStreamPreviewQuery = { readonly __typename?: 'query_root', readonly conference_Configuration_by_pk?: Maybe<{ readonly __typename?: 'conference_Configuration', readonly key: Conference_ConfigurationKey_Enum, readonly conferenceId: any, readonly value: any }> };

export type GetEventDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventDetailsQuery = { readonly __typename?: 'query_root', readonly schedule_Event_by_pk?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly id: any, readonly sessionId: string }> }> };

export type RoomEventDetailsFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly id: any, readonly sessionId: string }> };

export type VideoPlayer_GetElementQueryVariables = Exact<{
  elementId: Scalars['uuid'];
}>;


export type VideoPlayer_GetElementQuery = { readonly __typename?: 'query_root', readonly content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly isHidden: boolean, readonly data: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type GetRoomChimeDataMutationVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomChimeDataMutation = { readonly __typename?: 'mutation_root', readonly joinRoomChimeSession?: Maybe<{ readonly __typename?: 'JoinRoomChimeSessionOutput', readonly registrant?: Maybe<any>, readonly meeting?: Maybe<any>, readonly message?: Maybe<string> }> };

export type GetEventVonageTokenMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinEventVonageSession?: Maybe<{ readonly __typename?: 'JoinEventVonageSessionOutput', readonly accessToken?: Maybe<string>, readonly isRecorded?: Maybe<boolean> }> };

export type GetRoomVonageTokenMutationVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinRoomVonageSession?: Maybe<{ readonly __typename?: 'JoinRoomVonageSessionOutput', readonly accessToken?: Maybe<string>, readonly sessionId?: Maybe<string>, readonly isRecorded?: Maybe<boolean> }> };

export type GetRoomVonageSessionIdQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomVonageSessionIdQuery = { readonly __typename?: 'query_root', readonly room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly publicVonageSessionId?: Maybe<string> }> };

export type DeleteEventParticipantMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type DeleteEventParticipantMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_EventProgramPerson?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any }> }> };

export type SaveVonageRoomRecordingMutationVariables = Exact<{
  recordingId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type SaveVonageRoomRecordingMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_SavedVonageRoomRecording_one?: Maybe<{ readonly __typename?: 'registrant_SavedVonageRoomRecording', readonly id: any, readonly recordingId: any, readonly registrantId: any, readonly isHidden: boolean }> };

export type ToggleVonageRecordingStateMutationVariables = Exact<{
  vonageSessionId: Scalars['String'];
  recordingActive: Scalars['Boolean'];
}>;


export type ToggleVonageRecordingStateMutation = { readonly __typename?: 'mutation_root', readonly toggleVonageRecordingState?: Maybe<{ readonly __typename?: 'ToggleVonageRecordingStateOutput', readonly allowed: boolean, readonly recordingState: boolean }> };

export type GetAllRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type GetAllRoomsQuery = { readonly __typename?: 'query_root', readonly socialRooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> }>, readonly programRooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> }> };

export type GetAllTodaysRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  todayStart: Scalars['timestamptz'];
  todayEnd: Scalars['timestamptz'];
  registrantId: Scalars['uuid'];
}>;


export type GetAllTodaysRoomsQuery = { readonly __typename?: 'query_root', readonly socialOrDiscussionRooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> }>, readonly programRooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> }> };

export type RoomListRoomDetailsFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> };

export type GetSocialRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type GetSocialRoomsQuery = { readonly __typename?: 'query_root', readonly socialRooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number }> };

export type SocialRoomFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number };

export type RoomTile_GetRoomQueryVariables = Exact<{
  roomId: Scalars['uuid'];
  withEvent: Scalars['Boolean'];
  eventId?: Maybe<Scalars['uuid']>;
}>;


export type RoomTile_GetRoomQuery = { readonly __typename?: 'query_root', readonly room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }>, readonly events?: Maybe<ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly startTime: any, readonly endTime?: Maybe<any>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>> }> };

export type RoomTile_RoomFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }>, readonly events?: Maybe<ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly startTime: any, readonly endTime?: Maybe<any>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>> };

export type RoomTile_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly startTime: any, readonly endTime?: Maybe<any>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type GetSponsorBoothsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetSponsorBoothsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly priority: number }>, readonly logo: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> };

export type SponsorBoothsList_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly priority: number }>, readonly logo: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> };

export type Schedule_TagFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number };

export type Schedule_EventTagFragment = { readonly __typename?: 'schedule_EventTag', readonly id: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } };

export type Schedule_HappeningSoonQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  startBefore: Scalars['timestamptz'];
  endAfter: Scalars['timestamptz'];
}>;


export type Schedule_HappeningSoonQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }> }> }>, readonly collection_ProgramPerson: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> }>, readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number }> };

export type StarredEventFragment = { readonly __typename?: 'schedule_StarredEvent', readonly id: any, readonly eventId: any, readonly registrantId: any };

export type StarEventButton_GetStarsQueryVariables = Exact<{
  eventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type StarEventButton_GetStarsQuery = { readonly __typename?: 'query_root', readonly schedule_StarredEvent: ReadonlyArray<{ readonly __typename?: 'schedule_StarredEvent', readonly id: any, readonly eventId: any, readonly registrantId: any }> };

export type StarEventButton_InsertStarsMutationVariables = Exact<{
  objects: ReadonlyArray<Schedule_StarredEvent_Insert_Input> | Schedule_StarredEvent_Insert_Input;
}>;


export type StarEventButton_InsertStarsMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_StarredEvent?: Maybe<{ readonly __typename?: 'schedule_StarredEvent_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_StarredEvent', readonly id: any, readonly eventId: any, readonly registrantId: any }> }> };

export type StarEventButton_DeleteStarsMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type StarEventButton_DeleteStarsMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_StarredEvent?: Maybe<{ readonly __typename?: 'schedule_StarredEvent_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_StarredEvent', readonly id: any }> }> };

export type StarredEvents_SelectEventIdsQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type StarredEvents_SelectEventIdsQuery = { readonly __typename?: 'query_root', readonly schedule_StarredEvent: ReadonlyArray<{ readonly __typename?: 'schedule_StarredEvent', readonly id: any, readonly eventId: any, readonly registrantId: any }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any }> };

export type StarredEvents_SelectEventsQueryVariables = Exact<{
  eventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  conferenceId: Scalars['uuid'];
}>;


export type StarredEvents_SelectEventsQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }> }> }>, readonly collection_ProgramPerson: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> }>, readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number }> };

export type Schedule_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any };

export type Schedule_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> };

export type Schedule_ItemPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string };

export type Schedule_ItemFieldsFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }> };

export type Schedule_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly abstractElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any }> };

export type Schedule_SelectItemQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type Schedule_SelectItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly abstractElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any }> }> };

export type Schedule_EventSummaryFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any> };

export type Schedule_RoomSummaryFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum };

export type Schedule_SelectSummariesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type Schedule_SelectSummariesQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any> }>, readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }> }>, readonly collection_ProgramPerson: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> }>, readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number }> };

export type ScheduleV2_LightweightEventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly roomId: any };

export type ScheduleV2_DayLightweightEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  startOfDay: Scalars['timestamptz'];
  endOfDay: Scalars['timestamptz'];
  filter: Schedule_Event_Bool_Exp;
}>;


export type ScheduleV2_DayLightweightEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly roomId: any }> };

export type ScheduleV2_DayEventsQueryVariables = Exact<{
  eventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ScheduleV2_DayEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly abstractElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }> }> }> };

export type ScheduleV2_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any };

export type ScheduleV2_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> };

export type ScheduleV2_ItemPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } };

export type ScheduleV2_ItemElementsFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }> };

export type ScheduleV2_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly abstractElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }> }> };

export type ScheduleV2_RoomFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number };

export type ScheduleV2_RoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ScheduleV2_RoomsQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number }> };

export type ScheduleV2_TagFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number };

export type ScheduleV2_TagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ScheduleV2_TagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number }> };

export type ScheduleV2_AllEvents_ParamsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ScheduleV2_AllEvents_ParamsQuery = { readonly __typename?: 'query_root', readonly earliestStartingEvent: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any }>, readonly latestEndingEvent: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly endTime?: Maybe<any> }> };

export type SearchPanel_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> };

export type SearchPanel_ItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type SearchPanel_ItemsQuery = { readonly __typename?: 'query_root', readonly content_searchItems: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> }> };

export type SearchPanel_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly roomId: any, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> }>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } };

export type SearchPanel_EventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type SearchPanel_EventsQuery = { readonly __typename?: 'query_root', readonly schedule_searchEvents: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly roomId: any, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> } }> }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number } }> }>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }> };

export type SearchPanel_PersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type SearchPanel_PeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type SearchPanel_PeopleQuery = { readonly __typename?: 'query_root', readonly collection_searchProgramPerson: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> }> };

export type ConferenceStatsQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type ConferenceStatsQuery = { readonly __typename?: 'query_root', readonly conference_Conference_by_pk?: Maybe<{ readonly __typename?: 'conference_Conference', readonly completedRegistrationsStat?: Maybe<{ readonly __typename?: 'analytics_CompletedRegistrations', readonly count?: Maybe<any> }>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly stats: ReadonlyArray<{ readonly __typename?: 'analytics_ContentItemStats', readonly id: any, readonly itemId: any, readonly viewCount: number, readonly updated_at: any }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly stats: ReadonlyArray<{ readonly __typename?: 'analytics_ContentElementStats', readonly id: any, readonly elementId: any, readonly viewCount: number, readonly updated_at: any }> }> }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly presenceCounts: ReadonlyArray<{ readonly __typename?: 'analytics_RoomPresence', readonly created_at?: Maybe<any>, readonly count?: Maybe<any> }>, readonly stats: ReadonlyArray<{ readonly __typename?: 'analytics_RoomStats', readonly created_at: any, readonly hlsViewCount: number }>, readonly events: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }> }> }> }> };

export type GetChannelStacksQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetChannelStacksQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly name: string, readonly id: any, readonly channelStack?: Maybe<{ readonly __typename?: 'video_ChannelStack', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }> }> };

export type ConferenceConfiguration_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferenceConfiguration_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }> };

export type ConferenceConfiguration_ConferenceConfigurationsFragment = { readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any };

export type Conference_Configuration_UpdateConferenceConfigurationsMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  key: Conference_ConfigurationKey_Enum;
  value: Scalars['jsonb'];
}>;


export type Conference_Configuration_UpdateConferenceConfigurationsMutation = { readonly __typename?: 'mutation_root', readonly update_conference_Configuration_by_pk?: Maybe<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }> };

export type EventVonageControls_GetEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type EventVonageControls_GetEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }> };

export type EventVonageControls_StopEventBroadcastMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type EventVonageControls_StopEventBroadcastMutation = { readonly __typename?: 'mutation_root', readonly stopEventBroadcast?: Maybe<{ readonly __typename?: 'StopEventBroadcastOutput', readonly broadcastsStopped: number }> };

export type MonitorLivestreamsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  now: Scalars['timestamptz'];
  later: Scalars['timestamptz'];
}>;


export type MonitorLivestreamsQuery = { readonly __typename?: 'query_root', readonly liveEvents: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string> }> } }>, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly id: any, readonly sessionId: string }>, readonly participantStreams: ReadonlyArray<{ readonly __typename?: 'video_EventParticipantStream', readonly id: any, readonly registrantId: any, readonly vonageStreamType: string }> }>, readonly prerecordedEvents: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number } }> };

export type MonitorLivestreams_PrerecEventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number } };

export type MonitorLivestreams_PersonFragment = { readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string> }> } };

export type MonitorLivestreams_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string> }> } }>, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly id: any, readonly sessionId: string }>, readonly participantStreams: ReadonlyArray<{ readonly __typename?: 'video_EventParticipantStream', readonly id: any, readonly registrantId: any, readonly vonageStreamType: string }> };

export type CreateConferencePrepareJobMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateConferencePrepareJobMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_PrepareJob_one?: Maybe<{ readonly __typename?: 'conference_PrepareJob', readonly id: any, readonly conferenceId: any }> };

export type ConferencePrepareJobSubscriptionSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferencePrepareJobSubscriptionSubscription = { readonly __typename?: 'subscription_root', readonly conference_PrepareJob: ReadonlyArray<{ readonly __typename?: 'conference_PrepareJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly message?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly videoRenderJobs: ReadonlyArray<{ readonly __typename?: 'video_VideoRenderJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly updated_at: any, readonly created_at: any }> }> };

export type ManageModeration_ChatFlagFragment = { readonly __typename?: 'chat_Flag', readonly discussionChatId?: Maybe<any>, readonly flaggedById?: Maybe<any>, readonly id: number, readonly messageSId: any, readonly notes?: Maybe<string>, readonly resolution?: Maybe<string>, readonly resolved_at?: Maybe<any>, readonly type: Chat_FlagType_Enum, readonly updated_at: any, readonly created_at: any, readonly message: { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly id: number, readonly sId: any, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly reactions: ReadonlyArray<{ readonly __typename?: 'chat_Reaction', readonly sId: any, readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly duplicateSId?: Maybe<any>, readonly created_at: any, readonly updated_at: any, readonly chatId: any }> } };

export type ManageModeration_SelectFlagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageModeration_SelectFlagsQuery = { readonly __typename?: 'query_root', readonly chat_Flag: ReadonlyArray<{ readonly __typename?: 'chat_Flag', readonly discussionChatId?: Maybe<any>, readonly flaggedById?: Maybe<any>, readonly id: number, readonly messageSId: any, readonly notes?: Maybe<string>, readonly resolution?: Maybe<string>, readonly resolved_at?: Maybe<any>, readonly type: Chat_FlagType_Enum, readonly updated_at: any, readonly created_at: any, readonly message: { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly id: number, readonly sId: any, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly reactions: ReadonlyArray<{ readonly __typename?: 'chat_Reaction', readonly sId: any, readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly duplicateSId?: Maybe<any>, readonly created_at: any, readonly updated_at: any, readonly chatId: any }> } }> };

export type ManageModeration_UpdateFlagMutationVariables = Exact<{
  flagId: Scalars['Int'];
  update: Chat_Flag_Set_Input;
}>;


export type ManageModeration_UpdateFlagMutation = { readonly __typename?: 'mutation_root', readonly update_chat_Flag_by_pk?: Maybe<{ readonly __typename?: 'chat_Flag', readonly discussionChatId?: Maybe<any>, readonly flaggedById?: Maybe<any>, readonly id: number, readonly messageSId: any, readonly notes?: Maybe<string>, readonly resolution?: Maybe<string>, readonly resolved_at?: Maybe<any>, readonly type: Chat_FlagType_Enum, readonly updated_at: any, readonly created_at: any }> };

export type PreshowChecklistQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  now: Scalars['timestamptz'];
}>;


export type PreshowChecklistQuery = { readonly __typename?: 'query_root', readonly requiredProgramPeopleNotLinkedToRegistrant: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string> }>, readonly requiredProgramPeopleNotRegistered: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string> }>, readonly submissionsNotReceived: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }>, readonly livestreamEventsWithoutRegisteredPresenter: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly livestreamEventsWithoutRegisteredChair: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly prerecordedEventsWithoutVideo: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly prerecordedEventsWithVideo: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly data: any }> }> }>, readonly zoomEvents: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly data: any }> }> }>, readonly allLiveEventsWithPeople: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeopleWithRegistrant: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly personId: any }>, readonly itemPeopleWithoutRegistrant: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly personId: any }> }>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly personId: any }> }>, readonly emptyExhibitions: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly emptyTags: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string }>, readonly exhibitionEventsWithoutExhibition: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }>, readonly exhibitionEventsWithoutDiscussionRooms: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> }> }>, readonly liveEventsWithoutContent: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }>, readonly overlappingEvents: ReadonlyArray<{ readonly __typename?: 'schedule_OverlappingEvents', readonly eventX?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }>, readonly eventY?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any> }> }>, readonly shortEvents: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly roomsWithStreams: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly livestreamDuration?: Maybe<{ readonly __typename?: 'room_LivestreamDurations', readonly sum?: Maybe<any> }> }>, readonly eventsWithNegativeDuration: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }> };

export type ManageContent_ItemTagFragment = { readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any };

export type ManageContent_ItemExhibitionFragment = { readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly conferenceId: any, readonly exhibitionId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any>, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } };

export type ManageContent_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }> };

export type ManageContent_OriginatingDataFragment = { readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> };

export type ManageContent_RoomFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string };

export type ManageContent_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly itemId: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly isHidden: boolean, readonly updatedAt: any, readonly conferenceId: any };

export type ManageContent_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> };

export type ManageContent_ItemProgramPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> };

export type ManageContent_ItemSecondaryFragment = { readonly __typename?: 'content_Item', readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }> };

export type ManageContent_ItemForExportFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly originatingDataId?: Maybe<any>, readonly chatId?: Maybe<any>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly exhibitionId: any, readonly priority?: Maybe<number> }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly itemId: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly isHidden: boolean, readonly updatedAt: any, readonly conferenceId: any }> };

export type ManageContent_SelectAllItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectAllItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }> }> };

export type ManageContent_SelectItemsForExportQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_SelectItemsForExportQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly originatingDataId?: Maybe<any>, readonly chatId?: Maybe<any>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly exhibitionId: any, readonly priority?: Maybe<number> }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly itemId: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly isHidden: boolean, readonly updatedAt: any, readonly conferenceId: any }> }> };

export type ManageContent_SelectItemQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type ManageContent_SelectItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }> }>, readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly itemId: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly isHidden: boolean, readonly updatedAt: any, readonly conferenceId: any }> };

export type ManageContent_SelectItemPeopleQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type ManageContent_SelectItemPeopleQuery = { readonly __typename?: 'query_root', readonly content_ItemProgramPerson: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> }> };

export type ManageContent_InsertItemMutationVariables = Exact<{
  item: Content_Item_Insert_Input;
  itemTags: ReadonlyArray<Content_ItemTag_Insert_Input> | Content_ItemTag_Insert_Input;
}>;


export type ManageContent_InsertItemMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Item_one?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }> }>, readonly insert_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any }> }> };

export type ManageContent_UpdateItemMutationVariables = Exact<{
  id: Scalars['uuid'];
  item: Content_Item_Set_Input;
  tags: ReadonlyArray<Content_ItemTag_Insert_Input> | Content_ItemTag_Insert_Input;
  tagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_UpdateItemMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }> }>, readonly delete_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any }> }>, readonly update_content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any }> }> };

export type ManageContent_DeleteItemsMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_DeleteItemsMutation = { readonly __typename?: 'mutation_root', readonly delete_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any }> }> };

export type ManageContent_TagFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number };

export type ManageContent_SelectAllTagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectAllTagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number }> };

export type ManageContent_ExhibitionFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number, readonly isHidden: boolean, readonly descriptiveItemId?: Maybe<any>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any }> };

export type ManageContent_SelectAllExhibitionsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectAllExhibitionsQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number, readonly isHidden: boolean, readonly descriptiveItemId?: Maybe<any>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any }> }> };

export type ElementInfoFragment = { readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> };

export type OriginatingDataInfoFragment = { readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> };

export type ProgramPersonInfoFragment = { readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any> };

export type ItemTagInfoFragment = { readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any };

export type ItemExhibitionInfoFragment = { readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> };

export type ItemPersonInfoFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string };

export type ItemFullNestedInfoFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type TagInfoFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly priority: number };

export type ExhibitionInfoFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number, readonly isHidden: boolean };

export type SelectAllContentQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllContentQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }>, readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any> }>, readonly conference_OriginatingData: ReadonlyArray<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly priority: number }>, readonly collection_Exhibition: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number, readonly isHidden: boolean }> };

export type InsertDeleteItemsMutationVariables = Exact<{
  newGroups: ReadonlyArray<Content_Item_Insert_Input> | Content_Item_Insert_Input;
  deleteGroupIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type InsertDeleteItemsMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }> }>, readonly delete_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any }> }> };

export type InsertElementsMutationVariables = Exact<{
  newElements: ReadonlyArray<Content_Element_Insert_Input> | Content_Element_Insert_Input;
}>;


export type InsertElementsMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }> }> };

export type InsertOriginatingDatasMutationVariables = Exact<{
  newDatas: ReadonlyArray<Conference_OriginatingData_Insert_Input> | Conference_OriginatingData_Insert_Input;
}>;


export type InsertOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_OriginatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }> }> };

export type DeleteOriginatingDatasMutationVariables = Exact<{
  deleteDataIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly delete_conference_OriginatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'conference_OriginatingData', readonly id: any }> }> };

export type InsertTagsMutationVariables = Exact<{
  newTags: ReadonlyArray<Collection_Tag_Insert_Input> | Collection_Tag_Insert_Input;
}>;


export type InsertTagsMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Tag?: Maybe<{ readonly __typename?: 'collection_Tag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly priority: number }> }> };

export type InsertExhibitionsMutationVariables = Exact<{
  newExhibitions: ReadonlyArray<Collection_Exhibition_Insert_Input> | Collection_Exhibition_Insert_Input;
}>;


export type InsertExhibitionsMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number, readonly isHidden: boolean }> }> };

export type DeleteTagsMutationVariables = Exact<{
  deleteTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteTagsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Tag?: Maybe<{ readonly __typename?: 'collection_Tag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any }> }> };

export type DeleteExhibitionsMutationVariables = Exact<{
  deleteExhibitionIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteExhibitionsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any }> }> };

export type InsertProgramPeopleMutationVariables = Exact<{
  newPeople: ReadonlyArray<Collection_ProgramPersonWithAccessToken_Insert_Input> | Collection_ProgramPersonWithAccessToken_Insert_Input;
}>;


export type InsertProgramPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_ProgramPersonWithAccessToken?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any> }> }> };

export type DeleteProgramPeopleMutationVariables = Exact<{
  deletePersonIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteProgramPeopleMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_ProgramPersonWithAccessToken?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any> }> }> };

export type UpdateItemMutationVariables = Exact<{
  newItems: ReadonlyArray<Content_Element_Insert_Input> | Content_Element_Insert_Input;
  newGroupTags: ReadonlyArray<Content_ItemTag_Insert_Input> | Content_ItemTag_Insert_Input;
  newGroupExhibitions: ReadonlyArray<Content_ItemExhibition_Insert_Input> | Content_ItemExhibition_Insert_Input;
  groupId: Scalars['uuid'];
  typeName: Content_ItemType_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  shortTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  deleteItemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteGroupTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteGroupExhibitionIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  newGroupPeople: ReadonlyArray<Content_ItemProgramPerson_Insert_Input> | Content_ItemProgramPerson_Insert_Input;
  deleteGroupPeopleIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UpdateItemMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }> }>, readonly insert_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any }> }>, readonly insert_content_ItemExhibition?: Maybe<{ readonly __typename?: 'content_ItemExhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> }> }>, readonly insert_content_ItemProgramPerson?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }> }>, readonly update_content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }>, readonly delete_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any }> }>, readonly delete_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any }> }>, readonly delete_content_ItemExhibition?: Maybe<{ readonly __typename?: 'content_ItemExhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any }> }>, readonly delete_content_ItemProgramPerson?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any }> }> };

export type UpdateElementMutationVariables = Exact<{
  id: Scalars['uuid'];
  typeName: Content_ElementType_Enum;
  layoutData?: Maybe<Scalars['jsonb']>;
  name: Scalars['String'];
  data: Scalars['jsonb'];
  isHidden: Scalars['Boolean'];
  originatingDataId?: Maybe<Scalars['uuid']>;
  uploadsRemaining?: Maybe<Scalars['Int']>;
}>;


export type UpdateElementMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }> };

export type UpdateGroupPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  roleName: Scalars['String'];
  priority?: Maybe<Scalars['Int']>;
}>;


export type UpdateGroupPersonMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemProgramPerson_by_pk?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }> };

export type UpdateGroupExhibitionMutationVariables = Exact<{
  id: Scalars['uuid'];
  priority?: Maybe<Scalars['Int']>;
  layout?: Maybe<Scalars['jsonb']>;
}>;


export type UpdateGroupExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemExhibition_by_pk?: Maybe<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> }> };

export type UpdatePersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
  registrantId?: Maybe<Scalars['uuid']>;
}>;


export type UpdatePersonMutation = { readonly __typename?: 'mutation_root', readonly update_collection_ProgramPersonWithAccessToken?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any> }> }> };

export type UpdateTagMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  originatingDataId?: Maybe<Scalars['uuid']>;
  priority?: Scalars['Int'];
}>;


export type UpdateTagMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Tag_by_pk?: Maybe<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly priority: number }> };

export type UpdateExhibitionMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  priority: Scalars['Int'];
  isHidden: Scalars['Boolean'];
}>;


export type UpdateExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Exhibition_by_pk?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number, readonly isHidden: boolean }> };

export type BulkEdit_AddElementsMutationVariables = Exact<{
  objects: ReadonlyArray<Content_Element_Insert_Input> | Content_Element_Insert_Input;
}>;


export type BulkEdit_AddElementsMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly affected_rows: number }> };

export type CombineVideosModal_CreateCombineVideosJobMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  createdByRegistrantId: Scalars['uuid'];
  outputName: Scalars['String'];
  data: Scalars['jsonb'];
}>;


export type CombineVideosModal_CreateCombineVideosJobMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_CombineVideosJob_one?: Maybe<{ readonly __typename?: 'job_queues_CombineVideosJob', readonly id: any }> };

export type CombineVideosModal_GetCombineVideosJobQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CombineVideosModal_GetCombineVideosJobQuery = { readonly __typename?: 'query_root', readonly job_queues_CombineVideosJob: ReadonlyArray<{ readonly __typename?: 'job_queues_CombineVideosJob', readonly id: any, readonly message?: Maybe<string>, readonly jobStatusName: Video_JobStatus_Enum, readonly data: any }> };

export type CombineVideosModal_GetElementsQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type CombineVideosModal_GetElementsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly createdAt: any, readonly itemId: any, readonly data: any, readonly name: string }> };

export type SelectElements_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly itemId: any, readonly data: any }> };

export type SelectElements_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly itemId: any, readonly data: any };

export type SEoUm_InfosQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type SEoUm_InfosQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly itemId: any, readonly data: any }> }> };

export type UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type UpdateExhibitionDescriptiveItems_SelectExhibitionsQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }> };

export type UpdateExhibitionDescriptiveItemMutationVariables = Exact<{
  id: Scalars['uuid'];
  descriptiveItemId: Scalars['uuid'];
}>;


export type UpdateExhibitionDescriptiveItemMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Exhibition_by_pk?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly descriptiveItemId?: Maybe<any> }> };

export type UpdateLayoutMutationVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  layoutData: Scalars['jsonb'];
}>;


export type UpdateLayoutMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly affected_rows: number }> };

export type UpdateUploadsRemainingMutationVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  count: Scalars['Int'];
}>;


export type UpdateUploadsRemainingMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly affected_rows: number }> };

export type ManageContent_DeleteElementMutationVariables = Exact<{
  elementId: Scalars['uuid'];
}>;


export type ManageContent_DeleteElementMutation = { readonly __typename?: 'mutation_root', readonly delete_content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any }> };

export type ManageContent_UpdateElementMutationVariables = Exact<{
  elementId: Scalars['uuid'];
  element: Content_Element_Set_Input;
}>;


export type ManageContent_UpdateElementMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly itemId: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly isHidden: boolean, readonly updatedAt: any, readonly conferenceId: any }> };

export type ManageContent_SelectItemExhibitionsQueryVariables = Exact<{
  exhibitionId: Scalars['uuid'];
}>;


export type ManageContent_SelectItemExhibitionsQuery = { readonly __typename?: 'query_root', readonly content_ItemExhibition: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly conferenceId: any, readonly exhibitionId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any>, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type ManageContent_InsertItemExhibitionMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  exhibitionId: Scalars['uuid'];
  itemId: Scalars['uuid'];
  priority: Scalars['Int'];
}>;


export type ManageContent_InsertItemExhibitionMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ItemExhibition_one?: Maybe<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly conferenceId: any, readonly exhibitionId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any>, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type ManageContent_UpdateItemExhibitionMutationVariables = Exact<{
  itemExhibitionId: Scalars['uuid'];
  priority: Scalars['Int'];
}>;


export type ManageContent_UpdateItemExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemExhibition_by_pk?: Maybe<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly conferenceId: any, readonly exhibitionId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any>, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type ManageContent_DeleteItemExhibitionMutationVariables = Exact<{
  itemExhibitionId: Scalars['uuid'];
}>;


export type ManageContent_DeleteItemExhibitionMutation = { readonly __typename?: 'mutation_root', readonly delete_content_ItemExhibition_by_pk?: Maybe<{ readonly __typename?: 'content_ItemExhibition', readonly id: any }> };

export type ManageContent_InsertExhibitionMutationVariables = Exact<{
  exhibition: Collection_Exhibition_Insert_Input;
}>;


export type ManageContent_InsertExhibitionMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Exhibition_one?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number, readonly isHidden: boolean, readonly descriptiveItemId?: Maybe<any>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any }> }> };

export type ManageContent_UpdateExhibitionMutationVariables = Exact<{
  id: Scalars['uuid'];
  update: Collection_Exhibition_Set_Input;
}>;


export type ManageContent_UpdateExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Exhibition_by_pk?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number, readonly isHidden: boolean, readonly descriptiveItemId?: Maybe<any>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any }> }> };

export type ManageContent_DeleteExhibitionsMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_DeleteExhibitionsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any }> }> };

export type AddContentMenu_CreateElementMutationVariables = Exact<{
  object: Content_Element_Insert_Input;
}>;


export type AddContentMenu_CreateElementMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Element_one?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly itemId: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly isHidden: boolean, readonly updatedAt: any, readonly conferenceId: any }> };

export type Item_CreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  itemId: Scalars['uuid'];
}>;


export type Item_CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly createItemRoom?: Maybe<{ readonly __typename?: 'CreateItemRoomOutput', readonly roomId?: Maybe<string>, readonly message?: Maybe<string> }> };

export type ManageContent_SelectProgramPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectProgramPeopleQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> };

export type ManageContent_InsertItemProgramPersonMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  personId: Scalars['uuid'];
  roleName: Scalars['String'];
  priority: Scalars['Int'];
  itemId: Scalars['uuid'];
}>;


export type ManageContent_InsertItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ItemProgramPerson_one?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> }> };

export type ManageContent_UpdateItemProgramPersonMutationVariables = Exact<{
  itemPersonId: Scalars['uuid'];
  priority: Scalars['Int'];
  roleName: Scalars['String'];
}>;


export type ManageContent_UpdateItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemProgramPerson_by_pk?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> }> };

export type ManageContent_DeleteItemProgramPersonMutationVariables = Exact<{
  itemPersonId: Scalars['uuid'];
}>;


export type ManageContent_DeleteItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly delete_content_ItemProgramPerson_by_pk?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any }> };

export type ManageContent_InsertTagMutationVariables = Exact<{
  tag: Collection_Tag_Insert_Input;
}>;


export type ManageContent_InsertTagMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Tag_one?: Maybe<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number }> };

export type ManageContent_UpdateTagMutationVariables = Exact<{
  id: Scalars['uuid'];
  update: Collection_Tag_Set_Input;
}>;


export type ManageContent_UpdateTagMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Tag_by_pk?: Maybe<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number }> };

export type ManageContent_DeleteTagsMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_DeleteTagsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Tag?: Maybe<{ readonly __typename?: 'collection_Tag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any }> }> };

export type ElementSecurity_ElementPgFragment = { readonly __typename?: 'content_ElementPermissionGrant', readonly id: any, readonly permissionSetId: any, readonly conferenceSlug: string, readonly groupId?: Maybe<any>, readonly entityId?: Maybe<any> };

export type ElementSecurity_PermissionSetFragment = { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string };

export type ElementSecurity_GroupFragment = { readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string, readonly enabled: boolean, readonly includeUnauthenticated: boolean };

export type ElementSecurity_SelectGrantsQueryVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  conferenceId: Scalars['uuid'];
}>;


export type ElementSecurity_SelectGrantsQuery = { readonly __typename?: 'query_root', readonly content_ElementPermissionGrant: ReadonlyArray<{ readonly __typename?: 'content_ElementPermissionGrant', readonly id: any, readonly permissionSetId: any, readonly conferenceSlug: string, readonly groupId?: Maybe<any>, readonly entityId?: Maybe<any> }>, readonly permissions_Role: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string }>, readonly permissions_Group: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string, readonly enabled: boolean, readonly includeUnauthenticated: boolean }> };

export type ElementSecurity_InsertGrantsMutationVariables = Exact<{
  elementGrants: ReadonlyArray<Content_ElementPermissionGrant_Insert_Input> | Content_ElementPermissionGrant_Insert_Input;
}>;


export type ElementSecurity_InsertGrantsMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ElementPermissionGrant?: Maybe<{ readonly __typename?: 'content_ElementPermissionGrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ElementPermissionGrant', readonly id: any, readonly permissionSetId: any, readonly conferenceSlug: string, readonly groupId?: Maybe<any>, readonly entityId?: Maybe<any> }> }> };

export type ElementSecurity_DeleteGrantsMutationVariables = Exact<{
  elementGrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ElementSecurity_DeleteGrantsMutation = { readonly __typename?: 'mutation_root', readonly delete_content_ElementPermissionGrant?: Maybe<{ readonly __typename?: 'content_ElementPermissionGrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ElementPermissionGrant', readonly id: any }> }> };

export type InsertSubmissionRequestEmailJobsMutationVariables = Exact<{
  objs: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input> | Job_Queues_SubmissionRequestEmailJob_Insert_Input;
}>;


export type InsertSubmissionRequestEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<{ readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response', readonly affected_rows: number }> };

export type SubmissionRequestsModalDataQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type SubmissionRequestsModalDataQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly hasUnsubmittedElements?: Maybe<boolean>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly roleName: string, readonly hasSubmissionRequestBeenSent?: Maybe<boolean> }> }> };

export type SubmissionRequestsModal_ConferenceConfigurationFragment = { readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any };

export type SubmissionRequestsModal_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly hasUnsubmittedElements?: Maybe<boolean>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly personId: any, readonly roleName: string, readonly hasSubmissionRequestBeenSent?: Maybe<boolean> }> };

export type SubmissionsReviewModalDataQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type SubmissionsReviewModalDataQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly hasUnsubmittedElements?: Maybe<boolean>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly submissionRequestsSentCount?: Maybe<number> }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly data: any }> }> };

export type SubmissionsReviewModal_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly hasUnsubmittedElements?: Maybe<boolean>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly person?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly submissionRequestsSentCount?: Maybe<number> }> }>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly data: any }> };

export type SubmissionsReviewModal_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly data: any };

export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConfigureEmailTemplates_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }> };

export type ConfigureEmailTemplates_ConferenceConfigurationFragment = { readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any };

export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables = Exact<{
  value: Scalars['jsonb'];
  conferenceId: Scalars['uuid'];
  key: Conference_ConfigurationKey_Enum;
}>;


export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_Configuration_one?: Maybe<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }> };

export type ChooseElementByTagModal_GetTagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ChooseElementByTagModal_GetTagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string }> };

export type ChooseElementByTagModal_GetVideoElementsQueryVariables = Exact<{
  tagId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type ChooseElementByTagModal_GetVideoElementsQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type ChooseElementModal_GetItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ChooseElementModal_GetItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type ChooseElementModal_GetVideoElementsQueryVariables = Exact<{
  itemId?: Maybe<Scalars['uuid']>;
}>;


export type ChooseElementModal_GetVideoElementsQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string }> };

export type ManageExport_GetGoogleOAuthUrlMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  scopes: ReadonlyArray<Scalars['String']> | Scalars['String'];
}>;


export type ManageExport_GetGoogleOAuthUrlMutation = { readonly __typename?: 'mutation_root', readonly getGoogleOAuthUrl?: Maybe<{ readonly __typename?: 'GetGoogleOAuthUrlOutput', readonly url: string }> };

export type ManageExport_GetRegistrantGoogleAccountsQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type ManageExport_GetRegistrantGoogleAccountsQuery = { readonly __typename?: 'query_root', readonly registrant_GoogleAccount: ReadonlyArray<{ readonly __typename?: 'registrant_GoogleAccount', readonly id: any, readonly googleAccountEmail: string }> };

export type ManageExport_RegistrantGoogleAccountFragment = { readonly __typename?: 'registrant_GoogleAccount', readonly id: any, readonly googleAccountEmail: string };

export type ManageExport_DeleteRegistrantGoogleAccountMutationVariables = Exact<{
  registrantGoogleAccountId: Scalars['uuid'];
}>;


export type ManageExport_DeleteRegistrantGoogleAccountMutation = { readonly __typename?: 'mutation_root', readonly delete_registrant_GoogleAccount_by_pk?: Maybe<{ readonly __typename?: 'registrant_GoogleAccount', readonly id: any }> };

export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery = { readonly __typename?: 'query_root', readonly ongoing_UploadYouTubeVideoJob: ReadonlyArray<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly element: { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } } }>, readonly recent_UploadYouTubeVideoJob: ReadonlyArray<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly element: { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } } }> };

export type UploadYouTubeVideos_UploadYouTubeVideoJobFragment = { readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly element: { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } } };

export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery = { readonly __typename?: 'query_root', readonly registrant_GoogleAccount: ReadonlyArray<{ readonly __typename?: 'registrant_GoogleAccount', readonly id: any, readonly googleAccountEmail: string, readonly youTubeData?: Maybe<any> }> };

export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables = Exact<{
  objects: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input> | Job_Queues_UploadYouTubeVideoJob_Insert_Input;
}>;


export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_UploadYouTubeVideoJob?: Maybe<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any }> }> };

export type UploadYouTubeVideos_GetElementsQueryVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetElementsQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type UploadYouTubeVideos_GetTemplateDataQueryVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetTemplateDataQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly shortTitle?: Maybe<string>, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly youTubeUploads: ReadonlyArray<{ readonly __typename?: 'video_YouTubeUpload', readonly id: any, readonly videoTitle: string, readonly videoId: string }> }>, readonly abstractElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly paperLinkElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly paperUrlElements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly authors: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string> } }>, readonly presenters: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string> } }> } }> };

export type UploadYouTubeVideos_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly data: any };

export type UploadYouTubeVideos_RefreshYouTubeDataMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  registrantGoogleAccountId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_RefreshYouTubeDataMutation = { readonly __typename?: 'mutation_root', readonly refreshYouTubeData?: Maybe<{ readonly __typename?: 'RefreshYouTubeDataOutput', readonly message?: Maybe<string>, readonly success: boolean }> };

export type UploadYouTubeVideos_GetYouTubeUploadsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetYouTubeUploadsQuery = { readonly __typename?: 'query_root', readonly video_YouTubeUpload: ReadonlyArray<{ readonly __typename?: 'video_YouTubeUpload', readonly id: any, readonly videoId: string, readonly videoPrivacyStatus: string, readonly videoStatus: string, readonly videoTitle: string, readonly element?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> }> };

export type UploadYouTubeVideos_YouTubeUploadFragment = { readonly __typename?: 'video_YouTubeUpload', readonly id: any, readonly videoId: string, readonly videoPrivacyStatus: string, readonly videoStatus: string, readonly videoTitle: string, readonly element?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type ImportRegistrantsMutationVariables = Exact<{
  insertRegistrants: ReadonlyArray<Registrant_Registrant_Insert_Input> | Registrant_Registrant_Insert_Input;
  insertInvitations: ReadonlyArray<Registrant_Invitation_Insert_Input> | Registrant_Invitation_Insert_Input;
  insertGroupRegistrants: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input> | Permissions_GroupRegistrant_Insert_Input;
}>;


export type ImportRegistrantsMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant_mutation_response', readonly affected_rows: number }>, readonly insert_registrant_Invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation_mutation_response', readonly affected_rows: number }>, readonly insert_permissions_GroupRegistrant?: Maybe<{ readonly __typename?: 'permissions_GroupRegistrant_mutation_response', readonly affected_rows: number }> };

export type UpdateConferenceMutationVariables = Exact<{
  id: Scalars['uuid'];
  name?: Maybe<Scalars['String']>;
  shortName?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
}>;


export type UpdateConferenceMutation = { readonly __typename?: 'mutation_root', readonly update_conference_Conference?: Maybe<{ readonly __typename?: 'conference_Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> }> };

export type ManageGroups_GroupFragment = { readonly __typename?: 'permissions_Group', readonly conferenceId: any, readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any }> };

export type SelectAllGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly conferenceId: any, readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any }> }> };

export type CreateDeleteGroupsMutationVariables = Exact<{
  deleteGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
  insertGroups: ReadonlyArray<Permissions_Group_Insert_Input> | Permissions_Group_Insert_Input;
}>;


export type CreateDeleteGroupsMutation = { readonly __typename?: 'mutation_root', readonly delete_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any }> }>, readonly insert_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly includeUnauthenticated: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }> };

export type UpdateGroupMutationVariables = Exact<{
  groupId: Scalars['uuid'];
  groupName: Scalars['String'];
  enabled: Scalars['Boolean'];
  includeUnauthenticated: Scalars['Boolean'];
  insertRoles: ReadonlyArray<Permissions_GroupRole_Insert_Input> | Permissions_GroupRole_Insert_Input;
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type UpdateGroupMutation = { readonly __typename?: 'mutation_root', readonly update_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }>, readonly insert_permissions_GroupRole?: Maybe<{ readonly __typename?: 'permissions_GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }>, readonly delete_permissions_GroupRole?: Maybe<{ readonly __typename?: 'permissions_GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any }> }> };

export type ManageProgramPeople_RegistrantFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }>, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }> };

export type ManageProgramPeople_ProgramPersonWithAccessTokenFragment = { readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any>, readonly accessToken?: Maybe<string> };

export type ManageProgramPeople_SelectAllPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageProgramPeople_SelectAllPeopleQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any>, readonly accessToken?: Maybe<string> }> };

export type ManageProgramPeople_SelectAllRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageProgramPeople_SelectAllRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }>, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }> }> };

export type ManageProgramPeople_InsertProgramPersonMutationVariables = Exact<{
  person: Collection_ProgramPersonWithAccessToken_Insert_Input;
}>;


export type ManageProgramPeople_InsertProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_ProgramPersonWithAccessToken_one?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any>, readonly accessToken?: Maybe<string> }> };

export type ManageProgramPeople_DeleteProgramPersonsMutationVariables = Exact<{
  ids?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type ManageProgramPeople_DeleteProgramPersonsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_ProgramPersonWithAccessToken?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any> }> }> };

export type ManageProgramPeople_UpdateProgramPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  registrantId?: Maybe<Scalars['uuid']>;
}>;


export type ManageProgramPeople_UpdateProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly update_collection_ProgramPersonWithAccessToken?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any>, readonly accessToken?: Maybe<string> }> }> };

export type SelectAllPermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type SelectAllPermissionsQuery = { readonly __typename?: 'query_root', readonly permissions_Permission: ReadonlyArray<{ readonly __typename?: 'permissions_Permission', readonly name: string, readonly description: string }> };

export type SelectAllRolesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRolesQuery = { readonly __typename?: 'query_root', readonly permissions_Role: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly conferenceId: any, readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }> };

export type CreateDeleteRolesMutationVariables = Exact<{
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
  insertRoles: ReadonlyArray<Permissions_Role_Insert_Input> | Permissions_Role_Insert_Input;
}>;


export type CreateDeleteRolesMutation = { readonly __typename?: 'mutation_root', readonly delete_permissions_Role?: Maybe<{ readonly __typename?: 'permissions_Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly id: any }> }>, readonly insert_permissions_Role?: Maybe<{ readonly __typename?: 'permissions_Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly id: any, readonly conferenceId: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }> }> };

export type UpdateRoleMutationVariables = Exact<{
  roleId: Scalars['uuid'];
  roleName: Scalars['String'];
  insertPermissions: ReadonlyArray<Permissions_RolePermission_Insert_Input> | Permissions_RolePermission_Insert_Input;
  deletePermissionNames?: Maybe<ReadonlyArray<Permissions_Permission_Enum> | Permissions_Permission_Enum>;
}>;


export type UpdateRoleMutation = { readonly __typename?: 'mutation_root', readonly update_permissions_Role?: Maybe<{ readonly __typename?: 'permissions_Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }> }>, readonly insert_permissions_RolePermission?: Maybe<{ readonly __typename?: 'permissions_RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }>, readonly delete_permissions_RolePermission?: Maybe<{ readonly __typename?: 'permissions_RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any }> }> };

export type RoomParticipantWithRegistrantInfoFragment = { readonly __typename?: 'room_Participant', readonly id: any, readonly conferenceId: any, readonly registrantId: any, readonly roomId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } };

export type RoomWithParticipantInfoFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly created_at: any, readonly conferenceId: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly capacity?: Maybe<number>, readonly priority: number, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly id: any, readonly conferenceId: any, readonly registrantId: any, readonly roomId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean }> };

export type SelectAllRoomsWithParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRoomsWithParticipantsQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly created_at: any, readonly conferenceId: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly capacity?: Maybe<number>, readonly priority: number, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly id: any, readonly conferenceId: any, readonly registrantId: any, readonly roomId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean }> }> };

export type ManageRooms_SelectGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageRooms_SelectGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string }> };

export type ManageRooms_SelectItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageRooms_SelectItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type ManageRooms_SelectGroupRegistrantsQueryVariables = Exact<{
  groupId: Scalars['uuid'];
}>;


export type ManageRooms_SelectGroupRegistrantsQuery = { readonly __typename?: 'query_root', readonly permissions_GroupRegistrant: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly groupId: any, readonly registrantId: any }> };

export type RoomPersonInfoFragment = { readonly __typename?: 'room_RoomPerson', readonly id: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } };

export type ManageRooms_SelectRoomPeopleQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type ManageRooms_SelectRoomPeopleQuery = { readonly __typename?: 'query_root', readonly room_RoomPerson: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> };

export type CreateRoomMutationVariables = Exact<{
  room: Room_Room_Insert_Input;
}>;


export type CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_room_Room_one?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly created_at: any, readonly conferenceId: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly capacity?: Maybe<number>, readonly priority: number, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly id: any, readonly conferenceId: any, readonly registrantId: any, readonly roomId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean }> }> };

export type UpdateRoomsWithParticipantsMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity?: Maybe<Scalars['Int']>;
  priority: Scalars['Int'];
  managementModeName: Room_ManagementMode_Enum;
  originatingItemId?: Maybe<Scalars['uuid']>;
  chatId: Scalars['uuid'];
  enableMandatoryPin: Scalars['Boolean'];
  enableAutoPin: Scalars['Boolean'];
  enableMandatorySubscribe: Scalars['Boolean'];
  enableAutoSubscribe: Scalars['Boolean'];
}>;


export type UpdateRoomsWithParticipantsMutation = { readonly __typename?: 'mutation_root', readonly update_room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly created_at: any, readonly conferenceId: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly capacity?: Maybe<number>, readonly priority: number, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly id: any, readonly conferenceId: any, readonly registrantId: any, readonly roomId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean }> }>, readonly update_chat_Chat?: Maybe<{ readonly __typename?: 'chat_Chat_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly enableMandatoryPin: boolean, readonly enableAutoPin: boolean, readonly enableMandatorySubscribe: boolean, readonly enableAutoSubscribe: boolean }> }> };

export type InsertRoomPeopleMutationVariables = Exact<{
  people: ReadonlyArray<Room_RoomPerson_Insert_Input> | Room_RoomPerson_Insert_Input;
}>;


export type InsertRoomPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_room_RoomPerson?: Maybe<{ readonly __typename?: 'room_RoomPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> }> };

export type GetIsExternalRtmpBroadcastEnabledQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetIsExternalRtmpBroadcastEnabledQuery = { readonly __typename?: 'query_root', readonly conference_Configuration_by_pk?: Maybe<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }> };

export type InvitationPartsFragment = { readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> };

export type RegistrantPartsFragment = { readonly __typename?: 'registrant_Registrant', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly registrantId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> }> };

export type ManageRegistrants_ProfileFragment = { readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean };

export type SelectAllRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly registrantId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> }> }> };

export type ManageRegistrants_SelectProfilesQueryVariables = Exact<{
  registrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageRegistrants_SelectProfilesQuery = { readonly __typename?: 'query_root', readonly registrant_Profile: ReadonlyArray<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> };

export type InsertRegistrantMutationVariables = Exact<{
  registrant: Registrant_Registrant_Insert_Input;
  invitation: Registrant_Invitation_Insert_Input;
}>;


export type InsertRegistrantMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant_one?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly registrantId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> }> }>, readonly insert_registrant_Invitation_one?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> }> };

export type InsertRegistrantWithoutInviteMutationVariables = Exact<{
  registrant: Registrant_Registrant_Insert_Input;
}>;


export type InsertRegistrantWithoutInviteMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant_one?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly registrantId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> }> }> };

export type DeleteRegistrantsMutationVariables = Exact<{
  deleteRegistrantIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type DeleteRegistrantsMutation = { readonly __typename?: 'mutation_root', readonly delete_registrant_Registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any }> }> };

export type UpdateRegistrantMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  registrantName: Scalars['String'];
  upsertGroups: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input> | Permissions_GroupRegistrant_Insert_Input;
  remainingGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type UpdateRegistrantMutation = { readonly __typename?: 'mutation_root', readonly update_registrant_Registrant_by_pk?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly registrantId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> }> }>, readonly insert_permissions_GroupRegistrant?: Maybe<{ readonly __typename?: 'permissions_GroupRegistrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly registrantId: any, readonly groupId: any }> }>, readonly delete_permissions_GroupRegistrant?: Maybe<{ readonly __typename?: 'permissions_GroupRegistrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any }> }> };

export type InsertInvitationEmailJobsMutationVariables = Exact<{
  registrantIds: Scalars['jsonb'];
  conferenceId: Scalars['uuid'];
  sendRepeat: Scalars['Boolean'];
}>;


export type InsertInvitationEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_InvitationEmailJob?: Maybe<{ readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response', readonly affected_rows: number }> };

export type ManagePeople_InsertCustomEmailJobMutationVariables = Exact<{
  htmlBody: Scalars['String'];
  subject: Scalars['String'];
  conferenceId: Scalars['uuid'];
  registrantIds: Scalars['jsonb'];
}>;


export type ManagePeople_InsertCustomEmailJobMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_CustomEmailJob?: Maybe<{ readonly __typename?: 'job_queues_CustomEmailJob_mutation_response', readonly affected_rows: number }> };

export type SendEmail_GetAllGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SendEmail_GetAllGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly enabled: boolean, readonly name: string }> };

export type GetRoomRtmpOutputQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomRtmpOutputQuery = { readonly __typename?: 'query_root', readonly room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly rtmpOutput?: Maybe<{ readonly __typename?: 'video_RoomRtmpOutput', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly url: string, readonly streamKey: string }>, readonly channelStack?: Maybe<{ readonly __typename?: 'video_ChannelStackWithStreamKey', readonly id?: Maybe<any>, readonly rtmpOutputUri?: Maybe<string>, readonly rtmpOutputStreamKey?: Maybe<string>, readonly updateJobs: ReadonlyArray<{ readonly __typename?: 'job_queues_ChannelStackUpdateJob', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly jobStatusName: Video_JobStatus_Enum, readonly message?: Maybe<string> }>, readonly mediaLiveChannelStatus?: Maybe<{ readonly __typename?: 'video_MediaLiveChannelStatus', readonly id: any, readonly createdAt: any, readonly updatedAt: any, readonly state: string }> }> }> };

export type InsertRoomRtmpOutputMutationVariables = Exact<{
  roomId: Scalars['uuid'];
  url: Scalars['String'];
  key: Scalars['String'];
}>;


export type InsertRoomRtmpOutputMutation = { readonly __typename?: 'mutation_root', readonly insert_video_RoomRtmpOutput_one?: Maybe<{ readonly __typename?: 'video_RoomRtmpOutput', readonly id: any, readonly roomId: any, readonly created_at: any, readonly updated_at: any, readonly url: string, readonly streamKey: string }> };

export type UpdateRoomRtmpOutputMutationVariables = Exact<{
  id: Scalars['uuid'];
  url: Scalars['String'];
  key: Scalars['String'];
}>;


export type UpdateRoomRtmpOutputMutation = { readonly __typename?: 'mutation_root', readonly update_video_RoomRtmpOutput_by_pk?: Maybe<{ readonly __typename?: 'video_RoomRtmpOutput', readonly id: any, readonly roomId: any, readonly created_at: any, readonly updated_at: any, readonly url: string, readonly streamKey: string }> };

export type DeleteRoomRtmpOutputMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteRoomRtmpOutputMutation = { readonly __typename?: 'mutation_root', readonly delete_video_RoomRtmpOutput_by_pk?: Maybe<{ readonly __typename?: 'video_RoomRtmpOutput', readonly id: any }> };

export type AddEventPeople_ItemPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly personId: any, readonly roleName: string };

export type AddEventPeople_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> };

export type AddEventPeople_RegistrantFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }> };

export type AddEventPeople_GroupFragment = { readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string };

export type AddEventPeople_SelectItemPeopleQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  exhibitionIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type AddEventPeople_SelectItemPeopleQuery = { readonly __typename?: 'query_root', readonly content_ItemProgramPerson: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly personId: any, readonly roleName: string }>, readonly content_ItemExhibition: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly exhibitionId: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly personId: any, readonly roleName: string }> } }> };

export type AddEventPeople_SelectProgramPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectProgramPeopleQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> };

export type AddEventPeople_SelectRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }> }> };

export type AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables = Exact<{
  registrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type AddEventPeople_SelectProgramPeople_ByRegistrantQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> };

export type AddEventPeople_SelectGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string }> };

export type AddEventPeople_SelectRegistrants_ByGroupQueryVariables = Exact<{
  groupId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectRegistrants_ByGroupQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }> }> };

export type AddEventPeople_InsertProgramPeopleMutationVariables = Exact<{
  objects: ReadonlyArray<Collection_ProgramPersonWithAccessToken_Insert_Input> | Collection_ProgramPersonWithAccessToken_Insert_Input;
}>;


export type AddEventPeople_InsertProgramPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_ProgramPersonWithAccessToken?: Maybe<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> }> }> };

export type AddEventPeople_InsertEventPeopleMutationVariables = Exact<{
  objects: ReadonlyArray<Schedule_EventProgramPerson_Insert_Input> | Schedule_EventProgramPerson_Insert_Input;
}>;


export type AddEventPeople_InsertEventPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_EventProgramPerson?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }> }> };

export type ContinuationsEditor_ContinuationFragment = { readonly __typename?: 'schedule_Continuation', readonly id: any, readonly fromEvent?: Maybe<any>, readonly fromShuffleQueue?: Maybe<any>, readonly to: any, readonly defaultFor: string, readonly isActiveChoice: boolean, readonly priority: number, readonly colour: string, readonly description: string };

export type ContinuationsEditor_SelectContinuationsQueryVariables = Exact<{
  fromId: Scalars['uuid'];
}>;


export type ContinuationsEditor_SelectContinuationsQuery = { readonly __typename?: 'query_root', readonly schedule_Continuation: ReadonlyArray<{ readonly __typename?: 'schedule_Continuation', readonly id: any, readonly fromEvent?: Maybe<any>, readonly fromShuffleQueue?: Maybe<any>, readonly to: any, readonly defaultFor: string, readonly isActiveChoice: boolean, readonly priority: number, readonly colour: string, readonly description: string }> };

export type ContinuationsEditor_InsertMutationVariables = Exact<{
  object: Schedule_Continuation_Insert_Input;
}>;


export type ContinuationsEditor_InsertMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_Continuation_one?: Maybe<{ readonly __typename?: 'schedule_Continuation', readonly id: any, readonly fromEvent?: Maybe<any>, readonly fromShuffleQueue?: Maybe<any>, readonly to: any, readonly defaultFor: string, readonly isActiveChoice: boolean, readonly priority: number, readonly colour: string, readonly description: string }> };

export type ContinuationsEditor_UpdateMutationVariables = Exact<{
  id: Scalars['uuid'];
  object: Schedule_Continuation_Set_Input;
}>;


export type ContinuationsEditor_UpdateMutation = { readonly __typename?: 'mutation_root', readonly update_schedule_Continuation_by_pk?: Maybe<{ readonly __typename?: 'schedule_Continuation', readonly id: any, readonly fromEvent?: Maybe<any>, readonly fromShuffleQueue?: Maybe<any>, readonly to: any, readonly defaultFor: string, readonly isActiveChoice: boolean, readonly priority: number, readonly colour: string, readonly description: string }> };

export type ContinuationsEditor_UpdateManyMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  object: Schedule_Continuation_Set_Input;
}>;


export type ContinuationsEditor_UpdateManyMutation = { readonly __typename?: 'mutation_root', readonly update_schedule_Continuation?: Maybe<{ readonly __typename?: 'schedule_Continuation_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_Continuation', readonly id: any, readonly fromEvent?: Maybe<any>, readonly fromShuffleQueue?: Maybe<any>, readonly to: any, readonly defaultFor: string, readonly isActiveChoice: boolean, readonly priority: number, readonly colour: string, readonly description: string }> }> };

export type ContinuationsEditor_DeleteMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ContinuationsEditor_DeleteMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_Continuation?: Maybe<{ readonly __typename?: 'schedule_Continuation_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_Continuation', readonly id: any }> }> };

export type CreateContinuationModal_RoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateContinuationModal_RoomsQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }> };

export type CreateContinuationModal_EventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateContinuationModal_EventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly shufflePeriod?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly name: string }> }> };

export type CreateContinuationModal_ItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateContinuationModal_ItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type CreateContinuationModal_ExhibitionsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateContinuationModal_ExhibitionsQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }> };

export type CreateContinuationModal_ShufflePeriodsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateContinuationModal_ShufflePeriodsQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly name: string }> };

export type CreateContinuationModal_TagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateContinuationModal_TagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string }> };

export type CreateContinuationModal_ProfileQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateContinuationModal_ProfileQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string }> };

export type InsertEventProgramPersonMutationVariables = Exact<{
  newEventProgramPerson: Schedule_EventProgramPerson_Insert_Input;
}>;


export type InsertEventProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_EventProgramPerson_one?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }> };

export type DeleteEventProgramPersonsMutationVariables = Exact<{
  deleteEventPeopleIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventProgramPersonsMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_EventProgramPerson?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any }> }> };

export type UpdateEventProgramPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  personId: Scalars['uuid'];
  roleName: Schedule_EventProgramPersonRole_Enum;
}>;


export type UpdateEventProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly update_schedule_EventProgramPerson_by_pk?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }> };

export type ManageSchedule_ShufflePeriodsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  now: Scalars['timestamptz'];
}>;


export type ManageSchedule_ShufflePeriodsQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly name: string }> };

export type ShufflePeriodInfoFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly name: string };

export type InsertEventInfoMutationVariables = Exact<{
  id: Scalars['uuid'];
  roomId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  intendedRoomModeName: Room_Mode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  itemId?: Maybe<Scalars['uuid']>;
  exhibitionId?: Maybe<Scalars['uuid']>;
  shufflePeriodId?: Maybe<Scalars['uuid']>;
  insertContinuation: Scalars['Boolean'];
  enableRecording: Scalars['Boolean'];
}>;


export type InsertEventInfoMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_Event_one?: Maybe<{ readonly __typename?: 'schedule_Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly enableRecording: boolean, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }>, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any }> }>, readonly insert_schedule_Continuation_one?: Maybe<{ readonly __typename?: 'schedule_Continuation', readonly id: any }> };

export type UpdateEventInfoMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  roomId: Scalars['uuid'];
  intendedRoomModeName: Room_Mode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  itemId?: Maybe<Scalars['uuid']>;
  exhibitionId?: Maybe<Scalars['uuid']>;
  shufflePeriodId?: Maybe<Scalars['uuid']>;
  enableRecording: Scalars['Boolean'];
}>;


export type UpdateEventInfoMutation = { readonly __typename?: 'mutation_root', readonly update_schedule_Event_by_pk?: Maybe<{ readonly __typename?: 'schedule_Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly enableRecording: boolean, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }>, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any }> }> };

export type DeleteEventInfosMutationVariables = Exact<{
  eventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventInfosMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_Event?: Maybe<{ readonly __typename?: 'schedule_Event_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any }> }> };

export type RoomInfoFragment = { readonly __typename?: 'room_Room', readonly capacity?: Maybe<number>, readonly conferenceId: any, readonly currentModeName: Room_Mode_Enum, readonly id: any, readonly name: string, readonly priority: number, readonly originatingDataId?: Maybe<any>, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly registrantId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any }> };

export type RoomParticipantInfoFragment = { readonly __typename?: 'room_Participant', readonly registrantId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any };

export type EventInfoFragment = { readonly __typename?: 'schedule_Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly enableRecording: boolean, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }>, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any }> };

export type EventProgramPersonInfoFragment = { readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any };

export type EventTagInfoFragment = { readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any };

export type SelectWholeScheduleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectWholeScheduleQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly capacity?: Maybe<number>, readonly conferenceId: any, readonly currentModeName: Room_Mode_Enum, readonly id: any, readonly name: string, readonly priority: number, readonly originatingDataId?: Maybe<any>, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly registrantId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any }> }>, readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly enableRecording: boolean, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }>, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any }> }>, readonly conference_OriginatingData: ReadonlyArray<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly priority: number }>, readonly collection_Exhibition: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number, readonly isHidden: boolean }>, readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly uploadsRemaining?: Maybe<number> }>, readonly itemTags: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any }>, readonly itemExhibitions: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string }>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }>, readonly collection_ProgramPersonWithAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonWithAccessToken', readonly id?: Maybe<any>, readonly conferenceId?: Maybe<any>, readonly name?: Maybe<string>, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any> }> };

export type InsertRoomsMutationVariables = Exact<{
  newRooms: ReadonlyArray<Room_Room_Insert_Input> | Room_Room_Insert_Input;
}>;


export type InsertRoomsMutation = { readonly __typename?: 'mutation_root', readonly insert_room_Room?: Maybe<{ readonly __typename?: 'room_Room_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly capacity?: Maybe<number>, readonly conferenceId: any, readonly currentModeName: Room_Mode_Enum, readonly id: any, readonly name: string, readonly priority: number, readonly originatingDataId?: Maybe<any>, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly registrantId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any }> }> }> };

export type DeleteRoomsMutationVariables = Exact<{
  deleteRoomIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteRoomsMutation = { readonly __typename?: 'mutation_root', readonly delete_room_Room?: Maybe<{ readonly __typename?: 'room_Room_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }> };

export type UpdateRoomMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity?: Maybe<Scalars['Int']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
  priority: Scalars['Int'];
}>;


export type UpdateRoomMutation = { readonly __typename?: 'mutation_root', readonly update_room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly capacity?: Maybe<number>, readonly conferenceId: any, readonly currentModeName: Room_Mode_Enum, readonly id: any, readonly name: string, readonly priority: number, readonly originatingDataId?: Maybe<any>, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly originatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> }>, readonly participants: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly registrantId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any }> }> };

export type DeleteEventsMutationVariables = Exact<{
  deleteEventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventsMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_Event?: Maybe<{ readonly __typename?: 'schedule_Event_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any }> }> };

export type InsertEventMutationVariables = Exact<{
  newEvent: Schedule_Event_Insert_Input;
  newEventId: Scalars['uuid'];
  insertContinuation: Scalars['Boolean'];
}>;


export type InsertEventMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_Event_one?: Maybe<{ readonly __typename?: 'schedule_Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly enableRecording: boolean, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }>, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any }> }>, readonly insert_schedule_Continuation_one?: Maybe<{ readonly __typename?: 'schedule_Continuation', readonly id: any }> };

export type UpdateEventMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  roomId: Scalars['uuid'];
  intendedRoomModeName: Room_Mode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  itemId?: Maybe<Scalars['uuid']>;
  exhibitionId?: Maybe<Scalars['uuid']>;
  newEventTags: ReadonlyArray<Schedule_EventTag_Insert_Input> | Schedule_EventTag_Insert_Input;
  deleteEventTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UpdateEventMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_EventTag?: Maybe<{ readonly __typename?: 'schedule_EventTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any }> }>, readonly update_schedule_Event_by_pk?: Maybe<{ readonly __typename?: 'schedule_Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any>, readonly enableRecording: boolean, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any }>, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any }> }>, readonly delete_schedule_EventTag?: Maybe<{ readonly __typename?: 'schedule_EventTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly id: any }> }> };

export type UpdateShufflePeriodMutationVariables = Exact<{
  id: Scalars['uuid'];
  object: Room_ShufflePeriod_Set_Input;
}>;


export type UpdateShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly update_room_ShufflePeriod_by_pk?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetRegistrantsPerRoom: number, readonly maxRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum }> };

export type InsertShufflePeriodMutationVariables = Exact<{
  object: Room_ShufflePeriod_Insert_Input;
}>;


export type InsertShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly insert_room_ShufflePeriod_one?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetRegistrantsPerRoom: number, readonly maxRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum }> };

export type ManageShufflePeriods_ShufflePeriodFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetRegistrantsPerRoom: number, readonly maxRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum, readonly completedEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count: number }> }, readonly ongoingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count: number }> }, readonly waitingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count: number }> } };

export type ManageShufflePeriods_SelectAllQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageShufflePeriods_SelectAllQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetRegistrantsPerRoom: number, readonly maxRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum, readonly completedEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count: number }> }, readonly ongoingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count: number }> }, readonly waitingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count: number }> } }> };

export type DeleteShufflePeriodMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly delete_room_ShufflePeriod_by_pk?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any }> };

export type ConferenceTakenQueryVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
}>;


export type ConferenceTakenQuery = { readonly __typename?: 'query_root', readonly conference_Conference: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> };

export type CreateConferenceMutationVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
  demoCode: Scalars['uuid'];
}>;


export type CreateConferenceMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_Conference?: Maybe<{ readonly __typename?: 'conference_Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly slug: string }> }>, readonly update_conference_DemoCode?: Maybe<{ readonly __typename?: 'conference_DemoCode_mutation_response', readonly affected_rows: number }> };

export type CreateNewConferenceMetaStructureMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantDisplayName: Scalars['String'];
  userId: Scalars['String'];
  abstractData: Scalars['jsonb'];
  itemListData: Scalars['jsonb'];
}>;


export type CreateNewConferenceMetaStructureMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant_mutation_response', readonly affected_rows: number }>, readonly insert_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly roleId: any, readonly permissionName: Permissions_Permission_Enum }> } }> }> }>, readonly insert_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly affected_rows: number }> };

export type RegistrantsByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type RegistrantsByIdQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> };

export type RegistrantsByUserIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  userIds: ReadonlyArray<Scalars['String']> | Scalars['String'];
}>;


export type RegistrantsByUserIdQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> };

export type ConferenceBySlug_WithUserQueryVariables = Exact<{
  slug: Scalars['String'];
  userId: Scalars['String'];
}>;


export type ConferenceBySlug_WithUserQuery = { readonly __typename?: 'query_root', readonly conference_Conference: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string, readonly createdBy: string, readonly supportAddress: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly registrationURL: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly scheduleViewVersion: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly sponsorsLabel: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly disableNearbyEvents: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly publicGroups: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly permissionName: Permissions_Permission_Enum, readonly id: any, readonly roleId: any }> } }> }>, readonly registrants: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly groupId: any, readonly registrantId: any, readonly group: { readonly __typename?: 'permissions_Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly permissionName: Permissions_Permission_Enum, readonly id: any, readonly roleId: any }> } }> } }>, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> }> };

export type ConferenceBySlug_WithoutUserQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type ConferenceBySlug_WithoutUserQuery = { readonly __typename?: 'query_root', readonly conference_Conference: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string, readonly createdBy: string, readonly supportAddress: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly registrationURL: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly scheduleViewVersion: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly sponsorsLabel: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly disableNearbyEvents: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly publicGroups: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly permissionName: Permissions_Permission_Enum, readonly id: any, readonly roleId: any }> } }> }> }> };

export type AuthdConferenceInfoFragment = { readonly __typename?: 'conference_Conference', readonly registrants: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly groupId: any, readonly registrantId: any, readonly group: { readonly __typename?: 'permissions_Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly permissionName: Permissions_Permission_Enum, readonly id: any, readonly roleId: any }> } }> } }>, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> }> };

export type PublicConferenceInfoFragment = { readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string, readonly createdBy: string, readonly supportAddress: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly registrationURL: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly scheduleViewVersion: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly sponsorsLabel: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly disableNearbyEvents: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }>, readonly publicGroups: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly permissionName: Permissions_Permission_Enum, readonly id: any, readonly roleId: any }> } }> }> };

export type GroupDataFragment = { readonly __typename?: 'permissions_Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly permissionName: Permissions_Permission_Enum, readonly id: any, readonly roleId: any }> } }> };

export type ProfileDataFragment = { readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean };

export type RegistrantDataFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean }> };

export type UpdateSubtitlesMutationVariables = Exact<{
  elementId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
}>;


export type UpdateSubtitlesMutation = { readonly __typename?: 'mutation_root', readonly updateSubtitles?: Maybe<{ readonly __typename?: 'SubmitUpdatedSubtitlesOutput', readonly message: string, readonly success: boolean }> };

export type Submissions_ListUploadersQueryVariables = Exact<{
  elementId: Scalars['uuid'];
}>;


export type Submissions_ListUploadersQuery = { readonly __typename?: 'query_root', readonly content_Uploader: ReadonlyArray<{ readonly __typename?: 'content_Uploader', readonly id: any, readonly name: string, readonly email: string }> };

export type Submissions_GetProgramPersonAccessTokenQueryVariables = Exact<{
  elementId: Scalars['uuid'];
  uploaderEmail: Scalars['String'];
  elementAccessToken: Scalars['String'];
}>;


export type Submissions_GetProgramPersonAccessTokenQuery = { readonly __typename?: 'query_root', readonly getProgramPersonAccessToken: { readonly __typename?: 'MatchingPersonOutput', readonly accessToken?: Maybe<string> } };

export type ItemByPersonAccessTokenQueryVariables = Exact<{
  accessToken: Scalars['String'];
  itemId: Scalars['uuid'];
}>;


export type ItemByPersonAccessTokenQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPersonByAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonByAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string> }>, readonly content_ItemByPersonAccessToken: ReadonlyArray<{ readonly __typename?: 'content_ItemByPersonAccessToken', readonly id?: Maybe<any>, readonly title?: Maybe<string>, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_ElementByPersonAccessToken', readonly id?: Maybe<any>, readonly accessToken?: Maybe<string>, readonly name?: Maybe<string>, readonly data?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly layoutData?: Maybe<any> }> }> };

export type ItemsByPersonAccessTokenQueryVariables = Exact<{
  accessToken: Scalars['String'];
}>;


export type ItemsByPersonAccessTokenQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPersonByAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonByAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPersonByAccessToken', readonly id?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_ItemByPersonAccessToken', readonly id?: Maybe<any>, readonly title?: Maybe<string> }> }> }> };

export type GetElementQueryVariables = Exact<{
  accessToken: Scalars['String'];
  elementId: Scalars['uuid'];
}>;


export type GetElementQuery = { readonly __typename?: 'query_root', readonly content_ElementByPersonAccessToken: ReadonlyArray<{ readonly __typename?: 'content_ElementByPersonAccessToken', readonly typeName?: Maybe<string>, readonly data?: Maybe<any>, readonly name?: Maybe<string>, readonly id?: Maybe<any>, readonly uploadsRemaining?: Maybe<number>, readonly accessToken?: Maybe<string>, readonly item?: Maybe<{ readonly __typename?: 'content_ItemByPersonAccessToken', readonly title?: Maybe<string> }> }>, readonly collection_ProgramPersonByAccessToken: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPersonByAccessToken', readonly id?: Maybe<any>, readonly name?: Maybe<string> }> };

export type SubmitUploadableElementMutationVariables = Exact<{
  elementData: Scalars['jsonb'];
  magicToken: Scalars['String'];
}>;


export type SubmitUploadableElementMutation = { readonly __typename?: 'mutation_root', readonly submitUploadableElement?: Maybe<{ readonly __typename?: 'SubmitUploadableElementOutput', readonly message: string, readonly success: boolean }> };

export type GetUploadAgreementQueryVariables = Exact<{
  magicToken: Scalars['String'];
}>;


export type GetUploadAgreementQuery = { readonly __typename?: 'query_root', readonly getUploadAgreement?: Maybe<{ readonly __typename?: 'GetUploadAgreementOutput', readonly agreementText?: Maybe<string>, readonly agreementUrl?: Maybe<string> }> };

export type GetForceUserRefreshConfigQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetForceUserRefreshConfigQuery = { readonly __typename?: 'query_root', readonly conference_Configuration_by_pk?: Maybe<{ readonly __typename?: 'conference_Configuration', readonly conferenceId: any, readonly key: Conference_ConfigurationKey_Enum, readonly value: any }> };

export type GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables = Exact<{
  code: Scalars['String'];
  state: Scalars['String'];
}>;


export type GoogleOAuth_SubmitGoogleOAuthCodeMutation = { readonly __typename?: 'mutation_root', readonly submitGoogleOAuthCode?: Maybe<{ readonly __typename?: 'SubmitGoogleOAuthCodeOutput', readonly message?: Maybe<string>, readonly success: boolean }> };

export type SelectInvitationForAcceptQueryVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SelectInvitationForAcceptQuery = { readonly __typename?: 'query_root', readonly registrant_Invitation: ReadonlyArray<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }> };

export type Invitation_ConfirmCurrentMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type Invitation_ConfirmCurrentMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmCurrent?: Maybe<{ readonly __typename?: 'ConfirmInvitationOutput', readonly confSlug?: Maybe<string>, readonly ok: string }> };

export type GetEventsInNextHourQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  now: Scalars['timestamptz'];
  cutoff: Scalars['timestamptz'];
}>;


export type GetEventsInNextHourQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }> };

export type MinimalEventInfoFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } };

export type MenuScheduleQueryVariables = Exact<{
  now: Scalars['timestamptz'];
  inOneHour: Scalars['timestamptz'];
  conferenceId: Scalars['uuid'];
}>;


export type MenuScheduleQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly colour: string, readonly name: string } }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }> };

export type MenuSchedule_SearchEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type MenuSchedule_SearchEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly colour: string, readonly name: string } }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }> };

export type MenuSchedule_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly colour: string, readonly name: string } }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type MainMenuSponsors_GetSponsorsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type MainMenuSponsors_GetSponsorsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly priority: number }>, readonly logo: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> };

export type MainMenuSponsors_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly priority: number }>, readonly logo: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> };

export type CreateDmMutationVariables = Exact<{
  registrantIds: ReadonlyArray<Maybe<Scalars['uuid']>> | Maybe<Scalars['uuid']>;
  conferenceId: Scalars['uuid'];
}>;


export type CreateDmMutation = { readonly __typename?: 'mutation_root', readonly createRoomDm?: Maybe<{ readonly __typename?: 'CreateRoomDmOutput', readonly message?: Maybe<string>, readonly roomId?: Maybe<any>, readonly chatId?: Maybe<any> }> };

export type GetItemChatIdQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type GetItemChatIdQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly chatId?: Maybe<any> }> };

export type GetRoomChatIdQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomChatIdQuery = { readonly __typename?: 'query_root', readonly room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly chatId?: Maybe<any>, readonly name: string }> };

export type GetVapidPublicKeyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetVapidPublicKeyQuery = { readonly __typename?: 'query_root', readonly vapidPublicKey: { readonly __typename?: 'VAPIDPublicKeyOutput', readonly key: string } };

export type UpsertPushNotificationSubscriptionMutationVariables = Exact<{
  object: PushNotificationSubscription_Insert_Input;
}>;


export type UpsertPushNotificationSubscriptionMutation = { readonly __typename?: 'mutation_root', readonly insert_PushNotificationSubscription_one?: Maybe<{ readonly __typename?: 'PushNotificationSubscription', readonly endpoint: string }> };

export type DeletePushNotificationSubscriptionMutationVariables = Exact<{
  endpoint: Scalars['String'];
}>;


export type DeletePushNotificationSubscriptionMutation = { readonly __typename?: 'mutation_root', readonly delete_PushNotificationSubscription?: Maybe<{ readonly __typename?: 'PushNotificationSubscription_mutation_response', readonly affected_rows: number }> };

export type GetRoomMembersQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomMembersQuery = { readonly __typename?: 'query_root', readonly room_RoomPerson: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly roomId: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrantId: any }> };

export type RoomMemberFragment = { readonly __typename?: 'room_RoomPerson', readonly id: any, readonly roomId: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrantId: any };

export type GetAllRoomParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetAllRoomParticipantsQuery = { readonly __typename?: 'query_root', readonly room_Participant: ReadonlyArray<{ readonly __typename?: 'room_Participant', readonly conferenceId: any, readonly id: any, readonly roomId: any, readonly registrantId: any }> };

export type RoomParticipantDetailsFragment = { readonly __typename?: 'room_Participant', readonly conferenceId: any, readonly id: any, readonly roomId: any, readonly registrantId: any };

export type ShufflePeriodDataFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly conferenceId: any, readonly endAt: any, readonly maxRegistrantsPerRoom: number, readonly name: string, readonly roomDurationMinutes: number, readonly startAt: any, readonly targetRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly queueEntries: ReadonlyArray<{ readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly registrantId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> }> };

export type PrefetchShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly registrantId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> };

export type SubdShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly isExpired: boolean, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly roomId: any }> };

export type MyShuffleQueueEntryQueryVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type MyShuffleQueueEntryQuery = { readonly __typename?: 'query_root', readonly room_ShuffleQueueEntry_by_pk?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly isExpired: boolean, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly roomId: any }> }> };

export type ShufflePeriodsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  end: Scalars['timestamptz'];
}>;


export type ShufflePeriodsQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly conferenceId: any, readonly endAt: any, readonly maxRegistrantsPerRoom: number, readonly name: string, readonly roomDurationMinutes: number, readonly startAt: any, readonly targetRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly queueEntries: ReadonlyArray<{ readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly registrantId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> }> }> };

export type JoinShuffleQueueMutationVariables = Exact<{
  shufflePeriodId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type JoinShuffleQueueMutation = { readonly __typename?: 'mutation_root', readonly insert_room_ShuffleQueueEntry_one?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly registrantId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> }> };

export type GetShuffleRoomsParticipantsCountQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetShuffleRoomsParticipantsCountQuery = { readonly __typename?: 'query_root', readonly room_Participant_aggregate: { readonly __typename?: 'room_Participant_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_Participant_aggregate_fields', readonly count: number }> } };

export type RegistrantFieldsFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly createdAt: any, readonly updatedAt: any, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly photoURL_50x50?: Maybe<string> }>, readonly conference: { readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly group: { readonly __typename?: 'permissions_Group', readonly id: any, readonly enabled: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum }> } }> } }> };

export type UserInfoFragment = { readonly __typename?: 'User', readonly id: string, readonly email?: Maybe<string>, readonly acceptedTermsAt?: Maybe<any>, readonly acceptedPrivacyPolicyAt?: Maybe<any>, readonly registrants: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly createdAt: any, readonly updatedAt: any, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly photoURL_50x50?: Maybe<string> }>, readonly conference: { readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly group: { readonly __typename?: 'permissions_Group', readonly id: any, readonly enabled: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum }> } }> } }> }> };

export type SelectCurrentUserQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type SelectCurrentUserQuery = { readonly __typename?: 'query_root', readonly User_by_pk?: Maybe<{ readonly __typename?: 'User', readonly id: string, readonly email?: Maybe<string>, readonly acceptedTermsAt?: Maybe<any>, readonly acceptedPrivacyPolicyAt?: Maybe<any>, readonly registrants: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly createdAt: any, readonly updatedAt: any, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly photoURL_50x50?: Maybe<string> }>, readonly conference: { readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly group: { readonly __typename?: 'permissions_Group', readonly id: any, readonly enabled: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum }> } }> } }> }> }> };

export type TermsConfigsQueryVariables = Exact<{ [key: string]: never; }>;


export type TermsConfigsQuery = { readonly __typename?: 'query_root', readonly hostOrganisationName?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly termsTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly termsURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly ppTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly ppURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly cookiesTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly cookiesURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }> };

export type AgreeToTermsMutationVariables = Exact<{
  userId: Scalars['String'];
  at: Scalars['timestamptz'];
}>;


export type AgreeToTermsMutation = { readonly __typename?: 'mutation_root', readonly update_User_by_pk?: Maybe<{ readonly __typename?: 'User', readonly id: string, readonly acceptedTermsAt?: Maybe<any>, readonly acceptedPrivacyPolicyAt?: Maybe<any> }> };

export const ChatState_SubdMessageFragmentDoc = gql`
    fragment ChatState_SubdMessage on chat_Message {
  id
  chatId
  message
  type
  senderId
}
    `;
export const InitialChatState_ChatFragmentDoc = gql`
    fragment InitialChatState_Chat on chat_Chat {
  id
  items {
    id
    title
    shortTitle
  }
  nonDMRoom: rooms(where: {managementModeName: {_neq: DM}}) {
    id
    name
    priority
    managementModeName
  }
  DMRoom: rooms(where: {managementModeName: {_eq: DM}}) {
    id
    name
    roomPeople {
      id
      registrant {
        id
        displayName
      }
    }
  }
  enableAutoPin
  enableAutoSubscribe
  enableMandatoryPin
  enableMandatorySubscribe
  pins(where: {registrantId: {_eq: $registrantId}}) {
    registrantId
    chatId
    wasManuallyPinned
  }
  subscriptions(where: {registrantId: {_eq: $registrantId}}) {
    registrantId
    chatId
    wasManuallySubscribed
  }
}
    `;
export const ShortChatMessageDataFragmentDoc = gql`
    fragment ShortChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageSId
  message
  senderId
  type
  chatId
  sId
}
    `;
export const ShortChatReactionDataFragmentDoc = gql`
    fragment ShortChatReactionData on chat_Reaction {
  data
  senderId
  symbol
  type
  messageSId
  sId
  duplicateSId
}
    `;
export const ElementDataFragmentDoc = gql`
    fragment ElementData on content_Element {
  id
  data
  layoutData
  name
  typeName
}
    `;
export const ProgramPersonDataFragmentDoc = gql`
    fragment ProgramPersonData on content_ItemProgramPerson {
  id
  person {
    id
    name
    affiliation
    registrantId
  }
  roleName
  priority
}
    `;
export const ItemTagDataFragmentDoc = gql`
    fragment ItemTagData on content_ItemTag {
  id
  itemId
  tag {
    id
    name
    colour
    priority
  }
}
    `;
export const ExhibitionSummaryFragmentDoc = gql`
    fragment ExhibitionSummary on collection_Exhibition {
  id
  name
  colour
  priority
  items {
    id
    item {
      itemPeople {
        ...ProgramPersonData
      }
      itemTags {
        ...ItemTagData
      }
    }
  }
}
    ${ProgramPersonDataFragmentDoc}
${ItemTagDataFragmentDoc}`;
export const ItemExhibitionDataFragmentDoc = gql`
    fragment ItemExhibitionData on content_ItemExhibition {
  id
  itemId
  exhibition {
    ...ExhibitionSummary
  }
}
    ${ExhibitionSummaryFragmentDoc}`;
export const ItemElements_ItemDataFragmentDoc = gql`
    fragment ItemElements_ItemData on content_Item {
  id
  title
  typeName
  chatId
  chat {
    rooms {
      id
      name
    }
  }
  elements(
    where: {isHidden: {_eq: false}, _or: [{typeName: {_in: [ACTIVE_SOCIAL_ROOMS, CONTENT_GROUP_LIST, DIVIDER, EXPLORE_PROGRAM_BUTTON, EXPLORE_SCHEDULE_BUTTON, LIVE_PROGRAM_ROOMS, SPONSOR_BOOTHS, WHOLE_SCHEDULE]}}, {hasBeenSubmitted: {_eq: true}}]}
  ) {
    ...ElementData
  }
  itemPeople(order_by: {priority: asc}) {
    ...ProgramPersonData
  }
  itemTags {
    ...ItemTagData
  }
  itemExhibitions {
    ...ItemExhibitionData
  }
}
    ${ElementDataFragmentDoc}
${ProgramPersonDataFragmentDoc}
${ItemTagDataFragmentDoc}
${ItemExhibitionDataFragmentDoc}`;
export const ItemRoomEventFragmentDoc = gql`
    fragment ItemRoomEvent on schedule_Event {
  startTime
  item {
    id
    title
  }
  exhibitionId
  id
  durationSeconds
  endTime
  name
  intendedRoomModeName
}
    `;
export const ItemList_ItemDataFragmentDoc = gql`
    fragment ItemList_ItemData on content_Item {
  id
  title
  itemPeople {
    ...ProgramPersonData
  }
}
    ${ProgramPersonDataFragmentDoc}`;
export const ItemList_ItemTagDataFragmentDoc = gql`
    fragment ItemList_ItemTagData on content_ItemTag {
  item {
    ...ItemList_ItemData
  }
}
    ${ItemList_ItemDataFragmentDoc}`;
export const ItemList_TagInfoFragmentDoc = gql`
    fragment ItemList_TagInfo on collection_Tag {
  id
  colour
  name
  priority
}
    `;
export const ItemPage_ItemRoomsFragmentDoc = gql`
    fragment ItemPage_ItemRooms on content_Item {
  rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    `;
export const ItemEventFragmentDoc = gql`
    fragment ItemEvent on schedule_Event {
  startTime
  roomId
  room {
    name
    id
  }
  exhibitionId
  id
  durationSeconds
  endTime
  name
  intendedRoomModeName
}
    `;
export const ContinuationChoices_ContinuationFragmentDoc = gql`
    fragment ContinuationChoices_Continuation on schedule_Continuation {
  id
  to
  defaultFor
  isActiveChoice
  priority
  colour
  description
}
    `;
export const ExhibitionItemFragmentDoc = gql`
    fragment ExhibitionItem on content_Item {
  id
  title
  typeName
  elements(
    where: {isHidden: {_eq: false}, typeName: {_in: [ABSTRACT, IMAGE_FILE, IMAGE_URL, POSTER_FILE, POSTER_URL, TEXT, VIDEO_BROADCAST, VIDEO_FILE, VIDEO_PREPUBLISH, VIDEO_URL]}}
  ) {
    ...ElementData
  }
  events {
    id
    startTime
    endTime
    roomId
  }
  itemPeople(order_by: {priority: asc}) {
    ...ProgramPersonData
  }
  itemTags {
    ...ItemTagData
  }
  discussionRoom: rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    ${ElementDataFragmentDoc}
${ProgramPersonDataFragmentDoc}
${ItemTagDataFragmentDoc}`;
export const ExhibitionWithContentFragmentDoc = gql`
    fragment ExhibitionWithContent on collection_Exhibition {
  id
  name
  colour
  priority
  conferenceId
  descriptiveItem {
    id
    elements(where: {isHidden: {_eq: false}, typeName: {_in: [ABSTRACT, TEXT]}}) {
      ...ElementData
    }
  }
  items {
    id
    itemId
    exhibitionId
    layout
    priority
    item {
      ...ExhibitionItem
    }
  }
}
    ${ElementDataFragmentDoc}
${ExhibitionItemFragmentDoc}`;
export const MyBackstages_EventFragmentDoc = gql`
    fragment MyBackstages_Event on schedule_Event {
  id
  conferenceId
  item {
    id
    title
  }
  endTime
  intendedRoomModeName
  name
  room {
    id
    name
  }
  startTime
}
    `;
export const PrefetchShuffleQueueEntryDataFragmentDoc = gql`
    fragment PrefetchShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  registrantId
  created_at
  updated_at
  shuffleRoom {
    id
    startedAt
    isEnded
    roomId
  }
}
    `;
export const ShufflePeriodDataFragmentDoc = gql`
    fragment ShufflePeriodData on room_ShufflePeriod {
  id
  conferenceId
  endAt
  maxRegistrantsPerRoom
  name
  queueEntries(
    where: {isExpired: {_eq: false}}
    distinct_on: [registrantId]
    order_by: {registrantId: asc, id: desc}
  ) {
    ...PrefetchShuffleQueueEntryData
  }
  roomDurationMinutes
  startAt
  targetRegistrantsPerRoom
  waitRoomMaxDurationSeconds
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export const Room_EventSummaryFragmentDoc = gql`
    fragment Room_EventSummary on schedule_Event {
  id
  conferenceId
  startTime
  name
  endTime
  intendedRoomModeName
  itemId
  exhibitionId
  shufflePeriod {
    ...ShufflePeriodData
  }
  item {
    id
    title
    typeName
    videoElements: elements(
      where: {typeName: {_in: [VIDEO_BROADCAST, VIDEO_FILE, VIDEO_PREPUBLISH]}, isHidden: {_eq: false}}
      order_by: {name: asc}
    ) {
      id
      name
    }
    zoomItems: elements(where: {typeName: {_eq: ZOOM}}, limit: 1) {
      id
      data
      name
    }
    chatId
  }
  eventPeople {
    id
    person {
      id
      name
      affiliation
      registrantId
    }
    roleName
  }
}
    ${ShufflePeriodDataFragmentDoc}`;
export const RoomPage_RoomDetailsFragmentDoc = gql`
    fragment RoomPage_RoomDetails on room_Room {
  id
  name
  currentModeName
  isProgramRoom
  publicVonageSessionId
  chatId
  originatingItem {
    id
    typeName
    elements(
      where: {typeName: {_in: [IMAGE_URL, IMAGE_FILE]}, layoutData: {_contains: {isLogo: true}}}
      limit: 1
      order_by: {updatedAt: desc}
    ) {
      id
      data
    }
    title
  }
  managementModeName
  selfAdminPerson: roomPeople(
    where: {personRoleName: {_eq: ADMIN}, registrantId: {_eq: $registrantId}}
  ) {
    id
  }
  shuffleRooms(limit: 1, order_by: {id: desc}) {
    id
    startedAt
    durationMinutes
    reshuffleUponEnd
    shufflePeriodId
  }
  backendName
}
    `;
export const RoomPage_RoomChannelStackFragmentDoc = gql`
    fragment RoomPage_RoomChannelStack on video_ChannelStack {
  cloudFrontDomain
  endpointUri
  id
}
    `;
export const RoomSponsorContent_ElementDataFragmentDoc = gql`
    fragment RoomSponsorContent_ElementData on content_Element {
  id
  name
  isHidden
  typeName
  data
  layoutData
}
    `;
export const RoomSponsorContent_ItemDataFragmentDoc = gql`
    fragment RoomSponsorContent_ItemData on content_Item {
  id
  elements {
    ...RoomSponsorContent_ElementData
  }
}
    ${RoomSponsorContent_ElementDataFragmentDoc}`;
export const EventParticipantStreamDetailsFragmentDoc = gql`
    fragment EventParticipantStreamDetails on video_EventParticipantStream {
  id
  registrant {
    id
    displayName
  }
  conferenceId
  eventId
  vonageStreamType
  vonageStreamId
  registrantId
}
    `;
export const RoomEventDetailsFragmentDoc = gql`
    fragment RoomEventDetails on schedule_Event {
  id
  conferenceId
  startTime
  name
  durationSeconds
  endTime
  intendedRoomModeName
  eventVonageSession {
    id
    sessionId
  }
}
    `;
export const RoomListRoomDetailsFragmentDoc = gql`
    fragment RoomListRoomDetails on room_Room {
  id
  name
  priority
  managementModeName
  originatingItem {
    id
    itemPeople {
      id
      roleName
      person {
        id
        registrantId
      }
    }
  }
  originatingEventId
}
    `;
export const SocialRoomFragmentDoc = gql`
    fragment SocialRoom on room_Room {
  id
  name
  priority
}
    `;
export const RoomTile_EventFragmentDoc = gql`
    fragment RoomTile_Event on schedule_Event {
  id
  name
  intendedRoomModeName
  startTime
  endTime
  exhibition {
    id
    name
  }
  item {
    id
    title
  }
}
    `;
export const RoomTile_RoomFragmentDoc = gql`
    fragment RoomTile_Room on room_Room {
  id
  name
  priority
  managementModeName
  originatingItem {
    id
    title
    itemPeople {
      id
      roleName
      person {
        id
        registrantId
      }
    }
  }
  originatingEventId
  events(where: {id: {_eq: $eventId}}) @include(if: $withEvent) {
    ...RoomTile_Event
  }
}
    ${RoomTile_EventFragmentDoc}`;
export const SponsorBoothsList_ItemFragmentDoc = gql`
    fragment SponsorBoothsList_Item on content_Item {
  id
  rooms(
    limit: 1
    order_by: {created_at: asc}
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    id
    priority
  }
  logo: elements(
    where: {typeName: {_in: [IMAGE_URL, IMAGE_FILE]}, layoutData: {_contains: {isLogo: true}}}
    order_by: {updatedAt: desc}
    limit: 1
  ) {
    id
    data
  }
  title
  itemPeople {
    id
    person {
      id
      registrantId
    }
    roleName
  }
}
    `;
export const Schedule_TagFragmentDoc = gql`
    fragment Schedule_Tag on collection_Tag {
  id
  name
  colour
  priority
}
    `;
export const Schedule_EventTagFragmentDoc = gql`
    fragment Schedule_EventTag on schedule_EventTag {
  id
  tag {
    ...Schedule_Tag
  }
}
    ${Schedule_TagFragmentDoc}`;
export const StarredEventFragmentDoc = gql`
    fragment StarredEvent on schedule_StarredEvent {
  id
  eventId
  registrantId
}
    `;
export const Schedule_ProgramPersonFragmentDoc = gql`
    fragment Schedule_ProgramPerson on collection_ProgramPerson {
  id
  name
  affiliation
  registrantId
}
    `;
export const Schedule_ItemPersonFragmentDoc = gql`
    fragment Schedule_ItemPerson on content_ItemProgramPerson {
  id
  personId
  priority
  roleName
}
    `;
export const Schedule_ItemFieldsFragmentDoc = gql`
    fragment Schedule_ItemFields on content_Item {
  id
  title
  shortTitle
  typeName
  itemTags {
    id
    itemId
    tagId
  }
  itemExhibitions {
    id
    itemId
    exhibitionId
  }
  itemPeople {
    ...Schedule_ItemPerson
  }
}
    ${Schedule_ItemPersonFragmentDoc}`;
export const Schedule_ElementFragmentDoc = gql`
    fragment Schedule_Element on content_Element {
  id
  typeName
  name
  layoutData
  data
}
    `;
export const Schedule_ItemFragmentDoc = gql`
    fragment Schedule_Item on content_Item {
  ...Schedule_ItemFields
  abstractElements: elements(
    where: {typeName: {_eq: ABSTRACT}, isHidden: {_eq: false}}
  ) {
    ...Schedule_Element
  }
  itemPeople {
    ...Schedule_ItemPerson
  }
}
    ${Schedule_ItemFieldsFragmentDoc}
${Schedule_ElementFragmentDoc}
${Schedule_ItemPersonFragmentDoc}`;
export const Schedule_EventSummaryFragmentDoc = gql`
    fragment Schedule_EventSummary on schedule_Event {
  id
  roomId
  intendedRoomModeName
  name
  startTime
  durationSeconds
  itemId
  exhibitionId
  shufflePeriodId
}
    `;
export const Schedule_RoomSummaryFragmentDoc = gql`
    fragment Schedule_RoomSummary on room_Room {
  id
  name
  currentModeName
  priority
  managementModeName
}
    `;
export const ScheduleV2_LightweightEventFragmentDoc = gql`
    fragment ScheduleV2_LightweightEvent on schedule_Event {
  id
  startTime
  endTime
  roomId
}
    `;
export const ScheduleV2_ProgramPersonFragmentDoc = gql`
    fragment ScheduleV2_ProgramPerson on collection_ProgramPerson {
  id
  name
  affiliation
  registrantId
}
    `;
export const ScheduleV2_ItemPersonFragmentDoc = gql`
    fragment ScheduleV2_ItemPerson on content_ItemProgramPerson {
  id
  priority
  roleName
  person {
    ...ScheduleV2_ProgramPerson
  }
}
    ${ScheduleV2_ProgramPersonFragmentDoc}`;
export const ScheduleV2_ItemElementsFragmentDoc = gql`
    fragment ScheduleV2_ItemElements on content_Item {
  id
  title
  shortTitle
  typeName
  itemTags {
    id
    itemId
    tagId
  }
  itemPeople {
    ...ScheduleV2_ItemPerson
  }
}
    ${ScheduleV2_ItemPersonFragmentDoc}`;
export const ScheduleV2_ElementFragmentDoc = gql`
    fragment ScheduleV2_Element on content_Element {
  id
  typeName
  name
  layoutData
  data
}
    `;
export const ScheduleV2_EventFragmentDoc = gql`
    fragment ScheduleV2_Event on schedule_Event {
  id
  roomId
  intendedRoomModeName
  name
  startTime
  durationSeconds
  itemId
  exhibitionId
  shufflePeriodId
  item {
    ...ScheduleV2_ItemElements
    abstractElements: elements(
      where: {typeName: {_eq: ABSTRACT}, isHidden: {_eq: false}}
    ) {
      ...ScheduleV2_Element
    }
    itemPeople {
      ...ScheduleV2_ItemPerson
    }
  }
}
    ${ScheduleV2_ItemElementsFragmentDoc}
${ScheduleV2_ElementFragmentDoc}
${ScheduleV2_ItemPersonFragmentDoc}`;
export const ScheduleV2_RoomFragmentDoc = gql`
    fragment ScheduleV2_Room on room_Room {
  id
  name
  priority
}
    `;
export const ScheduleV2_TagFragmentDoc = gql`
    fragment ScheduleV2_Tag on collection_Tag {
  id
  name
  colour
  priority
}
    `;
export const SearchPanel_ItemFragmentDoc = gql`
    fragment SearchPanel_Item on content_Item {
  id
  title
  itemPeople {
    ...ProgramPersonData
  }
  itemTags {
    ...ItemTagData
  }
}
    ${ProgramPersonDataFragmentDoc}
${ItemTagDataFragmentDoc}`;
export const SearchPanel_EventFragmentDoc = gql`
    fragment SearchPanel_Event on schedule_Event {
  id
  startTime
  endTime
  exhibition {
    id
    name
    items {
      id
      item {
        ...SearchPanel_Item
      }
    }
  }
  intendedRoomModeName
  item {
    ...SearchPanel_Item
  }
  name
  roomId
  room {
    id
    name
  }
}
    ${SearchPanel_ItemFragmentDoc}`;
export const SearchPanel_PersonFragmentDoc = gql`
    fragment SearchPanel_Person on collection_ProgramPerson {
  id
  name
  affiliation
  registrantId
  itemPeople {
    id
    item {
      id
      title
    }
  }
}
    `;
export const ConferenceConfiguration_ConferenceConfigurationsFragmentDoc = gql`
    fragment ConferenceConfiguration_ConferenceConfigurations on conference_Configuration {
  conferenceId
  key
  value
}
    `;
export const MonitorLivestreams_PrerecEventFragmentDoc = gql`
    fragment MonitorLivestreams_PrerecEvent on schedule_Event {
  id
  startTime
  room {
    id
    name
    priority
  }
}
    `;
export const MonitorLivestreams_PersonFragmentDoc = gql`
    fragment MonitorLivestreams_Person on schedule_EventProgramPerson {
  id
  roleName
  person {
    id
    name
    affiliation
    registrant {
      id
      userId
    }
  }
}
    `;
export const MonitorLivestreams_EventFragmentDoc = gql`
    fragment MonitorLivestreams_Event on schedule_Event {
  id
  name
  startTime
  endTime
  room {
    id
    name
    priority
  }
  item {
    id
    title
  }
  eventPeople {
    ...MonitorLivestreams_Person
  }
  eventVonageSession {
    id
    sessionId
  }
  participantStreams {
    id
    registrantId
    vonageStreamType
  }
}
    ${MonitorLivestreams_PersonFragmentDoc}`;
export const ChatFlagDataFragmentDoc = gql`
    fragment ChatFlagData on chat_Flag {
  discussionChatId
  flaggedById
  id
  messageSId
  notes
  resolution
  resolved_at
  type
  updated_at
  created_at
}
    `;
export const ChatReactionDataFragmentDoc = gql`
    fragment ChatReactionData on chat_Reaction {
  sId
  data
  senderId
  symbol
  type
  messageSId
  duplicateSId
  created_at
  updated_at
  chatId
}
    `;
export const ChatMessageDataFragmentDoc = gql`
    fragment ChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageSId
  id
  sId
  message
  reactions {
    ...ChatReactionData
  }
  senderId
  type
  chatId
}
    ${ChatReactionDataFragmentDoc}`;
export const ManageModeration_ChatFlagFragmentDoc = gql`
    fragment ManageModeration_ChatFlag on chat_Flag {
  ...ChatFlagData
  message {
    ...ChatMessageData
  }
}
    ${ChatFlagDataFragmentDoc}
${ChatMessageDataFragmentDoc}`;
export const ManageContent_ItemExhibitionFragmentDoc = gql`
    fragment ManageContent_ItemExhibition on content_ItemExhibition {
  id
  conferenceId
  item {
    id
    title
  }
  exhibitionId
  priority
  layout
}
    `;
export const ManageContent_ItemTagFragmentDoc = gql`
    fragment ManageContent_ItemTag on content_ItemTag {
  id
  itemId
  tagId
}
    `;
export const ManageContent_ItemFragmentDoc = gql`
    fragment ManageContent_Item on content_Item {
  id
  conferenceId
  title
  shortTitle
  typeName
  itemTags {
    ...ManageContent_ItemTag
  }
}
    ${ManageContent_ItemTagFragmentDoc}`;
export const ManageContent_RoomFragmentDoc = gql`
    fragment ManageContent_Room on room_Room {
  id
  name
}
    `;
export const ManageContent_OriginatingDataFragmentDoc = gql`
    fragment ManageContent_OriginatingData on conference_OriginatingData {
  id
  conferenceId
  sourceId
  data
}
    `;
export const ManageContent_ItemSecondaryFragmentDoc = gql`
    fragment ManageContent_ItemSecondary on content_Item {
  typeName
  rooms {
    ...ManageContent_Room
  }
  chatId
  originatingData {
    ...ManageContent_OriginatingData
  }
}
    ${ManageContent_RoomFragmentDoc}
${ManageContent_OriginatingDataFragmentDoc}`;
export const ManageContent_ProgramPersonFragmentDoc = gql`
    fragment ManageContent_ProgramPerson on collection_ProgramPersonWithAccessToken {
  id
  name
  affiliation
  email
  registrantId
}
    `;
export const ManageContent_ItemProgramPersonFragmentDoc = gql`
    fragment ManageContent_ItemProgramPerson on content_ItemProgramPerson {
  id
  itemId
  priority
  roleName
  person: personWithAccessToken {
    ...ManageContent_ProgramPerson
  }
}
    ${ManageContent_ProgramPersonFragmentDoc}`;
export const ManageContent_ElementFragmentDoc = gql`
    fragment ManageContent_Element on content_Element {
  id
  itemId
  name
  typeName
  data
  layoutData
  uploadsRemaining
  isHidden
  updatedAt
  conferenceId
}
    `;
export const ManageContent_ItemForExportFragmentDoc = gql`
    fragment ManageContent_ItemForExport on content_Item {
  id
  conferenceId
  title
  shortTitle
  typeName
  originatingDataId
  itemTags {
    id
    tagId
  }
  itemExhibitions {
    id
    exhibitionId
    priority
  }
  rooms {
    id
  }
  chatId
  itemPeople {
    ...ManageContent_ItemProgramPerson
  }
  elements {
    ...ManageContent_Element
  }
}
    ${ManageContent_ItemProgramPersonFragmentDoc}
${ManageContent_ElementFragmentDoc}`;
export const ManageContent_TagFragmentDoc = gql`
    fragment ManageContent_Tag on collection_Tag {
  id
  conferenceId
  name
  colour
  priority
}
    `;
export const ManageContent_ExhibitionFragmentDoc = gql`
    fragment ManageContent_Exhibition on collection_Exhibition {
  id
  conferenceId
  name
  colour
  priority
  isHidden
  descriptiveItemId
  items {
    id
    itemId
  }
}
    `;
export const ProgramPersonInfoFragmentDoc = gql`
    fragment ProgramPersonInfo on collection_ProgramPersonWithAccessToken {
  id
  conferenceId
  name
  affiliation
  email
  originatingDataId
  registrantId
}
    `;
export const ElementInfoFragmentDoc = gql`
    fragment ElementInfo on content_Element {
  conferenceId
  itemId
  typeName
  data
  id
  isHidden
  layoutData
  name
  originatingDataId
  uploadsRemaining
}
    `;
export const ItemTagInfoFragmentDoc = gql`
    fragment ItemTagInfo on content_ItemTag {
  id
  tagId
  itemId
}
    `;
export const ItemExhibitionInfoFragmentDoc = gql`
    fragment ItemExhibitionInfo on content_ItemExhibition {
  id
  itemId
  exhibitionId
  conferenceId
  priority
  layout
}
    `;
export const ItemPersonInfoFragmentDoc = gql`
    fragment ItemPersonInfo on content_ItemProgramPerson {
  id
  conferenceId
  itemId
  personId
  priority
  roleName
}
    `;
export const ItemFullNestedInfoFragmentDoc = gql`
    fragment ItemFullNestedInfo on content_Item {
  id
  conferenceId
  typeName
  title
  shortTitle
  elements {
    ...ElementInfo
  }
  itemTags {
    ...ItemTagInfo
  }
  itemExhibitions {
    ...ItemExhibitionInfo
  }
  itemPeople {
    ...ItemPersonInfo
  }
  originatingDataId
  rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    ${ElementInfoFragmentDoc}
${ItemTagInfoFragmentDoc}
${ItemExhibitionInfoFragmentDoc}
${ItemPersonInfoFragmentDoc}`;
export const TagInfoFragmentDoc = gql`
    fragment TagInfo on collection_Tag {
  id
  conferenceId
  colour
  name
  originatingDataId
  priority
}
    `;
export const ExhibitionInfoFragmentDoc = gql`
    fragment ExhibitionInfo on collection_Exhibition {
  id
  conferenceId
  colour
  name
  priority
  isHidden
}
    `;
export const SelectElements_ElementFragmentDoc = gql`
    fragment SelectElements_Element on content_Element {
  id
  name
  typeName
  itemId
  data
}
    `;
export const SelectElements_ItemFragmentDoc = gql`
    fragment SelectElements_Item on content_Item {
  id
  title
  elements {
    ...SelectElements_Element
  }
}
    ${SelectElements_ElementFragmentDoc}`;
export const ElementSecurity_ElementPgFragmentDoc = gql`
    fragment ElementSecurity_ElementPG on content_ElementPermissionGrant {
  id
  permissionSetId
  conferenceSlug
  groupId
  entityId
}
    `;
export const ElementSecurity_PermissionSetFragmentDoc = gql`
    fragment ElementSecurity_PermissionSet on permissions_Role {
  id
  name
}
    `;
export const ElementSecurity_GroupFragmentDoc = gql`
    fragment ElementSecurity_Group on permissions_Group {
  id
  name
  enabled
  includeUnauthenticated
}
    `;
export const SubmissionRequestsModal_ConferenceConfigurationFragmentDoc = gql`
    fragment SubmissionRequestsModal_ConferenceConfiguration on conference_Configuration {
  conferenceId
  key
  value
}
    `;
export const SubmissionRequestsModal_ItemFragmentDoc = gql`
    fragment SubmissionRequestsModal_Item on content_Item {
  id
  title
  typeName
  hasUnsubmittedElements
  itemPeople {
    id
    personId
    roleName
    hasSubmissionRequestBeenSent
  }
}
    `;
export const SubmissionsReviewModal_ElementFragmentDoc = gql`
    fragment SubmissionsReviewModal_Element on content_Element {
  id
  typeName
  name
  data
}
    `;
export const SubmissionsReviewModal_ItemFragmentDoc = gql`
    fragment SubmissionsReviewModal_Item on content_Item {
  id
  title
  hasUnsubmittedElements
  itemPeople {
    id
    person: personWithAccessToken {
      id
      name
      submissionRequestsSentCount
    }
  }
  elements {
    ...SubmissionsReviewModal_Element
  }
}
    ${SubmissionsReviewModal_ElementFragmentDoc}`;
export const ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc = gql`
    fragment ConfigureEmailTemplates_ConferenceConfiguration on conference_Configuration {
  conferenceId
  key
  value
}
    `;
export const ManageExport_RegistrantGoogleAccountFragmentDoc = gql`
    fragment ManageExport_RegistrantGoogleAccount on registrant_GoogleAccount {
  id
  googleAccountEmail
}
    `;
export const UploadYouTubeVideos_UploadYouTubeVideoJobFragmentDoc = gql`
    fragment UploadYouTubeVideos_UploadYouTubeVideoJob on job_queues_UploadYouTubeVideoJob {
  id
  jobStatusName
  element {
    id
    item {
      id
      title
    }
    name
  }
}
    `;
export const UploadYouTubeVideos_ElementFragmentDoc = gql`
    fragment UploadYouTubeVideos_Element on content_Element {
  id
  data
}
    `;
export const UploadYouTubeVideos_YouTubeUploadFragmentDoc = gql`
    fragment UploadYouTubeVideos_YouTubeUpload on video_YouTubeUpload {
  id
  videoId
  videoPrivacyStatus
  videoStatus
  videoTitle
  element {
    id
    name
    item {
      id
      title
    }
  }
}
    `;
export const ManageGroups_GroupFragmentDoc = gql`
    fragment ManageGroups_Group on permissions_Group {
  conferenceId
  enabled
  id
  includeUnauthenticated
  name
  groupRoles {
    id
    roleId
    groupId
  }
}
    `;
export const ManageProgramPeople_RegistrantFragmentDoc = gql`
    fragment ManageProgramPeople_Registrant on registrant_Registrant {
  id
  displayName
  invitation {
    id
    invitedEmailAddress
  }
  profile {
    registrantId
    affiliation
  }
}
    `;
export const ManageProgramPeople_ProgramPersonWithAccessTokenFragmentDoc = gql`
    fragment ManageProgramPeople_ProgramPersonWithAccessToken on collection_ProgramPersonWithAccessToken {
  id
  conferenceId
  name
  affiliation
  email
  originatingDataId
  registrantId
  accessToken
}
    `;
export const RoomParticipantWithRegistrantInfoFragmentDoc = gql`
    fragment RoomParticipantWithRegistrantInfo on room_Participant {
  id
  conferenceId
  registrantId
  roomId
  registrant {
    id
    displayName
  }
}
    `;
export const OriginatingDataInfoFragmentDoc = gql`
    fragment OriginatingDataInfo on conference_OriginatingData {
  id
  conferenceId
  sourceId
  data
}
    `;
export const RoomWithParticipantInfoFragmentDoc = gql`
    fragment RoomWithParticipantInfo on room_Room {
  id
  created_at
  conferenceId
  name
  currentModeName
  capacity
  priority
  originatingEventId
  originatingItemId
  managementModeName
  isProgramRoom
  participants {
    ...RoomParticipantWithRegistrantInfo
  }
  originatingData {
    ...OriginatingDataInfo
  }
  chat {
    id
    enableMandatoryPin
    enableMandatorySubscribe
    enableAutoPin
    enableAutoSubscribe
  }
}
    ${RoomParticipantWithRegistrantInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}`;
export const RoomPersonInfoFragmentDoc = gql`
    fragment RoomPersonInfo on room_RoomPerson {
  id
  registrant {
    id
    displayName
  }
  personRoleName
}
    `;
export const InvitationPartsFragmentDoc = gql`
    fragment InvitationParts on registrant_Invitation {
  registrantId
  id
  inviteCode
  invitedEmailAddress
  linkToUserId
  createdAt
  updatedAt
  hash
}
    `;
export const RegistrantPartsFragmentDoc = gql`
    fragment RegistrantParts on registrant_Registrant {
  conferenceId
  id
  groupRegistrants {
    registrantId
    id
    groupId
  }
  invitation {
    ...InvitationParts
  }
  userId
  updatedAt
  createdAt
  displayName
  inviteSent
}
    ${InvitationPartsFragmentDoc}`;
export const ManageRegistrants_ProfileFragmentDoc = gql`
    fragment ManageRegistrants_Profile on registrant_Profile {
  registrantId
  badges
  affiliation
  country
  timezoneUTCOffset
  bio
  website
  github
  twitter
  affiliationURL
  pronouns
  photoURL_50x50
  photoURL_350x350
  hasBeenEdited
}
    `;
export const AddEventPeople_ItemPersonFragmentDoc = gql`
    fragment AddEventPeople_ItemPerson on content_ItemProgramPerson {
  id
  itemId
  personId
  roleName
}
    `;
export const AddEventPeople_ProgramPersonFragmentDoc = gql`
    fragment AddEventPeople_ProgramPerson on collection_ProgramPersonWithAccessToken {
  id
  name
  affiliation
  email
  registrantId
}
    `;
export const AddEventPeople_RegistrantFragmentDoc = gql`
    fragment AddEventPeople_Registrant on registrant_Registrant {
  id
  displayName
  profile {
    registrantId
    affiliation
  }
  invitation {
    id
    invitedEmailAddress
  }
}
    `;
export const AddEventPeople_GroupFragmentDoc = gql`
    fragment AddEventPeople_Group on permissions_Group {
  id
  name
}
    `;
export const ContinuationsEditor_ContinuationFragmentDoc = gql`
    fragment ContinuationsEditor_Continuation on schedule_Continuation {
  id
  fromEvent
  fromShuffleQueue
  to
  defaultFor
  isActiveChoice
  priority
  colour
  description
}
    `;
export const ShufflePeriodInfoFragmentDoc = gql`
    fragment ShufflePeriodInfo on room_ShufflePeriod {
  id
  name
}
    `;
export const RoomParticipantInfoFragmentDoc = gql`
    fragment RoomParticipantInfo on room_Participant {
  registrantId
  conferenceId
  id
  roomId
}
    `;
export const RoomInfoFragmentDoc = gql`
    fragment RoomInfo on room_Room {
  capacity
  conferenceId
  currentModeName
  id
  name
  priority
  originatingDataId
  originatingEventId
  originatingItemId
  managementModeName
  isProgramRoom
  originatingData {
    ...OriginatingDataInfo
  }
  participants {
    ...RoomParticipantInfo
  }
}
    ${OriginatingDataInfoFragmentDoc}
${RoomParticipantInfoFragmentDoc}`;
export const EventProgramPersonInfoFragmentDoc = gql`
    fragment EventProgramPersonInfo on schedule_EventProgramPerson {
  id
  eventId
  roleName
  personId
}
    `;
export const EventTagInfoFragmentDoc = gql`
    fragment EventTagInfo on schedule_EventTag {
  eventId
  id
  tagId
}
    `;
export const EventInfoFragmentDoc = gql`
    fragment EventInfo on schedule_Event {
  conferenceId
  id
  durationSeconds
  eventPeople {
    ...EventProgramPersonInfo
  }
  eventTags {
    ...EventTagInfo
  }
  id
  intendedRoomModeName
  name
  originatingDataId
  roomId
  startTime
  endTime
  itemId
  exhibitionId
  shufflePeriodId
  enableRecording
}
    ${EventProgramPersonInfoFragmentDoc}
${EventTagInfoFragmentDoc}`;
export const ManageShufflePeriods_ShufflePeriodFragmentDoc = gql`
    fragment ManageShufflePeriods_ShufflePeriod on room_ShufflePeriod {
  id
  created_at
  updated_at
  conferenceId
  startAt
  endAt
  roomDurationMinutes
  targetRegistrantsPerRoom
  maxRegistrantsPerRoom
  waitRoomMaxDurationSeconds
  name
  organiserId
  algorithm
  completedEntries: queueEntries_aggregate(
    where: {shuffleRoom: {isEnded: {_eq: true}}}
  ) {
    aggregate {
      count
    }
  }
  ongoingEntries: queueEntries_aggregate(
    where: {shuffleRoom: {isEnded: {_eq: false}}}
  ) {
    aggregate {
      count
    }
  }
  waitingEntries: queueEntries_aggregate(
    where: {allocatedShuffleRoomId: {_is_null: true}, isExpired: {_eq: false}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const ProfileDataFragmentDoc = gql`
    fragment ProfileData on registrant_Profile {
  registrantId
  badges
  affiliation
  affiliationURL
  country
  timezoneUTCOffset
  bio
  website
  github
  twitter
  pronouns
  photoURL_50x50
  photoURL_350x350
  hasBeenEdited
}
    `;
export const RegistrantDataFragmentDoc = gql`
    fragment RegistrantData on registrant_Registrant {
  id
  userId
  conferenceId
  displayName
  profile {
    ...ProfileData
  }
}
    ${ProfileDataFragmentDoc}`;
export const GroupDataFragmentDoc = gql`
    fragment GroupData on permissions_Group {
  groupRoles {
    role {
      rolePermissions {
        permissionName
        id
        roleId
      }
      id
      name
      conferenceId
    }
    id
    roleId
    groupId
  }
  enabled
  id
  includeUnauthenticated
  name
  conferenceId
}
    `;
export const AuthdConferenceInfoFragmentDoc = gql`
    fragment AuthdConferenceInfo on conference_Conference {
  registrants(where: {userId: {_eq: $userId}}) {
    ...RegistrantData
    groupRegistrants {
      group {
        ...GroupData
      }
      id
      groupId
      registrantId
    }
  }
}
    ${RegistrantDataFragmentDoc}
${GroupDataFragmentDoc}`;
export const PublicConferenceInfoFragmentDoc = gql`
    fragment PublicConferenceInfo on conference_Conference {
  id
  name
  shortName
  slug
  createdBy
  supportAddress: configurations(where: {key: {_eq: SUPPORT_ADDRESS}}) {
    conferenceId
    key
    value
  }
  registrationURL: configurations(where: {key: {_eq: REGISTRATION_URL}}) {
    conferenceId
    key
    value
  }
  scheduleViewVersion: configurations(where: {key: {_eq: SCHEDULE_VIEW_VERSION}}) {
    conferenceId
    key
    value
  }
  sponsorsLabel: configurations(where: {key: {_eq: SPONSORS_LABEL}}) {
    conferenceId
    key
    value
  }
  disableNearbyEvents: configurations(where: {key: {_eq: DISABLE_NEARBY_EVENTS}}) {
    conferenceId
    key
    value
  }
  publicGroups: groups(
    where: {enabled: {_eq: true}, includeUnauthenticated: {_eq: true}}
  ) {
    ...GroupData
  }
}
    ${GroupDataFragmentDoc}`;
export const MinimalEventInfoFragmentDoc = gql`
    fragment MinimalEventInfo on schedule_Event {
  id
  startTime
  endTime
  room {
    id
    name
  }
}
    `;
export const MenuSchedule_EventFragmentDoc = gql`
    fragment MenuSchedule_Event on schedule_Event {
  id
  name
  startTime
  room {
    id
    name
  }
  eventTags {
    tag {
      id
      colour
      name
    }
  }
  item {
    id
    title
  }
}
    `;
export const MainMenuSponsors_ItemDataFragmentDoc = gql`
    fragment MainMenuSponsors_ItemData on content_Item {
  id
  rooms(
    limit: 1
    order_by: {created_at: asc}
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    id
    priority
  }
  logo: elements(
    where: {typeName: {_in: [IMAGE_URL, IMAGE_FILE]}, layoutData: {_contains: {isLogo: true}}}
    order_by: {updatedAt: desc}
    limit: 1
  ) {
    id
    data
  }
  title
  shortTitle
  itemPeople {
    id
    person {
      id
      registrantId
    }
    roleName
  }
}
    `;
export const RoomMemberFragmentDoc = gql`
    fragment RoomMember on room_RoomPerson {
  id
  roomId
  personRoleName
  registrantId
}
    `;
export const RoomParticipantDetailsFragmentDoc = gql`
    fragment RoomParticipantDetails on room_Participant {
  conferenceId
  id
  roomId
  registrantId
}
    `;
export const SubdShuffleQueueEntryDataFragmentDoc = gql`
    fragment SubdShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  isExpired
  shuffleRoom {
    id
    roomId
  }
}
    `;
export const RegistrantFieldsFragmentDoc = gql`
    fragment RegistrantFields on registrant_Registrant {
  id
  userId
  conferenceId
  displayName
  createdAt
  updatedAt
  profile {
    registrantId
    photoURL_50x50
  }
  conference {
    id
    name
    shortName
    slug
  }
  groupRegistrants {
    id
    group {
      id
      enabled
      name
      groupRoles {
        id
        role {
          id
          name
          rolePermissions {
            id
            permissionName
          }
        }
      }
    }
  }
}
    `;
export const UserInfoFragmentDoc = gql`
    fragment UserInfo on User {
  id
  email
  acceptedTermsAt
  acceptedPrivacyPolicyAt
  registrants {
    ...RegistrantFields
  }
}
    ${RegistrantFieldsFragmentDoc}`;
export const GetSlugForUrlDocument = gql`
    query GetSlugForUrl($url: String!) {
  getSlug(url: $url) {
    slug
  }
}
    `;

/**
 * __useGetSlugForUrlQuery__
 *
 * To run a query within a React component, call `useGetSlugForUrlQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSlugForUrlQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSlugForUrlQuery({
 *   variables: {
 *      url: // value for 'url'
 *   },
 * });
 */
export function useGetSlugForUrlQuery(baseOptions: Apollo.QueryHookOptions<GetSlugForUrlQuery, GetSlugForUrlQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSlugForUrlQuery, GetSlugForUrlQueryVariables>(GetSlugForUrlDocument, options);
      }
export function useGetSlugForUrlLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSlugForUrlQuery, GetSlugForUrlQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSlugForUrlQuery, GetSlugForUrlQueryVariables>(GetSlugForUrlDocument, options);
        }
export type GetSlugForUrlQueryHookResult = ReturnType<typeof useGetSlugForUrlQuery>;
export type GetSlugForUrlLazyQueryHookResult = ReturnType<typeof useGetSlugForUrlLazyQuery>;
export type GetSlugForUrlQueryResult = Apollo.QueryResult<GetSlugForUrlQuery, GetSlugForUrlQueryVariables>;
export const InitialChatStateDocument = gql`
    query InitialChatState($registrantId: uuid!) {
  chat_Pin(where: {registrantId: {_eq: $registrantId}}) {
    chatId
    registrantId
    chat {
      ...InitialChatState_Chat
    }
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useInitialChatStateQuery__
 *
 * To run a query within a React component, call `useInitialChatStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useInitialChatStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInitialChatStateQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useInitialChatStateQuery(baseOptions: Apollo.QueryHookOptions<InitialChatStateQuery, InitialChatStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InitialChatStateQuery, InitialChatStateQueryVariables>(InitialChatStateDocument, options);
      }
export function useInitialChatStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InitialChatStateQuery, InitialChatStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InitialChatStateQuery, InitialChatStateQueryVariables>(InitialChatStateDocument, options);
        }
export type InitialChatStateQueryHookResult = ReturnType<typeof useInitialChatStateQuery>;
export type InitialChatStateLazyQueryHookResult = ReturnType<typeof useInitialChatStateLazyQuery>;
export type InitialChatStateQueryResult = Apollo.QueryResult<InitialChatStateQuery, InitialChatStateQueryVariables>;
export const SelectInitialChatStateDocument = gql`
    query SelectInitialChatState($chatId: uuid!, $registrantId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    ...InitialChatState_Chat
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useSelectInitialChatStateQuery__
 *
 * To run a query within a React component, call `useSelectInitialChatStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInitialChatStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInitialChatStateQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useSelectInitialChatStateQuery(baseOptions: Apollo.QueryHookOptions<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>(SelectInitialChatStateDocument, options);
      }
export function useSelectInitialChatStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>(SelectInitialChatStateDocument, options);
        }
export type SelectInitialChatStateQueryHookResult = ReturnType<typeof useSelectInitialChatStateQuery>;
export type SelectInitialChatStateLazyQueryHookResult = ReturnType<typeof useSelectInitialChatStateLazyQuery>;
export type SelectInitialChatStateQueryResult = Apollo.QueryResult<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>;
export const SelectInitialChatStatesDocument = gql`
    query SelectInitialChatStates($chatIds: [uuid!]!, $registrantId: uuid!) {
  chat_Chat(where: {id: {_in: $chatIds}}) {
    ...InitialChatState_Chat
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useSelectInitialChatStatesQuery__
 *
 * To run a query within a React component, call `useSelectInitialChatStatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInitialChatStatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInitialChatStatesQuery({
 *   variables: {
 *      chatIds: // value for 'chatIds'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useSelectInitialChatStatesQuery(baseOptions: Apollo.QueryHookOptions<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>(SelectInitialChatStatesDocument, options);
      }
export function useSelectInitialChatStatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>(SelectInitialChatStatesDocument, options);
        }
export type SelectInitialChatStatesQueryHookResult = ReturnType<typeof useSelectInitialChatStatesQuery>;
export type SelectInitialChatStatesLazyQueryHookResult = ReturnType<typeof useSelectInitialChatStatesLazyQuery>;
export type SelectInitialChatStatesQueryResult = Apollo.QueryResult<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>;
export const SubscribeChatDocument = gql`
    mutation SubscribeChat($chatId: uuid!, $registrantId: uuid!) {
  insert_chat_Subscription(
    objects: {chatId: $chatId, registrantId: $registrantId}
    on_conflict: {constraint: Subscription_pkey, update_columns: wasManuallySubscribed}
  ) {
    returning {
      chatId
      registrantId
    }
  }
}
    `;
export type SubscribeChatMutationFn = Apollo.MutationFunction<SubscribeChatMutation, SubscribeChatMutationVariables>;

/**
 * __useSubscribeChatMutation__
 *
 * To run a mutation, you first call `useSubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [subscribeChatMutation, { data, loading, error }] = useSubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useSubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<SubscribeChatMutation, SubscribeChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubscribeChatMutation, SubscribeChatMutationVariables>(SubscribeChatDocument, options);
      }
export type SubscribeChatMutationHookResult = ReturnType<typeof useSubscribeChatMutation>;
export type SubscribeChatMutationResult = Apollo.MutationResult<SubscribeChatMutation>;
export type SubscribeChatMutationOptions = Apollo.BaseMutationOptions<SubscribeChatMutation, SubscribeChatMutationVariables>;
export const UnsubscribeChatDocument = gql`
    mutation UnsubscribeChat($chatId: uuid!, $registrantId: uuid!) {
  delete_chat_Subscription_by_pk(chatId: $chatId, registrantId: $registrantId) {
    registrantId
    chatId
  }
}
    `;
export type UnsubscribeChatMutationFn = Apollo.MutationFunction<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;

/**
 * __useUnsubscribeChatMutation__
 *
 * To run a mutation, you first call `useUnsubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnsubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unsubscribeChatMutation, { data, loading, error }] = useUnsubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUnsubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>(UnsubscribeChatDocument, options);
      }
export type UnsubscribeChatMutationHookResult = ReturnType<typeof useUnsubscribeChatMutation>;
export type UnsubscribeChatMutationResult = Apollo.MutationResult<UnsubscribeChatMutation>;
export type UnsubscribeChatMutationOptions = Apollo.BaseMutationOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;
export const PinChatDocument = gql`
    mutation PinChat($chatId: uuid!, $registrantId: uuid!) {
  insert_chat_Pin(
    objects: {chatId: $chatId, registrantId: $registrantId}
    on_conflict: {constraint: ChatPin_pkey, update_columns: wasManuallyPinned}
  ) {
    returning {
      chatId
      registrantId
    }
  }
}
    `;
export type PinChatMutationFn = Apollo.MutationFunction<PinChatMutation, PinChatMutationVariables>;

/**
 * __usePinChatMutation__
 *
 * To run a mutation, you first call `usePinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [pinChatMutation, { data, loading, error }] = usePinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function usePinChatMutation(baseOptions?: Apollo.MutationHookOptions<PinChatMutation, PinChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PinChatMutation, PinChatMutationVariables>(PinChatDocument, options);
      }
export type PinChatMutationHookResult = ReturnType<typeof usePinChatMutation>;
export type PinChatMutationResult = Apollo.MutationResult<PinChatMutation>;
export type PinChatMutationOptions = Apollo.BaseMutationOptions<PinChatMutation, PinChatMutationVariables>;
export const UnpinChatDocument = gql`
    mutation UnpinChat($chatId: uuid!, $registrantId: uuid!) {
  delete_chat_Pin_by_pk(chatId: $chatId, registrantId: $registrantId) {
    registrantId
    chatId
  }
}
    `;
export type UnpinChatMutationFn = Apollo.MutationFunction<UnpinChatMutation, UnpinChatMutationVariables>;

/**
 * __useUnpinChatMutation__
 *
 * To run a mutation, you first call `useUnpinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpinChatMutation, { data, loading, error }] = useUnpinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUnpinChatMutation(baseOptions?: Apollo.MutationHookOptions<UnpinChatMutation, UnpinChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnpinChatMutation, UnpinChatMutationVariables>(UnpinChatDocument, options);
      }
export type UnpinChatMutationHookResult = ReturnType<typeof useUnpinChatMutation>;
export type UnpinChatMutationResult = Apollo.MutationResult<UnpinChatMutation>;
export type UnpinChatMutationOptions = Apollo.BaseMutationOptions<UnpinChatMutation, UnpinChatMutationVariables>;
export const SelectMessagesPageDocument = gql`
    query SelectMessagesPage($chatId: uuid!, $startAtIndex: Int!, $maxCount: Int!) {
  chat_Message(
    order_by: {id: desc}
    where: {chatId: {_eq: $chatId}, id: {_lte: $startAtIndex}, type: {_neq: EMOTE}}
    limit: $maxCount
  ) {
    ...ChatMessageData
  }
}
    ${ChatMessageDataFragmentDoc}`;

/**
 * __useSelectMessagesPageQuery__
 *
 * To run a query within a React component, call `useSelectMessagesPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectMessagesPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectMessagesPageQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      startAtIndex: // value for 'startAtIndex'
 *      maxCount: // value for 'maxCount'
 *   },
 * });
 */
export function useSelectMessagesPageQuery(baseOptions: Apollo.QueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, options);
      }
export function useSelectMessagesPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, options);
        }
export type SelectMessagesPageQueryHookResult = ReturnType<typeof useSelectMessagesPageQuery>;
export type SelectMessagesPageLazyQueryHookResult = ReturnType<typeof useSelectMessagesPageLazyQuery>;
export type SelectMessagesPageQueryResult = Apollo.QueryResult<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>;
export const InsertChatFlagDocument = gql`
    mutation InsertChatFlag($messageSId: uuid!, $registrantId: uuid!, $type: chat_FlagType_enum!, $reason: String!) {
  insert_chat_Flag_one(
    object: {messageSId: $messageSId, flaggedById: $registrantId, type: $type, notes: $reason}
  ) {
    ...ChatFlagData
  }
}
    ${ChatFlagDataFragmentDoc}`;
export type InsertChatFlagMutationFn = Apollo.MutationFunction<InsertChatFlagMutation, InsertChatFlagMutationVariables>;

/**
 * __useInsertChatFlagMutation__
 *
 * To run a mutation, you first call `useInsertChatFlagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertChatFlagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertChatFlagMutation, { data, loading, error }] = useInsertChatFlagMutation({
 *   variables: {
 *      messageSId: // value for 'messageSId'
 *      registrantId: // value for 'registrantId'
 *      type: // value for 'type'
 *      reason: // value for 'reason'
 *   },
 * });
 */
export function useInsertChatFlagMutation(baseOptions?: Apollo.MutationHookOptions<InsertChatFlagMutation, InsertChatFlagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertChatFlagMutation, InsertChatFlagMutationVariables>(InsertChatFlagDocument, options);
      }
export type InsertChatFlagMutationHookResult = ReturnType<typeof useInsertChatFlagMutation>;
export type InsertChatFlagMutationResult = Apollo.MutationResult<InsertChatFlagMutation>;
export type InsertChatFlagMutationOptions = Apollo.BaseMutationOptions<InsertChatFlagMutation, InsertChatFlagMutationVariables>;
export const GetChatPathDocument = gql`
    query GetChatPath($chatId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    id
    rooms {
      id
    }
    items {
      id
    }
  }
}
    `;

/**
 * __useGetChatPathQuery__
 *
 * To run a query within a React component, call `useGetChatPathQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChatPathQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChatPathQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useGetChatPathQuery(baseOptions: Apollo.QueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, options);
      }
export function useGetChatPathLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, options);
        }
export type GetChatPathQueryHookResult = ReturnType<typeof useGetChatPathQuery>;
export type GetChatPathLazyQueryHookResult = ReturnType<typeof useGetChatPathLazyQuery>;
export type GetChatPathQueryResult = Apollo.QueryResult<GetChatPathQuery, GetChatPathQueryVariables>;
export const ConferenceLandingPageItemDocument = gql`
    query ConferenceLandingPageItem($conferenceId: uuid!) {
  content_Item(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {typeName: {_eq: LANDING_PAGE}}]}
  ) {
    ...ItemElements_ItemData
  }
}
    ${ItemElements_ItemDataFragmentDoc}`;

/**
 * __useConferenceLandingPageItemQuery__
 *
 * To run a query within a React component, call `useConferenceLandingPageItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceLandingPageItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceLandingPageItemQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferenceLandingPageItemQuery(baseOptions: Apollo.QueryHookOptions<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>(ConferenceLandingPageItemDocument, options);
      }
export function useConferenceLandingPageItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>(ConferenceLandingPageItemDocument, options);
        }
export type ConferenceLandingPageItemQueryHookResult = ReturnType<typeof useConferenceLandingPageItemQuery>;
export type ConferenceLandingPageItemLazyQueryHookResult = ReturnType<typeof useConferenceLandingPageItemLazyQuery>;
export type ConferenceLandingPageItemQueryResult = Apollo.QueryResult<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>;
export const ItemElements_GetItemDocument = gql`
    query ItemElements_GetItem($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    ...ItemElements_ItemData
  }
}
    ${ItemElements_ItemDataFragmentDoc}`;

/**
 * __useItemElements_GetItemQuery__
 *
 * To run a query within a React component, call `useItemElements_GetItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useItemElements_GetItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useItemElements_GetItemQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useItemElements_GetItemQuery(baseOptions: Apollo.QueryHookOptions<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>(ItemElements_GetItemDocument, options);
      }
export function useItemElements_GetItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>(ItemElements_GetItemDocument, options);
        }
export type ItemElements_GetItemQueryHookResult = ReturnType<typeof useItemElements_GetItemQuery>;
export type ItemElements_GetItemLazyQueryHookResult = ReturnType<typeof useItemElements_GetItemLazyQuery>;
export type ItemElements_GetItemQueryResult = Apollo.QueryResult<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>;
export const ContentOfTagDocument = gql`
    query ContentOfTag($id: uuid!) {
  content_ItemTag(where: {tagId: {_eq: $id}}) {
    ...ItemList_ItemTagData
  }
}
    ${ItemList_ItemTagDataFragmentDoc}`;

/**
 * __useContentOfTagQuery__
 *
 * To run a query within a React component, call `useContentOfTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentOfTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentOfTagQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useContentOfTagQuery(baseOptions: Apollo.QueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, options);
      }
export function useContentOfTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, options);
        }
export type ContentOfTagQueryHookResult = ReturnType<typeof useContentOfTagQuery>;
export type ContentOfTagLazyQueryHookResult = ReturnType<typeof useContentOfTagLazyQuery>;
export type ContentOfTagQueryResult = Apollo.QueryResult<ContentOfTagQuery, ContentOfTagQueryVariables>;
export const TagsDocument = gql`
    query Tags($conferenceId: uuid!) {
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ItemList_TagInfo
  }
}
    ${ItemList_TagInfoFragmentDoc}`;

/**
 * __useTagsQuery__
 *
 * To run a query within a React component, call `useTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useTagsQuery(baseOptions: Apollo.QueryHookOptions<TagsQuery, TagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options);
      }
export function useTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TagsQuery, TagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options);
        }
export type TagsQueryHookResult = ReturnType<typeof useTagsQuery>;
export type TagsLazyQueryHookResult = ReturnType<typeof useTagsLazyQuery>;
export type TagsQueryResult = Apollo.QueryResult<TagsQuery, TagsQueryVariables>;
export const GetItemDocument = gql`
    query GetItem($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    ...ItemElements_ItemData
    ...ItemPage_ItemRooms
  }
  schedule_Event(
    where: {_or: [{itemId: {_eq: $itemId}}, {exhibition: {items: {itemId: {_eq: $itemId}}}}]}
  ) {
    ...ItemEvent
  }
}
    ${ItemElements_ItemDataFragmentDoc}
${ItemPage_ItemRoomsFragmentDoc}
${ItemEventFragmentDoc}`;

/**
 * __useGetItemQuery__
 *
 * To run a query within a React component, call `useGetItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetItemQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useGetItemQuery(baseOptions: Apollo.QueryHookOptions<GetItemQuery, GetItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetItemQuery, GetItemQueryVariables>(GetItemDocument, options);
      }
export function useGetItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetItemQuery, GetItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetItemQuery, GetItemQueryVariables>(GetItemDocument, options);
        }
export type GetItemQueryHookResult = ReturnType<typeof useGetItemQuery>;
export type GetItemLazyQueryHookResult = ReturnType<typeof useGetItemLazyQuery>;
export type GetItemQueryResult = Apollo.QueryResult<GetItemQuery, GetItemQueryVariables>;
export const ContinuationChoices_ContinuationsDocument = gql`
    query ContinuationChoices_Continuations($fromId: uuid!, $nowStart: timestamptz, $nowEnd: timestamptz) {
  schedule_Continuation(
    where: {_or: [{fromEvent: {_eq: $fromId}}, {fromShuffleQueue: {_eq: $fromId}}]}
  ) {
    ...ContinuationChoices_Continuation
  }
  room_ShufflePeriod(where: {id: {_eq: $fromId}}) {
    id
    endAt
    roomDurationMinutes
  }
  schedule_Event(
    where: {_or: [{id: {_eq: $fromId}}, {startTime: {_lte: $nowStart}, endTime: {_gte: $nowEnd}, shufflePeriodId: {_eq: $fromId}}]}
  ) {
    id
    roomId
    endTime
  }
}
    ${ContinuationChoices_ContinuationFragmentDoc}`;

/**
 * __useContinuationChoices_ContinuationsQuery__
 *
 * To run a query within a React component, call `useContinuationChoices_ContinuationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useContinuationChoices_ContinuationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContinuationChoices_ContinuationsQuery({
 *   variables: {
 *      fromId: // value for 'fromId'
 *      nowStart: // value for 'nowStart'
 *      nowEnd: // value for 'nowEnd'
 *   },
 * });
 */
export function useContinuationChoices_ContinuationsQuery(baseOptions: Apollo.QueryHookOptions<ContinuationChoices_ContinuationsQuery, ContinuationChoices_ContinuationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContinuationChoices_ContinuationsQuery, ContinuationChoices_ContinuationsQueryVariables>(ContinuationChoices_ContinuationsDocument, options);
      }
export function useContinuationChoices_ContinuationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContinuationChoices_ContinuationsQuery, ContinuationChoices_ContinuationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContinuationChoices_ContinuationsQuery, ContinuationChoices_ContinuationsQueryVariables>(ContinuationChoices_ContinuationsDocument, options);
        }
export type ContinuationChoices_ContinuationsQueryHookResult = ReturnType<typeof useContinuationChoices_ContinuationsQuery>;
export type ContinuationChoices_ContinuationsLazyQueryHookResult = ReturnType<typeof useContinuationChoices_ContinuationsLazyQuery>;
export type ContinuationChoices_ContinuationsQueryResult = Apollo.QueryResult<ContinuationChoices_ContinuationsQuery, ContinuationChoices_ContinuationsQueryVariables>;
export const ContinuationChoices_RoomsDocument = gql`
    query ContinuationChoices_Rooms($ids: [uuid!]!) {
  content_Item(where: {id: {_in: $ids}}) {
    id
    rooms(
      where: {originatingEventId: {_is_null: true}}
      limit: 1
      order_by: {created_at: asc}
    ) {
      id
    }
  }
  schedule_Event(where: {id: {_in: $ids}}) {
    id
    roomId
  }
}
    `;

/**
 * __useContinuationChoices_RoomsQuery__
 *
 * To run a query within a React component, call `useContinuationChoices_RoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useContinuationChoices_RoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContinuationChoices_RoomsQuery({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useContinuationChoices_RoomsQuery(baseOptions: Apollo.QueryHookOptions<ContinuationChoices_RoomsQuery, ContinuationChoices_RoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContinuationChoices_RoomsQuery, ContinuationChoices_RoomsQueryVariables>(ContinuationChoices_RoomsDocument, options);
      }
export function useContinuationChoices_RoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContinuationChoices_RoomsQuery, ContinuationChoices_RoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContinuationChoices_RoomsQuery, ContinuationChoices_RoomsQueryVariables>(ContinuationChoices_RoomsDocument, options);
        }
export type ContinuationChoices_RoomsQueryHookResult = ReturnType<typeof useContinuationChoices_RoomsQuery>;
export type ContinuationChoices_RoomsLazyQueryHookResult = ReturnType<typeof useContinuationChoices_RoomsLazyQuery>;
export type ContinuationChoices_RoomsQueryResult = Apollo.QueryResult<ContinuationChoices_RoomsQuery, ContinuationChoices_RoomsQueryVariables>;
export const SelectExhibitionDocument = gql`
    query SelectExhibition($id: uuid!) {
  collection_Exhibition_by_pk(id: $id) {
    ...ExhibitionWithContent
  }
  schedule_Event(where: {exhibitionId: {_eq: $id}}) {
    ...ItemEvent
  }
}
    ${ExhibitionWithContentFragmentDoc}
${ItemEventFragmentDoc}`;

/**
 * __useSelectExhibitionQuery__
 *
 * To run a query within a React component, call `useSelectExhibitionQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectExhibitionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectExhibitionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSelectExhibitionQuery(baseOptions: Apollo.QueryHookOptions<SelectExhibitionQuery, SelectExhibitionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectExhibitionQuery, SelectExhibitionQueryVariables>(SelectExhibitionDocument, options);
      }
export function useSelectExhibitionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectExhibitionQuery, SelectExhibitionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectExhibitionQuery, SelectExhibitionQueryVariables>(SelectExhibitionDocument, options);
        }
export type SelectExhibitionQueryHookResult = ReturnType<typeof useSelectExhibitionQuery>;
export type SelectExhibitionLazyQueryHookResult = ReturnType<typeof useSelectExhibitionLazyQuery>;
export type SelectExhibitionQueryResult = Apollo.QueryResult<SelectExhibitionQuery, SelectExhibitionQueryVariables>;
export const SelectAllExhibitionsDocument = gql`
    query SelectAllExhibitions($conferenceId: uuid!) {
  collection_Exhibition(
    where: {conferenceId: {_eq: $conferenceId}, isHidden: {_eq: false}}
  ) {
    ...ExhibitionSummary
  }
}
    ${ExhibitionSummaryFragmentDoc}`;

/**
 * __useSelectAllExhibitionsQuery__
 *
 * To run a query within a React component, call `useSelectAllExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllExhibitionsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>(SelectAllExhibitionsDocument, options);
      }
export function useSelectAllExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>(SelectAllExhibitionsDocument, options);
        }
export type SelectAllExhibitionsQueryHookResult = ReturnType<typeof useSelectAllExhibitionsQuery>;
export type SelectAllExhibitionsLazyQueryHookResult = ReturnType<typeof useSelectAllExhibitionsLazyQuery>;
export type SelectAllExhibitionsQueryResult = Apollo.QueryResult<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>;
export const RegistrantByIdDocument = gql`
    query RegistrantById($conferenceId: uuid!, $registrantId: uuid!) {
  registrant_Registrant(
    where: {id: {_eq: $registrantId}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useRegistrantByIdQuery__
 *
 * To run a query within a React component, call `useRegistrantByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useRegistrantByIdQuery(baseOptions: Apollo.QueryHookOptions<RegistrantByIdQuery, RegistrantByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantByIdQuery, RegistrantByIdQueryVariables>(RegistrantByIdDocument, options);
      }
export function useRegistrantByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantByIdQuery, RegistrantByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantByIdQuery, RegistrantByIdQueryVariables>(RegistrantByIdDocument, options);
        }
export type RegistrantByIdQueryHookResult = ReturnType<typeof useRegistrantByIdQuery>;
export type RegistrantByIdLazyQueryHookResult = ReturnType<typeof useRegistrantByIdLazyQuery>;
export type RegistrantByIdQueryResult = Apollo.QueryResult<RegistrantByIdQuery, RegistrantByIdQueryVariables>;
export const UpdateProfileDocument = gql`
    mutation UpdateProfile($registrantId: uuid!, $profile: registrant_Profile_set_input = {}) {
  update_registrant_Profile_by_pk(
    pk_columns: {registrantId: $registrantId}
    _set: $profile
  ) {
    ...ProfileData
  }
}
    ${ProfileDataFragmentDoc}`;
export type UpdateProfileMutationFn = Apollo.MutationFunction<UpdateProfileMutation, UpdateProfileMutationVariables>;

/**
 * __useUpdateProfileMutation__
 *
 * To run a mutation, you first call `useUpdateProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProfileMutation, { data, loading, error }] = useUpdateProfileMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      profile: // value for 'profile'
 *   },
 * });
 */
export function useUpdateProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProfileMutation, UpdateProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProfileMutation, UpdateProfileMutationVariables>(UpdateProfileDocument, options);
      }
export type UpdateProfileMutationHookResult = ReturnType<typeof useUpdateProfileMutation>;
export type UpdateProfileMutationResult = Apollo.MutationResult<UpdateProfileMutation>;
export type UpdateProfileMutationOptions = Apollo.BaseMutationOptions<UpdateProfileMutation, UpdateProfileMutationVariables>;
export const UpdateRegistrantDisplayNameDocument = gql`
    mutation UpdateRegistrantDisplayName($registrantId: uuid!, $name: String!) {
  update_registrant_Registrant_by_pk(
    pk_columns: {id: $registrantId}
    _set: {displayName: $name}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;
export type UpdateRegistrantDisplayNameMutationFn = Apollo.MutationFunction<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>;

/**
 * __useUpdateRegistrantDisplayNameMutation__
 *
 * To run a mutation, you first call `useUpdateRegistrantDisplayNameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRegistrantDisplayNameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRegistrantDisplayNameMutation, { data, loading, error }] = useUpdateRegistrantDisplayNameMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateRegistrantDisplayNameMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>(UpdateRegistrantDisplayNameDocument, options);
      }
export type UpdateRegistrantDisplayNameMutationHookResult = ReturnType<typeof useUpdateRegistrantDisplayNameMutation>;
export type UpdateRegistrantDisplayNameMutationResult = Apollo.MutationResult<UpdateRegistrantDisplayNameMutation>;
export type UpdateRegistrantDisplayNameMutationOptions = Apollo.BaseMutationOptions<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>;
export const SubmitProfilePhotoDocument = gql`
    mutation SubmitProfilePhoto($registrantId: uuid!, $s3URL: String!) {
  updateProfilePhoto(registrantId: $registrantId, s3URL: $s3URL) {
    ok
    photoURL_350x350
    photoURL_50x50
  }
}
    `;
export type SubmitProfilePhotoMutationFn = Apollo.MutationFunction<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;

/**
 * __useSubmitProfilePhotoMutation__
 *
 * To run a mutation, you first call `useSubmitProfilePhotoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitProfilePhotoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitProfilePhotoMutation, { data, loading, error }] = useSubmitProfilePhotoMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      s3URL: // value for 's3URL'
 *   },
 * });
 */
export function useSubmitProfilePhotoMutation(baseOptions?: Apollo.MutationHookOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>(SubmitProfilePhotoDocument, options);
      }
export type SubmitProfilePhotoMutationHookResult = ReturnType<typeof useSubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationResult = Apollo.MutationResult<SubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationOptions = Apollo.BaseMutationOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;
export const RegistrantEventsWithBackstagesDocument = gql`
    query RegistrantEventsWithBackstages($registrantId: uuid!) {
  schedule_Event(
    where: {eventPeople: {person: {registrantId: {_eq: $registrantId}}}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, room: {}}
  ) {
    ...MyBackstages_Event
  }
}
    ${MyBackstages_EventFragmentDoc}`;

/**
 * __useRegistrantEventsWithBackstagesQuery__
 *
 * To run a query within a React component, call `useRegistrantEventsWithBackstagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantEventsWithBackstagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantEventsWithBackstagesQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useRegistrantEventsWithBackstagesQuery(baseOptions: Apollo.QueryHookOptions<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>(RegistrantEventsWithBackstagesDocument, options);
      }
export function useRegistrantEventsWithBackstagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>(RegistrantEventsWithBackstagesDocument, options);
        }
export type RegistrantEventsWithBackstagesQueryHookResult = ReturnType<typeof useRegistrantEventsWithBackstagesQuery>;
export type RegistrantEventsWithBackstagesLazyQueryHookResult = ReturnType<typeof useRegistrantEventsWithBackstagesLazyQuery>;
export type RegistrantEventsWithBackstagesQueryResult = Apollo.QueryResult<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>;
export const ProfilePage_ItemsDocument = gql`
    query ProfilePage_Items($registrantId: uuid!) {
  content_Item(
    where: {itemPeople: {person: {registrantId: {_eq: $registrantId}}}}
  ) {
    ...SearchPanel_Item
  }
}
    ${SearchPanel_ItemFragmentDoc}`;

/**
 * __useProfilePage_ItemsQuery__
 *
 * To run a query within a React component, call `useProfilePage_ItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useProfilePage_ItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProfilePage_ItemsQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useProfilePage_ItemsQuery(baseOptions: Apollo.QueryHookOptions<ProfilePage_ItemsQuery, ProfilePage_ItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProfilePage_ItemsQuery, ProfilePage_ItemsQueryVariables>(ProfilePage_ItemsDocument, options);
      }
export function useProfilePage_ItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProfilePage_ItemsQuery, ProfilePage_ItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProfilePage_ItemsQuery, ProfilePage_ItemsQueryVariables>(ProfilePage_ItemsDocument, options);
        }
export type ProfilePage_ItemsQueryHookResult = ReturnType<typeof useProfilePage_ItemsQuery>;
export type ProfilePage_ItemsLazyQueryHookResult = ReturnType<typeof useProfilePage_ItemsLazyQuery>;
export type ProfilePage_ItemsQueryResult = Apollo.QueryResult<ProfilePage_ItemsQuery, ProfilePage_ItemsQueryVariables>;
export const MyRecordingsDocument = gql`
    query MyRecordings($registrantId: uuid!) {
  registrant_SavedVonageRoomRecording(
    where: {registrantId: {_eq: $registrantId}}
    order_by: {recording: {endedAt: desc}}
  ) {
    id
    recording {
      id
      room {
        id
        name
      }
      startedAt
      endedAt
      s3Url
    }
  }
}
    `;

/**
 * __useMyRecordingsQuery__
 *
 * To run a query within a React component, call `useMyRecordingsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyRecordingsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyRecordingsQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useMyRecordingsQuery(baseOptions: Apollo.QueryHookOptions<MyRecordingsQuery, MyRecordingsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyRecordingsQuery, MyRecordingsQueryVariables>(MyRecordingsDocument, options);
      }
export function useMyRecordingsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyRecordingsQuery, MyRecordingsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyRecordingsQuery, MyRecordingsQueryVariables>(MyRecordingsDocument, options);
        }
export type MyRecordingsQueryHookResult = ReturnType<typeof useMyRecordingsQuery>;
export type MyRecordingsLazyQueryHookResult = ReturnType<typeof useMyRecordingsLazyQuery>;
export type MyRecordingsQueryResult = Apollo.QueryResult<MyRecordingsQuery, MyRecordingsQueryVariables>;
export const SelectRegistrantsDocument = gql`
    query SelectRegistrants($conferenceId: uuid!) {
  registrant_Registrant(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {displayName: asc}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useSelectRegistrantsQuery__
 *
 * To run a query within a React component, call `useSelectRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>(SelectRegistrantsDocument, options);
      }
export function useSelectRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>(SelectRegistrantsDocument, options);
        }
export type SelectRegistrantsQueryHookResult = ReturnType<typeof useSelectRegistrantsQuery>;
export type SelectRegistrantsLazyQueryHookResult = ReturnType<typeof useSelectRegistrantsLazyQuery>;
export type SelectRegistrantsQueryResult = Apollo.QueryResult<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>;
export const SearchRegistrantsDocument = gql`
    query SearchRegistrants($conferenceId: uuid!, $search: String!) {
  registrant_Registrant(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {_or: [{displayName: {_ilike: $search}}, {profile: {_or: [{affiliation: {_ilike: $search}}, {bio: {_ilike: $search}}]}}, {badges: {name: {_ilike: $search}}}]}]}
    order_by: {displayName: asc}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useSearchRegistrantsQuery__
 *
 * To run a query within a React component, call `useSearchRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>(SearchRegistrantsDocument, options);
      }
export function useSearchRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>(SearchRegistrantsDocument, options);
        }
export type SearchRegistrantsQueryHookResult = ReturnType<typeof useSearchRegistrantsQuery>;
export type SearchRegistrantsLazyQueryHookResult = ReturnType<typeof useSearchRegistrantsLazyQuery>;
export type SearchRegistrantsQueryResult = Apollo.QueryResult<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>;
export const Registrant_RegistrantCreateRoomDocument = gql`
    mutation registrant_RegistrantCreateRoom($conferenceId: uuid!, $name: String!, $managementModeName: room_ManagementMode_enum!) {
  insert_room_Room_one(
    object: {capacity: 50, conferenceId: $conferenceId, currentModeName: VIDEO_CHAT, name: $name, managementModeName: $managementModeName}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;
export type Registrant_RegistrantCreateRoomMutationFn = Apollo.MutationFunction<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>;

/**
 * __useRegistrant_RegistrantCreateRoomMutation__
 *
 * To run a mutation, you first call `useRegistrant_RegistrantCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegistrant_RegistrantCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registrantRegistrantCreateRoomMutation, { data, loading, error }] = useRegistrant_RegistrantCreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      name: // value for 'name'
 *      managementModeName: // value for 'managementModeName'
 *   },
 * });
 */
export function useRegistrant_RegistrantCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>(Registrant_RegistrantCreateRoomDocument, options);
      }
export type Registrant_RegistrantCreateRoomMutationHookResult = ReturnType<typeof useRegistrant_RegistrantCreateRoomMutation>;
export type Registrant_RegistrantCreateRoomMutationResult = Apollo.MutationResult<Registrant_RegistrantCreateRoomMutation>;
export type Registrant_RegistrantCreateRoomMutationOptions = Apollo.BaseMutationOptions<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>;
export const Room_GetEventsDocument = gql`
    query Room_GetEvents($roomId: uuid!, $now: timestamptz!, $cutoff: timestamptz!) {
  schedule_Event(
    where: {roomId: {_eq: $roomId}, endTime: {_gte: $now}, startTime: {_lte: $cutoff}}
  ) {
    ...Room_EventSummary
  }
}
    ${Room_EventSummaryFragmentDoc}`;

/**
 * __useRoom_GetEventsQuery__
 *
 * To run a query within a React component, call `useRoom_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetEventsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *      now: // value for 'now'
 *      cutoff: // value for 'cutoff'
 *   },
 * });
 */
export function useRoom_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, options);
      }
export function useRoom_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, options);
        }
export type Room_GetEventsQueryHookResult = ReturnType<typeof useRoom_GetEventsQuery>;
export type Room_GetEventsLazyQueryHookResult = ReturnType<typeof useRoom_GetEventsLazyQuery>;
export type Room_GetEventsQueryResult = Apollo.QueryResult<Room_GetEventsQuery, Room_GetEventsQueryVariables>;
export const Room_GetDefaultVideoRoomBackendDocument = gql`
    query Room_GetDefaultVideoRoomBackend {
  system_Configuration_by_pk(key: DEFAULT_VIDEO_ROOM_BACKEND) {
    value
  }
}
    `;

/**
 * __useRoom_GetDefaultVideoRoomBackendQuery__
 *
 * To run a query within a React component, call `useRoom_GetDefaultVideoRoomBackendQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetDefaultVideoRoomBackendQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetDefaultVideoRoomBackendQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoom_GetDefaultVideoRoomBackendQuery(baseOptions?: Apollo.QueryHookOptions<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>(Room_GetDefaultVideoRoomBackendDocument, options);
      }
export function useRoom_GetDefaultVideoRoomBackendLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>(Room_GetDefaultVideoRoomBackendDocument, options);
        }
export type Room_GetDefaultVideoRoomBackendQueryHookResult = ReturnType<typeof useRoom_GetDefaultVideoRoomBackendQuery>;
export type Room_GetDefaultVideoRoomBackendLazyQueryHookResult = ReturnType<typeof useRoom_GetDefaultVideoRoomBackendLazyQuery>;
export type Room_GetDefaultVideoRoomBackendQueryResult = Apollo.QueryResult<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>;
export const AddParticipantToRoomDocument = gql`
    mutation AddParticipantToRoom($registrantId: uuid!, $roomId: uuid!) {
  insert_room_RoomPerson_one(
    object: {registrantId: $registrantId, roomId: $roomId, personRoleName: PARTICIPANT}
  ) {
    id
  }
}
    `;
export type AddParticipantToRoomMutationFn = Apollo.MutationFunction<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;

/**
 * __useAddParticipantToRoomMutation__
 *
 * To run a mutation, you first call `useAddParticipantToRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddParticipantToRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addParticipantToRoomMutation, { data, loading, error }] = useAddParticipantToRoomMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useAddParticipantToRoomMutation(baseOptions?: Apollo.MutationHookOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>(AddParticipantToRoomDocument, options);
      }
export type AddParticipantToRoomMutationHookResult = ReturnType<typeof useAddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationResult = Apollo.MutationResult<AddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationOptions = Apollo.BaseMutationOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;
export const RoomPage_GetRoomDetailsDocument = gql`
    query RoomPage_GetRoomDetails($roomId: uuid!, $registrantId: uuid!) {
  room_Room_by_pk(id: $roomId) {
    ...RoomPage_RoomDetails
  }
}
    ${RoomPage_RoomDetailsFragmentDoc}`;

/**
 * __useRoomPage_GetRoomDetailsQuery__
 *
 * To run a query within a React component, call `useRoomPage_GetRoomDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomPage_GetRoomDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomPage_GetRoomDetailsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useRoomPage_GetRoomDetailsQuery(baseOptions: Apollo.QueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, options);
      }
export function useRoomPage_GetRoomDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, options);
        }
export type RoomPage_GetRoomDetailsQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsQuery>;
export type RoomPage_GetRoomDetailsLazyQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsLazyQuery>;
export type RoomPage_GetRoomDetailsQueryResult = Apollo.QueryResult<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>;
export const RoomPage_GetRoomChannelStackDocument = gql`
    query RoomPage_GetRoomChannelStack($roomId: uuid!) {
  video_ChannelStack(where: {roomId: {_eq: $roomId}}) {
    ...RoomPage_RoomChannelStack
  }
}
    ${RoomPage_RoomChannelStackFragmentDoc}`;

/**
 * __useRoomPage_GetRoomChannelStackQuery__
 *
 * To run a query within a React component, call `useRoomPage_GetRoomChannelStackQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomPage_GetRoomChannelStackQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomPage_GetRoomChannelStackQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useRoomPage_GetRoomChannelStackQuery(baseOptions: Apollo.QueryHookOptions<RoomPage_GetRoomChannelStackQuery, RoomPage_GetRoomChannelStackQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomPage_GetRoomChannelStackQuery, RoomPage_GetRoomChannelStackQueryVariables>(RoomPage_GetRoomChannelStackDocument, options);
      }
export function useRoomPage_GetRoomChannelStackLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomPage_GetRoomChannelStackQuery, RoomPage_GetRoomChannelStackQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomPage_GetRoomChannelStackQuery, RoomPage_GetRoomChannelStackQueryVariables>(RoomPage_GetRoomChannelStackDocument, options);
        }
export type RoomPage_GetRoomChannelStackQueryHookResult = ReturnType<typeof useRoomPage_GetRoomChannelStackQuery>;
export type RoomPage_GetRoomChannelStackLazyQueryHookResult = ReturnType<typeof useRoomPage_GetRoomChannelStackLazyQuery>;
export type RoomPage_GetRoomChannelStackQueryResult = Apollo.QueryResult<RoomPage_GetRoomChannelStackQuery, RoomPage_GetRoomChannelStackQueryVariables>;
export const GetEventVonageDetailsDocument = gql`
    query GetEventVonageDetails($eventId: uuid!) {
  schedule_Event_by_pk(id: $eventId) {
    eventVonageSession {
      sessionId
      id
    }
    id
  }
}
    `;

/**
 * __useGetEventVonageDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventVonageDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventVonageDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, options);
      }
export function useGetEventVonageDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, options);
        }
export type GetEventVonageDetailsQueryHookResult = ReturnType<typeof useGetEventVonageDetailsQuery>;
export type GetEventVonageDetailsLazyQueryHookResult = ReturnType<typeof useGetEventVonageDetailsLazyQuery>;
export type GetEventVonageDetailsQueryResult = Apollo.QueryResult<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>;
export const RoomSponsorContent_GetElementsDocument = gql`
    query RoomSponsorContent_GetElements($itemId: uuid!) {
  content_Item(where: {id: {_eq: $itemId}, typeName: {_eq: SPONSOR}}) {
    ...RoomSponsorContent_ItemData
  }
}
    ${RoomSponsorContent_ItemDataFragmentDoc}`;

/**
 * __useRoomSponsorContent_GetElementsQuery__
 *
 * To run a query within a React component, call `useRoomSponsorContent_GetElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomSponsorContent_GetElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomSponsorContent_GetElementsQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useRoomSponsorContent_GetElementsQuery(baseOptions: Apollo.QueryHookOptions<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>(RoomSponsorContent_GetElementsDocument, options);
      }
export function useRoomSponsorContent_GetElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>(RoomSponsorContent_GetElementsDocument, options);
        }
export type RoomSponsorContent_GetElementsQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetElementsQuery>;
export type RoomSponsorContent_GetElementsLazyQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetElementsLazyQuery>;
export type RoomSponsorContent_GetElementsQueryResult = Apollo.QueryResult<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>;
export const GetEventParticipantStreamsDocument = gql`
    subscription GetEventParticipantStreams($eventId: uuid!) {
  video_EventParticipantStream(where: {eventId: {_eq: $eventId}}) {
    ...EventParticipantStreamDetails
  }
}
    ${EventParticipantStreamDetailsFragmentDoc}`;

/**
 * __useGetEventParticipantStreamsSubscription__
 *
 * To run a query within a React component, call `useGetEventParticipantStreamsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetEventParticipantStreamsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventParticipantStreamsSubscription({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventParticipantStreamsSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>(GetEventParticipantStreamsDocument, options);
      }
export type GetEventParticipantStreamsSubscriptionHookResult = ReturnType<typeof useGetEventParticipantStreamsSubscription>;
export type GetEventParticipantStreamsSubscriptionResult = Apollo.SubscriptionResult<GetEventParticipantStreamsSubscription>;
export const ImmediateSwitch_GetElementsDocument = gql`
    query ImmediateSwitch_GetElements($eventId: uuid!) {
  schedule_Event_by_pk(id: $eventId) {
    id
    item {
      id
      title
      elements(
        where: {typeName: {_in: [VIDEO_BROADCAST, VIDEO_FILE, VIDEO_PREPUBLISH]}}
      ) {
        id
        name
      }
    }
    exhibition {
      id
      items {
        id
        item {
          id
          title
          elements(
            where: {typeName: {_in: [VIDEO_BROADCAST, VIDEO_FILE, VIDEO_PREPUBLISH]}}
          ) {
            id
            name
          }
        }
      }
    }
  }
}
    `;

/**
 * __useImmediateSwitch_GetElementsQuery__
 *
 * To run a query within a React component, call `useImmediateSwitch_GetElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useImmediateSwitch_GetElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImmediateSwitch_GetElementsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useImmediateSwitch_GetElementsQuery(baseOptions: Apollo.QueryHookOptions<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>(ImmediateSwitch_GetElementsDocument, options);
      }
export function useImmediateSwitch_GetElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>(ImmediateSwitch_GetElementsDocument, options);
        }
export type ImmediateSwitch_GetElementsQueryHookResult = ReturnType<typeof useImmediateSwitch_GetElementsQuery>;
export type ImmediateSwitch_GetElementsLazyQueryHookResult = ReturnType<typeof useImmediateSwitch_GetElementsLazyQuery>;
export type ImmediateSwitch_GetElementsQueryResult = Apollo.QueryResult<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>;
export const ImmediateSwitch_CreateDocument = gql`
    mutation ImmediateSwitch_Create($data: jsonb!, $eventId: uuid!, $conferenceId: uuid!) {
  insert_video_ImmediateSwitch_one(
    object: {data: $data, eventId: $eventId, conferenceId: $conferenceId}
  ) {
    id
  }
}
    `;
export type ImmediateSwitch_CreateMutationFn = Apollo.MutationFunction<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>;

/**
 * __useImmediateSwitch_CreateMutation__
 *
 * To run a mutation, you first call `useImmediateSwitch_CreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImmediateSwitch_CreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [immediateSwitchCreateMutation, { data, loading, error }] = useImmediateSwitch_CreateMutation({
 *   variables: {
 *      data: // value for 'data'
 *      eventId: // value for 'eventId'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useImmediateSwitch_CreateMutation(baseOptions?: Apollo.MutationHookOptions<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>(ImmediateSwitch_CreateDocument, options);
      }
export type ImmediateSwitch_CreateMutationHookResult = ReturnType<typeof useImmediateSwitch_CreateMutation>;
export type ImmediateSwitch_CreateMutationResult = Apollo.MutationResult<ImmediateSwitch_CreateMutation>;
export type ImmediateSwitch_CreateMutationOptions = Apollo.BaseMutationOptions<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>;
export const UpdateEventVonageSessionLayoutDocument = gql`
    mutation UpdateEventVonageSessionLayout($eventVonageSessionId: uuid!, $layoutData: jsonb!) {
  update_video_EventVonageSession_by_pk(
    pk_columns: {id: $eventVonageSessionId}
    _set: {layoutData: $layoutData}
  ) {
    id
  }
}
    `;
export type UpdateEventVonageSessionLayoutMutationFn = Apollo.MutationFunction<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;

/**
 * __useUpdateEventVonageSessionLayoutMutation__
 *
 * To run a mutation, you first call `useUpdateEventVonageSessionLayoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventVonageSessionLayoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventVonageSessionLayoutMutation, { data, loading, error }] = useUpdateEventVonageSessionLayoutMutation({
 *   variables: {
 *      eventVonageSessionId: // value for 'eventVonageSessionId'
 *      layoutData: // value for 'layoutData'
 *   },
 * });
 */
export function useUpdateEventVonageSessionLayoutMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>(UpdateEventVonageSessionLayoutDocument, options);
      }
export type UpdateEventVonageSessionLayoutMutationHookResult = ReturnType<typeof useUpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationResult = Apollo.MutationResult<UpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationOptions = Apollo.BaseMutationOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;
export const LiveIndicator_GetLatestDocument = gql`
    query LiveIndicator_GetLatest($eventId: uuid!) {
  video_ImmediateSwitch(
    order_by: {executedAt: desc_nulls_last}
    where: {eventId: {_eq: $eventId}, executedAt: {_is_null: false}}
    limit: 1
  ) {
    id
    data
    executedAt
  }
}
    `;

/**
 * __useLiveIndicator_GetLatestQuery__
 *
 * To run a query within a React component, call `useLiveIndicator_GetLatestQuery` and pass it any options that fit your needs.
 * When your component renders, `useLiveIndicator_GetLatestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLiveIndicator_GetLatestQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useLiveIndicator_GetLatestQuery(baseOptions: Apollo.QueryHookOptions<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>(LiveIndicator_GetLatestDocument, options);
      }
export function useLiveIndicator_GetLatestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>(LiveIndicator_GetLatestDocument, options);
        }
export type LiveIndicator_GetLatestQueryHookResult = ReturnType<typeof useLiveIndicator_GetLatestQuery>;
export type LiveIndicator_GetLatestLazyQueryHookResult = ReturnType<typeof useLiveIndicator_GetLatestLazyQuery>;
export type LiveIndicator_GetLatestQueryResult = Apollo.QueryResult<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>;
export const LiveIndicator_GetElementDocument = gql`
    query LiveIndicator_GetElement($elementId: uuid!) {
  content_Element_by_pk(id: $elementId) {
    id
    data
  }
}
    `;

/**
 * __useLiveIndicator_GetElementQuery__
 *
 * To run a query within a React component, call `useLiveIndicator_GetElementQuery` and pass it any options that fit your needs.
 * When your component renders, `useLiveIndicator_GetElementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLiveIndicator_GetElementQuery({
 *   variables: {
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useLiveIndicator_GetElementQuery(baseOptions: Apollo.QueryHookOptions<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>(LiveIndicator_GetElementDocument, options);
      }
export function useLiveIndicator_GetElementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>(LiveIndicator_GetElementDocument, options);
        }
export type LiveIndicator_GetElementQueryHookResult = ReturnType<typeof useLiveIndicator_GetElementQuery>;
export type LiveIndicator_GetElementLazyQueryHookResult = ReturnType<typeof useLiveIndicator_GetElementLazyQuery>;
export type LiveIndicator_GetElementQueryResult = Apollo.QueryResult<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>;
export const EnableBackstageStreamPreviewDocument = gql`
    query EnableBackstageStreamPreview($conferenceId: uuid!) {
  conference_Configuration_by_pk(
    key: ENABLE_BACKSTAGE_STREAM_PREVIEW
    conferenceId: $conferenceId
  ) {
    key
    conferenceId
    value
  }
}
    `;

/**
 * __useEnableBackstageStreamPreviewQuery__
 *
 * To run a query within a React component, call `useEnableBackstageStreamPreviewQuery` and pass it any options that fit your needs.
 * When your component renders, `useEnableBackstageStreamPreviewQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEnableBackstageStreamPreviewQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useEnableBackstageStreamPreviewQuery(baseOptions: Apollo.QueryHookOptions<EnableBackstageStreamPreviewQuery, EnableBackstageStreamPreviewQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EnableBackstageStreamPreviewQuery, EnableBackstageStreamPreviewQueryVariables>(EnableBackstageStreamPreviewDocument, options);
      }
export function useEnableBackstageStreamPreviewLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EnableBackstageStreamPreviewQuery, EnableBackstageStreamPreviewQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EnableBackstageStreamPreviewQuery, EnableBackstageStreamPreviewQueryVariables>(EnableBackstageStreamPreviewDocument, options);
        }
export type EnableBackstageStreamPreviewQueryHookResult = ReturnType<typeof useEnableBackstageStreamPreviewQuery>;
export type EnableBackstageStreamPreviewLazyQueryHookResult = ReturnType<typeof useEnableBackstageStreamPreviewLazyQuery>;
export type EnableBackstageStreamPreviewQueryResult = Apollo.QueryResult<EnableBackstageStreamPreviewQuery, EnableBackstageStreamPreviewQueryVariables>;
export const GetEventDetailsDocument = gql`
    query GetEventDetails($eventId: uuid!) {
  schedule_Event_by_pk(id: $eventId) {
    ...RoomEventDetails
  }
}
    ${RoomEventDetailsFragmentDoc}`;

/**
 * __useGetEventDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
      }
export function useGetEventDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
        }
export type GetEventDetailsQueryHookResult = ReturnType<typeof useGetEventDetailsQuery>;
export type GetEventDetailsLazyQueryHookResult = ReturnType<typeof useGetEventDetailsLazyQuery>;
export type GetEventDetailsQueryResult = Apollo.QueryResult<GetEventDetailsQuery, GetEventDetailsQueryVariables>;
export const VideoPlayer_GetElementDocument = gql`
    query VideoPlayer_GetElement($elementId: uuid!) {
  content_Element_by_pk(id: $elementId) {
    id
    typeName
    isHidden
    data
    name
    item {
      id
      title
    }
  }
}
    `;

/**
 * __useVideoPlayer_GetElementQuery__
 *
 * To run a query within a React component, call `useVideoPlayer_GetElementQuery` and pass it any options that fit your needs.
 * When your component renders, `useVideoPlayer_GetElementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useVideoPlayer_GetElementQuery({
 *   variables: {
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useVideoPlayer_GetElementQuery(baseOptions: Apollo.QueryHookOptions<VideoPlayer_GetElementQuery, VideoPlayer_GetElementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<VideoPlayer_GetElementQuery, VideoPlayer_GetElementQueryVariables>(VideoPlayer_GetElementDocument, options);
      }
export function useVideoPlayer_GetElementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<VideoPlayer_GetElementQuery, VideoPlayer_GetElementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<VideoPlayer_GetElementQuery, VideoPlayer_GetElementQueryVariables>(VideoPlayer_GetElementDocument, options);
        }
export type VideoPlayer_GetElementQueryHookResult = ReturnType<typeof useVideoPlayer_GetElementQuery>;
export type VideoPlayer_GetElementLazyQueryHookResult = ReturnType<typeof useVideoPlayer_GetElementLazyQuery>;
export type VideoPlayer_GetElementQueryResult = Apollo.QueryResult<VideoPlayer_GetElementQuery, VideoPlayer_GetElementQueryVariables>;
export const GetRoomChimeDataDocument = gql`
    mutation GetRoomChimeData($roomId: uuid!) {
  joinRoomChimeSession(roomId: $roomId) {
    registrant
    meeting
    message
  }
}
    `;
export type GetRoomChimeDataMutationFn = Apollo.MutationFunction<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>;

/**
 * __useGetRoomChimeDataMutation__
 *
 * To run a mutation, you first call `useGetRoomChimeDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetRoomChimeDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getRoomChimeDataMutation, { data, loading, error }] = useGetRoomChimeDataMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomChimeDataMutation(baseOptions?: Apollo.MutationHookOptions<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>(GetRoomChimeDataDocument, options);
      }
export type GetRoomChimeDataMutationHookResult = ReturnType<typeof useGetRoomChimeDataMutation>;
export type GetRoomChimeDataMutationResult = Apollo.MutationResult<GetRoomChimeDataMutation>;
export type GetRoomChimeDataMutationOptions = Apollo.BaseMutationOptions<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>;
export const GetEventVonageTokenDocument = gql`
    mutation GetEventVonageToken($eventId: uuid!) {
  joinEventVonageSession(eventId: $eventId) {
    accessToken
    isRecorded
  }
}
    `;
export type GetEventVonageTokenMutationFn = Apollo.MutationFunction<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;

/**
 * __useGetEventVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetEventVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getEventVonageTokenMutation, { data, loading, error }] = useGetEventVonageTokenMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>(GetEventVonageTokenDocument, options);
      }
export type GetEventVonageTokenMutationHookResult = ReturnType<typeof useGetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationResult = Apollo.MutationResult<GetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;
export const GetRoomVonageTokenDocument = gql`
    mutation GetRoomVonageToken($roomId: uuid!) {
  joinRoomVonageSession(roomId: $roomId) {
    accessToken
    sessionId
    isRecorded
  }
}
    `;
export type GetRoomVonageTokenMutationFn = Apollo.MutationFunction<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;

/**
 * __useGetRoomVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetRoomVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetRoomVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getRoomVonageTokenMutation, { data, loading, error }] = useGetRoomVonageTokenMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>(GetRoomVonageTokenDocument, options);
      }
export type GetRoomVonageTokenMutationHookResult = ReturnType<typeof useGetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationResult = Apollo.MutationResult<GetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;
export const GetRoomVonageSessionIdDocument = gql`
    query GetRoomVonageSessionId($roomId: uuid!) {
  room_Room_by_pk(id: $roomId) {
    id
    publicVonageSessionId
  }
}
    `;

/**
 * __useGetRoomVonageSessionIdQuery__
 *
 * To run a query within a React component, call `useGetRoomVonageSessionIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomVonageSessionIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomVonageSessionIdQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomVonageSessionIdQuery(baseOptions: Apollo.QueryHookOptions<GetRoomVonageSessionIdQuery, GetRoomVonageSessionIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomVonageSessionIdQuery, GetRoomVonageSessionIdQueryVariables>(GetRoomVonageSessionIdDocument, options);
      }
export function useGetRoomVonageSessionIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomVonageSessionIdQuery, GetRoomVonageSessionIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomVonageSessionIdQuery, GetRoomVonageSessionIdQueryVariables>(GetRoomVonageSessionIdDocument, options);
        }
export type GetRoomVonageSessionIdQueryHookResult = ReturnType<typeof useGetRoomVonageSessionIdQuery>;
export type GetRoomVonageSessionIdLazyQueryHookResult = ReturnType<typeof useGetRoomVonageSessionIdLazyQuery>;
export type GetRoomVonageSessionIdQueryResult = Apollo.QueryResult<GetRoomVonageSessionIdQuery, GetRoomVonageSessionIdQueryVariables>;
export const DeleteEventParticipantDocument = gql`
    mutation DeleteEventParticipant($eventId: uuid!, $registrantId: uuid!) {
  delete_schedule_EventProgramPerson(
    where: {eventId: {_eq: $eventId}, person: {registrantId: {_eq: $registrantId}}, roleName: {_eq: PARTICIPANT}}
  ) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventParticipantMutationFn = Apollo.MutationFunction<DeleteEventParticipantMutation, DeleteEventParticipantMutationVariables>;

/**
 * __useDeleteEventParticipantMutation__
 *
 * To run a mutation, you first call `useDeleteEventParticipantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventParticipantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventParticipantMutation, { data, loading, error }] = useDeleteEventParticipantMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useDeleteEventParticipantMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventParticipantMutation, DeleteEventParticipantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventParticipantMutation, DeleteEventParticipantMutationVariables>(DeleteEventParticipantDocument, options);
      }
export type DeleteEventParticipantMutationHookResult = ReturnType<typeof useDeleteEventParticipantMutation>;
export type DeleteEventParticipantMutationResult = Apollo.MutationResult<DeleteEventParticipantMutation>;
export type DeleteEventParticipantMutationOptions = Apollo.BaseMutationOptions<DeleteEventParticipantMutation, DeleteEventParticipantMutationVariables>;
export const SaveVonageRoomRecordingDocument = gql`
    mutation SaveVonageRoomRecording($recordingId: uuid!, $registrantId: uuid!) {
  insert_registrant_SavedVonageRoomRecording_one(
    object: {recordingId: $recordingId, registrantId: $registrantId}
    on_conflict: {constraint: SavedVonageRoomRecording_recordingId_registrantId_key, update_columns: []}
  ) {
    id
    recordingId
    registrantId
    isHidden
  }
}
    `;
export type SaveVonageRoomRecordingMutationFn = Apollo.MutationFunction<SaveVonageRoomRecordingMutation, SaveVonageRoomRecordingMutationVariables>;

/**
 * __useSaveVonageRoomRecordingMutation__
 *
 * To run a mutation, you first call `useSaveVonageRoomRecordingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSaveVonageRoomRecordingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [saveVonageRoomRecordingMutation, { data, loading, error }] = useSaveVonageRoomRecordingMutation({
 *   variables: {
 *      recordingId: // value for 'recordingId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useSaveVonageRoomRecordingMutation(baseOptions?: Apollo.MutationHookOptions<SaveVonageRoomRecordingMutation, SaveVonageRoomRecordingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SaveVonageRoomRecordingMutation, SaveVonageRoomRecordingMutationVariables>(SaveVonageRoomRecordingDocument, options);
      }
export type SaveVonageRoomRecordingMutationHookResult = ReturnType<typeof useSaveVonageRoomRecordingMutation>;
export type SaveVonageRoomRecordingMutationResult = Apollo.MutationResult<SaveVonageRoomRecordingMutation>;
export type SaveVonageRoomRecordingMutationOptions = Apollo.BaseMutationOptions<SaveVonageRoomRecordingMutation, SaveVonageRoomRecordingMutationVariables>;
export const ToggleVonageRecordingStateDocument = gql`
    mutation ToggleVonageRecordingState($vonageSessionId: String!, $recordingActive: Boolean!) {
  toggleVonageRecordingState(
    vonageSessionId: $vonageSessionId
    recordingActive: $recordingActive
  ) {
    allowed
    recordingState
  }
}
    `;
export type ToggleVonageRecordingStateMutationFn = Apollo.MutationFunction<ToggleVonageRecordingStateMutation, ToggleVonageRecordingStateMutationVariables>;

/**
 * __useToggleVonageRecordingStateMutation__
 *
 * To run a mutation, you first call `useToggleVonageRecordingStateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useToggleVonageRecordingStateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [toggleVonageRecordingStateMutation, { data, loading, error }] = useToggleVonageRecordingStateMutation({
 *   variables: {
 *      vonageSessionId: // value for 'vonageSessionId'
 *      recordingActive: // value for 'recordingActive'
 *   },
 * });
 */
export function useToggleVonageRecordingStateMutation(baseOptions?: Apollo.MutationHookOptions<ToggleVonageRecordingStateMutation, ToggleVonageRecordingStateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ToggleVonageRecordingStateMutation, ToggleVonageRecordingStateMutationVariables>(ToggleVonageRecordingStateDocument, options);
      }
export type ToggleVonageRecordingStateMutationHookResult = ReturnType<typeof useToggleVonageRecordingStateMutation>;
export type ToggleVonageRecordingStateMutationResult = Apollo.MutationResult<ToggleVonageRecordingStateMutation>;
export type ToggleVonageRecordingStateMutationOptions = Apollo.BaseMutationOptions<ToggleVonageRecordingStateMutation, ToggleVonageRecordingStateMutationVariables>;
export const GetAllRoomsDocument = gql`
    query GetAllRooms($conferenceId: uuid!, $registrantId: uuid!) {
  socialRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatoryPin: {_eq: true}}}]}, originatingItemId: {_is_null: true}, originatingEventId: {_is_null: true}, _or: [{managementModeName: {_eq: PUBLIC}}, {managementModeName: {_eq: PRIVATE}, roomPeople: {registrantId: {_eq: $registrantId}}}]}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
  programRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, events: {}, managementModeName: {_in: [PUBLIC, PRIVATE]}, _or: [{originatingItemId: {_is_null: true}}, {originatingItem: {typeName: {_neq: SPONSOR}}}]}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;

/**
 * __useGetAllRoomsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useGetAllRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, options);
      }
export function useGetAllRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, options);
        }
export type GetAllRoomsQueryHookResult = ReturnType<typeof useGetAllRoomsQuery>;
export type GetAllRoomsLazyQueryHookResult = ReturnType<typeof useGetAllRoomsLazyQuery>;
export type GetAllRoomsQueryResult = Apollo.QueryResult<GetAllRoomsQuery, GetAllRoomsQueryVariables>;
export const GetAllTodaysRoomsDocument = gql`
    query GetAllTodaysRooms($conferenceId: uuid!, $todayStart: timestamptz!, $todayEnd: timestamptz!, $registrantId: uuid!) {
  socialOrDiscussionRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatorySubscribe: {_eq: true}}}]}, _and: [{_or: [{originatingItemId: {_is_null: true}}, {originatingItem: {typeName: {_neq: SPONSOR}}}]}, {_or: [{managementModeName: {_eq: PUBLIC}}, {managementModeName: {_eq: PRIVATE}, roomPeople: {registrantId: {_eq: $registrantId}}}]}]}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
  programRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, events: {startTime: {_lte: $todayEnd}, endTime: {_gte: $todayStart}}, _or: [{originatingItemId: {_is_null: true}}, {originatingItem: {typeName: {_neq: SPONSOR}}}], managementModeName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;

/**
 * __useGetAllTodaysRoomsQuery__
 *
 * To run a query within a React component, call `useGetAllTodaysRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllTodaysRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllTodaysRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      todayStart: // value for 'todayStart'
 *      todayEnd: // value for 'todayEnd'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useGetAllTodaysRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>(GetAllTodaysRoomsDocument, options);
      }
export function useGetAllTodaysRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>(GetAllTodaysRoomsDocument, options);
        }
export type GetAllTodaysRoomsQueryHookResult = ReturnType<typeof useGetAllTodaysRoomsQuery>;
export type GetAllTodaysRoomsLazyQueryHookResult = ReturnType<typeof useGetAllTodaysRoomsLazyQuery>;
export type GetAllTodaysRoomsQueryResult = Apollo.QueryResult<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>;
export const GetSocialRoomsDocument = gql`
    query GetSocialRooms($conferenceId: uuid!, $registrantId: uuid!) {
  socialRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatoryPin: {_eq: true}}}]}, originatingItemId: {_is_null: true}, originatingEventId: {_is_null: true}, _or: [{managementModeName: {_eq: PUBLIC}}, {managementModeName: {_eq: PRIVATE}, roomPeople: {registrantId: {_eq: $registrantId}}}]}
    order_by: {name: asc}
  ) {
    ...SocialRoom
  }
}
    ${SocialRoomFragmentDoc}`;

/**
 * __useGetSocialRoomsQuery__
 *
 * To run a query within a React component, call `useGetSocialRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSocialRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSocialRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useGetSocialRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetSocialRoomsQuery, GetSocialRoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSocialRoomsQuery, GetSocialRoomsQueryVariables>(GetSocialRoomsDocument, options);
      }
export function useGetSocialRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSocialRoomsQuery, GetSocialRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSocialRoomsQuery, GetSocialRoomsQueryVariables>(GetSocialRoomsDocument, options);
        }
export type GetSocialRoomsQueryHookResult = ReturnType<typeof useGetSocialRoomsQuery>;
export type GetSocialRoomsLazyQueryHookResult = ReturnType<typeof useGetSocialRoomsLazyQuery>;
export type GetSocialRoomsQueryResult = Apollo.QueryResult<GetSocialRoomsQuery, GetSocialRoomsQueryVariables>;
export const RoomTile_GetRoomDocument = gql`
    query RoomTile_GetRoom($roomId: uuid!, $withEvent: Boolean!, $eventId: uuid) {
  room_Room_by_pk(id: $roomId) {
    ...RoomTile_Room
  }
}
    ${RoomTile_RoomFragmentDoc}`;

/**
 * __useRoomTile_GetRoomQuery__
 *
 * To run a query within a React component, call `useRoomTile_GetRoomQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomTile_GetRoomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomTile_GetRoomQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *      withEvent: // value for 'withEvent'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useRoomTile_GetRoomQuery(baseOptions: Apollo.QueryHookOptions<RoomTile_GetRoomQuery, RoomTile_GetRoomQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomTile_GetRoomQuery, RoomTile_GetRoomQueryVariables>(RoomTile_GetRoomDocument, options);
      }
export function useRoomTile_GetRoomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomTile_GetRoomQuery, RoomTile_GetRoomQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomTile_GetRoomQuery, RoomTile_GetRoomQueryVariables>(RoomTile_GetRoomDocument, options);
        }
export type RoomTile_GetRoomQueryHookResult = ReturnType<typeof useRoomTile_GetRoomQuery>;
export type RoomTile_GetRoomLazyQueryHookResult = ReturnType<typeof useRoomTile_GetRoomLazyQuery>;
export type RoomTile_GetRoomQueryResult = Apollo.QueryResult<RoomTile_GetRoomQuery, RoomTile_GetRoomQueryVariables>;
export const GetSponsorBoothsDocument = gql`
    query GetSponsorBooths($conferenceId: uuid!) {
  content_Item(
    where: {conferenceId: {_eq: $conferenceId}, typeName: {_eq: SPONSOR}}
    order_by: {title: asc}
  ) {
    ...SponsorBoothsList_Item
  }
}
    ${SponsorBoothsList_ItemFragmentDoc}`;

/**
 * __useGetSponsorBoothsQuery__
 *
 * To run a query within a React component, call `useGetSponsorBoothsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetSponsorBoothsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetSponsorBoothsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetSponsorBoothsQuery(baseOptions: Apollo.QueryHookOptions<GetSponsorBoothsQuery, GetSponsorBoothsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetSponsorBoothsQuery, GetSponsorBoothsQueryVariables>(GetSponsorBoothsDocument, options);
      }
export function useGetSponsorBoothsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetSponsorBoothsQuery, GetSponsorBoothsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetSponsorBoothsQuery, GetSponsorBoothsQueryVariables>(GetSponsorBoothsDocument, options);
        }
export type GetSponsorBoothsQueryHookResult = ReturnType<typeof useGetSponsorBoothsQuery>;
export type GetSponsorBoothsLazyQueryHookResult = ReturnType<typeof useGetSponsorBoothsLazyQuery>;
export type GetSponsorBoothsQueryResult = Apollo.QueryResult<GetSponsorBoothsQuery, GetSponsorBoothsQueryVariables>;
export const Schedule_HappeningSoonDocument = gql`
    query Schedule_HappeningSoon($conferenceId: uuid!, $startBefore: timestamptz!, $endAfter: timestamptz!) {
  room_Room(
    where: {conferenceId: {_eq: $conferenceId}, managementModeName: {_in: [PUBLIC, PRIVATE]}, events: {startTime: {_lte: $startBefore}, endTime: {_gte: $endAfter}}}
  ) {
    ...Schedule_RoomSummary
  }
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, startTime: {_lte: $startBefore}, endTime: {_gte: $endAfter}}
  ) {
    ...Schedule_EventSummary
    item {
      ...Schedule_ItemFields
    }
  }
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_ProgramPerson
  }
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_Tag
  }
}
    ${Schedule_RoomSummaryFragmentDoc}
${Schedule_EventSummaryFragmentDoc}
${Schedule_ItemFieldsFragmentDoc}
${Schedule_ProgramPersonFragmentDoc}
${Schedule_TagFragmentDoc}`;

/**
 * __useSchedule_HappeningSoonQuery__
 *
 * To run a query within a React component, call `useSchedule_HappeningSoonQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchedule_HappeningSoonQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchedule_HappeningSoonQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      startBefore: // value for 'startBefore'
 *      endAfter: // value for 'endAfter'
 *   },
 * });
 */
export function useSchedule_HappeningSoonQuery(baseOptions: Apollo.QueryHookOptions<Schedule_HappeningSoonQuery, Schedule_HappeningSoonQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Schedule_HappeningSoonQuery, Schedule_HappeningSoonQueryVariables>(Schedule_HappeningSoonDocument, options);
      }
export function useSchedule_HappeningSoonLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Schedule_HappeningSoonQuery, Schedule_HappeningSoonQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Schedule_HappeningSoonQuery, Schedule_HappeningSoonQueryVariables>(Schedule_HappeningSoonDocument, options);
        }
export type Schedule_HappeningSoonQueryHookResult = ReturnType<typeof useSchedule_HappeningSoonQuery>;
export type Schedule_HappeningSoonLazyQueryHookResult = ReturnType<typeof useSchedule_HappeningSoonLazyQuery>;
export type Schedule_HappeningSoonQueryResult = Apollo.QueryResult<Schedule_HappeningSoonQuery, Schedule_HappeningSoonQueryVariables>;
export const StarEventButton_GetStarsDocument = gql`
    query StarEventButton_GetStars($eventIds: [uuid!]!, $registrantId: uuid!) {
  schedule_StarredEvent(
    where: {eventId: {_in: $eventIds}, registrantId: {_eq: $registrantId}}
  ) {
    ...StarredEvent
  }
}
    ${StarredEventFragmentDoc}`;

/**
 * __useStarEventButton_GetStarsQuery__
 *
 * To run a query within a React component, call `useStarEventButton_GetStarsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStarEventButton_GetStarsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStarEventButton_GetStarsQuery({
 *   variables: {
 *      eventIds: // value for 'eventIds'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useStarEventButton_GetStarsQuery(baseOptions: Apollo.QueryHookOptions<StarEventButton_GetStarsQuery, StarEventButton_GetStarsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StarEventButton_GetStarsQuery, StarEventButton_GetStarsQueryVariables>(StarEventButton_GetStarsDocument, options);
      }
export function useStarEventButton_GetStarsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StarEventButton_GetStarsQuery, StarEventButton_GetStarsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StarEventButton_GetStarsQuery, StarEventButton_GetStarsQueryVariables>(StarEventButton_GetStarsDocument, options);
        }
export type StarEventButton_GetStarsQueryHookResult = ReturnType<typeof useStarEventButton_GetStarsQuery>;
export type StarEventButton_GetStarsLazyQueryHookResult = ReturnType<typeof useStarEventButton_GetStarsLazyQuery>;
export type StarEventButton_GetStarsQueryResult = Apollo.QueryResult<StarEventButton_GetStarsQuery, StarEventButton_GetStarsQueryVariables>;
export const StarEventButton_InsertStarsDocument = gql`
    mutation StarEventButton_InsertStars($objects: [schedule_StarredEvent_insert_input!]!) {
  insert_schedule_StarredEvent(objects: $objects) {
    returning {
      ...StarredEvent
    }
  }
}
    ${StarredEventFragmentDoc}`;
export type StarEventButton_InsertStarsMutationFn = Apollo.MutationFunction<StarEventButton_InsertStarsMutation, StarEventButton_InsertStarsMutationVariables>;

/**
 * __useStarEventButton_InsertStarsMutation__
 *
 * To run a mutation, you first call `useStarEventButton_InsertStarsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStarEventButton_InsertStarsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [starEventButtonInsertStarsMutation, { data, loading, error }] = useStarEventButton_InsertStarsMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useStarEventButton_InsertStarsMutation(baseOptions?: Apollo.MutationHookOptions<StarEventButton_InsertStarsMutation, StarEventButton_InsertStarsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StarEventButton_InsertStarsMutation, StarEventButton_InsertStarsMutationVariables>(StarEventButton_InsertStarsDocument, options);
      }
export type StarEventButton_InsertStarsMutationHookResult = ReturnType<typeof useStarEventButton_InsertStarsMutation>;
export type StarEventButton_InsertStarsMutationResult = Apollo.MutationResult<StarEventButton_InsertStarsMutation>;
export type StarEventButton_InsertStarsMutationOptions = Apollo.BaseMutationOptions<StarEventButton_InsertStarsMutation, StarEventButton_InsertStarsMutationVariables>;
export const StarEventButton_DeleteStarsDocument = gql`
    mutation StarEventButton_DeleteStars($ids: [uuid!]!) {
  delete_schedule_StarredEvent(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type StarEventButton_DeleteStarsMutationFn = Apollo.MutationFunction<StarEventButton_DeleteStarsMutation, StarEventButton_DeleteStarsMutationVariables>;

/**
 * __useStarEventButton_DeleteStarsMutation__
 *
 * To run a mutation, you first call `useStarEventButton_DeleteStarsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useStarEventButton_DeleteStarsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [starEventButtonDeleteStarsMutation, { data, loading, error }] = useStarEventButton_DeleteStarsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useStarEventButton_DeleteStarsMutation(baseOptions?: Apollo.MutationHookOptions<StarEventButton_DeleteStarsMutation, StarEventButton_DeleteStarsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<StarEventButton_DeleteStarsMutation, StarEventButton_DeleteStarsMutationVariables>(StarEventButton_DeleteStarsDocument, options);
      }
export type StarEventButton_DeleteStarsMutationHookResult = ReturnType<typeof useStarEventButton_DeleteStarsMutation>;
export type StarEventButton_DeleteStarsMutationResult = Apollo.MutationResult<StarEventButton_DeleteStarsMutation>;
export type StarEventButton_DeleteStarsMutationOptions = Apollo.BaseMutationOptions<StarEventButton_DeleteStarsMutation, StarEventButton_DeleteStarsMutationVariables>;
export const StarredEvents_SelectEventIdsDocument = gql`
    query StarredEvents_SelectEventIds($registrantId: uuid!) {
  schedule_StarredEvent(where: {registrantId: {_eq: $registrantId}}) {
    ...StarredEvent
  }
  schedule_Event(
    where: {eventPeople: {person: {registrantId: {_eq: $registrantId}}}}
  ) {
    id
  }
}
    ${StarredEventFragmentDoc}`;

/**
 * __useStarredEvents_SelectEventIdsQuery__
 *
 * To run a query within a React component, call `useStarredEvents_SelectEventIdsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStarredEvents_SelectEventIdsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStarredEvents_SelectEventIdsQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useStarredEvents_SelectEventIdsQuery(baseOptions: Apollo.QueryHookOptions<StarredEvents_SelectEventIdsQuery, StarredEvents_SelectEventIdsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StarredEvents_SelectEventIdsQuery, StarredEvents_SelectEventIdsQueryVariables>(StarredEvents_SelectEventIdsDocument, options);
      }
export function useStarredEvents_SelectEventIdsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StarredEvents_SelectEventIdsQuery, StarredEvents_SelectEventIdsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StarredEvents_SelectEventIdsQuery, StarredEvents_SelectEventIdsQueryVariables>(StarredEvents_SelectEventIdsDocument, options);
        }
export type StarredEvents_SelectEventIdsQueryHookResult = ReturnType<typeof useStarredEvents_SelectEventIdsQuery>;
export type StarredEvents_SelectEventIdsLazyQueryHookResult = ReturnType<typeof useStarredEvents_SelectEventIdsLazyQuery>;
export type StarredEvents_SelectEventIdsQueryResult = Apollo.QueryResult<StarredEvents_SelectEventIdsQuery, StarredEvents_SelectEventIdsQueryVariables>;
export const StarredEvents_SelectEventsDocument = gql`
    query StarredEvents_SelectEvents($eventIds: [uuid!]!, $conferenceId: uuid!) {
  room_Room(where: {events: {id: {_in: $eventIds}}}) {
    ...Schedule_RoomSummary
  }
  schedule_Event(where: {id: {_in: $eventIds}}) {
    ...Schedule_EventSummary
    item {
      ...Schedule_ItemFields
    }
  }
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_ProgramPerson
  }
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_Tag
  }
}
    ${Schedule_RoomSummaryFragmentDoc}
${Schedule_EventSummaryFragmentDoc}
${Schedule_ItemFieldsFragmentDoc}
${Schedule_ProgramPersonFragmentDoc}
${Schedule_TagFragmentDoc}`;

/**
 * __useStarredEvents_SelectEventsQuery__
 *
 * To run a query within a React component, call `useStarredEvents_SelectEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useStarredEvents_SelectEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useStarredEvents_SelectEventsQuery({
 *   variables: {
 *      eventIds: // value for 'eventIds'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useStarredEvents_SelectEventsQuery(baseOptions: Apollo.QueryHookOptions<StarredEvents_SelectEventsQuery, StarredEvents_SelectEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<StarredEvents_SelectEventsQuery, StarredEvents_SelectEventsQueryVariables>(StarredEvents_SelectEventsDocument, options);
      }
export function useStarredEvents_SelectEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<StarredEvents_SelectEventsQuery, StarredEvents_SelectEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<StarredEvents_SelectEventsQuery, StarredEvents_SelectEventsQueryVariables>(StarredEvents_SelectEventsDocument, options);
        }
export type StarredEvents_SelectEventsQueryHookResult = ReturnType<typeof useStarredEvents_SelectEventsQuery>;
export type StarredEvents_SelectEventsLazyQueryHookResult = ReturnType<typeof useStarredEvents_SelectEventsLazyQuery>;
export type StarredEvents_SelectEventsQueryResult = Apollo.QueryResult<StarredEvents_SelectEventsQuery, StarredEvents_SelectEventsQueryVariables>;
export const Schedule_SelectItemDocument = gql`
    query Schedule_SelectItem($id: uuid!) {
  content_Item_by_pk(id: $id) {
    ...Schedule_Item
  }
}
    ${Schedule_ItemFragmentDoc}`;

/**
 * __useSchedule_SelectItemQuery__
 *
 * To run a query within a React component, call `useSchedule_SelectItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchedule_SelectItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchedule_SelectItemQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSchedule_SelectItemQuery(baseOptions: Apollo.QueryHookOptions<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>(Schedule_SelectItemDocument, options);
      }
export function useSchedule_SelectItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>(Schedule_SelectItemDocument, options);
        }
export type Schedule_SelectItemQueryHookResult = ReturnType<typeof useSchedule_SelectItemQuery>;
export type Schedule_SelectItemLazyQueryHookResult = ReturnType<typeof useSchedule_SelectItemLazyQuery>;
export type Schedule_SelectItemQueryResult = Apollo.QueryResult<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>;
export const Schedule_SelectSummariesDocument = gql`
    query Schedule_SelectSummaries($conferenceId: uuid!) {
  room_Room(
    where: {conferenceId: {_eq: $conferenceId}, managementModeName: {_in: [PUBLIC, PRIVATE]}, events: {}}
  ) {
    ...Schedule_RoomSummary
  }
  schedule_Event(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_EventSummary
  }
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_ItemFields
  }
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_ProgramPerson
  }
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_Tag
  }
}
    ${Schedule_RoomSummaryFragmentDoc}
${Schedule_EventSummaryFragmentDoc}
${Schedule_ItemFieldsFragmentDoc}
${Schedule_ProgramPersonFragmentDoc}
${Schedule_TagFragmentDoc}`;

/**
 * __useSchedule_SelectSummariesQuery__
 *
 * To run a query within a React component, call `useSchedule_SelectSummariesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchedule_SelectSummariesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchedule_SelectSummariesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSchedule_SelectSummariesQuery(baseOptions: Apollo.QueryHookOptions<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>(Schedule_SelectSummariesDocument, options);
      }
export function useSchedule_SelectSummariesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>(Schedule_SelectSummariesDocument, options);
        }
export type Schedule_SelectSummariesQueryHookResult = ReturnType<typeof useSchedule_SelectSummariesQuery>;
export type Schedule_SelectSummariesLazyQueryHookResult = ReturnType<typeof useSchedule_SelectSummariesLazyQuery>;
export type Schedule_SelectSummariesQueryResult = Apollo.QueryResult<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>;
export const ScheduleV2_DayLightweightEventsDocument = gql`
    query ScheduleV2_DayLightweightEvents($conferenceId: uuid!, $startOfDay: timestamptz!, $endOfDay: timestamptz!, $filter: schedule_Event_bool_exp!) {
  schedule_Event(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {startTime: {_lt: $endOfDay}}, {endTime: {_gt: $startOfDay}}, $filter]}
  ) {
    ...ScheduleV2_LightweightEvent
  }
}
    ${ScheduleV2_LightweightEventFragmentDoc}`;

/**
 * __useScheduleV2_DayLightweightEventsQuery__
 *
 * To run a query within a React component, call `useScheduleV2_DayLightweightEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useScheduleV2_DayLightweightEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScheduleV2_DayLightweightEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      startOfDay: // value for 'startOfDay'
 *      endOfDay: // value for 'endOfDay'
 *      filter: // value for 'filter'
 *   },
 * });
 */
export function useScheduleV2_DayLightweightEventsQuery(baseOptions: Apollo.QueryHookOptions<ScheduleV2_DayLightweightEventsQuery, ScheduleV2_DayLightweightEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScheduleV2_DayLightweightEventsQuery, ScheduleV2_DayLightweightEventsQueryVariables>(ScheduleV2_DayLightweightEventsDocument, options);
      }
export function useScheduleV2_DayLightweightEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScheduleV2_DayLightweightEventsQuery, ScheduleV2_DayLightweightEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScheduleV2_DayLightweightEventsQuery, ScheduleV2_DayLightweightEventsQueryVariables>(ScheduleV2_DayLightweightEventsDocument, options);
        }
export type ScheduleV2_DayLightweightEventsQueryHookResult = ReturnType<typeof useScheduleV2_DayLightweightEventsQuery>;
export type ScheduleV2_DayLightweightEventsLazyQueryHookResult = ReturnType<typeof useScheduleV2_DayLightweightEventsLazyQuery>;
export type ScheduleV2_DayLightweightEventsQueryResult = Apollo.QueryResult<ScheduleV2_DayLightweightEventsQuery, ScheduleV2_DayLightweightEventsQueryVariables>;
export const ScheduleV2_DayEventsDocument = gql`
    query ScheduleV2_DayEvents($eventIds: [uuid!]!) {
  schedule_Event(where: {id: {_in: $eventIds}}) {
    ...ScheduleV2_Event
  }
}
    ${ScheduleV2_EventFragmentDoc}`;

/**
 * __useScheduleV2_DayEventsQuery__
 *
 * To run a query within a React component, call `useScheduleV2_DayEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useScheduleV2_DayEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScheduleV2_DayEventsQuery({
 *   variables: {
 *      eventIds: // value for 'eventIds'
 *   },
 * });
 */
export function useScheduleV2_DayEventsQuery(baseOptions: Apollo.QueryHookOptions<ScheduleV2_DayEventsQuery, ScheduleV2_DayEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScheduleV2_DayEventsQuery, ScheduleV2_DayEventsQueryVariables>(ScheduleV2_DayEventsDocument, options);
      }
export function useScheduleV2_DayEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScheduleV2_DayEventsQuery, ScheduleV2_DayEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScheduleV2_DayEventsQuery, ScheduleV2_DayEventsQueryVariables>(ScheduleV2_DayEventsDocument, options);
        }
export type ScheduleV2_DayEventsQueryHookResult = ReturnType<typeof useScheduleV2_DayEventsQuery>;
export type ScheduleV2_DayEventsLazyQueryHookResult = ReturnType<typeof useScheduleV2_DayEventsLazyQuery>;
export type ScheduleV2_DayEventsQueryResult = Apollo.QueryResult<ScheduleV2_DayEventsQuery, ScheduleV2_DayEventsQueryVariables>;
export const ScheduleV2_RoomsDocument = gql`
    query ScheduleV2_Rooms($conferenceId: uuid!) {
  room_Room(where: {conferenceId: {_eq: $conferenceId}, events: {}}) {
    ...ScheduleV2_Room
  }
}
    ${ScheduleV2_RoomFragmentDoc}`;

/**
 * __useScheduleV2_RoomsQuery__
 *
 * To run a query within a React component, call `useScheduleV2_RoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useScheduleV2_RoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScheduleV2_RoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useScheduleV2_RoomsQuery(baseOptions: Apollo.QueryHookOptions<ScheduleV2_RoomsQuery, ScheduleV2_RoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScheduleV2_RoomsQuery, ScheduleV2_RoomsQueryVariables>(ScheduleV2_RoomsDocument, options);
      }
export function useScheduleV2_RoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScheduleV2_RoomsQuery, ScheduleV2_RoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScheduleV2_RoomsQuery, ScheduleV2_RoomsQueryVariables>(ScheduleV2_RoomsDocument, options);
        }
export type ScheduleV2_RoomsQueryHookResult = ReturnType<typeof useScheduleV2_RoomsQuery>;
export type ScheduleV2_RoomsLazyQueryHookResult = ReturnType<typeof useScheduleV2_RoomsLazyQuery>;
export type ScheduleV2_RoomsQueryResult = Apollo.QueryResult<ScheduleV2_RoomsQuery, ScheduleV2_RoomsQueryVariables>;
export const ScheduleV2_TagsDocument = gql`
    query ScheduleV2_Tags($conferenceId: uuid!) {
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ScheduleV2_Tag
  }
}
    ${ScheduleV2_TagFragmentDoc}`;

/**
 * __useScheduleV2_TagsQuery__
 *
 * To run a query within a React component, call `useScheduleV2_TagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useScheduleV2_TagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScheduleV2_TagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useScheduleV2_TagsQuery(baseOptions: Apollo.QueryHookOptions<ScheduleV2_TagsQuery, ScheduleV2_TagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScheduleV2_TagsQuery, ScheduleV2_TagsQueryVariables>(ScheduleV2_TagsDocument, options);
      }
export function useScheduleV2_TagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScheduleV2_TagsQuery, ScheduleV2_TagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScheduleV2_TagsQuery, ScheduleV2_TagsQueryVariables>(ScheduleV2_TagsDocument, options);
        }
export type ScheduleV2_TagsQueryHookResult = ReturnType<typeof useScheduleV2_TagsQuery>;
export type ScheduleV2_TagsLazyQueryHookResult = ReturnType<typeof useScheduleV2_TagsLazyQuery>;
export type ScheduleV2_TagsQueryResult = Apollo.QueryResult<ScheduleV2_TagsQuery, ScheduleV2_TagsQueryVariables>;
export const ScheduleV2_AllEvents_ParamsDocument = gql`
    query ScheduleV2_AllEvents_Params($conferenceId: uuid!) {
  earliestStartingEvent: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}}
    limit: 1
    order_by: {startTime: asc}
  ) {
    id
    startTime
  }
  latestEndingEvent: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}}
    limit: 1
    order_by: {endTime: desc}
  ) {
    id
    endTime
  }
}
    `;

/**
 * __useScheduleV2_AllEvents_ParamsQuery__
 *
 * To run a query within a React component, call `useScheduleV2_AllEvents_ParamsQuery` and pass it any options that fit your needs.
 * When your component renders, `useScheduleV2_AllEvents_ParamsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useScheduleV2_AllEvents_ParamsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useScheduleV2_AllEvents_ParamsQuery(baseOptions: Apollo.QueryHookOptions<ScheduleV2_AllEvents_ParamsQuery, ScheduleV2_AllEvents_ParamsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ScheduleV2_AllEvents_ParamsQuery, ScheduleV2_AllEvents_ParamsQueryVariables>(ScheduleV2_AllEvents_ParamsDocument, options);
      }
export function useScheduleV2_AllEvents_ParamsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ScheduleV2_AllEvents_ParamsQuery, ScheduleV2_AllEvents_ParamsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ScheduleV2_AllEvents_ParamsQuery, ScheduleV2_AllEvents_ParamsQueryVariables>(ScheduleV2_AllEvents_ParamsDocument, options);
        }
export type ScheduleV2_AllEvents_ParamsQueryHookResult = ReturnType<typeof useScheduleV2_AllEvents_ParamsQuery>;
export type ScheduleV2_AllEvents_ParamsLazyQueryHookResult = ReturnType<typeof useScheduleV2_AllEvents_ParamsLazyQuery>;
export type ScheduleV2_AllEvents_ParamsQueryResult = Apollo.QueryResult<ScheduleV2_AllEvents_ParamsQuery, ScheduleV2_AllEvents_ParamsQueryVariables>;
export const SearchPanel_ItemsDocument = gql`
    query SearchPanel_Items($conferenceId: uuid!, $search: String!) {
  content_searchItems(args: {conferenceId: $conferenceId, search: $search}) {
    ...SearchPanel_Item
  }
}
    ${SearchPanel_ItemFragmentDoc}`;

/**
 * __useSearchPanel_ItemsQuery__
 *
 * To run a query within a React component, call `useSearchPanel_ItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPanel_ItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPanel_ItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchPanel_ItemsQuery(baseOptions: Apollo.QueryHookOptions<SearchPanel_ItemsQuery, SearchPanel_ItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchPanel_ItemsQuery, SearchPanel_ItemsQueryVariables>(SearchPanel_ItemsDocument, options);
      }
export function useSearchPanel_ItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchPanel_ItemsQuery, SearchPanel_ItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchPanel_ItemsQuery, SearchPanel_ItemsQueryVariables>(SearchPanel_ItemsDocument, options);
        }
export type SearchPanel_ItemsQueryHookResult = ReturnType<typeof useSearchPanel_ItemsQuery>;
export type SearchPanel_ItemsLazyQueryHookResult = ReturnType<typeof useSearchPanel_ItemsLazyQuery>;
export type SearchPanel_ItemsQueryResult = Apollo.QueryResult<SearchPanel_ItemsQuery, SearchPanel_ItemsQueryVariables>;
export const SearchPanel_EventsDocument = gql`
    query SearchPanel_Events($conferenceId: uuid!, $search: String!) {
  schedule_searchEvents(
    args: {conferenceId: $conferenceId, search: $search}
    order_by: [{startTime: asc}, {endTime: asc}, {room: {name: asc}}]
  ) {
    ...SearchPanel_Event
  }
}
    ${SearchPanel_EventFragmentDoc}`;

/**
 * __useSearchPanel_EventsQuery__
 *
 * To run a query within a React component, call `useSearchPanel_EventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPanel_EventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPanel_EventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchPanel_EventsQuery(baseOptions: Apollo.QueryHookOptions<SearchPanel_EventsQuery, SearchPanel_EventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchPanel_EventsQuery, SearchPanel_EventsQueryVariables>(SearchPanel_EventsDocument, options);
      }
export function useSearchPanel_EventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchPanel_EventsQuery, SearchPanel_EventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchPanel_EventsQuery, SearchPanel_EventsQueryVariables>(SearchPanel_EventsDocument, options);
        }
export type SearchPanel_EventsQueryHookResult = ReturnType<typeof useSearchPanel_EventsQuery>;
export type SearchPanel_EventsLazyQueryHookResult = ReturnType<typeof useSearchPanel_EventsLazyQuery>;
export type SearchPanel_EventsQueryResult = Apollo.QueryResult<SearchPanel_EventsQuery, SearchPanel_EventsQueryVariables>;
export const SearchPanel_PeopleDocument = gql`
    query SearchPanel_People($conferenceId: uuid!, $search: String!) {
  collection_searchProgramPerson(
    args: {search: $search, conferenceid: $conferenceId}
  ) {
    ...SearchPanel_Person
  }
}
    ${SearchPanel_PersonFragmentDoc}`;

/**
 * __useSearchPanel_PeopleQuery__
 *
 * To run a query within a React component, call `useSearchPanel_PeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchPanel_PeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchPanel_PeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchPanel_PeopleQuery(baseOptions: Apollo.QueryHookOptions<SearchPanel_PeopleQuery, SearchPanel_PeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchPanel_PeopleQuery, SearchPanel_PeopleQueryVariables>(SearchPanel_PeopleDocument, options);
      }
export function useSearchPanel_PeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchPanel_PeopleQuery, SearchPanel_PeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchPanel_PeopleQuery, SearchPanel_PeopleQueryVariables>(SearchPanel_PeopleDocument, options);
        }
export type SearchPanel_PeopleQueryHookResult = ReturnType<typeof useSearchPanel_PeopleQuery>;
export type SearchPanel_PeopleLazyQueryHookResult = ReturnType<typeof useSearchPanel_PeopleLazyQuery>;
export type SearchPanel_PeopleQueryResult = Apollo.QueryResult<SearchPanel_PeopleQuery, SearchPanel_PeopleQueryVariables>;
export const ConferenceStatsDocument = gql`
    query ConferenceStats($id: uuid!) {
  conference_Conference_by_pk(id: $id) {
    completedRegistrationsStat {
      count
    }
    items(where: {stats: {}}) {
      id
      title
      stats(order_by: [{updated_at: asc}]) {
        id
        itemId
        viewCount
        updated_at
      }
      elements(
        where: {typeName: {_in: [VIDEO_BROADCAST, VIDEO_PREPUBLISH, VIDEO_FILE]}, stats: {}}
      ) {
        id
        name
        stats(order_by: [{updated_at: asc}]) {
          id
          elementId
          viewCount
          updated_at
        }
      }
    }
    rooms(where: {_or: [{managementModeName: {_eq: PUBLIC}}, {events: {}}]}) {
      id
      name
      presenceCounts(order_by: [{created_at: asc}]) {
        created_at
        count
      }
      stats(order_by: [{created_at: asc}]) {
        created_at
        hlsViewCount
      }
      events(order_by: [{startTime: asc}, {endTime: asc}]) {
        id
        name
        item {
          id
          title
        }
        exhibition {
          id
          name
        }
        startTime
        endTime
        intendedRoomModeName
      }
    }
  }
}
    `;

/**
 * __useConferenceStatsQuery__
 *
 * To run a query within a React component, call `useConferenceStatsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceStatsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceStatsQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useConferenceStatsQuery(baseOptions: Apollo.QueryHookOptions<ConferenceStatsQuery, ConferenceStatsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceStatsQuery, ConferenceStatsQueryVariables>(ConferenceStatsDocument, options);
      }
export function useConferenceStatsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceStatsQuery, ConferenceStatsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceStatsQuery, ConferenceStatsQueryVariables>(ConferenceStatsDocument, options);
        }
export type ConferenceStatsQueryHookResult = ReturnType<typeof useConferenceStatsQuery>;
export type ConferenceStatsLazyQueryHookResult = ReturnType<typeof useConferenceStatsLazyQuery>;
export type ConferenceStatsQueryResult = Apollo.QueryResult<ConferenceStatsQuery, ConferenceStatsQueryVariables>;
export const GetChannelStacksDocument = gql`
    query GetChannelStacks($conferenceId: uuid!) {
  room_Room(where: {channelStack: {}, conferenceId: {_eq: $conferenceId}}) {
    channelStack {
      cloudFrontDomain
      endpointUri
      id
    }
    name
    id
  }
}
    `;

/**
 * __useGetChannelStacksQuery__
 *
 * To run a query within a React component, call `useGetChannelStacksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChannelStacksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChannelStacksQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetChannelStacksQuery(baseOptions: Apollo.QueryHookOptions<GetChannelStacksQuery, GetChannelStacksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetChannelStacksQuery, GetChannelStacksQueryVariables>(GetChannelStacksDocument, options);
      }
export function useGetChannelStacksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChannelStacksQuery, GetChannelStacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetChannelStacksQuery, GetChannelStacksQueryVariables>(GetChannelStacksDocument, options);
        }
export type GetChannelStacksQueryHookResult = ReturnType<typeof useGetChannelStacksQuery>;
export type GetChannelStacksLazyQueryHookResult = ReturnType<typeof useGetChannelStacksLazyQuery>;
export type GetChannelStacksQueryResult = Apollo.QueryResult<GetChannelStacksQuery, GetChannelStacksQueryVariables>;
export const ConferenceConfiguration_GetConferenceConfigurationsDocument = gql`
    query ConferenceConfiguration_GetConferenceConfigurations($conferenceId: uuid!) {
  conference_Configuration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConferenceConfiguration_ConferenceConfigurations
  }
}
    ${ConferenceConfiguration_ConferenceConfigurationsFragmentDoc}`;

/**
 * __useConferenceConfiguration_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useConferenceConfiguration_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceConfiguration_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceConfiguration_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferenceConfiguration_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>(ConferenceConfiguration_GetConferenceConfigurationsDocument, options);
      }
export function useConferenceConfiguration_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>(ConferenceConfiguration_GetConferenceConfigurationsDocument, options);
        }
export type ConferenceConfiguration_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useConferenceConfiguration_GetConferenceConfigurationsQuery>;
export type ConferenceConfiguration_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useConferenceConfiguration_GetConferenceConfigurationsLazyQuery>;
export type ConferenceConfiguration_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>;
export const Conference_Configuration_UpdateConferenceConfigurationsDocument = gql`
    mutation conference_Configuration_UpdateConferenceConfigurations($conferenceId: uuid!, $key: conference_ConfigurationKey_enum!, $value: jsonb!) {
  update_conference_Configuration_by_pk(
    pk_columns: {conferenceId: $conferenceId, key: $key}
    _set: {value: $value}
  ) {
    conferenceId
    key
    value
  }
}
    `;
export type Conference_Configuration_UpdateConferenceConfigurationsMutationFn = Apollo.MutationFunction<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>;

/**
 * __useConference_Configuration_UpdateConferenceConfigurationsMutation__
 *
 * To run a mutation, you first call `useConference_Configuration_UpdateConferenceConfigurationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConference_Configuration_UpdateConferenceConfigurationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [conferenceConfigurationUpdateConferenceConfigurationsMutation, { data, loading, error }] = useConference_Configuration_UpdateConferenceConfigurationsMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      key: // value for 'key'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useConference_Configuration_UpdateConferenceConfigurationsMutation(baseOptions?: Apollo.MutationHookOptions<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>(Conference_Configuration_UpdateConferenceConfigurationsDocument, options);
      }
export type Conference_Configuration_UpdateConferenceConfigurationsMutationHookResult = ReturnType<typeof useConference_Configuration_UpdateConferenceConfigurationsMutation>;
export type Conference_Configuration_UpdateConferenceConfigurationsMutationResult = Apollo.MutationResult<Conference_Configuration_UpdateConferenceConfigurationsMutation>;
export type Conference_Configuration_UpdateConferenceConfigurationsMutationOptions = Apollo.BaseMutationOptions<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>;
export const EventVonageControls_GetEventsDocument = gql`
    query EventVonageControls_GetEvents($conferenceId: uuid!) {
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [Q_AND_A, PRESENTATION]}}
  ) {
    id
    name
    item {
      id
      title
    }
  }
}
    `;

/**
 * __useEventVonageControls_GetEventsQuery__
 *
 * To run a query within a React component, call `useEventVonageControls_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventVonageControls_GetEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useEventVonageControls_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, options);
      }
export function useEventVonageControls_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, options);
        }
export type EventVonageControls_GetEventsQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsQuery>;
export type EventVonageControls_GetEventsLazyQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsLazyQuery>;
export type EventVonageControls_GetEventsQueryResult = Apollo.QueryResult<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>;
export const EventVonageControls_StopEventBroadcastDocument = gql`
    mutation EventVonageControls_StopEventBroadcast($eventId: uuid!) {
  stopEventBroadcast(eventId: $eventId) {
    broadcastsStopped
  }
}
    `;
export type EventVonageControls_StopEventBroadcastMutationFn = Apollo.MutationFunction<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;

/**
 * __useEventVonageControls_StopEventBroadcastMutation__
 *
 * To run a mutation, you first call `useEventVonageControls_StopEventBroadcastMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_StopEventBroadcastMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [eventVonageControlsStopEventBroadcastMutation, { data, loading, error }] = useEventVonageControls_StopEventBroadcastMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useEventVonageControls_StopEventBroadcastMutation(baseOptions?: Apollo.MutationHookOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>(EventVonageControls_StopEventBroadcastDocument, options);
      }
export type EventVonageControls_StopEventBroadcastMutationHookResult = ReturnType<typeof useEventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationResult = Apollo.MutationResult<EventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationOptions = Apollo.BaseMutationOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;
export const MonitorLivestreamsDocument = gql`
    query MonitorLivestreams($conferenceId: uuid!, $now: timestamptz!, $later: timestamptz!) {
  liveEvents: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, startTime: {_lte: $later}, endTime: {_gte: $now}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}}
    order_by: [{startTime: asc}, {endTime: asc}, {room: {name: asc}}]
  ) {
    ...MonitorLivestreams_Event
  }
  prerecordedEvents: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, startTime: {_lte: $later}, endTime: {_gte: $now}, intendedRoomModeName: {_in: [PRERECORDED]}}
    order_by: [{startTime: asc}, {endTime: asc}, {room: {name: asc}}]
  ) {
    ...MonitorLivestreams_PrerecEvent
  }
}
    ${MonitorLivestreams_EventFragmentDoc}
${MonitorLivestreams_PrerecEventFragmentDoc}`;

/**
 * __useMonitorLivestreamsQuery__
 *
 * To run a query within a React component, call `useMonitorLivestreamsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMonitorLivestreamsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMonitorLivestreamsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      now: // value for 'now'
 *      later: // value for 'later'
 *   },
 * });
 */
export function useMonitorLivestreamsQuery(baseOptions: Apollo.QueryHookOptions<MonitorLivestreamsQuery, MonitorLivestreamsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MonitorLivestreamsQuery, MonitorLivestreamsQueryVariables>(MonitorLivestreamsDocument, options);
      }
export function useMonitorLivestreamsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MonitorLivestreamsQuery, MonitorLivestreamsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MonitorLivestreamsQuery, MonitorLivestreamsQueryVariables>(MonitorLivestreamsDocument, options);
        }
export type MonitorLivestreamsQueryHookResult = ReturnType<typeof useMonitorLivestreamsQuery>;
export type MonitorLivestreamsLazyQueryHookResult = ReturnType<typeof useMonitorLivestreamsLazyQuery>;
export type MonitorLivestreamsQueryResult = Apollo.QueryResult<MonitorLivestreamsQuery, MonitorLivestreamsQueryVariables>;
export const CreateConferencePrepareJobDocument = gql`
    mutation CreateConferencePrepareJob($conferenceId: uuid!) {
  insert_conference_PrepareJob_one(object: {conferenceId: $conferenceId}) {
    id
    conferenceId
  }
}
    `;
export type CreateConferencePrepareJobMutationFn = Apollo.MutationFunction<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;

/**
 * __useCreateConferencePrepareJobMutation__
 *
 * To run a mutation, you first call `useCreateConferencePrepareJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferencePrepareJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferencePrepareJobMutation, { data, loading, error }] = useCreateConferencePrepareJobMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateConferencePrepareJobMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>(CreateConferencePrepareJobDocument, options);
      }
export type CreateConferencePrepareJobMutationHookResult = ReturnType<typeof useCreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationResult = Apollo.MutationResult<CreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationOptions = Apollo.BaseMutationOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;
export const ConferencePrepareJobSubscriptionDocument = gql`
    subscription ConferencePrepareJobSubscription($conferenceId: uuid!) {
  conference_PrepareJob(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {createdAt: desc}
    limit: 10
  ) {
    id
    jobStatusName
    message
    updatedAt
    createdAt
    videoRenderJobs {
      id
      jobStatusName
      updated_at
      created_at
    }
  }
}
    `;

/**
 * __useConferencePrepareJobSubscriptionSubscription__
 *
 * To run a query within a React component, call `useConferencePrepareJobSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useConferencePrepareJobSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferencePrepareJobSubscriptionSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferencePrepareJobSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>(ConferencePrepareJobSubscriptionDocument, options);
      }
export type ConferencePrepareJobSubscriptionSubscriptionHookResult = ReturnType<typeof useConferencePrepareJobSubscriptionSubscription>;
export type ConferencePrepareJobSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ConferencePrepareJobSubscriptionSubscription>;
export const ManageModeration_SelectFlagsDocument = gql`
    query ManageModeration_SelectFlags($conferenceId: uuid!) {
  chat_Flag(where: {message: {chat: {conferenceId: {_eq: $conferenceId}}}}) {
    ...ManageModeration_ChatFlag
  }
}
    ${ManageModeration_ChatFlagFragmentDoc}`;

/**
 * __useManageModeration_SelectFlagsQuery__
 *
 * To run a query within a React component, call `useManageModeration_SelectFlagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageModeration_SelectFlagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageModeration_SelectFlagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageModeration_SelectFlagsQuery(baseOptions: Apollo.QueryHookOptions<ManageModeration_SelectFlagsQuery, ManageModeration_SelectFlagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageModeration_SelectFlagsQuery, ManageModeration_SelectFlagsQueryVariables>(ManageModeration_SelectFlagsDocument, options);
      }
export function useManageModeration_SelectFlagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageModeration_SelectFlagsQuery, ManageModeration_SelectFlagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageModeration_SelectFlagsQuery, ManageModeration_SelectFlagsQueryVariables>(ManageModeration_SelectFlagsDocument, options);
        }
export type ManageModeration_SelectFlagsQueryHookResult = ReturnType<typeof useManageModeration_SelectFlagsQuery>;
export type ManageModeration_SelectFlagsLazyQueryHookResult = ReturnType<typeof useManageModeration_SelectFlagsLazyQuery>;
export type ManageModeration_SelectFlagsQueryResult = Apollo.QueryResult<ManageModeration_SelectFlagsQuery, ManageModeration_SelectFlagsQueryVariables>;
export const ManageModeration_UpdateFlagDocument = gql`
    mutation ManageModeration_UpdateFlag($flagId: Int!, $update: chat_Flag_set_input!) {
  update_chat_Flag_by_pk(pk_columns: {id: $flagId}, _set: $update) {
    ...ChatFlagData
  }
}
    ${ChatFlagDataFragmentDoc}`;
export type ManageModeration_UpdateFlagMutationFn = Apollo.MutationFunction<ManageModeration_UpdateFlagMutation, ManageModeration_UpdateFlagMutationVariables>;

/**
 * __useManageModeration_UpdateFlagMutation__
 *
 * To run a mutation, you first call `useManageModeration_UpdateFlagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageModeration_UpdateFlagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageModerationUpdateFlagMutation, { data, loading, error }] = useManageModeration_UpdateFlagMutation({
 *   variables: {
 *      flagId: // value for 'flagId'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useManageModeration_UpdateFlagMutation(baseOptions?: Apollo.MutationHookOptions<ManageModeration_UpdateFlagMutation, ManageModeration_UpdateFlagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageModeration_UpdateFlagMutation, ManageModeration_UpdateFlagMutationVariables>(ManageModeration_UpdateFlagDocument, options);
      }
export type ManageModeration_UpdateFlagMutationHookResult = ReturnType<typeof useManageModeration_UpdateFlagMutation>;
export type ManageModeration_UpdateFlagMutationResult = Apollo.MutationResult<ManageModeration_UpdateFlagMutation>;
export type ManageModeration_UpdateFlagMutationOptions = Apollo.BaseMutationOptions<ManageModeration_UpdateFlagMutation, ManageModeration_UpdateFlagMutationVariables>;
export const PreshowChecklistDocument = gql`
    query PreshowChecklist($conferenceId: uuid!, $now: timestamptz!) {
  requiredProgramPeopleNotLinkedToRegistrant: collection_ProgramPersonWithAccessToken(
    where: {conferenceId: {_eq: $conferenceId}, eventPeople: {event: {intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, endTime: {_gte: $now}}}, registrantId: {_is_null: true}}
  ) {
    id
    name
    affiliation
    email
  }
  requiredProgramPeopleNotRegistered: collection_ProgramPersonWithAccessToken(
    where: {conferenceId: {_eq: $conferenceId}, eventPeople: {event: {intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, endTime: {_gte: $now}}}, registrant: {userId: {_is_null: true}}}
  ) {
    id
    name
    affiliation
    email
  }
  submissionsNotReceived: content_Element(
    where: {conferenceId: {_eq: $conferenceId}, data: {_eq: []}}
  ) {
    id
    name
    typeName
    item {
      id
      title
    }
  }
  livestreamEventsWithoutRegisteredPresenter: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, _not: {eventPeople: {roleName: {_eq: PRESENTER}, person: {registrantId: {_is_null: false}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  livestreamEventsWithoutRegisteredChair: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, _not: {eventPeople: {roleName: {_eq: CHAIR}, person: {registrantId: {_is_null: false}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  prerecordedEventsWithoutVideo: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_eq: PRERECORDED}, _not: {item: {elements: {typeName: {_eq: VIDEO_BROADCAST}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  prerecordedEventsWithVideo: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_eq: PRERECORDED}, item: {elements: {typeName: {_eq: VIDEO_BROADCAST}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
      elements(where: {typeName: {_eq: VIDEO_BROADCAST}}) {
        id
        name
        data
      }
    }
  }
  zoomEvents: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_eq: ZOOM}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
      elements(where: {typeName: {_eq: ZOOM}}) {
        id
        name
        data
      }
    }
  }
  allLiveEventsWithPeople: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}}
  ) {
    id
    name
    intendedRoomModeName
    room {
      id
      name
    }
    item {
      id
      title
      itemPeopleWithRegistrant: itemPeople(
        where: {person: {registrantId: {_is_null: false}}}
      ) {
        personId
      }
      itemPeopleWithoutRegistrant: itemPeople(
        where: {person: {registrantId: {_is_null: true}}}
      ) {
        personId
      }
    }
    exhibition {
      id
      name
    }
    startTime
    endTime
    eventPeople {
      id
      personId
    }
  }
  emptyExhibitions: collection_Exhibition(
    where: {conferenceId: {_eq: $conferenceId}, _not: {items: {}}}
  ) {
    id
    name
  }
  emptyTags: collection_Tag(
    where: {conferenceId: {_eq: $conferenceId}, _not: {itemTags: {}}}
  ) {
    id
    name
  }
  exhibitionEventsWithoutExhibition: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [EXHIBITION]}, exhibitionId: {_is_null: true}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
  }
  exhibitionEventsWithoutDiscussionRooms: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [EXHIBITION, NONE]}, exhibition: {items: {item: {_not: {rooms: {}}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    exhibition {
      id
      name
      items(where: {item: {_not: {rooms: {}}}}) {
        id
        item {
          id
          title
        }
      }
    }
  }
  liveEventsWithoutContent: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, itemId: {_is_null: true}}
  ) {
    id
    name
    startTime
    endTime
    item {
      id
      title
    }
    room {
      id
      name
    }
  }
  overlappingEvents: schedule_OverlappingEvents(
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    eventX {
      id
      name
      startTime
      endTime
      room {
        id
        name
      }
    }
    eventY {
      id
      name
      startTime
      endTime
    }
  }
  shortEvents: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, durationSeconds: {_lte: 60}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  roomsWithStreams: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, livestreamDuration: {}}
  ) {
    id
    name
    livestreamDuration {
      sum
    }
  }
  eventsWithNegativeDuration: schedule_Event(
    where: {endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, durationSeconds: {_lt: 0}}
  ) {
    id
    name
    startTime
    durationSeconds
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
}
    `;

/**
 * __usePreshowChecklistQuery__
 *
 * To run a query within a React component, call `usePreshowChecklistQuery` and pass it any options that fit your needs.
 * When your component renders, `usePreshowChecklistQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePreshowChecklistQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      now: // value for 'now'
 *   },
 * });
 */
export function usePreshowChecklistQuery(baseOptions: Apollo.QueryHookOptions<PreshowChecklistQuery, PreshowChecklistQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PreshowChecklistQuery, PreshowChecklistQueryVariables>(PreshowChecklistDocument, options);
      }
export function usePreshowChecklistLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PreshowChecklistQuery, PreshowChecklistQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PreshowChecklistQuery, PreshowChecklistQueryVariables>(PreshowChecklistDocument, options);
        }
export type PreshowChecklistQueryHookResult = ReturnType<typeof usePreshowChecklistQuery>;
export type PreshowChecklistLazyQueryHookResult = ReturnType<typeof usePreshowChecklistLazyQuery>;
export type PreshowChecklistQueryResult = Apollo.QueryResult<PreshowChecklistQuery, PreshowChecklistQueryVariables>;
export const ManageContent_SelectAllItemsDocument = gql`
    query ManageContent_SelectAllItems($conferenceId: uuid!) {
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContent_Item
  }
}
    ${ManageContent_ItemFragmentDoc}`;

/**
 * __useManageContent_SelectAllItemsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectAllItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectAllItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectAllItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectAllItemsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>(ManageContent_SelectAllItemsDocument, options);
      }
export function useManageContent_SelectAllItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>(ManageContent_SelectAllItemsDocument, options);
        }
export type ManageContent_SelectAllItemsQueryHookResult = ReturnType<typeof useManageContent_SelectAllItemsQuery>;
export type ManageContent_SelectAllItemsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectAllItemsLazyQuery>;
export type ManageContent_SelectAllItemsQueryResult = Apollo.QueryResult<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>;
export const ManageContent_SelectItemsForExportDocument = gql`
    query ManageContent_SelectItemsForExport($itemIds: [uuid!]!) {
  content_Item(where: {id: {_in: $itemIds}}) {
    ...ManageContent_ItemForExport
  }
}
    ${ManageContent_ItemForExportFragmentDoc}`;

/**
 * __useManageContent_SelectItemsForExportQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectItemsForExportQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectItemsForExportQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectItemsForExportQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useManageContent_SelectItemsForExportQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectItemsForExportQuery, ManageContent_SelectItemsForExportQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectItemsForExportQuery, ManageContent_SelectItemsForExportQueryVariables>(ManageContent_SelectItemsForExportDocument, options);
      }
export function useManageContent_SelectItemsForExportLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectItemsForExportQuery, ManageContent_SelectItemsForExportQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectItemsForExportQuery, ManageContent_SelectItemsForExportQueryVariables>(ManageContent_SelectItemsForExportDocument, options);
        }
export type ManageContent_SelectItemsForExportQueryHookResult = ReturnType<typeof useManageContent_SelectItemsForExportQuery>;
export type ManageContent_SelectItemsForExportLazyQueryHookResult = ReturnType<typeof useManageContent_SelectItemsForExportLazyQuery>;
export type ManageContent_SelectItemsForExportQueryResult = Apollo.QueryResult<ManageContent_SelectItemsForExportQuery, ManageContent_SelectItemsForExportQueryVariables>;
export const ManageContent_SelectItemDocument = gql`
    query ManageContent_SelectItem($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    ...ManageContent_ItemSecondary
  }
  content_Element(where: {itemId: {_eq: $itemId}}) {
    ...ManageContent_Element
  }
}
    ${ManageContent_ItemSecondaryFragmentDoc}
${ManageContent_ElementFragmentDoc}`;

/**
 * __useManageContent_SelectItemQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectItemQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useManageContent_SelectItemQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>(ManageContent_SelectItemDocument, options);
      }
export function useManageContent_SelectItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>(ManageContent_SelectItemDocument, options);
        }
export type ManageContent_SelectItemQueryHookResult = ReturnType<typeof useManageContent_SelectItemQuery>;
export type ManageContent_SelectItemLazyQueryHookResult = ReturnType<typeof useManageContent_SelectItemLazyQuery>;
export type ManageContent_SelectItemQueryResult = Apollo.QueryResult<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>;
export const ManageContent_SelectItemPeopleDocument = gql`
    query ManageContent_SelectItemPeople($itemId: uuid!) {
  content_ItemProgramPerson(where: {itemId: {_eq: $itemId}}) {
    ...ManageContent_ItemProgramPerson
  }
}
    ${ManageContent_ItemProgramPersonFragmentDoc}`;

/**
 * __useManageContent_SelectItemPeopleQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectItemPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectItemPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectItemPeopleQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useManageContent_SelectItemPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>(ManageContent_SelectItemPeopleDocument, options);
      }
export function useManageContent_SelectItemPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>(ManageContent_SelectItemPeopleDocument, options);
        }
export type ManageContent_SelectItemPeopleQueryHookResult = ReturnType<typeof useManageContent_SelectItemPeopleQuery>;
export type ManageContent_SelectItemPeopleLazyQueryHookResult = ReturnType<typeof useManageContent_SelectItemPeopleLazyQuery>;
export type ManageContent_SelectItemPeopleQueryResult = Apollo.QueryResult<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>;
export const ManageContent_InsertItemDocument = gql`
    mutation ManageContent_InsertItem($item: content_Item_insert_input!, $itemTags: [content_ItemTag_insert_input!]!) {
  insert_content_Item_one(object: $item) {
    ...ManageContent_Item
  }
  insert_content_ItemTag(objects: $itemTags) {
    returning {
      id
    }
  }
}
    ${ManageContent_ItemFragmentDoc}`;
export type ManageContent_InsertItemMutationFn = Apollo.MutationFunction<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>;

/**
 * __useManageContent_InsertItemMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertItemMutation, { data, loading, error }] = useManageContent_InsertItemMutation({
 *   variables: {
 *      item: // value for 'item'
 *      itemTags: // value for 'itemTags'
 *   },
 * });
 */
export function useManageContent_InsertItemMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>(ManageContent_InsertItemDocument, options);
      }
export type ManageContent_InsertItemMutationHookResult = ReturnType<typeof useManageContent_InsertItemMutation>;
export type ManageContent_InsertItemMutationResult = Apollo.MutationResult<ManageContent_InsertItemMutation>;
export type ManageContent_InsertItemMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>;
export const ManageContent_UpdateItemDocument = gql`
    mutation ManageContent_UpdateItem($id: uuid!, $item: content_Item_set_input!, $tags: [content_ItemTag_insert_input!]!, $tagIds: [uuid!]!) {
  insert_content_ItemTag(
    objects: $tags
    on_conflict: {constraint: ItemTag_itemId_tagId_key, update_columns: []}
  ) {
    returning {
      ...ManageContent_ItemTag
    }
  }
  delete_content_ItemTag(where: {tagId: {_nin: $tagIds}, itemId: {_eq: $id}}) {
    returning {
      id
    }
  }
  update_content_Item_by_pk(pk_columns: {id: $id}, _set: $item) {
    ...ManageContent_Item
  }
}
    ${ManageContent_ItemTagFragmentDoc}
${ManageContent_ItemFragmentDoc}`;
export type ManageContent_UpdateItemMutationFn = Apollo.MutationFunction<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>;

/**
 * __useManageContent_UpdateItemMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateItemMutation, { data, loading, error }] = useManageContent_UpdateItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *      item: // value for 'item'
 *      tags: // value for 'tags'
 *      tagIds: // value for 'tagIds'
 *   },
 * });
 */
export function useManageContent_UpdateItemMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>(ManageContent_UpdateItemDocument, options);
      }
export type ManageContent_UpdateItemMutationHookResult = ReturnType<typeof useManageContent_UpdateItemMutation>;
export type ManageContent_UpdateItemMutationResult = Apollo.MutationResult<ManageContent_UpdateItemMutation>;
export type ManageContent_UpdateItemMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>;
export const ManageContent_DeleteItemsDocument = gql`
    mutation ManageContent_DeleteItems($ids: [uuid!]!) {
  delete_content_Item(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContent_DeleteItemsMutationFn = Apollo.MutationFunction<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>;

/**
 * __useManageContent_DeleteItemsMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteItemsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteItemsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteItemsMutation, { data, loading, error }] = useManageContent_DeleteItemsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContent_DeleteItemsMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>(ManageContent_DeleteItemsDocument, options);
      }
export type ManageContent_DeleteItemsMutationHookResult = ReturnType<typeof useManageContent_DeleteItemsMutation>;
export type ManageContent_DeleteItemsMutationResult = Apollo.MutationResult<ManageContent_DeleteItemsMutation>;
export type ManageContent_DeleteItemsMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>;
export const ManageContent_SelectAllTagsDocument = gql`
    query ManageContent_SelectAllTags($conferenceId: uuid!) {
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContent_Tag
  }
}
    ${ManageContent_TagFragmentDoc}`;

/**
 * __useManageContent_SelectAllTagsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectAllTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectAllTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectAllTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectAllTagsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>(ManageContent_SelectAllTagsDocument, options);
      }
export function useManageContent_SelectAllTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>(ManageContent_SelectAllTagsDocument, options);
        }
export type ManageContent_SelectAllTagsQueryHookResult = ReturnType<typeof useManageContent_SelectAllTagsQuery>;
export type ManageContent_SelectAllTagsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectAllTagsLazyQuery>;
export type ManageContent_SelectAllTagsQueryResult = Apollo.QueryResult<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>;
export const ManageContent_SelectAllExhibitionsDocument = gql`
    query ManageContent_SelectAllExhibitions($conferenceId: uuid!) {
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContent_Exhibition
  }
}
    ${ManageContent_ExhibitionFragmentDoc}`;

/**
 * __useManageContent_SelectAllExhibitionsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectAllExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectAllExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectAllExhibitionsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectAllExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>(ManageContent_SelectAllExhibitionsDocument, options);
      }
export function useManageContent_SelectAllExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>(ManageContent_SelectAllExhibitionsDocument, options);
        }
export type ManageContent_SelectAllExhibitionsQueryHookResult = ReturnType<typeof useManageContent_SelectAllExhibitionsQuery>;
export type ManageContent_SelectAllExhibitionsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectAllExhibitionsLazyQuery>;
export type ManageContent_SelectAllExhibitionsQueryResult = Apollo.QueryResult<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>;
export const SelectAllContentDocument = gql`
    query SelectAllContent($conferenceId: uuid!) {
  content_Item(
    where: {conferenceId: {_eq: $conferenceId}, typeName: {_neq: SPONSOR}}
  ) {
    ...ItemFullNestedInfo
  }
  collection_ProgramPersonWithAccessToken(
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    ...ProgramPersonInfo
  }
  conference_OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ExhibitionInfo
  }
}
    ${ItemFullNestedInfoFragmentDoc}
${ProgramPersonInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${ExhibitionInfoFragmentDoc}`;

/**
 * __useSelectAllContentQuery__
 *
 * To run a query within a React component, call `useSelectAllContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllContentQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllContentQuery(baseOptions: Apollo.QueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, options);
      }
export function useSelectAllContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, options);
        }
export type SelectAllContentQueryHookResult = ReturnType<typeof useSelectAllContentQuery>;
export type SelectAllContentLazyQueryHookResult = ReturnType<typeof useSelectAllContentLazyQuery>;
export type SelectAllContentQueryResult = Apollo.QueryResult<SelectAllContentQuery, SelectAllContentQueryVariables>;
export const InsertDeleteItemsDocument = gql`
    mutation InsertDeleteItems($newGroups: [content_Item_insert_input!]!, $deleteGroupIds: [uuid!]!) {
  insert_content_Item(objects: $newGroups) {
    returning {
      ...ItemFullNestedInfo
    }
  }
  delete_content_Item(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
}
    ${ItemFullNestedInfoFragmentDoc}`;
export type InsertDeleteItemsMutationFn = Apollo.MutationFunction<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>;

/**
 * __useInsertDeleteItemsMutation__
 *
 * To run a mutation, you first call `useInsertDeleteItemsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertDeleteItemsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertDeleteItemsMutation, { data, loading, error }] = useInsertDeleteItemsMutation({
 *   variables: {
 *      newGroups: // value for 'newGroups'
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *   },
 * });
 */
export function useInsertDeleteItemsMutation(baseOptions?: Apollo.MutationHookOptions<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>(InsertDeleteItemsDocument, options);
      }
export type InsertDeleteItemsMutationHookResult = ReturnType<typeof useInsertDeleteItemsMutation>;
export type InsertDeleteItemsMutationResult = Apollo.MutationResult<InsertDeleteItemsMutation>;
export type InsertDeleteItemsMutationOptions = Apollo.BaseMutationOptions<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>;
export const InsertElementsDocument = gql`
    mutation InsertElements($newElements: [content_Element_insert_input!]!) {
  insert_content_Element(objects: $newElements) {
    returning {
      ...ElementInfo
    }
  }
}
    ${ElementInfoFragmentDoc}`;
export type InsertElementsMutationFn = Apollo.MutationFunction<InsertElementsMutation, InsertElementsMutationVariables>;

/**
 * __useInsertElementsMutation__
 *
 * To run a mutation, you first call `useInsertElementsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertElementsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertElementsMutation, { data, loading, error }] = useInsertElementsMutation({
 *   variables: {
 *      newElements: // value for 'newElements'
 *   },
 * });
 */
export function useInsertElementsMutation(baseOptions?: Apollo.MutationHookOptions<InsertElementsMutation, InsertElementsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertElementsMutation, InsertElementsMutationVariables>(InsertElementsDocument, options);
      }
export type InsertElementsMutationHookResult = ReturnType<typeof useInsertElementsMutation>;
export type InsertElementsMutationResult = Apollo.MutationResult<InsertElementsMutation>;
export type InsertElementsMutationOptions = Apollo.BaseMutationOptions<InsertElementsMutation, InsertElementsMutationVariables>;
export const InsertOriginatingDatasDocument = gql`
    mutation InsertOriginatingDatas($newDatas: [conference_OriginatingData_insert_input!]!) {
  insert_conference_OriginatingData(objects: $newDatas) {
    returning {
      ...OriginatingDataInfo
    }
  }
}
    ${OriginatingDataInfoFragmentDoc}`;
export type InsertOriginatingDatasMutationFn = Apollo.MutationFunction<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;

/**
 * __useInsertOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useInsertOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertOriginatingDatasMutation, { data, loading, error }] = useInsertOriginatingDatasMutation({
 *   variables: {
 *      newDatas: // value for 'newDatas'
 *   },
 * });
 */
export function useInsertOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>(InsertOriginatingDatasDocument, options);
      }
export type InsertOriginatingDatasMutationHookResult = ReturnType<typeof useInsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationResult = Apollo.MutationResult<InsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;
export const DeleteOriginatingDatasDocument = gql`
    mutation DeleteOriginatingDatas($deleteDataIds: [uuid!]!) {
  delete_conference_OriginatingData(where: {id: {_in: $deleteDataIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteOriginatingDatasMutationFn = Apollo.MutationFunction<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;

/**
 * __useDeleteOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useDeleteOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOriginatingDatasMutation, { data, loading, error }] = useDeleteOriginatingDatasMutation({
 *   variables: {
 *      deleteDataIds: // value for 'deleteDataIds'
 *   },
 * });
 */
export function useDeleteOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>(DeleteOriginatingDatasDocument, options);
      }
export type DeleteOriginatingDatasMutationHookResult = ReturnType<typeof useDeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationResult = Apollo.MutationResult<DeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;
export const InsertTagsDocument = gql`
    mutation InsertTags($newTags: [collection_Tag_insert_input!]!) {
  insert_collection_Tag(objects: $newTags) {
    returning {
      ...TagInfo
    }
  }
}
    ${TagInfoFragmentDoc}`;
export type InsertTagsMutationFn = Apollo.MutationFunction<InsertTagsMutation, InsertTagsMutationVariables>;

/**
 * __useInsertTagsMutation__
 *
 * To run a mutation, you first call `useInsertTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertTagsMutation, { data, loading, error }] = useInsertTagsMutation({
 *   variables: {
 *      newTags: // value for 'newTags'
 *   },
 * });
 */
export function useInsertTagsMutation(baseOptions?: Apollo.MutationHookOptions<InsertTagsMutation, InsertTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertTagsMutation, InsertTagsMutationVariables>(InsertTagsDocument, options);
      }
export type InsertTagsMutationHookResult = ReturnType<typeof useInsertTagsMutation>;
export type InsertTagsMutationResult = Apollo.MutationResult<InsertTagsMutation>;
export type InsertTagsMutationOptions = Apollo.BaseMutationOptions<InsertTagsMutation, InsertTagsMutationVariables>;
export const InsertExhibitionsDocument = gql`
    mutation InsertExhibitions($newExhibitions: [collection_Exhibition_insert_input!]!) {
  insert_collection_Exhibition(objects: $newExhibitions) {
    returning {
      ...ExhibitionInfo
    }
  }
}
    ${ExhibitionInfoFragmentDoc}`;
export type InsertExhibitionsMutationFn = Apollo.MutationFunction<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>;

/**
 * __useInsertExhibitionsMutation__
 *
 * To run a mutation, you first call `useInsertExhibitionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertExhibitionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertExhibitionsMutation, { data, loading, error }] = useInsertExhibitionsMutation({
 *   variables: {
 *      newExhibitions: // value for 'newExhibitions'
 *   },
 * });
 */
export function useInsertExhibitionsMutation(baseOptions?: Apollo.MutationHookOptions<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>(InsertExhibitionsDocument, options);
      }
export type InsertExhibitionsMutationHookResult = ReturnType<typeof useInsertExhibitionsMutation>;
export type InsertExhibitionsMutationResult = Apollo.MutationResult<InsertExhibitionsMutation>;
export type InsertExhibitionsMutationOptions = Apollo.BaseMutationOptions<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>;
export const DeleteTagsDocument = gql`
    mutation DeleteTags($deleteTagIds: [uuid!]!) {
  delete_collection_Tag(where: {id: {_in: $deleteTagIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteTagsMutationFn = Apollo.MutationFunction<DeleteTagsMutation, DeleteTagsMutationVariables>;

/**
 * __useDeleteTagsMutation__
 *
 * To run a mutation, you first call `useDeleteTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTagsMutation, { data, loading, error }] = useDeleteTagsMutation({
 *   variables: {
 *      deleteTagIds: // value for 'deleteTagIds'
 *   },
 * });
 */
export function useDeleteTagsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTagsMutation, DeleteTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTagsMutation, DeleteTagsMutationVariables>(DeleteTagsDocument, options);
      }
export type DeleteTagsMutationHookResult = ReturnType<typeof useDeleteTagsMutation>;
export type DeleteTagsMutationResult = Apollo.MutationResult<DeleteTagsMutation>;
export type DeleteTagsMutationOptions = Apollo.BaseMutationOptions<DeleteTagsMutation, DeleteTagsMutationVariables>;
export const DeleteExhibitionsDocument = gql`
    mutation DeleteExhibitions($deleteExhibitionIds: [uuid!]!) {
  delete_collection_Exhibition(where: {id: {_in: $deleteExhibitionIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteExhibitionsMutationFn = Apollo.MutationFunction<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>;

/**
 * __useDeleteExhibitionsMutation__
 *
 * To run a mutation, you first call `useDeleteExhibitionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteExhibitionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteExhibitionsMutation, { data, loading, error }] = useDeleteExhibitionsMutation({
 *   variables: {
 *      deleteExhibitionIds: // value for 'deleteExhibitionIds'
 *   },
 * });
 */
export function useDeleteExhibitionsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>(DeleteExhibitionsDocument, options);
      }
export type DeleteExhibitionsMutationHookResult = ReturnType<typeof useDeleteExhibitionsMutation>;
export type DeleteExhibitionsMutationResult = Apollo.MutationResult<DeleteExhibitionsMutation>;
export type DeleteExhibitionsMutationOptions = Apollo.BaseMutationOptions<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>;
export const InsertProgramPeopleDocument = gql`
    mutation InsertProgramPeople($newPeople: [collection_ProgramPersonWithAccessToken_insert_input!]!) {
  insert_collection_ProgramPersonWithAccessToken(objects: $newPeople) {
    returning {
      ...ProgramPersonInfo
    }
  }
}
    ${ProgramPersonInfoFragmentDoc}`;
export type InsertProgramPeopleMutationFn = Apollo.MutationFunction<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>;

/**
 * __useInsertProgramPeopleMutation__
 *
 * To run a mutation, you first call `useInsertProgramPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertProgramPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertProgramPeopleMutation, { data, loading, error }] = useInsertProgramPeopleMutation({
 *   variables: {
 *      newPeople: // value for 'newPeople'
 *   },
 * });
 */
export function useInsertProgramPeopleMutation(baseOptions?: Apollo.MutationHookOptions<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>(InsertProgramPeopleDocument, options);
      }
export type InsertProgramPeopleMutationHookResult = ReturnType<typeof useInsertProgramPeopleMutation>;
export type InsertProgramPeopleMutationResult = Apollo.MutationResult<InsertProgramPeopleMutation>;
export type InsertProgramPeopleMutationOptions = Apollo.BaseMutationOptions<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>;
export const DeleteProgramPeopleDocument = gql`
    mutation DeleteProgramPeople($deletePersonIds: [uuid!]!) {
  delete_collection_ProgramPersonWithAccessToken(
    where: {id: {_in: $deletePersonIds}}
  ) {
    returning {
      id
    }
  }
}
    `;
export type DeleteProgramPeopleMutationFn = Apollo.MutationFunction<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>;

/**
 * __useDeleteProgramPeopleMutation__
 *
 * To run a mutation, you first call `useDeleteProgramPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProgramPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProgramPeopleMutation, { data, loading, error }] = useDeleteProgramPeopleMutation({
 *   variables: {
 *      deletePersonIds: // value for 'deletePersonIds'
 *   },
 * });
 */
export function useDeleteProgramPeopleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>(DeleteProgramPeopleDocument, options);
      }
export type DeleteProgramPeopleMutationHookResult = ReturnType<typeof useDeleteProgramPeopleMutation>;
export type DeleteProgramPeopleMutationResult = Apollo.MutationResult<DeleteProgramPeopleMutation>;
export type DeleteProgramPeopleMutationOptions = Apollo.BaseMutationOptions<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>;
export const UpdateItemDocument = gql`
    mutation UpdateItem($newItems: [content_Element_insert_input!]!, $newGroupTags: [content_ItemTag_insert_input!]!, $newGroupExhibitions: [content_ItemExhibition_insert_input!]!, $groupId: uuid!, $typeName: content_ItemType_enum!, $originatingDataId: uuid = null, $shortTitle: String = null, $title: String!, $deleteItemIds: [uuid!]!, $deleteGroupTagIds: [uuid!]!, $deleteGroupExhibitionIds: [uuid!]!, $newGroupPeople: [content_ItemProgramPerson_insert_input!]!, $deleteGroupPeopleIds: [uuid!]!) {
  insert_content_Element(objects: $newItems) {
    returning {
      ...ElementInfo
    }
  }
  insert_content_ItemTag(objects: $newGroupTags) {
    returning {
      ...ItemTagInfo
    }
  }
  insert_content_ItemExhibition(objects: $newGroupExhibitions) {
    returning {
      ...ItemExhibitionInfo
    }
  }
  insert_content_ItemProgramPerson(objects: $newGroupPeople) {
    returning {
      ...ItemPersonInfo
    }
  }
  update_content_Item_by_pk(
    pk_columns: {id: $groupId}
    _set: {typeName: $typeName, originatingDataId: $originatingDataId, shortTitle: $shortTitle, title: $title}
  ) {
    ...ItemFullNestedInfo
  }
  delete_content_Element(where: {id: {_in: $deleteItemIds}}) {
    returning {
      id
    }
  }
  delete_content_ItemTag(
    where: {itemId: {_eq: $groupId}, tagId: {_in: $deleteGroupTagIds}}
  ) {
    returning {
      id
    }
  }
  delete_content_ItemExhibition(where: {id: {_in: $deleteGroupExhibitionIds}}) {
    returning {
      id
    }
  }
  delete_content_ItemProgramPerson(where: {id: {_in: $deleteGroupPeopleIds}}) {
    returning {
      id
    }
  }
}
    ${ElementInfoFragmentDoc}
${ItemTagInfoFragmentDoc}
${ItemExhibitionInfoFragmentDoc}
${ItemPersonInfoFragmentDoc}
${ItemFullNestedInfoFragmentDoc}`;
export type UpdateItemMutationFn = Apollo.MutationFunction<UpdateItemMutation, UpdateItemMutationVariables>;

/**
 * __useUpdateItemMutation__
 *
 * To run a mutation, you first call `useUpdateItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateItemMutation, { data, loading, error }] = useUpdateItemMutation({
 *   variables: {
 *      newItems: // value for 'newItems'
 *      newGroupTags: // value for 'newGroupTags'
 *      newGroupExhibitions: // value for 'newGroupExhibitions'
 *      groupId: // value for 'groupId'
 *      typeName: // value for 'typeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      shortTitle: // value for 'shortTitle'
 *      title: // value for 'title'
 *      deleteItemIds: // value for 'deleteItemIds'
 *      deleteGroupTagIds: // value for 'deleteGroupTagIds'
 *      deleteGroupExhibitionIds: // value for 'deleteGroupExhibitionIds'
 *      newGroupPeople: // value for 'newGroupPeople'
 *      deleteGroupPeopleIds: // value for 'deleteGroupPeopleIds'
 *   },
 * });
 */
export function useUpdateItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateItemMutation, UpdateItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateItemMutation, UpdateItemMutationVariables>(UpdateItemDocument, options);
      }
export type UpdateItemMutationHookResult = ReturnType<typeof useUpdateItemMutation>;
export type UpdateItemMutationResult = Apollo.MutationResult<UpdateItemMutation>;
export type UpdateItemMutationOptions = Apollo.BaseMutationOptions<UpdateItemMutation, UpdateItemMutationVariables>;
export const UpdateElementDocument = gql`
    mutation UpdateElement($id: uuid!, $typeName: content_ElementType_enum!, $layoutData: jsonb = null, $name: String!, $data: jsonb!, $isHidden: Boolean!, $originatingDataId: uuid = null, $uploadsRemaining: Int = null) {
  update_content_Element_by_pk(
    pk_columns: {id: $id}
    _set: {typeName: $typeName, layoutData: $layoutData, name: $name, data: $data, isHidden: $isHidden, originatingDataId: $originatingDataId, uploadsRemaining: $uploadsRemaining}
  ) {
    ...ElementInfo
  }
}
    ${ElementInfoFragmentDoc}`;
export type UpdateElementMutationFn = Apollo.MutationFunction<UpdateElementMutation, UpdateElementMutationVariables>;

/**
 * __useUpdateElementMutation__
 *
 * To run a mutation, you first call `useUpdateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateElementMutation, { data, loading, error }] = useUpdateElementMutation({
 *   variables: {
 *      id: // value for 'id'
 *      typeName: // value for 'typeName'
 *      layoutData: // value for 'layoutData'
 *      name: // value for 'name'
 *      data: // value for 'data'
 *      isHidden: // value for 'isHidden'
 *      originatingDataId: // value for 'originatingDataId'
 *      uploadsRemaining: // value for 'uploadsRemaining'
 *   },
 * });
 */
export function useUpdateElementMutation(baseOptions?: Apollo.MutationHookOptions<UpdateElementMutation, UpdateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateElementMutation, UpdateElementMutationVariables>(UpdateElementDocument, options);
      }
export type UpdateElementMutationHookResult = ReturnType<typeof useUpdateElementMutation>;
export type UpdateElementMutationResult = Apollo.MutationResult<UpdateElementMutation>;
export type UpdateElementMutationOptions = Apollo.BaseMutationOptions<UpdateElementMutation, UpdateElementMutationVariables>;
export const UpdateGroupPersonDocument = gql`
    mutation UpdateGroupPerson($id: uuid!, $roleName: String!, $priority: Int = null) {
  update_content_ItemProgramPerson_by_pk(
    pk_columns: {id: $id}
    _set: {roleName: $roleName, priority: $priority}
  ) {
    ...ItemPersonInfo
  }
}
    ${ItemPersonInfoFragmentDoc}`;
export type UpdateGroupPersonMutationFn = Apollo.MutationFunction<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;

/**
 * __useUpdateGroupPersonMutation__
 *
 * To run a mutation, you first call `useUpdateGroupPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupPersonMutation, { data, loading, error }] = useUpdateGroupPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      roleName: // value for 'roleName'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateGroupPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>(UpdateGroupPersonDocument, options);
      }
export type UpdateGroupPersonMutationHookResult = ReturnType<typeof useUpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationResult = Apollo.MutationResult<UpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationOptions = Apollo.BaseMutationOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;
export const UpdateGroupExhibitionDocument = gql`
    mutation UpdateGroupExhibition($id: uuid!, $priority: Int = null, $layout: jsonb = null) {
  update_content_ItemExhibition_by_pk(
    pk_columns: {id: $id}
    _set: {layout: $layout, priority: $priority}
  ) {
    ...ItemExhibitionInfo
  }
}
    ${ItemExhibitionInfoFragmentDoc}`;
export type UpdateGroupExhibitionMutationFn = Apollo.MutationFunction<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>;

/**
 * __useUpdateGroupExhibitionMutation__
 *
 * To run a mutation, you first call `useUpdateGroupExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupExhibitionMutation, { data, loading, error }] = useUpdateGroupExhibitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      priority: // value for 'priority'
 *      layout: // value for 'layout'
 *   },
 * });
 */
export function useUpdateGroupExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>(UpdateGroupExhibitionDocument, options);
      }
export type UpdateGroupExhibitionMutationHookResult = ReturnType<typeof useUpdateGroupExhibitionMutation>;
export type UpdateGroupExhibitionMutationResult = Apollo.MutationResult<UpdateGroupExhibitionMutation>;
export type UpdateGroupExhibitionMutationOptions = Apollo.BaseMutationOptions<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>;
export const UpdatePersonDocument = gql`
    mutation UpdatePerson($id: uuid!, $name: String!, $affiliation: String = null, $email: String = null, $originatingDataId: uuid = null, $registrantId: uuid = null) {
  update_collection_ProgramPersonWithAccessToken(
    where: {id: {_eq: $id}}
    _set: {name: $name, affiliation: $affiliation, email: $email, originatingDataId: $originatingDataId, registrantId: $registrantId}
  ) {
    returning {
      ...ProgramPersonInfo
    }
  }
}
    ${ProgramPersonInfoFragmentDoc}`;
export type UpdatePersonMutationFn = Apollo.MutationFunction<UpdatePersonMutation, UpdatePersonMutationVariables>;

/**
 * __useUpdatePersonMutation__
 *
 * To run a mutation, you first call `useUpdatePersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePersonMutation, { data, loading, error }] = useUpdatePersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      email: // value for 'email'
 *      originatingDataId: // value for 'originatingDataId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUpdatePersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePersonMutation, UpdatePersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePersonMutation, UpdatePersonMutationVariables>(UpdatePersonDocument, options);
      }
export type UpdatePersonMutationHookResult = ReturnType<typeof useUpdatePersonMutation>;
export type UpdatePersonMutationResult = Apollo.MutationResult<UpdatePersonMutation>;
export type UpdatePersonMutationOptions = Apollo.BaseMutationOptions<UpdatePersonMutation, UpdatePersonMutationVariables>;
export const UpdateTagDocument = gql`
    mutation UpdateTag($id: uuid!, $name: String!, $colour: String!, $originatingDataId: uuid = null, $priority: Int! = 10) {
  update_collection_Tag_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, originatingDataId: $originatingDataId, priority: $priority}
  ) {
    ...TagInfo
  }
}
    ${TagInfoFragmentDoc}`;
export type UpdateTagMutationFn = Apollo.MutationFunction<UpdateTagMutation, UpdateTagMutationVariables>;

/**
 * __useUpdateTagMutation__
 *
 * To run a mutation, you first call `useUpdateTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTagMutation, { data, loading, error }] = useUpdateTagMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      originatingDataId: // value for 'originatingDataId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateTagMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTagMutation, UpdateTagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTagMutation, UpdateTagMutationVariables>(UpdateTagDocument, options);
      }
export type UpdateTagMutationHookResult = ReturnType<typeof useUpdateTagMutation>;
export type UpdateTagMutationResult = Apollo.MutationResult<UpdateTagMutation>;
export type UpdateTagMutationOptions = Apollo.BaseMutationOptions<UpdateTagMutation, UpdateTagMutationVariables>;
export const UpdateExhibitionDocument = gql`
    mutation UpdateExhibition($id: uuid!, $name: String!, $colour: String!, $priority: Int!, $isHidden: Boolean!) {
  update_collection_Exhibition_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, priority: $priority, isHidden: $isHidden}
  ) {
    ...ExhibitionInfo
  }
}
    ${ExhibitionInfoFragmentDoc}`;
export type UpdateExhibitionMutationFn = Apollo.MutationFunction<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>;

/**
 * __useUpdateExhibitionMutation__
 *
 * To run a mutation, you first call `useUpdateExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateExhibitionMutation, { data, loading, error }] = useUpdateExhibitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      priority: // value for 'priority'
 *      isHidden: // value for 'isHidden'
 *   },
 * });
 */
export function useUpdateExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>(UpdateExhibitionDocument, options);
      }
export type UpdateExhibitionMutationHookResult = ReturnType<typeof useUpdateExhibitionMutation>;
export type UpdateExhibitionMutationResult = Apollo.MutationResult<UpdateExhibitionMutation>;
export type UpdateExhibitionMutationOptions = Apollo.BaseMutationOptions<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>;
export const BulkEdit_AddElementsDocument = gql`
    mutation BulkEdit_AddElements($objects: [content_Element_insert_input!]!) {
  insert_content_Element(objects: $objects) {
    affected_rows
  }
}
    `;
export type BulkEdit_AddElementsMutationFn = Apollo.MutationFunction<BulkEdit_AddElementsMutation, BulkEdit_AddElementsMutationVariables>;

/**
 * __useBulkEdit_AddElementsMutation__
 *
 * To run a mutation, you first call `useBulkEdit_AddElementsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useBulkEdit_AddElementsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [bulkEditAddElementsMutation, { data, loading, error }] = useBulkEdit_AddElementsMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useBulkEdit_AddElementsMutation(baseOptions?: Apollo.MutationHookOptions<BulkEdit_AddElementsMutation, BulkEdit_AddElementsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<BulkEdit_AddElementsMutation, BulkEdit_AddElementsMutationVariables>(BulkEdit_AddElementsDocument, options);
      }
export type BulkEdit_AddElementsMutationHookResult = ReturnType<typeof useBulkEdit_AddElementsMutation>;
export type BulkEdit_AddElementsMutationResult = Apollo.MutationResult<BulkEdit_AddElementsMutation>;
export type BulkEdit_AddElementsMutationOptions = Apollo.BaseMutationOptions<BulkEdit_AddElementsMutation, BulkEdit_AddElementsMutationVariables>;
export const CombineVideosModal_CreateCombineVideosJobDocument = gql`
    mutation CombineVideosModal_CreateCombineVideosJob($conferenceId: uuid!, $createdByRegistrantId: uuid!, $outputName: String!, $data: jsonb!) {
  insert_job_queues_CombineVideosJob_one(
    object: {conferenceId: $conferenceId, createdByRegistrantId: $createdByRegistrantId, outputName: $outputName, data: $data}
  ) {
    id
  }
}
    `;
export type CombineVideosModal_CreateCombineVideosJobMutationFn = Apollo.MutationFunction<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>;

/**
 * __useCombineVideosModal_CreateCombineVideosJobMutation__
 *
 * To run a mutation, you first call `useCombineVideosModal_CreateCombineVideosJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCombineVideosModal_CreateCombineVideosJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [combineVideosModalCreateCombineVideosJobMutation, { data, loading, error }] = useCombineVideosModal_CreateCombineVideosJobMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      createdByRegistrantId: // value for 'createdByRegistrantId'
 *      outputName: // value for 'outputName'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCombineVideosModal_CreateCombineVideosJobMutation(baseOptions?: Apollo.MutationHookOptions<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>(CombineVideosModal_CreateCombineVideosJobDocument, options);
      }
export type CombineVideosModal_CreateCombineVideosJobMutationHookResult = ReturnType<typeof useCombineVideosModal_CreateCombineVideosJobMutation>;
export type CombineVideosModal_CreateCombineVideosJobMutationResult = Apollo.MutationResult<CombineVideosModal_CreateCombineVideosJobMutation>;
export type CombineVideosModal_CreateCombineVideosJobMutationOptions = Apollo.BaseMutationOptions<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>;
export const CombineVideosModal_GetCombineVideosJobDocument = gql`
    query CombineVideosModal_GetCombineVideosJob($conferenceId: uuid!) {
  job_queues_CombineVideosJob(
    where: {conferenceId: {_eq: $conferenceId}, jobStatusName: {_in: [NEW, IN_PROGRESS]}}
  ) {
    id
    message
    jobStatusName
    data
  }
}
    `;

/**
 * __useCombineVideosModal_GetCombineVideosJobQuery__
 *
 * To run a query within a React component, call `useCombineVideosModal_GetCombineVideosJobQuery` and pass it any options that fit your needs.
 * When your component renders, `useCombineVideosModal_GetCombineVideosJobQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCombineVideosModal_GetCombineVideosJobQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCombineVideosModal_GetCombineVideosJobQuery(baseOptions: Apollo.QueryHookOptions<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>(CombineVideosModal_GetCombineVideosJobDocument, options);
      }
export function useCombineVideosModal_GetCombineVideosJobLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>(CombineVideosModal_GetCombineVideosJobDocument, options);
        }
export type CombineVideosModal_GetCombineVideosJobQueryHookResult = ReturnType<typeof useCombineVideosModal_GetCombineVideosJobQuery>;
export type CombineVideosModal_GetCombineVideosJobLazyQueryHookResult = ReturnType<typeof useCombineVideosModal_GetCombineVideosJobLazyQuery>;
export type CombineVideosModal_GetCombineVideosJobQueryResult = Apollo.QueryResult<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>;
export const CombineVideosModal_GetElementsDocument = gql`
    query CombineVideosModal_GetElements($itemIds: [uuid!]!, $elementIds: [uuid!]!) {
  content_Item(where: {id: {_in: $itemIds}}) {
    id
    title
  }
  content_Element(where: {id: {_in: $elementIds}}) {
    id
    createdAt
    itemId
    data
    name
  }
}
    `;

/**
 * __useCombineVideosModal_GetElementsQuery__
 *
 * To run a query within a React component, call `useCombineVideosModal_GetElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCombineVideosModal_GetElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCombineVideosModal_GetElementsQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *      elementIds: // value for 'elementIds'
 *   },
 * });
 */
export function useCombineVideosModal_GetElementsQuery(baseOptions: Apollo.QueryHookOptions<CombineVideosModal_GetElementsQuery, CombineVideosModal_GetElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CombineVideosModal_GetElementsQuery, CombineVideosModal_GetElementsQueryVariables>(CombineVideosModal_GetElementsDocument, options);
      }
export function useCombineVideosModal_GetElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CombineVideosModal_GetElementsQuery, CombineVideosModal_GetElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CombineVideosModal_GetElementsQuery, CombineVideosModal_GetElementsQueryVariables>(CombineVideosModal_GetElementsDocument, options);
        }
export type CombineVideosModal_GetElementsQueryHookResult = ReturnType<typeof useCombineVideosModal_GetElementsQuery>;
export type CombineVideosModal_GetElementsLazyQueryHookResult = ReturnType<typeof useCombineVideosModal_GetElementsLazyQuery>;
export type CombineVideosModal_GetElementsQueryResult = Apollo.QueryResult<CombineVideosModal_GetElementsQuery, CombineVideosModal_GetElementsQueryVariables>;
export const SEoUm_InfosDocument = gql`
    query SEoUM_Infos($itemIds: [uuid!]!) {
  content_Item(where: {id: {_in: $itemIds}}) {
    ...SelectElements_Item
  }
}
    ${SelectElements_ItemFragmentDoc}`;

/**
 * __useSEoUm_InfosQuery__
 *
 * To run a query within a React component, call `useSEoUm_InfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useSEoUm_InfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSEoUm_InfosQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useSEoUm_InfosQuery(baseOptions: Apollo.QueryHookOptions<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>(SEoUm_InfosDocument, options);
      }
export function useSEoUm_InfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>(SEoUm_InfosDocument, options);
        }
export type SEoUm_InfosQueryHookResult = ReturnType<typeof useSEoUm_InfosQuery>;
export type SEoUm_InfosLazyQueryHookResult = ReturnType<typeof useSEoUm_InfosLazyQuery>;
export type SEoUm_InfosQueryResult = Apollo.QueryResult<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>;
export const UpdateExhibitionDescriptiveItems_SelectExhibitionsDocument = gql`
    query UpdateExhibitionDescriptiveItems_SelectExhibitions($conferenceId: uuid!) {
  collection_Exhibition(
    where: {conferenceId: {_eq: $conferenceId}, descriptiveItemId: {_is_null: true}}
  ) {
    id
    name
  }
}
    `;

/**
 * __useUpdateExhibitionDescriptiveItems_SelectExhibitionsQuery__
 *
 * To run a query within a React component, call `useUpdateExhibitionDescriptiveItems_SelectExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUpdateExhibitionDescriptiveItems_SelectExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUpdateExhibitionDescriptiveItems_SelectExhibitionsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useUpdateExhibitionDescriptiveItems_SelectExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<UpdateExhibitionDescriptiveItems_SelectExhibitionsQuery, UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UpdateExhibitionDescriptiveItems_SelectExhibitionsQuery, UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryVariables>(UpdateExhibitionDescriptiveItems_SelectExhibitionsDocument, options);
      }
export function useUpdateExhibitionDescriptiveItems_SelectExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UpdateExhibitionDescriptiveItems_SelectExhibitionsQuery, UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UpdateExhibitionDescriptiveItems_SelectExhibitionsQuery, UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryVariables>(UpdateExhibitionDescriptiveItems_SelectExhibitionsDocument, options);
        }
export type UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryHookResult = ReturnType<typeof useUpdateExhibitionDescriptiveItems_SelectExhibitionsQuery>;
export type UpdateExhibitionDescriptiveItems_SelectExhibitionsLazyQueryHookResult = ReturnType<typeof useUpdateExhibitionDescriptiveItems_SelectExhibitionsLazyQuery>;
export type UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryResult = Apollo.QueryResult<UpdateExhibitionDescriptiveItems_SelectExhibitionsQuery, UpdateExhibitionDescriptiveItems_SelectExhibitionsQueryVariables>;
export const UpdateExhibitionDescriptiveItemDocument = gql`
    mutation UpdateExhibitionDescriptiveItem($id: uuid!, $descriptiveItemId: uuid!) {
  update_collection_Exhibition_by_pk(
    pk_columns: {id: $id}
    _set: {descriptiveItemId: $descriptiveItemId}
  ) {
    id
    descriptiveItemId
  }
}
    `;
export type UpdateExhibitionDescriptiveItemMutationFn = Apollo.MutationFunction<UpdateExhibitionDescriptiveItemMutation, UpdateExhibitionDescriptiveItemMutationVariables>;

/**
 * __useUpdateExhibitionDescriptiveItemMutation__
 *
 * To run a mutation, you first call `useUpdateExhibitionDescriptiveItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateExhibitionDescriptiveItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateExhibitionDescriptiveItemMutation, { data, loading, error }] = useUpdateExhibitionDescriptiveItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *      descriptiveItemId: // value for 'descriptiveItemId'
 *   },
 * });
 */
export function useUpdateExhibitionDescriptiveItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateExhibitionDescriptiveItemMutation, UpdateExhibitionDescriptiveItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateExhibitionDescriptiveItemMutation, UpdateExhibitionDescriptiveItemMutationVariables>(UpdateExhibitionDescriptiveItemDocument, options);
      }
export type UpdateExhibitionDescriptiveItemMutationHookResult = ReturnType<typeof useUpdateExhibitionDescriptiveItemMutation>;
export type UpdateExhibitionDescriptiveItemMutationResult = Apollo.MutationResult<UpdateExhibitionDescriptiveItemMutation>;
export type UpdateExhibitionDescriptiveItemMutationOptions = Apollo.BaseMutationOptions<UpdateExhibitionDescriptiveItemMutation, UpdateExhibitionDescriptiveItemMutationVariables>;
export const UpdateLayoutDocument = gql`
    mutation UpdateLayout($elementIds: [uuid!]!, $layoutData: jsonb!) {
  update_content_Element(
    where: {id: {_in: $elementIds}}
    _append: {layoutData: $layoutData}
  ) {
    affected_rows
  }
}
    `;
export type UpdateLayoutMutationFn = Apollo.MutationFunction<UpdateLayoutMutation, UpdateLayoutMutationVariables>;

/**
 * __useUpdateLayoutMutation__
 *
 * To run a mutation, you first call `useUpdateLayoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateLayoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateLayoutMutation, { data, loading, error }] = useUpdateLayoutMutation({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *      layoutData: // value for 'layoutData'
 *   },
 * });
 */
export function useUpdateLayoutMutation(baseOptions?: Apollo.MutationHookOptions<UpdateLayoutMutation, UpdateLayoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateLayoutMutation, UpdateLayoutMutationVariables>(UpdateLayoutDocument, options);
      }
export type UpdateLayoutMutationHookResult = ReturnType<typeof useUpdateLayoutMutation>;
export type UpdateLayoutMutationResult = Apollo.MutationResult<UpdateLayoutMutation>;
export type UpdateLayoutMutationOptions = Apollo.BaseMutationOptions<UpdateLayoutMutation, UpdateLayoutMutationVariables>;
export const UpdateUploadsRemainingDocument = gql`
    mutation UpdateUploadsRemaining($elementIds: [uuid!]!, $count: Int!) {
  update_content_Element(
    where: {id: {_in: $elementIds}}
    _set: {uploadsRemaining: $count}
  ) {
    affected_rows
  }
}
    `;
export type UpdateUploadsRemainingMutationFn = Apollo.MutationFunction<UpdateUploadsRemainingMutation, UpdateUploadsRemainingMutationVariables>;

/**
 * __useUpdateUploadsRemainingMutation__
 *
 * To run a mutation, you first call `useUpdateUploadsRemainingMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUploadsRemainingMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUploadsRemainingMutation, { data, loading, error }] = useUpdateUploadsRemainingMutation({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *      count: // value for 'count'
 *   },
 * });
 */
export function useUpdateUploadsRemainingMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUploadsRemainingMutation, UpdateUploadsRemainingMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUploadsRemainingMutation, UpdateUploadsRemainingMutationVariables>(UpdateUploadsRemainingDocument, options);
      }
export type UpdateUploadsRemainingMutationHookResult = ReturnType<typeof useUpdateUploadsRemainingMutation>;
export type UpdateUploadsRemainingMutationResult = Apollo.MutationResult<UpdateUploadsRemainingMutation>;
export type UpdateUploadsRemainingMutationOptions = Apollo.BaseMutationOptions<UpdateUploadsRemainingMutation, UpdateUploadsRemainingMutationVariables>;
export const ManageContent_DeleteElementDocument = gql`
    mutation ManageContent_DeleteElement($elementId: uuid!) {
  delete_content_Element_by_pk(id: $elementId) {
    id
  }
}
    `;
export type ManageContent_DeleteElementMutationFn = Apollo.MutationFunction<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>;

/**
 * __useManageContent_DeleteElementMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteElementMutation, { data, loading, error }] = useManageContent_DeleteElementMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useManageContent_DeleteElementMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>(ManageContent_DeleteElementDocument, options);
      }
export type ManageContent_DeleteElementMutationHookResult = ReturnType<typeof useManageContent_DeleteElementMutation>;
export type ManageContent_DeleteElementMutationResult = Apollo.MutationResult<ManageContent_DeleteElementMutation>;
export type ManageContent_DeleteElementMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>;
export const ManageContent_UpdateElementDocument = gql`
    mutation ManageContent_UpdateElement($elementId: uuid!, $element: content_Element_set_input!) {
  update_content_Element_by_pk(pk_columns: {id: $elementId}, _set: $element) {
    ...ManageContent_Element
  }
}
    ${ManageContent_ElementFragmentDoc}`;
export type ManageContent_UpdateElementMutationFn = Apollo.MutationFunction<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>;

/**
 * __useManageContent_UpdateElementMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateElementMutation, { data, loading, error }] = useManageContent_UpdateElementMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *      element: // value for 'element'
 *   },
 * });
 */
export function useManageContent_UpdateElementMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>(ManageContent_UpdateElementDocument, options);
      }
export type ManageContent_UpdateElementMutationHookResult = ReturnType<typeof useManageContent_UpdateElementMutation>;
export type ManageContent_UpdateElementMutationResult = Apollo.MutationResult<ManageContent_UpdateElementMutation>;
export type ManageContent_UpdateElementMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>;
export const ManageContent_SelectItemExhibitionsDocument = gql`
    query ManageContent_SelectItemExhibitions($exhibitionId: uuid!) {
  content_ItemExhibition(where: {exhibitionId: {_eq: $exhibitionId}}) {
    ...ManageContent_ItemExhibition
  }
}
    ${ManageContent_ItemExhibitionFragmentDoc}`;

/**
 * __useManageContent_SelectItemExhibitionsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectItemExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectItemExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectItemExhibitionsQuery({
 *   variables: {
 *      exhibitionId: // value for 'exhibitionId'
 *   },
 * });
 */
export function useManageContent_SelectItemExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>(ManageContent_SelectItemExhibitionsDocument, options);
      }
export function useManageContent_SelectItemExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>(ManageContent_SelectItemExhibitionsDocument, options);
        }
export type ManageContent_SelectItemExhibitionsQueryHookResult = ReturnType<typeof useManageContent_SelectItemExhibitionsQuery>;
export type ManageContent_SelectItemExhibitionsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectItemExhibitionsLazyQuery>;
export type ManageContent_SelectItemExhibitionsQueryResult = Apollo.QueryResult<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>;
export const ManageContent_InsertItemExhibitionDocument = gql`
    mutation ManageContent_InsertItemExhibition($conferenceId: uuid!, $exhibitionId: uuid!, $itemId: uuid!, $priority: Int!) {
  insert_content_ItemExhibition_one(
    object: {conferenceId: $conferenceId, exhibitionId: $exhibitionId, itemId: $itemId, priority: $priority}
  ) {
    ...ManageContent_ItemExhibition
  }
}
    ${ManageContent_ItemExhibitionFragmentDoc}`;
export type ManageContent_InsertItemExhibitionMutationFn = Apollo.MutationFunction<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>;

/**
 * __useManageContent_InsertItemExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertItemExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertItemExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertItemExhibitionMutation, { data, loading, error }] = useManageContent_InsertItemExhibitionMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      exhibitionId: // value for 'exhibitionId'
 *      itemId: // value for 'itemId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useManageContent_InsertItemExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>(ManageContent_InsertItemExhibitionDocument, options);
      }
export type ManageContent_InsertItemExhibitionMutationHookResult = ReturnType<typeof useManageContent_InsertItemExhibitionMutation>;
export type ManageContent_InsertItemExhibitionMutationResult = Apollo.MutationResult<ManageContent_InsertItemExhibitionMutation>;
export type ManageContent_InsertItemExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>;
export const ManageContent_UpdateItemExhibitionDocument = gql`
    mutation ManageContent_UpdateItemExhibition($itemExhibitionId: uuid!, $priority: Int!) {
  update_content_ItemExhibition_by_pk(
    pk_columns: {id: $itemExhibitionId}
    _set: {priority: $priority}
  ) {
    ...ManageContent_ItemExhibition
  }
}
    ${ManageContent_ItemExhibitionFragmentDoc}`;
export type ManageContent_UpdateItemExhibitionMutationFn = Apollo.MutationFunction<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>;

/**
 * __useManageContent_UpdateItemExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateItemExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateItemExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateItemExhibitionMutation, { data, loading, error }] = useManageContent_UpdateItemExhibitionMutation({
 *   variables: {
 *      itemExhibitionId: // value for 'itemExhibitionId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useManageContent_UpdateItemExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>(ManageContent_UpdateItemExhibitionDocument, options);
      }
export type ManageContent_UpdateItemExhibitionMutationHookResult = ReturnType<typeof useManageContent_UpdateItemExhibitionMutation>;
export type ManageContent_UpdateItemExhibitionMutationResult = Apollo.MutationResult<ManageContent_UpdateItemExhibitionMutation>;
export type ManageContent_UpdateItemExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>;
export const ManageContent_DeleteItemExhibitionDocument = gql`
    mutation ManageContent_DeleteItemExhibition($itemExhibitionId: uuid!) {
  delete_content_ItemExhibition_by_pk(id: $itemExhibitionId) {
    id
  }
}
    `;
export type ManageContent_DeleteItemExhibitionMutationFn = Apollo.MutationFunction<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>;

/**
 * __useManageContent_DeleteItemExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteItemExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteItemExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteItemExhibitionMutation, { data, loading, error }] = useManageContent_DeleteItemExhibitionMutation({
 *   variables: {
 *      itemExhibitionId: // value for 'itemExhibitionId'
 *   },
 * });
 */
export function useManageContent_DeleteItemExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>(ManageContent_DeleteItemExhibitionDocument, options);
      }
export type ManageContent_DeleteItemExhibitionMutationHookResult = ReturnType<typeof useManageContent_DeleteItemExhibitionMutation>;
export type ManageContent_DeleteItemExhibitionMutationResult = Apollo.MutationResult<ManageContent_DeleteItemExhibitionMutation>;
export type ManageContent_DeleteItemExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>;
export const ManageContent_InsertExhibitionDocument = gql`
    mutation ManageContent_InsertExhibition($exhibition: collection_Exhibition_insert_input!) {
  insert_collection_Exhibition_one(object: $exhibition) {
    ...ManageContent_Exhibition
  }
}
    ${ManageContent_ExhibitionFragmentDoc}`;
export type ManageContent_InsertExhibitionMutationFn = Apollo.MutationFunction<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>;

/**
 * __useManageContent_InsertExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertExhibitionMutation, { data, loading, error }] = useManageContent_InsertExhibitionMutation({
 *   variables: {
 *      exhibition: // value for 'exhibition'
 *   },
 * });
 */
export function useManageContent_InsertExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>(ManageContent_InsertExhibitionDocument, options);
      }
export type ManageContent_InsertExhibitionMutationHookResult = ReturnType<typeof useManageContent_InsertExhibitionMutation>;
export type ManageContent_InsertExhibitionMutationResult = Apollo.MutationResult<ManageContent_InsertExhibitionMutation>;
export type ManageContent_InsertExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>;
export const ManageContent_UpdateExhibitionDocument = gql`
    mutation ManageContent_UpdateExhibition($id: uuid!, $update: collection_Exhibition_set_input!) {
  update_collection_Exhibition_by_pk(pk_columns: {id: $id}, _set: $update) {
    ...ManageContent_Exhibition
  }
}
    ${ManageContent_ExhibitionFragmentDoc}`;
export type ManageContent_UpdateExhibitionMutationFn = Apollo.MutationFunction<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>;

/**
 * __useManageContent_UpdateExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateExhibitionMutation, { data, loading, error }] = useManageContent_UpdateExhibitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useManageContent_UpdateExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>(ManageContent_UpdateExhibitionDocument, options);
      }
export type ManageContent_UpdateExhibitionMutationHookResult = ReturnType<typeof useManageContent_UpdateExhibitionMutation>;
export type ManageContent_UpdateExhibitionMutationResult = Apollo.MutationResult<ManageContent_UpdateExhibitionMutation>;
export type ManageContent_UpdateExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>;
export const ManageContent_DeleteExhibitionsDocument = gql`
    mutation ManageContent_DeleteExhibitions($ids: [uuid!]!) {
  delete_collection_Exhibition(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContent_DeleteExhibitionsMutationFn = Apollo.MutationFunction<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>;

/**
 * __useManageContent_DeleteExhibitionsMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteExhibitionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteExhibitionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteExhibitionsMutation, { data, loading, error }] = useManageContent_DeleteExhibitionsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContent_DeleteExhibitionsMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>(ManageContent_DeleteExhibitionsDocument, options);
      }
export type ManageContent_DeleteExhibitionsMutationHookResult = ReturnType<typeof useManageContent_DeleteExhibitionsMutation>;
export type ManageContent_DeleteExhibitionsMutationResult = Apollo.MutationResult<ManageContent_DeleteExhibitionsMutation>;
export type ManageContent_DeleteExhibitionsMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>;
export const AddContentMenu_CreateElementDocument = gql`
    mutation AddContentMenu_CreateElement($object: content_Element_insert_input!) {
  insert_content_Element_one(object: $object) {
    ...ManageContent_Element
  }
}
    ${ManageContent_ElementFragmentDoc}`;
export type AddContentMenu_CreateElementMutationFn = Apollo.MutationFunction<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>;

/**
 * __useAddContentMenu_CreateElementMutation__
 *
 * To run a mutation, you first call `useAddContentMenu_CreateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddContentMenu_CreateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addContentMenuCreateElementMutation, { data, loading, error }] = useAddContentMenu_CreateElementMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useAddContentMenu_CreateElementMutation(baseOptions?: Apollo.MutationHookOptions<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>(AddContentMenu_CreateElementDocument, options);
      }
export type AddContentMenu_CreateElementMutationHookResult = ReturnType<typeof useAddContentMenu_CreateElementMutation>;
export type AddContentMenu_CreateElementMutationResult = Apollo.MutationResult<AddContentMenu_CreateElementMutation>;
export type AddContentMenu_CreateElementMutationOptions = Apollo.BaseMutationOptions<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>;
export const Item_CreateRoomDocument = gql`
    mutation Item_CreateRoom($conferenceId: uuid!, $itemId: uuid!) {
  createItemRoom(conferenceId: $conferenceId, itemId: $itemId) {
    roomId
    message
  }
}
    `;
export type Item_CreateRoomMutationFn = Apollo.MutationFunction<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>;

/**
 * __useItem_CreateRoomMutation__
 *
 * To run a mutation, you first call `useItem_CreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useItem_CreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [itemCreateRoomMutation, { data, loading, error }] = useItem_CreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useItem_CreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>(Item_CreateRoomDocument, options);
      }
export type Item_CreateRoomMutationHookResult = ReturnType<typeof useItem_CreateRoomMutation>;
export type Item_CreateRoomMutationResult = Apollo.MutationResult<Item_CreateRoomMutation>;
export type Item_CreateRoomMutationOptions = Apollo.BaseMutationOptions<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>;
export const ManageContent_SelectProgramPeopleDocument = gql`
    query ManageContent_SelectProgramPeople($conferenceId: uuid!) {
  collection_ProgramPersonWithAccessToken(
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    ...ManageContent_ProgramPerson
  }
}
    ${ManageContent_ProgramPersonFragmentDoc}`;

/**
 * __useManageContent_SelectProgramPeopleQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectProgramPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectProgramPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectProgramPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectProgramPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>(ManageContent_SelectProgramPeopleDocument, options);
      }
export function useManageContent_SelectProgramPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>(ManageContent_SelectProgramPeopleDocument, options);
        }
export type ManageContent_SelectProgramPeopleQueryHookResult = ReturnType<typeof useManageContent_SelectProgramPeopleQuery>;
export type ManageContent_SelectProgramPeopleLazyQueryHookResult = ReturnType<typeof useManageContent_SelectProgramPeopleLazyQuery>;
export type ManageContent_SelectProgramPeopleQueryResult = Apollo.QueryResult<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>;
export const ManageContent_InsertItemProgramPersonDocument = gql`
    mutation ManageContent_InsertItemProgramPerson($conferenceId: uuid!, $personId: uuid!, $roleName: String!, $priority: Int!, $itemId: uuid!) {
  insert_content_ItemProgramPerson_one(
    object: {conferenceId: $conferenceId, personId: $personId, itemId: $itemId, priority: $priority, roleName: $roleName}
  ) {
    ...ManageContent_ItemProgramPerson
  }
}
    ${ManageContent_ItemProgramPersonFragmentDoc}`;
export type ManageContent_InsertItemProgramPersonMutationFn = Apollo.MutationFunction<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>;

/**
 * __useManageContent_InsertItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertItemProgramPersonMutation, { data, loading, error }] = useManageContent_InsertItemProgramPersonMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      personId: // value for 'personId'
 *      roleName: // value for 'roleName'
 *      priority: // value for 'priority'
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useManageContent_InsertItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>(ManageContent_InsertItemProgramPersonDocument, options);
      }
export type ManageContent_InsertItemProgramPersonMutationHookResult = ReturnType<typeof useManageContent_InsertItemProgramPersonMutation>;
export type ManageContent_InsertItemProgramPersonMutationResult = Apollo.MutationResult<ManageContent_InsertItemProgramPersonMutation>;
export type ManageContent_InsertItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>;
export const ManageContent_UpdateItemProgramPersonDocument = gql`
    mutation ManageContent_UpdateItemProgramPerson($itemPersonId: uuid!, $priority: Int!, $roleName: String!) {
  update_content_ItemProgramPerson_by_pk(
    pk_columns: {id: $itemPersonId}
    _set: {priority: $priority, roleName: $roleName}
  ) {
    ...ManageContent_ItemProgramPerson
  }
}
    ${ManageContent_ItemProgramPersonFragmentDoc}`;
export type ManageContent_UpdateItemProgramPersonMutationFn = Apollo.MutationFunction<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>;

/**
 * __useManageContent_UpdateItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateItemProgramPersonMutation, { data, loading, error }] = useManageContent_UpdateItemProgramPersonMutation({
 *   variables: {
 *      itemPersonId: // value for 'itemPersonId'
 *      priority: // value for 'priority'
 *      roleName: // value for 'roleName'
 *   },
 * });
 */
export function useManageContent_UpdateItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>(ManageContent_UpdateItemProgramPersonDocument, options);
      }
export type ManageContent_UpdateItemProgramPersonMutationHookResult = ReturnType<typeof useManageContent_UpdateItemProgramPersonMutation>;
export type ManageContent_UpdateItemProgramPersonMutationResult = Apollo.MutationResult<ManageContent_UpdateItemProgramPersonMutation>;
export type ManageContent_UpdateItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>;
export const ManageContent_DeleteItemProgramPersonDocument = gql`
    mutation ManageContent_DeleteItemProgramPerson($itemPersonId: uuid!) {
  delete_content_ItemProgramPerson_by_pk(id: $itemPersonId) {
    id
  }
}
    `;
export type ManageContent_DeleteItemProgramPersonMutationFn = Apollo.MutationFunction<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>;

/**
 * __useManageContent_DeleteItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteItemProgramPersonMutation, { data, loading, error }] = useManageContent_DeleteItemProgramPersonMutation({
 *   variables: {
 *      itemPersonId: // value for 'itemPersonId'
 *   },
 * });
 */
export function useManageContent_DeleteItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>(ManageContent_DeleteItemProgramPersonDocument, options);
      }
export type ManageContent_DeleteItemProgramPersonMutationHookResult = ReturnType<typeof useManageContent_DeleteItemProgramPersonMutation>;
export type ManageContent_DeleteItemProgramPersonMutationResult = Apollo.MutationResult<ManageContent_DeleteItemProgramPersonMutation>;
export type ManageContent_DeleteItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>;
export const ManageContent_InsertTagDocument = gql`
    mutation ManageContent_InsertTag($tag: collection_Tag_insert_input!) {
  insert_collection_Tag_one(object: $tag) {
    ...ManageContent_Tag
  }
}
    ${ManageContent_TagFragmentDoc}`;
export type ManageContent_InsertTagMutationFn = Apollo.MutationFunction<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>;

/**
 * __useManageContent_InsertTagMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertTagMutation, { data, loading, error }] = useManageContent_InsertTagMutation({
 *   variables: {
 *      tag: // value for 'tag'
 *   },
 * });
 */
export function useManageContent_InsertTagMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>(ManageContent_InsertTagDocument, options);
      }
export type ManageContent_InsertTagMutationHookResult = ReturnType<typeof useManageContent_InsertTagMutation>;
export type ManageContent_InsertTagMutationResult = Apollo.MutationResult<ManageContent_InsertTagMutation>;
export type ManageContent_InsertTagMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>;
export const ManageContent_UpdateTagDocument = gql`
    mutation ManageContent_UpdateTag($id: uuid!, $update: collection_Tag_set_input!) {
  update_collection_Tag_by_pk(pk_columns: {id: $id}, _set: $update) {
    ...ManageContent_Tag
  }
}
    ${ManageContent_TagFragmentDoc}`;
export type ManageContent_UpdateTagMutationFn = Apollo.MutationFunction<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>;

/**
 * __useManageContent_UpdateTagMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateTagMutation, { data, loading, error }] = useManageContent_UpdateTagMutation({
 *   variables: {
 *      id: // value for 'id'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useManageContent_UpdateTagMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>(ManageContent_UpdateTagDocument, options);
      }
export type ManageContent_UpdateTagMutationHookResult = ReturnType<typeof useManageContent_UpdateTagMutation>;
export type ManageContent_UpdateTagMutationResult = Apollo.MutationResult<ManageContent_UpdateTagMutation>;
export type ManageContent_UpdateTagMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>;
export const ManageContent_DeleteTagsDocument = gql`
    mutation ManageContent_DeleteTags($ids: [uuid!]!) {
  delete_collection_Tag(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContent_DeleteTagsMutationFn = Apollo.MutationFunction<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>;

/**
 * __useManageContent_DeleteTagsMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteTagsMutation, { data, loading, error }] = useManageContent_DeleteTagsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContent_DeleteTagsMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>(ManageContent_DeleteTagsDocument, options);
      }
export type ManageContent_DeleteTagsMutationHookResult = ReturnType<typeof useManageContent_DeleteTagsMutation>;
export type ManageContent_DeleteTagsMutationResult = Apollo.MutationResult<ManageContent_DeleteTagsMutation>;
export type ManageContent_DeleteTagsMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>;
export const ElementSecurity_SelectGrantsDocument = gql`
    query ElementSecurity_SelectGrants($elementIds: [uuid!]!, $conferenceId: uuid!) {
  content_ElementPermissionGrant(
    where: {_or: [{_and: [{entityId: {_is_null: true}}, {conference: {id: {_eq: $conferenceId}}}]}, {entityId: {_in: $elementIds}}]}
  ) {
    ...ElementSecurity_ElementPG
  }
  permissions_Role(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ElementSecurity_PermissionSet
  }
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ElementSecurity_Group
  }
}
    ${ElementSecurity_ElementPgFragmentDoc}
${ElementSecurity_PermissionSetFragmentDoc}
${ElementSecurity_GroupFragmentDoc}`;

/**
 * __useElementSecurity_SelectGrantsQuery__
 *
 * To run a query within a React component, call `useElementSecurity_SelectGrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useElementSecurity_SelectGrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useElementSecurity_SelectGrantsQuery({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useElementSecurity_SelectGrantsQuery(baseOptions: Apollo.QueryHookOptions<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>(ElementSecurity_SelectGrantsDocument, options);
      }
export function useElementSecurity_SelectGrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>(ElementSecurity_SelectGrantsDocument, options);
        }
export type ElementSecurity_SelectGrantsQueryHookResult = ReturnType<typeof useElementSecurity_SelectGrantsQuery>;
export type ElementSecurity_SelectGrantsLazyQueryHookResult = ReturnType<typeof useElementSecurity_SelectGrantsLazyQuery>;
export type ElementSecurity_SelectGrantsQueryResult = Apollo.QueryResult<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>;
export const ElementSecurity_InsertGrantsDocument = gql`
    mutation ElementSecurity_InsertGrants($elementGrants: [content_ElementPermissionGrant_insert_input!]!) {
  insert_content_ElementPermissionGrant(
    objects: $elementGrants
    on_conflict: {constraint: ElementPermissionGrant_permissionSetId_groupId_entityId_key, update_columns: []}
  ) {
    returning {
      ...ElementSecurity_ElementPG
    }
  }
}
    ${ElementSecurity_ElementPgFragmentDoc}`;
export type ElementSecurity_InsertGrantsMutationFn = Apollo.MutationFunction<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>;

/**
 * __useElementSecurity_InsertGrantsMutation__
 *
 * To run a mutation, you first call `useElementSecurity_InsertGrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useElementSecurity_InsertGrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [elementSecurityInsertGrantsMutation, { data, loading, error }] = useElementSecurity_InsertGrantsMutation({
 *   variables: {
 *      elementGrants: // value for 'elementGrants'
 *   },
 * });
 */
export function useElementSecurity_InsertGrantsMutation(baseOptions?: Apollo.MutationHookOptions<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>(ElementSecurity_InsertGrantsDocument, options);
      }
export type ElementSecurity_InsertGrantsMutationHookResult = ReturnType<typeof useElementSecurity_InsertGrantsMutation>;
export type ElementSecurity_InsertGrantsMutationResult = Apollo.MutationResult<ElementSecurity_InsertGrantsMutation>;
export type ElementSecurity_InsertGrantsMutationOptions = Apollo.BaseMutationOptions<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>;
export const ElementSecurity_DeleteGrantsDocument = gql`
    mutation ElementSecurity_DeleteGrants($elementGrantIds: [uuid!]!) {
  delete_content_ElementPermissionGrant(where: {id: {_in: $elementGrantIds}}) {
    returning {
      id
    }
  }
}
    `;
export type ElementSecurity_DeleteGrantsMutationFn = Apollo.MutationFunction<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>;

/**
 * __useElementSecurity_DeleteGrantsMutation__
 *
 * To run a mutation, you first call `useElementSecurity_DeleteGrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useElementSecurity_DeleteGrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [elementSecurityDeleteGrantsMutation, { data, loading, error }] = useElementSecurity_DeleteGrantsMutation({
 *   variables: {
 *      elementGrantIds: // value for 'elementGrantIds'
 *   },
 * });
 */
export function useElementSecurity_DeleteGrantsMutation(baseOptions?: Apollo.MutationHookOptions<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>(ElementSecurity_DeleteGrantsDocument, options);
      }
export type ElementSecurity_DeleteGrantsMutationHookResult = ReturnType<typeof useElementSecurity_DeleteGrantsMutation>;
export type ElementSecurity_DeleteGrantsMutationResult = Apollo.MutationResult<ElementSecurity_DeleteGrantsMutation>;
export type ElementSecurity_DeleteGrantsMutationOptions = Apollo.BaseMutationOptions<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>;
export const InsertSubmissionRequestEmailJobsDocument = gql`
    mutation InsertSubmissionRequestEmailJobs($objs: [job_queues_SubmissionRequestEmailJob_insert_input!]!) {
  insert_job_queues_SubmissionRequestEmailJob(objects: $objs) {
    affected_rows
  }
}
    `;
export type InsertSubmissionRequestEmailJobsMutationFn = Apollo.MutationFunction<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;

/**
 * __useInsertSubmissionRequestEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertSubmissionRequestEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertSubmissionRequestEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertSubmissionRequestEmailJobsMutation, { data, loading, error }] = useInsertSubmissionRequestEmailJobsMutation({
 *   variables: {
 *      objs: // value for 'objs'
 *   },
 * });
 */
export function useInsertSubmissionRequestEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>(InsertSubmissionRequestEmailJobsDocument, options);
      }
export type InsertSubmissionRequestEmailJobsMutationHookResult = ReturnType<typeof useInsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationResult = Apollo.MutationResult<InsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;
export const SubmissionRequestsModalDataDocument = gql`
    query SubmissionRequestsModalData($conferenceId: uuid!, $itemIds: [uuid!]!) {
  conference_Configuration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConfigureEmailTemplates_ConferenceConfiguration
  }
  content_Item(where: {id: {_in: $itemIds}}) {
    ...SubmissionRequestsModal_Item
  }
}
    ${ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc}
${SubmissionRequestsModal_ItemFragmentDoc}`;

/**
 * __useSubmissionRequestsModalDataQuery__
 *
 * To run a query within a React component, call `useSubmissionRequestsModalDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissionRequestsModalDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissionRequestsModalDataQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useSubmissionRequestsModalDataQuery(baseOptions: Apollo.QueryHookOptions<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>(SubmissionRequestsModalDataDocument, options);
      }
export function useSubmissionRequestsModalDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>(SubmissionRequestsModalDataDocument, options);
        }
export type SubmissionRequestsModalDataQueryHookResult = ReturnType<typeof useSubmissionRequestsModalDataQuery>;
export type SubmissionRequestsModalDataLazyQueryHookResult = ReturnType<typeof useSubmissionRequestsModalDataLazyQuery>;
export type SubmissionRequestsModalDataQueryResult = Apollo.QueryResult<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>;
export const SubmissionsReviewModalDataDocument = gql`
    query SubmissionsReviewModalData($itemIds: [uuid!]!) {
  content_Item(where: {id: {_in: $itemIds}}) {
    ...SubmissionsReviewModal_Item
  }
}
    ${SubmissionsReviewModal_ItemFragmentDoc}`;

/**
 * __useSubmissionsReviewModalDataQuery__
 *
 * To run a query within a React component, call `useSubmissionsReviewModalDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissionsReviewModalDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissionsReviewModalDataQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useSubmissionsReviewModalDataQuery(baseOptions: Apollo.QueryHookOptions<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>(SubmissionsReviewModalDataDocument, options);
      }
export function useSubmissionsReviewModalDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>(SubmissionsReviewModalDataDocument, options);
        }
export type SubmissionsReviewModalDataQueryHookResult = ReturnType<typeof useSubmissionsReviewModalDataQuery>;
export type SubmissionsReviewModalDataLazyQueryHookResult = ReturnType<typeof useSubmissionsReviewModalDataLazyQuery>;
export type SubmissionsReviewModalDataQueryResult = Apollo.QueryResult<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>;
export const ConfigureEmailTemplates_GetConferenceConfigurationsDocument = gql`
    query ConfigureEmailTemplates_GetConferenceConfigurations($conferenceId: uuid!) {
  conference_Configuration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConfigureEmailTemplates_ConferenceConfiguration
  }
}
    ${ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc}`;

/**
 * __useConfigureEmailTemplates_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useConfigureEmailTemplates_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConfigureEmailTemplates_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConfigureEmailTemplates_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConfigureEmailTemplates_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>(ConfigureEmailTemplates_GetConferenceConfigurationsDocument, options);
      }
export function useConfigureEmailTemplates_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>(ConfigureEmailTemplates_GetConferenceConfigurationsDocument, options);
        }
export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useConfigureEmailTemplates_GetConferenceConfigurationsQuery>;
export type ConfigureEmailTemplates_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useConfigureEmailTemplates_GetConferenceConfigurationsLazyQuery>;
export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>;
export const ConfigureEmailTemplates_UpdateConferenceConfigurationDocument = gql`
    mutation ConfigureEmailTemplates_UpdateConferenceConfiguration($value: jsonb!, $conferenceId: uuid!, $key: conference_ConfigurationKey_enum!) {
  insert_conference_Configuration_one(
    object: {value: $value, conferenceId: $conferenceId, key: $key}
    on_conflict: {constraint: Configuration_pkey, update_columns: value}
  ) {
    conferenceId
    key
    value
  }
}
    `;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationFn = Apollo.MutationFunction<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>;

/**
 * __useConfigureEmailTemplates_UpdateConferenceConfigurationMutation__
 *
 * To run a mutation, you first call `useConfigureEmailTemplates_UpdateConferenceConfigurationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConfigureEmailTemplates_UpdateConferenceConfigurationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [configureEmailTemplatesUpdateConferenceConfigurationMutation, { data, loading, error }] = useConfigureEmailTemplates_UpdateConferenceConfigurationMutation({
 *   variables: {
 *      value: // value for 'value'
 *      conferenceId: // value for 'conferenceId'
 *      key: // value for 'key'
 *   },
 * });
 */
export function useConfigureEmailTemplates_UpdateConferenceConfigurationMutation(baseOptions?: Apollo.MutationHookOptions<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>(ConfigureEmailTemplates_UpdateConferenceConfigurationDocument, options);
      }
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationHookResult = ReturnType<typeof useConfigureEmailTemplates_UpdateConferenceConfigurationMutation>;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationResult = Apollo.MutationResult<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation>;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationOptions = Apollo.BaseMutationOptions<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>;
export const ChooseElementByTagModal_GetTagsDocument = gql`
    query ChooseElementByTagModal_GetTags($conferenceId: uuid!) {
  collection_Tag(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {name: asc}
  ) {
    id
    name
  }
}
    `;

/**
 * __useChooseElementByTagModal_GetTagsQuery__
 *
 * To run a query within a React component, call `useChooseElementByTagModal_GetTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementByTagModal_GetTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementByTagModal_GetTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useChooseElementByTagModal_GetTagsQuery(baseOptions: Apollo.QueryHookOptions<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>(ChooseElementByTagModal_GetTagsDocument, options);
      }
export function useChooseElementByTagModal_GetTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>(ChooseElementByTagModal_GetTagsDocument, options);
        }
export type ChooseElementByTagModal_GetTagsQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetTagsQuery>;
export type ChooseElementByTagModal_GetTagsLazyQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetTagsLazyQuery>;
export type ChooseElementByTagModal_GetTagsQueryResult = Apollo.QueryResult<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>;
export const ChooseElementByTagModal_GetVideoElementsDocument = gql`
    query ChooseElementByTagModal_GetVideoElements($tagId: uuid!, $name: String!) {
  content_Element(
    where: {typeName: {_in: [VIDEO_FILE, VIDEO_BROADCAST, VIDEO_PREPUBLISH]}, item: {itemTags: {tag: {id: {_eq: $tagId}}}}, name: {_ilike: $name}}
    order_by: [{item: {title: asc}}, {name: asc}]
  ) {
    id
    name
    item {
      id
      title
    }
  }
}
    `;

/**
 * __useChooseElementByTagModal_GetVideoElementsQuery__
 *
 * To run a query within a React component, call `useChooseElementByTagModal_GetVideoElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementByTagModal_GetVideoElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementByTagModal_GetVideoElementsQuery({
 *   variables: {
 *      tagId: // value for 'tagId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useChooseElementByTagModal_GetVideoElementsQuery(baseOptions: Apollo.QueryHookOptions<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>(ChooseElementByTagModal_GetVideoElementsDocument, options);
      }
export function useChooseElementByTagModal_GetVideoElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>(ChooseElementByTagModal_GetVideoElementsDocument, options);
        }
export type ChooseElementByTagModal_GetVideoElementsQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetVideoElementsQuery>;
export type ChooseElementByTagModal_GetVideoElementsLazyQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetVideoElementsLazyQuery>;
export type ChooseElementByTagModal_GetVideoElementsQueryResult = Apollo.QueryResult<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>;
export const ChooseElementModal_GetItemsDocument = gql`
    query ChooseElementModal_GetItems($conferenceId: uuid!) {
  content_Item(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {title: asc}
  ) {
    id
    title
  }
}
    `;

/**
 * __useChooseElementModal_GetItemsQuery__
 *
 * To run a query within a React component, call `useChooseElementModal_GetItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementModal_GetItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementModal_GetItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useChooseElementModal_GetItemsQuery(baseOptions: Apollo.QueryHookOptions<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>(ChooseElementModal_GetItemsDocument, options);
      }
export function useChooseElementModal_GetItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>(ChooseElementModal_GetItemsDocument, options);
        }
export type ChooseElementModal_GetItemsQueryHookResult = ReturnType<typeof useChooseElementModal_GetItemsQuery>;
export type ChooseElementModal_GetItemsLazyQueryHookResult = ReturnType<typeof useChooseElementModal_GetItemsLazyQuery>;
export type ChooseElementModal_GetItemsQueryResult = Apollo.QueryResult<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>;
export const ChooseElementModal_GetVideoElementsDocument = gql`
    query ChooseElementModal_GetVideoElements($itemId: uuid) {
  content_Element(
    where: {itemId: {_eq: $itemId}, typeName: {_in: [VIDEO_FILE, VIDEO_BROADCAST, VIDEO_PREPUBLISH]}}
    order_by: {name: asc}
  ) {
    id
    name
  }
}
    `;

/**
 * __useChooseElementModal_GetVideoElementsQuery__
 *
 * To run a query within a React component, call `useChooseElementModal_GetVideoElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementModal_GetVideoElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementModal_GetVideoElementsQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useChooseElementModal_GetVideoElementsQuery(baseOptions?: Apollo.QueryHookOptions<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>(ChooseElementModal_GetVideoElementsDocument, options);
      }
export function useChooseElementModal_GetVideoElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>(ChooseElementModal_GetVideoElementsDocument, options);
        }
export type ChooseElementModal_GetVideoElementsQueryHookResult = ReturnType<typeof useChooseElementModal_GetVideoElementsQuery>;
export type ChooseElementModal_GetVideoElementsLazyQueryHookResult = ReturnType<typeof useChooseElementModal_GetVideoElementsLazyQuery>;
export type ChooseElementModal_GetVideoElementsQueryResult = Apollo.QueryResult<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>;
export const ManageExport_GetGoogleOAuthUrlDocument = gql`
    mutation ManageExport_GetGoogleOAuthUrl($registrantId: uuid!, $scopes: [String!]!) {
  getGoogleOAuthUrl(registrantId: $registrantId, scopes: $scopes) {
    url
  }
}
    `;
export type ManageExport_GetGoogleOAuthUrlMutationFn = Apollo.MutationFunction<ManageExport_GetGoogleOAuthUrlMutation, ManageExport_GetGoogleOAuthUrlMutationVariables>;

/**
 * __useManageExport_GetGoogleOAuthUrlMutation__
 *
 * To run a mutation, you first call `useManageExport_GetGoogleOAuthUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageExport_GetGoogleOAuthUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageExportGetGoogleOAuthUrlMutation, { data, loading, error }] = useManageExport_GetGoogleOAuthUrlMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      scopes: // value for 'scopes'
 *   },
 * });
 */
export function useManageExport_GetGoogleOAuthUrlMutation(baseOptions?: Apollo.MutationHookOptions<ManageExport_GetGoogleOAuthUrlMutation, ManageExport_GetGoogleOAuthUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageExport_GetGoogleOAuthUrlMutation, ManageExport_GetGoogleOAuthUrlMutationVariables>(ManageExport_GetGoogleOAuthUrlDocument, options);
      }
export type ManageExport_GetGoogleOAuthUrlMutationHookResult = ReturnType<typeof useManageExport_GetGoogleOAuthUrlMutation>;
export type ManageExport_GetGoogleOAuthUrlMutationResult = Apollo.MutationResult<ManageExport_GetGoogleOAuthUrlMutation>;
export type ManageExport_GetGoogleOAuthUrlMutationOptions = Apollo.BaseMutationOptions<ManageExport_GetGoogleOAuthUrlMutation, ManageExport_GetGoogleOAuthUrlMutationVariables>;
export const ManageExport_GetRegistrantGoogleAccountsDocument = gql`
    query ManageExport_GetRegistrantGoogleAccounts($registrantId: uuid!) {
  registrant_GoogleAccount(where: {registrantId: {_eq: $registrantId}}) {
    ...ManageExport_RegistrantGoogleAccount
  }
}
    ${ManageExport_RegistrantGoogleAccountFragmentDoc}`;

/**
 * __useManageExport_GetRegistrantGoogleAccountsQuery__
 *
 * To run a query within a React component, call `useManageExport_GetRegistrantGoogleAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageExport_GetRegistrantGoogleAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageExport_GetRegistrantGoogleAccountsQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useManageExport_GetRegistrantGoogleAccountsQuery(baseOptions: Apollo.QueryHookOptions<ManageExport_GetRegistrantGoogleAccountsQuery, ManageExport_GetRegistrantGoogleAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageExport_GetRegistrantGoogleAccountsQuery, ManageExport_GetRegistrantGoogleAccountsQueryVariables>(ManageExport_GetRegistrantGoogleAccountsDocument, options);
      }
export function useManageExport_GetRegistrantGoogleAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageExport_GetRegistrantGoogleAccountsQuery, ManageExport_GetRegistrantGoogleAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageExport_GetRegistrantGoogleAccountsQuery, ManageExport_GetRegistrantGoogleAccountsQueryVariables>(ManageExport_GetRegistrantGoogleAccountsDocument, options);
        }
export type ManageExport_GetRegistrantGoogleAccountsQueryHookResult = ReturnType<typeof useManageExport_GetRegistrantGoogleAccountsQuery>;
export type ManageExport_GetRegistrantGoogleAccountsLazyQueryHookResult = ReturnType<typeof useManageExport_GetRegistrantGoogleAccountsLazyQuery>;
export type ManageExport_GetRegistrantGoogleAccountsQueryResult = Apollo.QueryResult<ManageExport_GetRegistrantGoogleAccountsQuery, ManageExport_GetRegistrantGoogleAccountsQueryVariables>;
export const ManageExport_DeleteRegistrantGoogleAccountDocument = gql`
    mutation ManageExport_DeleteRegistrantGoogleAccount($registrantGoogleAccountId: uuid!) {
  delete_registrant_GoogleAccount_by_pk(id: $registrantGoogleAccountId) {
    id
  }
}
    `;
export type ManageExport_DeleteRegistrantGoogleAccountMutationFn = Apollo.MutationFunction<ManageExport_DeleteRegistrantGoogleAccountMutation, ManageExport_DeleteRegistrantGoogleAccountMutationVariables>;

/**
 * __useManageExport_DeleteRegistrantGoogleAccountMutation__
 *
 * To run a mutation, you first call `useManageExport_DeleteRegistrantGoogleAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageExport_DeleteRegistrantGoogleAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageExportDeleteRegistrantGoogleAccountMutation, { data, loading, error }] = useManageExport_DeleteRegistrantGoogleAccountMutation({
 *   variables: {
 *      registrantGoogleAccountId: // value for 'registrantGoogleAccountId'
 *   },
 * });
 */
export function useManageExport_DeleteRegistrantGoogleAccountMutation(baseOptions?: Apollo.MutationHookOptions<ManageExport_DeleteRegistrantGoogleAccountMutation, ManageExport_DeleteRegistrantGoogleAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageExport_DeleteRegistrantGoogleAccountMutation, ManageExport_DeleteRegistrantGoogleAccountMutationVariables>(ManageExport_DeleteRegistrantGoogleAccountDocument, options);
      }
export type ManageExport_DeleteRegistrantGoogleAccountMutationHookResult = ReturnType<typeof useManageExport_DeleteRegistrantGoogleAccountMutation>;
export type ManageExport_DeleteRegistrantGoogleAccountMutationResult = Apollo.MutationResult<ManageExport_DeleteRegistrantGoogleAccountMutation>;
export type ManageExport_DeleteRegistrantGoogleAccountMutationOptions = Apollo.BaseMutationOptions<ManageExport_DeleteRegistrantGoogleAccountMutation, ManageExport_DeleteRegistrantGoogleAccountMutationVariables>;
export const UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument = gql`
    query UploadYouTubeVideos_GetUploadYouTubeVideoJobs($conferenceId: uuid!) {
  ongoing_UploadYouTubeVideoJob: job_queues_UploadYouTubeVideoJob(
    where: {conferenceId: {_eq: $conferenceId}, jobStatusName: {_in: [NEW, IN_PROGRESS]}}
    order_by: {createdAt: desc}
    limit: 100
  ) {
    ...UploadYouTubeVideos_UploadYouTubeVideoJob
  }
  recent_UploadYouTubeVideoJob: job_queues_UploadYouTubeVideoJob(
    where: {conferenceId: {_eq: $conferenceId}, jobStatusName: {_nin: [NEW, IN_PROGRESS]}}
    order_by: {createdAt: desc}
    limit: 10
  ) {
    ...UploadYouTubeVideos_UploadYouTubeVideoJob
  }
}
    ${UploadYouTubeVideos_UploadYouTubeVideoJobFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>(UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument, options);
      }
export function useUploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>(UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument, options);
        }
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery>;
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQuery>;
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>;
export const UploadYouTubeVideos_GetRegistrantGoogleAccountsDocument = gql`
    query UploadYouTubeVideos_GetRegistrantGoogleAccounts($registrantId: uuid!) {
  registrant_GoogleAccount(where: {registrantId: {_eq: $registrantId}}) {
    id
    googleAccountEmail
    youTubeData
  }
}
    `;

/**
 * __useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>(UploadYouTubeVideos_GetRegistrantGoogleAccountsDocument, options);
      }
export function useUploadYouTubeVideos_GetRegistrantGoogleAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>(UploadYouTubeVideos_GetRegistrantGoogleAccountsDocument, options);
        }
export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery>;
export type UploadYouTubeVideos_GetRegistrantGoogleAccountsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetRegistrantGoogleAccountsLazyQuery>;
export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>;
export const UploadYouTubeVideos_CreateUploadYouTubeVideoJobsDocument = gql`
    mutation UploadYouTubeVideos_CreateUploadYouTubeVideoJobs($objects: [job_queues_UploadYouTubeVideoJob_insert_input!]!) {
  insert_job_queues_UploadYouTubeVideoJob(objects: $objects) {
    returning {
      id
    }
  }
}
    `;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationFn = Apollo.MutationFunction<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>;

/**
 * __useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation__
 *
 * To run a mutation, you first call `useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadYouTubeVideosCreateUploadYouTubeVideoJobsMutation, { data, loading, error }] = useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation(baseOptions?: Apollo.MutationHookOptions<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>(UploadYouTubeVideos_CreateUploadYouTubeVideoJobsDocument, options);
      }
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationHookResult = ReturnType<typeof useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation>;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationResult = Apollo.MutationResult<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation>;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationOptions = Apollo.BaseMutationOptions<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>;
export const UploadYouTubeVideos_GetElementsDocument = gql`
    query UploadYouTubeVideos_GetElements($elementIds: [uuid!]!) {
  content_Element(where: {id: {_in: $elementIds}}) {
    id
    name
    item {
      id
      title
    }
  }
}
    `;

/**
 * __useUploadYouTubeVideos_GetElementsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetElementsQuery({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetElementsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>(UploadYouTubeVideos_GetElementsDocument, options);
      }
export function useUploadYouTubeVideos_GetElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>(UploadYouTubeVideos_GetElementsDocument, options);
        }
export type UploadYouTubeVideos_GetElementsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetElementsQuery>;
export type UploadYouTubeVideos_GetElementsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetElementsLazyQuery>;
export type UploadYouTubeVideos_GetElementsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>;
export const UploadYouTubeVideos_GetTemplateDataDocument = gql`
    query UploadYouTubeVideos_GetTemplateData($elementIds: [uuid!]!) {
  content_Element(where: {id: {_in: $elementIds}}) {
    id
    name
    item {
      id
      shortTitle
      title
      elements {
        id
        youTubeUploads {
          id
          videoTitle
          videoId
        }
      }
      abstractElements: elements(
        where: {typeName: {_eq: ABSTRACT}}
        order_by: {updatedAt: desc}
        limit: 1
      ) {
        ...UploadYouTubeVideos_Element
      }
      paperLinkElements: elements(where: {typeName: {_eq: PAPER_LINK}}) {
        ...UploadYouTubeVideos_Element
      }
      paperUrlElements: elements(where: {typeName: {_eq: PAPER_URL}}) {
        ...UploadYouTubeVideos_Element
      }
      authors: itemPeople(
        where: {roleName: {_eq: "AUTHOR"}}
        order_by: {priority: asc}
      ) {
        id
        person {
          id
          name
          affiliation
        }
      }
      presenters: itemPeople(
        where: {roleName: {_eq: "PRESENTER"}}
        order_by: {priority: asc}
      ) {
        id
        person {
          id
          name
          affiliation
        }
      }
    }
  }
}
    ${UploadYouTubeVideos_ElementFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetTemplateDataQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetTemplateDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetTemplateDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetTemplateDataQuery({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetTemplateDataQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>(UploadYouTubeVideos_GetTemplateDataDocument, options);
      }
export function useUploadYouTubeVideos_GetTemplateDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>(UploadYouTubeVideos_GetTemplateDataDocument, options);
        }
export type UploadYouTubeVideos_GetTemplateDataQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetTemplateDataQuery>;
export type UploadYouTubeVideos_GetTemplateDataLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetTemplateDataLazyQuery>;
export type UploadYouTubeVideos_GetTemplateDataQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>;
export const UploadYouTubeVideos_RefreshYouTubeDataDocument = gql`
    mutation UploadYouTubeVideos_RefreshYouTubeData($registrantId: uuid!, $registrantGoogleAccountId: uuid!) {
  refreshYouTubeData(
    registrantId: $registrantId
    registrantGoogleAccountId: $registrantGoogleAccountId
  ) {
    message
    success
  }
}
    `;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationFn = Apollo.MutationFunction<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>;

/**
 * __useUploadYouTubeVideos_RefreshYouTubeDataMutation__
 *
 * To run a mutation, you first call `useUploadYouTubeVideos_RefreshYouTubeDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_RefreshYouTubeDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadYouTubeVideosRefreshYouTubeDataMutation, { data, loading, error }] = useUploadYouTubeVideos_RefreshYouTubeDataMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      registrantGoogleAccountId: // value for 'registrantGoogleAccountId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_RefreshYouTubeDataMutation(baseOptions?: Apollo.MutationHookOptions<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>(UploadYouTubeVideos_RefreshYouTubeDataDocument, options);
      }
export type UploadYouTubeVideos_RefreshYouTubeDataMutationHookResult = ReturnType<typeof useUploadYouTubeVideos_RefreshYouTubeDataMutation>;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationResult = Apollo.MutationResult<UploadYouTubeVideos_RefreshYouTubeDataMutation>;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationOptions = Apollo.BaseMutationOptions<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>;
export const UploadYouTubeVideos_GetYouTubeUploadsDocument = gql`
    query UploadYouTubeVideos_GetYouTubeUploads($conferenceId: uuid!) {
  video_YouTubeUpload(where: {conferenceId: {_eq: $conferenceId}}) {
    ...UploadYouTubeVideos_YouTubeUpload
  }
}
    ${UploadYouTubeVideos_YouTubeUploadFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetYouTubeUploadsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetYouTubeUploadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetYouTubeUploadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetYouTubeUploadsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetYouTubeUploadsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>(UploadYouTubeVideos_GetYouTubeUploadsDocument, options);
      }
export function useUploadYouTubeVideos_GetYouTubeUploadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>(UploadYouTubeVideos_GetYouTubeUploadsDocument, options);
        }
export type UploadYouTubeVideos_GetYouTubeUploadsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetYouTubeUploadsQuery>;
export type UploadYouTubeVideos_GetYouTubeUploadsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetYouTubeUploadsLazyQuery>;
export type UploadYouTubeVideos_GetYouTubeUploadsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>;
export const ImportRegistrantsDocument = gql`
    mutation ImportRegistrants($insertRegistrants: [registrant_Registrant_insert_input!]!, $insertInvitations: [registrant_Invitation_insert_input!]!, $insertGroupRegistrants: [permissions_GroupRegistrant_insert_input!]!) {
  insert_registrant_Registrant(objects: $insertRegistrants) {
    affected_rows
  }
  insert_registrant_Invitation(objects: $insertInvitations) {
    affected_rows
  }
  insert_permissions_GroupRegistrant(objects: $insertGroupRegistrants) {
    affected_rows
  }
}
    `;
export type ImportRegistrantsMutationFn = Apollo.MutationFunction<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>;

/**
 * __useImportRegistrantsMutation__
 *
 * To run a mutation, you first call `useImportRegistrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportRegistrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importRegistrantsMutation, { data, loading, error }] = useImportRegistrantsMutation({
 *   variables: {
 *      insertRegistrants: // value for 'insertRegistrants'
 *      insertInvitations: // value for 'insertInvitations'
 *      insertGroupRegistrants: // value for 'insertGroupRegistrants'
 *   },
 * });
 */
export function useImportRegistrantsMutation(baseOptions?: Apollo.MutationHookOptions<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>(ImportRegistrantsDocument, options);
      }
export type ImportRegistrantsMutationHookResult = ReturnType<typeof useImportRegistrantsMutation>;
export type ImportRegistrantsMutationResult = Apollo.MutationResult<ImportRegistrantsMutation>;
export type ImportRegistrantsMutationOptions = Apollo.BaseMutationOptions<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>;
export const UpdateConferenceDocument = gql`
    mutation UpdateConference($id: uuid!, $name: String = "", $shortName: String = "", $slug: String = "") {
  update_conference_Conference(
    where: {id: {_eq: $id}}
    _set: {name: $name, shortName: $shortName, slug: $slug}
  ) {
    returning {
      id
      name
      shortName
      slug
    }
  }
}
    `;
export type UpdateConferenceMutationFn = Apollo.MutationFunction<UpdateConferenceMutation, UpdateConferenceMutationVariables>;

/**
 * __useUpdateConferenceMutation__
 *
 * To run a mutation, you first call `useUpdateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConferenceMutation, { data, loading, error }] = useUpdateConferenceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useUpdateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConferenceMutation, UpdateConferenceMutationVariables>(UpdateConferenceDocument, options);
      }
export type UpdateConferenceMutationHookResult = ReturnType<typeof useUpdateConferenceMutation>;
export type UpdateConferenceMutationResult = Apollo.MutationResult<UpdateConferenceMutation>;
export type UpdateConferenceMutationOptions = Apollo.BaseMutationOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>;
export const SelectAllGroupsDocument = gql`
    query SelectAllGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageGroups_Group
  }
}
    ${ManageGroups_GroupFragmentDoc}`;

/**
 * __useSelectAllGroupsQuery__
 *
 * To run a query within a React component, call `useSelectAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllGroupsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, options);
      }
export function useSelectAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, options);
        }
export type SelectAllGroupsQueryHookResult = ReturnType<typeof useSelectAllGroupsQuery>;
export type SelectAllGroupsLazyQueryHookResult = ReturnType<typeof useSelectAllGroupsLazyQuery>;
export type SelectAllGroupsQueryResult = Apollo.QueryResult<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>;
export const CreateDeleteGroupsDocument = gql`
    mutation CreateDeleteGroups($deleteGroupIds: [uuid!] = [], $insertGroups: [permissions_Group_insert_input!]!) {
  delete_permissions_Group(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
  insert_permissions_Group(objects: $insertGroups) {
    returning {
      id
      conferenceId
      name
      enabled
      includeUnauthenticated
      groupRoles {
        id
        groupId
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteGroupsMutationFn = Apollo.MutationFunction<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;

/**
 * __useCreateDeleteGroupsMutation__
 *
 * To run a mutation, you first call `useCreateDeleteGroupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteGroupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteGroupsMutation, { data, loading, error }] = useCreateDeleteGroupsMutation({
 *   variables: {
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *      insertGroups: // value for 'insertGroups'
 *   },
 * });
 */
export function useCreateDeleteGroupsMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>(CreateDeleteGroupsDocument, options);
      }
export type CreateDeleteGroupsMutationHookResult = ReturnType<typeof useCreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationResult = Apollo.MutationResult<CreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationOptions = Apollo.BaseMutationOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;
export const UpdateGroupDocument = gql`
    mutation UpdateGroup($groupId: uuid!, $groupName: String!, $enabled: Boolean!, $includeUnauthenticated: Boolean!, $insertRoles: [permissions_GroupRole_insert_input!]!, $deleteRoleIds: [uuid!] = []) {
  update_permissions_Group(
    where: {id: {_eq: $groupId}}
    _set: {name: $groupName, enabled: $enabled, includeUnauthenticated: $includeUnauthenticated}
  ) {
    returning {
      id
      name
      groupRoles {
        id
        groupId
        roleId
      }
      conferenceId
    }
  }
  insert_permissions_GroupRole(objects: $insertRoles) {
    returning {
      id
      groupId
      roleId
    }
  }
  delete_permissions_GroupRole(
    where: {groupId: {_eq: $groupId}, roleId: {_in: $deleteRoleIds}}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateGroupMutationFn = Apollo.MutationFunction<UpdateGroupMutation, UpdateGroupMutationVariables>;

/**
 * __useUpdateGroupMutation__
 *
 * To run a mutation, you first call `useUpdateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupMutation, { data, loading, error }] = useUpdateGroupMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      groupName: // value for 'groupName'
 *      enabled: // value for 'enabled'
 *      includeUnauthenticated: // value for 'includeUnauthenticated'
 *      insertRoles: // value for 'insertRoles'
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *   },
 * });
 */
export function useUpdateGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupMutation, UpdateGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupMutation, UpdateGroupMutationVariables>(UpdateGroupDocument, options);
      }
export type UpdateGroupMutationHookResult = ReturnType<typeof useUpdateGroupMutation>;
export type UpdateGroupMutationResult = Apollo.MutationResult<UpdateGroupMutation>;
export type UpdateGroupMutationOptions = Apollo.BaseMutationOptions<UpdateGroupMutation, UpdateGroupMutationVariables>;
export const ManageProgramPeople_SelectAllPeopleDocument = gql`
    query ManageProgramPeople_SelectAllPeople($conferenceId: uuid!) {
  collection_ProgramPersonWithAccessToken(
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    ...ManageProgramPeople_ProgramPersonWithAccessToken
  }
}
    ${ManageProgramPeople_ProgramPersonWithAccessTokenFragmentDoc}`;

/**
 * __useManageProgramPeople_SelectAllPeopleQuery__
 *
 * To run a query within a React component, call `useManageProgramPeople_SelectAllPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_SelectAllPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageProgramPeople_SelectAllPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageProgramPeople_SelectAllPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>(ManageProgramPeople_SelectAllPeopleDocument, options);
      }
export function useManageProgramPeople_SelectAllPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>(ManageProgramPeople_SelectAllPeopleDocument, options);
        }
export type ManageProgramPeople_SelectAllPeopleQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllPeopleQuery>;
export type ManageProgramPeople_SelectAllPeopleLazyQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllPeopleLazyQuery>;
export type ManageProgramPeople_SelectAllPeopleQueryResult = Apollo.QueryResult<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>;
export const ManageProgramPeople_SelectAllRegistrantsDocument = gql`
    query ManageProgramPeople_SelectAllRegistrants($conferenceId: uuid!) {
  registrant_Registrant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageProgramPeople_Registrant
  }
}
    ${ManageProgramPeople_RegistrantFragmentDoc}`;

/**
 * __useManageProgramPeople_SelectAllRegistrantsQuery__
 *
 * To run a query within a React component, call `useManageProgramPeople_SelectAllRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_SelectAllRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageProgramPeople_SelectAllRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageProgramPeople_SelectAllRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>(ManageProgramPeople_SelectAllRegistrantsDocument, options);
      }
export function useManageProgramPeople_SelectAllRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>(ManageProgramPeople_SelectAllRegistrantsDocument, options);
        }
export type ManageProgramPeople_SelectAllRegistrantsQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllRegistrantsQuery>;
export type ManageProgramPeople_SelectAllRegistrantsLazyQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllRegistrantsLazyQuery>;
export type ManageProgramPeople_SelectAllRegistrantsQueryResult = Apollo.QueryResult<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>;
export const ManageProgramPeople_InsertProgramPersonDocument = gql`
    mutation ManageProgramPeople_InsertProgramPerson($person: collection_ProgramPersonWithAccessToken_insert_input!) {
  insert_collection_ProgramPersonWithAccessToken_one(object: $person) {
    ...ManageProgramPeople_ProgramPersonWithAccessToken
  }
}
    ${ManageProgramPeople_ProgramPersonWithAccessTokenFragmentDoc}`;
export type ManageProgramPeople_InsertProgramPersonMutationFn = Apollo.MutationFunction<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>;

/**
 * __useManageProgramPeople_InsertProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageProgramPeople_InsertProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_InsertProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageProgramPeopleInsertProgramPersonMutation, { data, loading, error }] = useManageProgramPeople_InsertProgramPersonMutation({
 *   variables: {
 *      person: // value for 'person'
 *   },
 * });
 */
export function useManageProgramPeople_InsertProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>(ManageProgramPeople_InsertProgramPersonDocument, options);
      }
export type ManageProgramPeople_InsertProgramPersonMutationHookResult = ReturnType<typeof useManageProgramPeople_InsertProgramPersonMutation>;
export type ManageProgramPeople_InsertProgramPersonMutationResult = Apollo.MutationResult<ManageProgramPeople_InsertProgramPersonMutation>;
export type ManageProgramPeople_InsertProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>;
export const ManageProgramPeople_DeleteProgramPersonsDocument = gql`
    mutation ManageProgramPeople_DeleteProgramPersons($ids: [uuid!] = []) {
  delete_collection_ProgramPersonWithAccessToken(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageProgramPeople_DeleteProgramPersonsMutationFn = Apollo.MutationFunction<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>;

/**
 * __useManageProgramPeople_DeleteProgramPersonsMutation__
 *
 * To run a mutation, you first call `useManageProgramPeople_DeleteProgramPersonsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_DeleteProgramPersonsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageProgramPeopleDeleteProgramPersonsMutation, { data, loading, error }] = useManageProgramPeople_DeleteProgramPersonsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageProgramPeople_DeleteProgramPersonsMutation(baseOptions?: Apollo.MutationHookOptions<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>(ManageProgramPeople_DeleteProgramPersonsDocument, options);
      }
export type ManageProgramPeople_DeleteProgramPersonsMutationHookResult = ReturnType<typeof useManageProgramPeople_DeleteProgramPersonsMutation>;
export type ManageProgramPeople_DeleteProgramPersonsMutationResult = Apollo.MutationResult<ManageProgramPeople_DeleteProgramPersonsMutation>;
export type ManageProgramPeople_DeleteProgramPersonsMutationOptions = Apollo.BaseMutationOptions<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>;
export const ManageProgramPeople_UpdateProgramPersonDocument = gql`
    mutation ManageProgramPeople_UpdateProgramPerson($id: uuid!, $name: String!, $affiliation: String, $email: String, $registrantId: uuid) {
  update_collection_ProgramPersonWithAccessToken(
    where: {id: {_eq: $id}}
    _set: {name: $name, affiliation: $affiliation, email: $email, registrantId: $registrantId}
  ) {
    returning {
      ...ManageProgramPeople_ProgramPersonWithAccessToken
    }
  }
}
    ${ManageProgramPeople_ProgramPersonWithAccessTokenFragmentDoc}`;
export type ManageProgramPeople_UpdateProgramPersonMutationFn = Apollo.MutationFunction<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>;

/**
 * __useManageProgramPeople_UpdateProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageProgramPeople_UpdateProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_UpdateProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageProgramPeopleUpdateProgramPersonMutation, { data, loading, error }] = useManageProgramPeople_UpdateProgramPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      email: // value for 'email'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useManageProgramPeople_UpdateProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>(ManageProgramPeople_UpdateProgramPersonDocument, options);
      }
export type ManageProgramPeople_UpdateProgramPersonMutationHookResult = ReturnType<typeof useManageProgramPeople_UpdateProgramPersonMutation>;
export type ManageProgramPeople_UpdateProgramPersonMutationResult = Apollo.MutationResult<ManageProgramPeople_UpdateProgramPersonMutation>;
export type ManageProgramPeople_UpdateProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>;
export const SelectAllPermissionsDocument = gql`
    query SelectAllPermissions {
  permissions_Permission {
    name
    description
  }
}
    `;

/**
 * __useSelectAllPermissionsQuery__
 *
 * To run a query within a React component, call `useSelectAllPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllPermissionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSelectAllPermissionsQuery(baseOptions?: Apollo.QueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, options);
      }
export function useSelectAllPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, options);
        }
export type SelectAllPermissionsQueryHookResult = ReturnType<typeof useSelectAllPermissionsQuery>;
export type SelectAllPermissionsLazyQueryHookResult = ReturnType<typeof useSelectAllPermissionsLazyQuery>;
export type SelectAllPermissionsQueryResult = Apollo.QueryResult<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>;
export const SelectAllRolesDocument = gql`
    query SelectAllRoles($conferenceId: uuid!) {
  permissions_Role(where: {conferenceId: {_eq: $conferenceId}}) {
    conferenceId
    id
    name
    rolePermissions {
      id
      permissionName
      roleId
    }
  }
}
    `;

/**
 * __useSelectAllRolesQuery__
 *
 * To run a query within a React component, call `useSelectAllRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRolesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRolesQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, options);
      }
export function useSelectAllRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, options);
        }
export type SelectAllRolesQueryHookResult = ReturnType<typeof useSelectAllRolesQuery>;
export type SelectAllRolesLazyQueryHookResult = ReturnType<typeof useSelectAllRolesLazyQuery>;
export type SelectAllRolesQueryResult = Apollo.QueryResult<SelectAllRolesQuery, SelectAllRolesQueryVariables>;
export const CreateDeleteRolesDocument = gql`
    mutation CreateDeleteRoles($deleteRoleIds: [uuid!] = [], $insertRoles: [permissions_Role_insert_input!]!) {
  delete_permissions_Role(where: {id: {_in: $deleteRoleIds}}) {
    returning {
      id
    }
  }
  insert_permissions_Role(objects: $insertRoles) {
    returning {
      id
      conferenceId
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteRolesMutationFn = Apollo.MutationFunction<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;

/**
 * __useCreateDeleteRolesMutation__
 *
 * To run a mutation, you first call `useCreateDeleteRolesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteRolesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteRolesMutation, { data, loading, error }] = useCreateDeleteRolesMutation({
 *   variables: {
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *      insertRoles: // value for 'insertRoles'
 *   },
 * });
 */
export function useCreateDeleteRolesMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>(CreateDeleteRolesDocument, options);
      }
export type CreateDeleteRolesMutationHookResult = ReturnType<typeof useCreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationResult = Apollo.MutationResult<CreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationOptions = Apollo.BaseMutationOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;
export const UpdateRoleDocument = gql`
    mutation UpdateRole($roleId: uuid!, $roleName: String!, $insertPermissions: [permissions_RolePermission_insert_input!]!, $deletePermissionNames: [permissions_Permission_enum!] = []) {
  update_permissions_Role(where: {id: {_eq: $roleId}}, _set: {name: $roleName}) {
    returning {
      id
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
      conferenceId
    }
  }
  insert_permissions_RolePermission(objects: $insertPermissions) {
    returning {
      id
      permissionName
      roleId
    }
  }
  delete_permissions_RolePermission(
    where: {roleId: {_eq: $roleId}, permissionName: {_in: $deletePermissionNames}}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateRoleMutationFn = Apollo.MutationFunction<UpdateRoleMutation, UpdateRoleMutationVariables>;

/**
 * __useUpdateRoleMutation__
 *
 * To run a mutation, you first call `useUpdateRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoleMutation, { data, loading, error }] = useUpdateRoleMutation({
 *   variables: {
 *      roleId: // value for 'roleId'
 *      roleName: // value for 'roleName'
 *      insertPermissions: // value for 'insertPermissions'
 *      deletePermissionNames: // value for 'deletePermissionNames'
 *   },
 * });
 */
export function useUpdateRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoleMutation, UpdateRoleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoleMutation, UpdateRoleMutationVariables>(UpdateRoleDocument, options);
      }
export type UpdateRoleMutationHookResult = ReturnType<typeof useUpdateRoleMutation>;
export type UpdateRoleMutationResult = Apollo.MutationResult<UpdateRoleMutation>;
export type UpdateRoleMutationOptions = Apollo.BaseMutationOptions<UpdateRoleMutation, UpdateRoleMutationVariables>;
export const SelectAllRoomsWithParticipantsDocument = gql`
    query SelectAllRoomsWithParticipants($conferenceId: uuid!) {
  room_Room(
    where: {conferenceId: {_eq: $conferenceId}, managementModeName: {_in: [PUBLIC, PRIVATE]}}
  ) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;

/**
 * __useSelectAllRoomsWithParticipantsQuery__
 *
 * To run a query within a React component, call `useSelectAllRoomsWithParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRoomsWithParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRoomsWithParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRoomsWithParticipantsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, options);
      }
export function useSelectAllRoomsWithParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, options);
        }
export type SelectAllRoomsWithParticipantsQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsQuery>;
export type SelectAllRoomsWithParticipantsLazyQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsLazyQuery>;
export type SelectAllRoomsWithParticipantsQueryResult = Apollo.QueryResult<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>;
export const ManageRooms_SelectGroupsDocument = gql`
    query ManageRooms_SelectGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
  }
}
    `;

/**
 * __useManageRooms_SelectGroupsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageRooms_SelectGroupsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>(ManageRooms_SelectGroupsDocument, options);
      }
export function useManageRooms_SelectGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>(ManageRooms_SelectGroupsDocument, options);
        }
export type ManageRooms_SelectGroupsQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupsQuery>;
export type ManageRooms_SelectGroupsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupsLazyQuery>;
export type ManageRooms_SelectGroupsQueryResult = Apollo.QueryResult<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>;
export const ManageRooms_SelectItemsDocument = gql`
    query ManageRooms_SelectItems($conferenceId: uuid!) {
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    title
  }
}
    `;

/**
 * __useManageRooms_SelectItemsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageRooms_SelectItemsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>(ManageRooms_SelectItemsDocument, options);
      }
export function useManageRooms_SelectItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>(ManageRooms_SelectItemsDocument, options);
        }
export type ManageRooms_SelectItemsQueryHookResult = ReturnType<typeof useManageRooms_SelectItemsQuery>;
export type ManageRooms_SelectItemsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectItemsLazyQuery>;
export type ManageRooms_SelectItemsQueryResult = Apollo.QueryResult<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>;
export const ManageRooms_SelectGroupRegistrantsDocument = gql`
    query ManageRooms_SelectGroupRegistrants($groupId: uuid!) {
  permissions_GroupRegistrant(where: {groupId: {_eq: $groupId}}) {
    id
    groupId
    registrantId
  }
}
    `;

/**
 * __useManageRooms_SelectGroupRegistrantsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectGroupRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectGroupRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectGroupRegistrantsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useManageRooms_SelectGroupRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>(ManageRooms_SelectGroupRegistrantsDocument, options);
      }
export function useManageRooms_SelectGroupRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>(ManageRooms_SelectGroupRegistrantsDocument, options);
        }
export type ManageRooms_SelectGroupRegistrantsQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupRegistrantsQuery>;
export type ManageRooms_SelectGroupRegistrantsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupRegistrantsLazyQuery>;
export type ManageRooms_SelectGroupRegistrantsQueryResult = Apollo.QueryResult<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>;
export const ManageRooms_SelectRoomPeopleDocument = gql`
    query ManageRooms_SelectRoomPeople($roomId: uuid!) {
  room_RoomPerson(where: {roomId: {_eq: $roomId}}) {
    ...RoomPersonInfo
  }
}
    ${RoomPersonInfoFragmentDoc}`;

/**
 * __useManageRooms_SelectRoomPeopleQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectRoomPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectRoomPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectRoomPeopleQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useManageRooms_SelectRoomPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>(ManageRooms_SelectRoomPeopleDocument, options);
      }
export function useManageRooms_SelectRoomPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>(ManageRooms_SelectRoomPeopleDocument, options);
        }
export type ManageRooms_SelectRoomPeopleQueryHookResult = ReturnType<typeof useManageRooms_SelectRoomPeopleQuery>;
export type ManageRooms_SelectRoomPeopleLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectRoomPeopleLazyQuery>;
export type ManageRooms_SelectRoomPeopleQueryResult = Apollo.QueryResult<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>;
export const CreateRoomDocument = gql`
    mutation CreateRoom($room: room_Room_insert_input!) {
  insert_room_Room_one(object: $room) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type CreateRoomMutationFn = Apollo.MutationFunction<CreateRoomMutation, CreateRoomMutationVariables>;

/**
 * __useCreateRoomMutation__
 *
 * To run a mutation, you first call `useCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoomMutation, { data, loading, error }] = useCreateRoomMutation({
 *   variables: {
 *      room: // value for 'room'
 *   },
 * });
 */
export function useCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<CreateRoomMutation, CreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRoomMutation, CreateRoomMutationVariables>(CreateRoomDocument, options);
      }
export type CreateRoomMutationHookResult = ReturnType<typeof useCreateRoomMutation>;
export type CreateRoomMutationResult = Apollo.MutationResult<CreateRoomMutation>;
export type CreateRoomMutationOptions = Apollo.BaseMutationOptions<CreateRoomMutation, CreateRoomMutationVariables>;
export const UpdateRoomsWithParticipantsDocument = gql`
    mutation UpdateRoomsWithParticipants($id: uuid!, $name: String!, $capacity: Int, $priority: Int!, $managementModeName: room_ManagementMode_enum!, $originatingItemId: uuid, $chatId: uuid!, $enableMandatoryPin: Boolean!, $enableAutoPin: Boolean!, $enableMandatorySubscribe: Boolean!, $enableAutoSubscribe: Boolean!) {
  update_room_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, priority: $priority, managementModeName: $managementModeName, originatingItemId: $originatingItemId}
  ) {
    ...RoomWithParticipantInfo
  }
  update_chat_Chat(
    where: {id: {_eq: $chatId}}
    _set: {enableMandatoryPin: $enableMandatoryPin, enableAutoPin: $enableAutoPin, enableMandatorySubscribe: $enableMandatorySubscribe, enableAutoSubscribe: $enableAutoSubscribe}
  ) {
    returning {
      id
      enableMandatoryPin
      enableAutoPin
      enableMandatorySubscribe
      enableAutoSubscribe
    }
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type UpdateRoomsWithParticipantsMutationFn = Apollo.MutationFunction<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;

/**
 * __useUpdateRoomsWithParticipantsMutation__
 *
 * To run a mutation, you first call `useUpdateRoomsWithParticipantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomsWithParticipantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomsWithParticipantsMutation, { data, loading, error }] = useUpdateRoomsWithParticipantsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      priority: // value for 'priority'
 *      managementModeName: // value for 'managementModeName'
 *      originatingItemId: // value for 'originatingItemId'
 *      chatId: // value for 'chatId'
 *      enableMandatoryPin: // value for 'enableMandatoryPin'
 *      enableAutoPin: // value for 'enableAutoPin'
 *      enableMandatorySubscribe: // value for 'enableMandatorySubscribe'
 *      enableAutoSubscribe: // value for 'enableAutoSubscribe'
 *   },
 * });
 */
export function useUpdateRoomsWithParticipantsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>(UpdateRoomsWithParticipantsDocument, options);
      }
export type UpdateRoomsWithParticipantsMutationHookResult = ReturnType<typeof useUpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationResult = Apollo.MutationResult<UpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationOptions = Apollo.BaseMutationOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;
export const InsertRoomPeopleDocument = gql`
    mutation InsertRoomPeople($people: [room_RoomPerson_insert_input!]!) {
  insert_room_RoomPerson(
    objects: $people
    on_conflict: {constraint: RoomPerson_registrantId_roomId_key, update_columns: []}
  ) {
    returning {
      ...RoomPersonInfo
    }
  }
}
    ${RoomPersonInfoFragmentDoc}`;
export type InsertRoomPeopleMutationFn = Apollo.MutationFunction<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>;

/**
 * __useInsertRoomPeopleMutation__
 *
 * To run a mutation, you first call `useInsertRoomPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomPeopleMutation, { data, loading, error }] = useInsertRoomPeopleMutation({
 *   variables: {
 *      people: // value for 'people'
 *   },
 * });
 */
export function useInsertRoomPeopleMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>(InsertRoomPeopleDocument, options);
      }
export type InsertRoomPeopleMutationHookResult = ReturnType<typeof useInsertRoomPeopleMutation>;
export type InsertRoomPeopleMutationResult = Apollo.MutationResult<InsertRoomPeopleMutation>;
export type InsertRoomPeopleMutationOptions = Apollo.BaseMutationOptions<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>;
export const GetIsExternalRtmpBroadcastEnabledDocument = gql`
    query GetIsExternalRtmpBroadcastEnabled($conferenceId: uuid!) {
  conference_Configuration_by_pk(
    conferenceId: $conferenceId
    key: ENABLE_EXTERNAL_RTMP_BROADCAST
  ) {
    conferenceId
    key
    value
  }
}
    `;

/**
 * __useGetIsExternalRtmpBroadcastEnabledQuery__
 *
 * To run a query within a React component, call `useGetIsExternalRtmpBroadcastEnabledQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetIsExternalRtmpBroadcastEnabledQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetIsExternalRtmpBroadcastEnabledQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetIsExternalRtmpBroadcastEnabledQuery(baseOptions: Apollo.QueryHookOptions<GetIsExternalRtmpBroadcastEnabledQuery, GetIsExternalRtmpBroadcastEnabledQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetIsExternalRtmpBroadcastEnabledQuery, GetIsExternalRtmpBroadcastEnabledQueryVariables>(GetIsExternalRtmpBroadcastEnabledDocument, options);
      }
export function useGetIsExternalRtmpBroadcastEnabledLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetIsExternalRtmpBroadcastEnabledQuery, GetIsExternalRtmpBroadcastEnabledQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetIsExternalRtmpBroadcastEnabledQuery, GetIsExternalRtmpBroadcastEnabledQueryVariables>(GetIsExternalRtmpBroadcastEnabledDocument, options);
        }
export type GetIsExternalRtmpBroadcastEnabledQueryHookResult = ReturnType<typeof useGetIsExternalRtmpBroadcastEnabledQuery>;
export type GetIsExternalRtmpBroadcastEnabledLazyQueryHookResult = ReturnType<typeof useGetIsExternalRtmpBroadcastEnabledLazyQuery>;
export type GetIsExternalRtmpBroadcastEnabledQueryResult = Apollo.QueryResult<GetIsExternalRtmpBroadcastEnabledQuery, GetIsExternalRtmpBroadcastEnabledQueryVariables>;
export const SelectAllRegistrantsDocument = gql`
    query SelectAllRegistrants($conferenceId: uuid!) {
  registrant_Registrant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RegistrantParts
  }
}
    ${RegistrantPartsFragmentDoc}`;

/**
 * __useSelectAllRegistrantsQuery__
 *
 * To run a query within a React component, call `useSelectAllRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>(SelectAllRegistrantsDocument, options);
      }
export function useSelectAllRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>(SelectAllRegistrantsDocument, options);
        }
export type SelectAllRegistrantsQueryHookResult = ReturnType<typeof useSelectAllRegistrantsQuery>;
export type SelectAllRegistrantsLazyQueryHookResult = ReturnType<typeof useSelectAllRegistrantsLazyQuery>;
export type SelectAllRegistrantsQueryResult = Apollo.QueryResult<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>;
export const ManageRegistrants_SelectProfilesDocument = gql`
    query ManageRegistrants_SelectProfiles($registrantIds: [uuid!]!) {
  registrant_Profile(where: {registrantId: {_in: $registrantIds}}) {
    ...ManageRegistrants_Profile
  }
}
    ${ManageRegistrants_ProfileFragmentDoc}`;

/**
 * __useManageRegistrants_SelectProfilesQuery__
 *
 * To run a query within a React component, call `useManageRegistrants_SelectProfilesQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRegistrants_SelectProfilesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRegistrants_SelectProfilesQuery({
 *   variables: {
 *      registrantIds: // value for 'registrantIds'
 *   },
 * });
 */
export function useManageRegistrants_SelectProfilesQuery(baseOptions: Apollo.QueryHookOptions<ManageRegistrants_SelectProfilesQuery, ManageRegistrants_SelectProfilesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRegistrants_SelectProfilesQuery, ManageRegistrants_SelectProfilesQueryVariables>(ManageRegistrants_SelectProfilesDocument, options);
      }
export function useManageRegistrants_SelectProfilesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRegistrants_SelectProfilesQuery, ManageRegistrants_SelectProfilesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRegistrants_SelectProfilesQuery, ManageRegistrants_SelectProfilesQueryVariables>(ManageRegistrants_SelectProfilesDocument, options);
        }
export type ManageRegistrants_SelectProfilesQueryHookResult = ReturnType<typeof useManageRegistrants_SelectProfilesQuery>;
export type ManageRegistrants_SelectProfilesLazyQueryHookResult = ReturnType<typeof useManageRegistrants_SelectProfilesLazyQuery>;
export type ManageRegistrants_SelectProfilesQueryResult = Apollo.QueryResult<ManageRegistrants_SelectProfilesQuery, ManageRegistrants_SelectProfilesQueryVariables>;
export const InsertRegistrantDocument = gql`
    mutation InsertRegistrant($registrant: registrant_Registrant_insert_input!, $invitation: registrant_Invitation_insert_input!) {
  insert_registrant_Registrant_one(object: $registrant) {
    ...RegistrantParts
  }
  insert_registrant_Invitation_one(object: $invitation) {
    ...InvitationParts
  }
}
    ${RegistrantPartsFragmentDoc}
${InvitationPartsFragmentDoc}`;
export type InsertRegistrantMutationFn = Apollo.MutationFunction<InsertRegistrantMutation, InsertRegistrantMutationVariables>;

/**
 * __useInsertRegistrantMutation__
 *
 * To run a mutation, you first call `useInsertRegistrantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRegistrantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRegistrantMutation, { data, loading, error }] = useInsertRegistrantMutation({
 *   variables: {
 *      registrant: // value for 'registrant'
 *      invitation: // value for 'invitation'
 *   },
 * });
 */
export function useInsertRegistrantMutation(baseOptions?: Apollo.MutationHookOptions<InsertRegistrantMutation, InsertRegistrantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRegistrantMutation, InsertRegistrantMutationVariables>(InsertRegistrantDocument, options);
      }
export type InsertRegistrantMutationHookResult = ReturnType<typeof useInsertRegistrantMutation>;
export type InsertRegistrantMutationResult = Apollo.MutationResult<InsertRegistrantMutation>;
export type InsertRegistrantMutationOptions = Apollo.BaseMutationOptions<InsertRegistrantMutation, InsertRegistrantMutationVariables>;
export const InsertRegistrantWithoutInviteDocument = gql`
    mutation InsertRegistrantWithoutInvite($registrant: registrant_Registrant_insert_input!) {
  insert_registrant_Registrant_one(object: $registrant) {
    ...RegistrantParts
  }
}
    ${RegistrantPartsFragmentDoc}`;
export type InsertRegistrantWithoutInviteMutationFn = Apollo.MutationFunction<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>;

/**
 * __useInsertRegistrantWithoutInviteMutation__
 *
 * To run a mutation, you first call `useInsertRegistrantWithoutInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRegistrantWithoutInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRegistrantWithoutInviteMutation, { data, loading, error }] = useInsertRegistrantWithoutInviteMutation({
 *   variables: {
 *      registrant: // value for 'registrant'
 *   },
 * });
 */
export function useInsertRegistrantWithoutInviteMutation(baseOptions?: Apollo.MutationHookOptions<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>(InsertRegistrantWithoutInviteDocument, options);
      }
export type InsertRegistrantWithoutInviteMutationHookResult = ReturnType<typeof useInsertRegistrantWithoutInviteMutation>;
export type InsertRegistrantWithoutInviteMutationResult = Apollo.MutationResult<InsertRegistrantWithoutInviteMutation>;
export type InsertRegistrantWithoutInviteMutationOptions = Apollo.BaseMutationOptions<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>;
export const DeleteRegistrantsDocument = gql`
    mutation DeleteRegistrants($deleteRegistrantIds: [uuid!] = []) {
  delete_registrant_Registrant(where: {id: {_in: $deleteRegistrantIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteRegistrantsMutationFn = Apollo.MutationFunction<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>;

/**
 * __useDeleteRegistrantsMutation__
 *
 * To run a mutation, you first call `useDeleteRegistrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRegistrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRegistrantsMutation, { data, loading, error }] = useDeleteRegistrantsMutation({
 *   variables: {
 *      deleteRegistrantIds: // value for 'deleteRegistrantIds'
 *   },
 * });
 */
export function useDeleteRegistrantsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>(DeleteRegistrantsDocument, options);
      }
export type DeleteRegistrantsMutationHookResult = ReturnType<typeof useDeleteRegistrantsMutation>;
export type DeleteRegistrantsMutationResult = Apollo.MutationResult<DeleteRegistrantsMutation>;
export type DeleteRegistrantsMutationOptions = Apollo.BaseMutationOptions<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>;
export const UpdateRegistrantDocument = gql`
    mutation UpdateRegistrant($registrantId: uuid!, $registrantName: String!, $upsertGroups: [permissions_GroupRegistrant_insert_input!]!, $remainingGroupIds: [uuid!]) {
  update_registrant_Registrant_by_pk(
    pk_columns: {id: $registrantId}
    _set: {displayName: $registrantName}
  ) {
    ...RegistrantParts
  }
  insert_permissions_GroupRegistrant(
    objects: $upsertGroups
    on_conflict: {constraint: GroupRegistrant_groupId_registrantId_key, update_columns: []}
  ) {
    returning {
      id
      registrantId
      groupId
    }
  }
  delete_permissions_GroupRegistrant(
    where: {registrantId: {_eq: $registrantId}, groupId: {_nin: $remainingGroupIds}}
  ) {
    returning {
      id
    }
  }
}
    ${RegistrantPartsFragmentDoc}`;
export type UpdateRegistrantMutationFn = Apollo.MutationFunction<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>;

/**
 * __useUpdateRegistrantMutation__
 *
 * To run a mutation, you first call `useUpdateRegistrantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRegistrantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRegistrantMutation, { data, loading, error }] = useUpdateRegistrantMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      registrantName: // value for 'registrantName'
 *      upsertGroups: // value for 'upsertGroups'
 *      remainingGroupIds: // value for 'remainingGroupIds'
 *   },
 * });
 */
export function useUpdateRegistrantMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>(UpdateRegistrantDocument, options);
      }
export type UpdateRegistrantMutationHookResult = ReturnType<typeof useUpdateRegistrantMutation>;
export type UpdateRegistrantMutationResult = Apollo.MutationResult<UpdateRegistrantMutation>;
export type UpdateRegistrantMutationOptions = Apollo.BaseMutationOptions<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>;
export const InsertInvitationEmailJobsDocument = gql`
    mutation InsertInvitationEmailJobs($registrantIds: jsonb!, $conferenceId: uuid!, $sendRepeat: Boolean!) {
  insert_job_queues_InvitationEmailJob(
    objects: [{registrantIds: $registrantIds, conferenceId: $conferenceId, sendRepeat: $sendRepeat}]
  ) {
    affected_rows
  }
}
    `;
export type InsertInvitationEmailJobsMutationFn = Apollo.MutationFunction<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;

/**
 * __useInsertInvitationEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertInvitationEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertInvitationEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertInvitationEmailJobsMutation, { data, loading, error }] = useInsertInvitationEmailJobsMutation({
 *   variables: {
 *      registrantIds: // value for 'registrantIds'
 *      conferenceId: // value for 'conferenceId'
 *      sendRepeat: // value for 'sendRepeat'
 *   },
 * });
 */
export function useInsertInvitationEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>(InsertInvitationEmailJobsDocument, options);
      }
export type InsertInvitationEmailJobsMutationHookResult = ReturnType<typeof useInsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationResult = Apollo.MutationResult<InsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;
export const ManagePeople_InsertCustomEmailJobDocument = gql`
    mutation ManagePeople_InsertCustomEmailJob($htmlBody: String!, $subject: String!, $conferenceId: uuid!, $registrantIds: jsonb!) {
  insert_job_queues_CustomEmailJob(
    objects: {htmlBody: $htmlBody, subject: $subject, conferenceId: $conferenceId, registrantIds: $registrantIds}
  ) {
    affected_rows
  }
}
    `;
export type ManagePeople_InsertCustomEmailJobMutationFn = Apollo.MutationFunction<ManagePeople_InsertCustomEmailJobMutation, ManagePeople_InsertCustomEmailJobMutationVariables>;

/**
 * __useManagePeople_InsertCustomEmailJobMutation__
 *
 * To run a mutation, you first call `useManagePeople_InsertCustomEmailJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManagePeople_InsertCustomEmailJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [managePeopleInsertCustomEmailJobMutation, { data, loading, error }] = useManagePeople_InsertCustomEmailJobMutation({
 *   variables: {
 *      htmlBody: // value for 'htmlBody'
 *      subject: // value for 'subject'
 *      conferenceId: // value for 'conferenceId'
 *      registrantIds: // value for 'registrantIds'
 *   },
 * });
 */
export function useManagePeople_InsertCustomEmailJobMutation(baseOptions?: Apollo.MutationHookOptions<ManagePeople_InsertCustomEmailJobMutation, ManagePeople_InsertCustomEmailJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManagePeople_InsertCustomEmailJobMutation, ManagePeople_InsertCustomEmailJobMutationVariables>(ManagePeople_InsertCustomEmailJobDocument, options);
      }
export type ManagePeople_InsertCustomEmailJobMutationHookResult = ReturnType<typeof useManagePeople_InsertCustomEmailJobMutation>;
export type ManagePeople_InsertCustomEmailJobMutationResult = Apollo.MutationResult<ManagePeople_InsertCustomEmailJobMutation>;
export type ManagePeople_InsertCustomEmailJobMutationOptions = Apollo.BaseMutationOptions<ManagePeople_InsertCustomEmailJobMutation, ManagePeople_InsertCustomEmailJobMutationVariables>;
export const SendEmail_GetAllGroupsDocument = gql`
    query SendEmail_GetAllGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    enabled
    name
  }
}
    `;

/**
 * __useSendEmail_GetAllGroupsQuery__
 *
 * To run a query within a React component, call `useSendEmail_GetAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendEmail_GetAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendEmail_GetAllGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSendEmail_GetAllGroupsQuery(baseOptions: Apollo.QueryHookOptions<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>(SendEmail_GetAllGroupsDocument, options);
      }
export function useSendEmail_GetAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>(SendEmail_GetAllGroupsDocument, options);
        }
export type SendEmail_GetAllGroupsQueryHookResult = ReturnType<typeof useSendEmail_GetAllGroupsQuery>;
export type SendEmail_GetAllGroupsLazyQueryHookResult = ReturnType<typeof useSendEmail_GetAllGroupsLazyQuery>;
export type SendEmail_GetAllGroupsQueryResult = Apollo.QueryResult<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>;
export const GetRoomRtmpOutputDocument = gql`
    query GetRoomRtmpOutput($roomId: uuid!) {
  room_Room_by_pk(id: $roomId) {
    id
    rtmpOutput {
      id
      created_at
      updated_at
      url
      streamKey
    }
    channelStack: channelStackWithStreamKey {
      id
      rtmpOutputUri
      rtmpOutputStreamKey
      updateJobs: channelStackUpdateJobs(
        where: {jobStatusName: {_in: [NEW, IN_PROGRESS]}}
      ) {
        id
        created_at
        updated_at
        jobStatusName
        message
      }
      mediaLiveChannelStatus {
        id
        createdAt
        updatedAt
        state
      }
    }
  }
}
    `;

/**
 * __useGetRoomRtmpOutputQuery__
 *
 * To run a query within a React component, call `useGetRoomRtmpOutputQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomRtmpOutputQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomRtmpOutputQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomRtmpOutputQuery(baseOptions: Apollo.QueryHookOptions<GetRoomRtmpOutputQuery, GetRoomRtmpOutputQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomRtmpOutputQuery, GetRoomRtmpOutputQueryVariables>(GetRoomRtmpOutputDocument, options);
      }
export function useGetRoomRtmpOutputLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomRtmpOutputQuery, GetRoomRtmpOutputQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomRtmpOutputQuery, GetRoomRtmpOutputQueryVariables>(GetRoomRtmpOutputDocument, options);
        }
export type GetRoomRtmpOutputQueryHookResult = ReturnType<typeof useGetRoomRtmpOutputQuery>;
export type GetRoomRtmpOutputLazyQueryHookResult = ReturnType<typeof useGetRoomRtmpOutputLazyQuery>;
export type GetRoomRtmpOutputQueryResult = Apollo.QueryResult<GetRoomRtmpOutputQuery, GetRoomRtmpOutputQueryVariables>;
export const InsertRoomRtmpOutputDocument = gql`
    mutation InsertRoomRtmpOutput($roomId: uuid!, $url: String!, $key: String!) {
  insert_video_RoomRtmpOutput_one(
    object: {roomId: $roomId, url: $url, streamKey: $key}
  ) {
    id
    roomId
    created_at
    updated_at
    url
    streamKey
  }
}
    `;
export type InsertRoomRtmpOutputMutationFn = Apollo.MutationFunction<InsertRoomRtmpOutputMutation, InsertRoomRtmpOutputMutationVariables>;

/**
 * __useInsertRoomRtmpOutputMutation__
 *
 * To run a mutation, you first call `useInsertRoomRtmpOutputMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomRtmpOutputMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomRtmpOutputMutation, { data, loading, error }] = useInsertRoomRtmpOutputMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *      url: // value for 'url'
 *      key: // value for 'key'
 *   },
 * });
 */
export function useInsertRoomRtmpOutputMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomRtmpOutputMutation, InsertRoomRtmpOutputMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRoomRtmpOutputMutation, InsertRoomRtmpOutputMutationVariables>(InsertRoomRtmpOutputDocument, options);
      }
export type InsertRoomRtmpOutputMutationHookResult = ReturnType<typeof useInsertRoomRtmpOutputMutation>;
export type InsertRoomRtmpOutputMutationResult = Apollo.MutationResult<InsertRoomRtmpOutputMutation>;
export type InsertRoomRtmpOutputMutationOptions = Apollo.BaseMutationOptions<InsertRoomRtmpOutputMutation, InsertRoomRtmpOutputMutationVariables>;
export const UpdateRoomRtmpOutputDocument = gql`
    mutation UpdateRoomRtmpOutput($id: uuid!, $url: String!, $key: String!) {
  update_video_RoomRtmpOutput_by_pk(
    pk_columns: {id: $id}
    _set: {url: $url, streamKey: $key}
  ) {
    id
    roomId
    created_at
    updated_at
    url
    streamKey
  }
}
    `;
export type UpdateRoomRtmpOutputMutationFn = Apollo.MutationFunction<UpdateRoomRtmpOutputMutation, UpdateRoomRtmpOutputMutationVariables>;

/**
 * __useUpdateRoomRtmpOutputMutation__
 *
 * To run a mutation, you first call `useUpdateRoomRtmpOutputMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomRtmpOutputMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomRtmpOutputMutation, { data, loading, error }] = useUpdateRoomRtmpOutputMutation({
 *   variables: {
 *      id: // value for 'id'
 *      url: // value for 'url'
 *      key: // value for 'key'
 *   },
 * });
 */
export function useUpdateRoomRtmpOutputMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomRtmpOutputMutation, UpdateRoomRtmpOutputMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoomRtmpOutputMutation, UpdateRoomRtmpOutputMutationVariables>(UpdateRoomRtmpOutputDocument, options);
      }
export type UpdateRoomRtmpOutputMutationHookResult = ReturnType<typeof useUpdateRoomRtmpOutputMutation>;
export type UpdateRoomRtmpOutputMutationResult = Apollo.MutationResult<UpdateRoomRtmpOutputMutation>;
export type UpdateRoomRtmpOutputMutationOptions = Apollo.BaseMutationOptions<UpdateRoomRtmpOutputMutation, UpdateRoomRtmpOutputMutationVariables>;
export const DeleteRoomRtmpOutputDocument = gql`
    mutation DeleteRoomRtmpOutput($id: uuid!) {
  delete_video_RoomRtmpOutput_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteRoomRtmpOutputMutationFn = Apollo.MutationFunction<DeleteRoomRtmpOutputMutation, DeleteRoomRtmpOutputMutationVariables>;

/**
 * __useDeleteRoomRtmpOutputMutation__
 *
 * To run a mutation, you first call `useDeleteRoomRtmpOutputMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRoomRtmpOutputMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRoomRtmpOutputMutation, { data, loading, error }] = useDeleteRoomRtmpOutputMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteRoomRtmpOutputMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRoomRtmpOutputMutation, DeleteRoomRtmpOutputMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRoomRtmpOutputMutation, DeleteRoomRtmpOutputMutationVariables>(DeleteRoomRtmpOutputDocument, options);
      }
export type DeleteRoomRtmpOutputMutationHookResult = ReturnType<typeof useDeleteRoomRtmpOutputMutation>;
export type DeleteRoomRtmpOutputMutationResult = Apollo.MutationResult<DeleteRoomRtmpOutputMutation>;
export type DeleteRoomRtmpOutputMutationOptions = Apollo.BaseMutationOptions<DeleteRoomRtmpOutputMutation, DeleteRoomRtmpOutputMutationVariables>;
export const AddEventPeople_SelectItemPeopleDocument = gql`
    query AddEventPeople_SelectItemPeople($itemIds: [uuid!]!, $exhibitionIds: [uuid!]!) {
  content_ItemProgramPerson(where: {_or: [{itemId: {_in: $itemIds}}]}) {
    ...AddEventPeople_ItemPerson
  }
  content_ItemExhibition(where: {exhibitionId: {_in: $exhibitionIds}}) {
    id
    exhibitionId
    item {
      id
      itemPeople {
        ...AddEventPeople_ItemPerson
      }
    }
  }
}
    ${AddEventPeople_ItemPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectItemPeopleQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectItemPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectItemPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectItemPeopleQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *      exhibitionIds: // value for 'exhibitionIds'
 *   },
 * });
 */
export function useAddEventPeople_SelectItemPeopleQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>(AddEventPeople_SelectItemPeopleDocument, options);
      }
export function useAddEventPeople_SelectItemPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>(AddEventPeople_SelectItemPeopleDocument, options);
        }
export type AddEventPeople_SelectItemPeopleQueryHookResult = ReturnType<typeof useAddEventPeople_SelectItemPeopleQuery>;
export type AddEventPeople_SelectItemPeopleLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectItemPeopleLazyQuery>;
export type AddEventPeople_SelectItemPeopleQueryResult = Apollo.QueryResult<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>;
export const AddEventPeople_SelectProgramPeopleDocument = gql`
    query AddEventPeople_SelectProgramPeople($conferenceId: uuid!) {
  collection_ProgramPersonWithAccessToken(
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    ...AddEventPeople_ProgramPerson
  }
}
    ${AddEventPeople_ProgramPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectProgramPeopleQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectProgramPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectProgramPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectProgramPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectProgramPeopleQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>(AddEventPeople_SelectProgramPeopleDocument, options);
      }
export function useAddEventPeople_SelectProgramPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>(AddEventPeople_SelectProgramPeopleDocument, options);
        }
export type AddEventPeople_SelectProgramPeopleQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeopleQuery>;
export type AddEventPeople_SelectProgramPeopleLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeopleLazyQuery>;
export type AddEventPeople_SelectProgramPeopleQueryResult = Apollo.QueryResult<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>;
export const AddEventPeople_SelectRegistrantsDocument = gql`
    query AddEventPeople_SelectRegistrants($conferenceId: uuid!) {
  registrant_Registrant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_Registrant
  }
}
    ${AddEventPeople_RegistrantFragmentDoc}`;

/**
 * __useAddEventPeople_SelectRegistrantsQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>(AddEventPeople_SelectRegistrantsDocument, options);
      }
export function useAddEventPeople_SelectRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>(AddEventPeople_SelectRegistrantsDocument, options);
        }
export type AddEventPeople_SelectRegistrantsQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrantsQuery>;
export type AddEventPeople_SelectRegistrantsLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrantsLazyQuery>;
export type AddEventPeople_SelectRegistrantsQueryResult = Apollo.QueryResult<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>;
export const AddEventPeople_SelectProgramPeople_ByRegistrantDocument = gql`
    query AddEventPeople_SelectProgramPeople_ByRegistrant($registrantIds: [uuid!]!) {
  collection_ProgramPersonWithAccessToken(
    where: {registrantId: {_in: $registrantIds}}
  ) {
    ...AddEventPeople_ProgramPerson
  }
}
    ${AddEventPeople_ProgramPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectProgramPeople_ByRegistrantQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectProgramPeople_ByRegistrantQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectProgramPeople_ByRegistrantQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectProgramPeople_ByRegistrantQuery({
 *   variables: {
 *      registrantIds: // value for 'registrantIds'
 *   },
 * });
 */
export function useAddEventPeople_SelectProgramPeople_ByRegistrantQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>(AddEventPeople_SelectProgramPeople_ByRegistrantDocument, options);
      }
export function useAddEventPeople_SelectProgramPeople_ByRegistrantLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>(AddEventPeople_SelectProgramPeople_ByRegistrantDocument, options);
        }
export type AddEventPeople_SelectProgramPeople_ByRegistrantQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeople_ByRegistrantQuery>;
export type AddEventPeople_SelectProgramPeople_ByRegistrantLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeople_ByRegistrantLazyQuery>;
export type AddEventPeople_SelectProgramPeople_ByRegistrantQueryResult = Apollo.QueryResult<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>;
export const AddEventPeople_SelectGroupsDocument = gql`
    query AddEventPeople_SelectGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_Group
  }
}
    ${AddEventPeople_GroupFragmentDoc}`;

/**
 * __useAddEventPeople_SelectGroupsQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectGroupsQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>(AddEventPeople_SelectGroupsDocument, options);
      }
export function useAddEventPeople_SelectGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>(AddEventPeople_SelectGroupsDocument, options);
        }
export type AddEventPeople_SelectGroupsQueryHookResult = ReturnType<typeof useAddEventPeople_SelectGroupsQuery>;
export type AddEventPeople_SelectGroupsLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectGroupsLazyQuery>;
export type AddEventPeople_SelectGroupsQueryResult = Apollo.QueryResult<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>;
export const AddEventPeople_SelectRegistrants_ByGroupDocument = gql`
    query AddEventPeople_SelectRegistrants_ByGroup($groupId: uuid!) {
  registrant_Registrant(where: {groupRegistrants: {groupId: {_eq: $groupId}}}) {
    ...AddEventPeople_Registrant
  }
}
    ${AddEventPeople_RegistrantFragmentDoc}`;

/**
 * __useAddEventPeople_SelectRegistrants_ByGroupQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectRegistrants_ByGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectRegistrants_ByGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectRegistrants_ByGroupQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useAddEventPeople_SelectRegistrants_ByGroupQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>(AddEventPeople_SelectRegistrants_ByGroupDocument, options);
      }
export function useAddEventPeople_SelectRegistrants_ByGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>(AddEventPeople_SelectRegistrants_ByGroupDocument, options);
        }
export type AddEventPeople_SelectRegistrants_ByGroupQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrants_ByGroupQuery>;
export type AddEventPeople_SelectRegistrants_ByGroupLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrants_ByGroupLazyQuery>;
export type AddEventPeople_SelectRegistrants_ByGroupQueryResult = Apollo.QueryResult<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>;
export const AddEventPeople_InsertProgramPeopleDocument = gql`
    mutation AddEventPeople_InsertProgramPeople($objects: [collection_ProgramPersonWithAccessToken_insert_input!]!) {
  insert_collection_ProgramPersonWithAccessToken(objects: $objects) {
    returning {
      ...AddEventPeople_ProgramPerson
    }
  }
}
    ${AddEventPeople_ProgramPersonFragmentDoc}`;
export type AddEventPeople_InsertProgramPeopleMutationFn = Apollo.MutationFunction<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>;

/**
 * __useAddEventPeople_InsertProgramPeopleMutation__
 *
 * To run a mutation, you first call `useAddEventPeople_InsertProgramPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_InsertProgramPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addEventPeopleInsertProgramPeopleMutation, { data, loading, error }] = useAddEventPeople_InsertProgramPeopleMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useAddEventPeople_InsertProgramPeopleMutation(baseOptions?: Apollo.MutationHookOptions<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>(AddEventPeople_InsertProgramPeopleDocument, options);
      }
export type AddEventPeople_InsertProgramPeopleMutationHookResult = ReturnType<typeof useAddEventPeople_InsertProgramPeopleMutation>;
export type AddEventPeople_InsertProgramPeopleMutationResult = Apollo.MutationResult<AddEventPeople_InsertProgramPeopleMutation>;
export type AddEventPeople_InsertProgramPeopleMutationOptions = Apollo.BaseMutationOptions<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>;
export const AddEventPeople_InsertEventPeopleDocument = gql`
    mutation AddEventPeople_InsertEventPeople($objects: [schedule_EventProgramPerson_insert_input!]!) {
  insert_schedule_EventProgramPerson(objects: $objects) {
    returning {
      ...EventProgramPersonInfo
    }
  }
}
    ${EventProgramPersonInfoFragmentDoc}`;
export type AddEventPeople_InsertEventPeopleMutationFn = Apollo.MutationFunction<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>;

/**
 * __useAddEventPeople_InsertEventPeopleMutation__
 *
 * To run a mutation, you first call `useAddEventPeople_InsertEventPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_InsertEventPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addEventPeopleInsertEventPeopleMutation, { data, loading, error }] = useAddEventPeople_InsertEventPeopleMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useAddEventPeople_InsertEventPeopleMutation(baseOptions?: Apollo.MutationHookOptions<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>(AddEventPeople_InsertEventPeopleDocument, options);
      }
export type AddEventPeople_InsertEventPeopleMutationHookResult = ReturnType<typeof useAddEventPeople_InsertEventPeopleMutation>;
export type AddEventPeople_InsertEventPeopleMutationResult = Apollo.MutationResult<AddEventPeople_InsertEventPeopleMutation>;
export type AddEventPeople_InsertEventPeopleMutationOptions = Apollo.BaseMutationOptions<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>;
export const ContinuationsEditor_SelectContinuationsDocument = gql`
    query ContinuationsEditor_SelectContinuations($fromId: uuid!) {
  schedule_Continuation(
    where: {_or: [{fromEvent: {_eq: $fromId}}, {fromShuffleQueue: {_eq: $fromId}}]}
  ) {
    ...ContinuationsEditor_Continuation
  }
}
    ${ContinuationsEditor_ContinuationFragmentDoc}`;

/**
 * __useContinuationsEditor_SelectContinuationsQuery__
 *
 * To run a query within a React component, call `useContinuationsEditor_SelectContinuationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useContinuationsEditor_SelectContinuationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContinuationsEditor_SelectContinuationsQuery({
 *   variables: {
 *      fromId: // value for 'fromId'
 *   },
 * });
 */
export function useContinuationsEditor_SelectContinuationsQuery(baseOptions: Apollo.QueryHookOptions<ContinuationsEditor_SelectContinuationsQuery, ContinuationsEditor_SelectContinuationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContinuationsEditor_SelectContinuationsQuery, ContinuationsEditor_SelectContinuationsQueryVariables>(ContinuationsEditor_SelectContinuationsDocument, options);
      }
export function useContinuationsEditor_SelectContinuationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContinuationsEditor_SelectContinuationsQuery, ContinuationsEditor_SelectContinuationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContinuationsEditor_SelectContinuationsQuery, ContinuationsEditor_SelectContinuationsQueryVariables>(ContinuationsEditor_SelectContinuationsDocument, options);
        }
export type ContinuationsEditor_SelectContinuationsQueryHookResult = ReturnType<typeof useContinuationsEditor_SelectContinuationsQuery>;
export type ContinuationsEditor_SelectContinuationsLazyQueryHookResult = ReturnType<typeof useContinuationsEditor_SelectContinuationsLazyQuery>;
export type ContinuationsEditor_SelectContinuationsQueryResult = Apollo.QueryResult<ContinuationsEditor_SelectContinuationsQuery, ContinuationsEditor_SelectContinuationsQueryVariables>;
export const ContinuationsEditor_InsertDocument = gql`
    mutation ContinuationsEditor_Insert($object: schedule_Continuation_insert_input!) {
  insert_schedule_Continuation_one(object: $object) {
    ...ContinuationsEditor_Continuation
  }
}
    ${ContinuationsEditor_ContinuationFragmentDoc}`;
export type ContinuationsEditor_InsertMutationFn = Apollo.MutationFunction<ContinuationsEditor_InsertMutation, ContinuationsEditor_InsertMutationVariables>;

/**
 * __useContinuationsEditor_InsertMutation__
 *
 * To run a mutation, you first call `useContinuationsEditor_InsertMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useContinuationsEditor_InsertMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [continuationsEditorInsertMutation, { data, loading, error }] = useContinuationsEditor_InsertMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useContinuationsEditor_InsertMutation(baseOptions?: Apollo.MutationHookOptions<ContinuationsEditor_InsertMutation, ContinuationsEditor_InsertMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ContinuationsEditor_InsertMutation, ContinuationsEditor_InsertMutationVariables>(ContinuationsEditor_InsertDocument, options);
      }
export type ContinuationsEditor_InsertMutationHookResult = ReturnType<typeof useContinuationsEditor_InsertMutation>;
export type ContinuationsEditor_InsertMutationResult = Apollo.MutationResult<ContinuationsEditor_InsertMutation>;
export type ContinuationsEditor_InsertMutationOptions = Apollo.BaseMutationOptions<ContinuationsEditor_InsertMutation, ContinuationsEditor_InsertMutationVariables>;
export const ContinuationsEditor_UpdateDocument = gql`
    mutation ContinuationsEditor_Update($id: uuid!, $object: schedule_Continuation_set_input!) {
  update_schedule_Continuation_by_pk(pk_columns: {id: $id}, _set: $object) {
    ...ContinuationsEditor_Continuation
  }
}
    ${ContinuationsEditor_ContinuationFragmentDoc}`;
export type ContinuationsEditor_UpdateMutationFn = Apollo.MutationFunction<ContinuationsEditor_UpdateMutation, ContinuationsEditor_UpdateMutationVariables>;

/**
 * __useContinuationsEditor_UpdateMutation__
 *
 * To run a mutation, you first call `useContinuationsEditor_UpdateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useContinuationsEditor_UpdateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [continuationsEditorUpdateMutation, { data, loading, error }] = useContinuationsEditor_UpdateMutation({
 *   variables: {
 *      id: // value for 'id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function useContinuationsEditor_UpdateMutation(baseOptions?: Apollo.MutationHookOptions<ContinuationsEditor_UpdateMutation, ContinuationsEditor_UpdateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ContinuationsEditor_UpdateMutation, ContinuationsEditor_UpdateMutationVariables>(ContinuationsEditor_UpdateDocument, options);
      }
export type ContinuationsEditor_UpdateMutationHookResult = ReturnType<typeof useContinuationsEditor_UpdateMutation>;
export type ContinuationsEditor_UpdateMutationResult = Apollo.MutationResult<ContinuationsEditor_UpdateMutation>;
export type ContinuationsEditor_UpdateMutationOptions = Apollo.BaseMutationOptions<ContinuationsEditor_UpdateMutation, ContinuationsEditor_UpdateMutationVariables>;
export const ContinuationsEditor_UpdateManyDocument = gql`
    mutation ContinuationsEditor_UpdateMany($ids: [uuid!]!, $object: schedule_Continuation_set_input!) {
  update_schedule_Continuation(where: {id: {_in: $ids}}, _set: $object) {
    returning {
      ...ContinuationsEditor_Continuation
    }
  }
}
    ${ContinuationsEditor_ContinuationFragmentDoc}`;
export type ContinuationsEditor_UpdateManyMutationFn = Apollo.MutationFunction<ContinuationsEditor_UpdateManyMutation, ContinuationsEditor_UpdateManyMutationVariables>;

/**
 * __useContinuationsEditor_UpdateManyMutation__
 *
 * To run a mutation, you first call `useContinuationsEditor_UpdateManyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useContinuationsEditor_UpdateManyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [continuationsEditorUpdateManyMutation, { data, loading, error }] = useContinuationsEditor_UpdateManyMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *      object: // value for 'object'
 *   },
 * });
 */
export function useContinuationsEditor_UpdateManyMutation(baseOptions?: Apollo.MutationHookOptions<ContinuationsEditor_UpdateManyMutation, ContinuationsEditor_UpdateManyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ContinuationsEditor_UpdateManyMutation, ContinuationsEditor_UpdateManyMutationVariables>(ContinuationsEditor_UpdateManyDocument, options);
      }
export type ContinuationsEditor_UpdateManyMutationHookResult = ReturnType<typeof useContinuationsEditor_UpdateManyMutation>;
export type ContinuationsEditor_UpdateManyMutationResult = Apollo.MutationResult<ContinuationsEditor_UpdateManyMutation>;
export type ContinuationsEditor_UpdateManyMutationOptions = Apollo.BaseMutationOptions<ContinuationsEditor_UpdateManyMutation, ContinuationsEditor_UpdateManyMutationVariables>;
export const ContinuationsEditor_DeleteDocument = gql`
    mutation ContinuationsEditor_Delete($ids: [uuid!]!) {
  delete_schedule_Continuation(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ContinuationsEditor_DeleteMutationFn = Apollo.MutationFunction<ContinuationsEditor_DeleteMutation, ContinuationsEditor_DeleteMutationVariables>;

/**
 * __useContinuationsEditor_DeleteMutation__
 *
 * To run a mutation, you first call `useContinuationsEditor_DeleteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useContinuationsEditor_DeleteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [continuationsEditorDeleteMutation, { data, loading, error }] = useContinuationsEditor_DeleteMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useContinuationsEditor_DeleteMutation(baseOptions?: Apollo.MutationHookOptions<ContinuationsEditor_DeleteMutation, ContinuationsEditor_DeleteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ContinuationsEditor_DeleteMutation, ContinuationsEditor_DeleteMutationVariables>(ContinuationsEditor_DeleteDocument, options);
      }
export type ContinuationsEditor_DeleteMutationHookResult = ReturnType<typeof useContinuationsEditor_DeleteMutation>;
export type ContinuationsEditor_DeleteMutationResult = Apollo.MutationResult<ContinuationsEditor_DeleteMutation>;
export type ContinuationsEditor_DeleteMutationOptions = Apollo.BaseMutationOptions<ContinuationsEditor_DeleteMutation, ContinuationsEditor_DeleteMutationVariables>;
export const CreateContinuationModal_RoomsDocument = gql`
    query CreateContinuationModal_Rooms($conferenceId: uuid!) {
  room_Room(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
  }
}
    `;

/**
 * __useCreateContinuationModal_RoomsQuery__
 *
 * To run a query within a React component, call `useCreateContinuationModal_RoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateContinuationModal_RoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateContinuationModal_RoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateContinuationModal_RoomsQuery(baseOptions: Apollo.QueryHookOptions<CreateContinuationModal_RoomsQuery, CreateContinuationModal_RoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateContinuationModal_RoomsQuery, CreateContinuationModal_RoomsQueryVariables>(CreateContinuationModal_RoomsDocument, options);
      }
export function useCreateContinuationModal_RoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateContinuationModal_RoomsQuery, CreateContinuationModal_RoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateContinuationModal_RoomsQuery, CreateContinuationModal_RoomsQueryVariables>(CreateContinuationModal_RoomsDocument, options);
        }
export type CreateContinuationModal_RoomsQueryHookResult = ReturnType<typeof useCreateContinuationModal_RoomsQuery>;
export type CreateContinuationModal_RoomsLazyQueryHookResult = ReturnType<typeof useCreateContinuationModal_RoomsLazyQuery>;
export type CreateContinuationModal_RoomsQueryResult = Apollo.QueryResult<CreateContinuationModal_RoomsQuery, CreateContinuationModal_RoomsQueryVariables>;
export const CreateContinuationModal_EventsDocument = gql`
    query CreateContinuationModal_Events($conferenceId: uuid!) {
  schedule_Event(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
    startTime
    endTime
    intendedRoomModeName
    item {
      id
      title
    }
    exhibition {
      id
      name
    }
    shufflePeriod {
      id
      name
    }
  }
}
    `;

/**
 * __useCreateContinuationModal_EventsQuery__
 *
 * To run a query within a React component, call `useCreateContinuationModal_EventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateContinuationModal_EventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateContinuationModal_EventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateContinuationModal_EventsQuery(baseOptions: Apollo.QueryHookOptions<CreateContinuationModal_EventsQuery, CreateContinuationModal_EventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateContinuationModal_EventsQuery, CreateContinuationModal_EventsQueryVariables>(CreateContinuationModal_EventsDocument, options);
      }
export function useCreateContinuationModal_EventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateContinuationModal_EventsQuery, CreateContinuationModal_EventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateContinuationModal_EventsQuery, CreateContinuationModal_EventsQueryVariables>(CreateContinuationModal_EventsDocument, options);
        }
export type CreateContinuationModal_EventsQueryHookResult = ReturnType<typeof useCreateContinuationModal_EventsQuery>;
export type CreateContinuationModal_EventsLazyQueryHookResult = ReturnType<typeof useCreateContinuationModal_EventsLazyQuery>;
export type CreateContinuationModal_EventsQueryResult = Apollo.QueryResult<CreateContinuationModal_EventsQuery, CreateContinuationModal_EventsQueryVariables>;
export const CreateContinuationModal_ItemsDocument = gql`
    query CreateContinuationModal_Items($conferenceId: uuid!) {
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    title
  }
}
    `;

/**
 * __useCreateContinuationModal_ItemsQuery__
 *
 * To run a query within a React component, call `useCreateContinuationModal_ItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateContinuationModal_ItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateContinuationModal_ItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateContinuationModal_ItemsQuery(baseOptions: Apollo.QueryHookOptions<CreateContinuationModal_ItemsQuery, CreateContinuationModal_ItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateContinuationModal_ItemsQuery, CreateContinuationModal_ItemsQueryVariables>(CreateContinuationModal_ItemsDocument, options);
      }
export function useCreateContinuationModal_ItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateContinuationModal_ItemsQuery, CreateContinuationModal_ItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateContinuationModal_ItemsQuery, CreateContinuationModal_ItemsQueryVariables>(CreateContinuationModal_ItemsDocument, options);
        }
export type CreateContinuationModal_ItemsQueryHookResult = ReturnType<typeof useCreateContinuationModal_ItemsQuery>;
export type CreateContinuationModal_ItemsLazyQueryHookResult = ReturnType<typeof useCreateContinuationModal_ItemsLazyQuery>;
export type CreateContinuationModal_ItemsQueryResult = Apollo.QueryResult<CreateContinuationModal_ItemsQuery, CreateContinuationModal_ItemsQueryVariables>;
export const CreateContinuationModal_ExhibitionsDocument = gql`
    query CreateContinuationModal_Exhibitions($conferenceId: uuid!) {
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
  }
}
    `;

/**
 * __useCreateContinuationModal_ExhibitionsQuery__
 *
 * To run a query within a React component, call `useCreateContinuationModal_ExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateContinuationModal_ExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateContinuationModal_ExhibitionsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateContinuationModal_ExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<CreateContinuationModal_ExhibitionsQuery, CreateContinuationModal_ExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateContinuationModal_ExhibitionsQuery, CreateContinuationModal_ExhibitionsQueryVariables>(CreateContinuationModal_ExhibitionsDocument, options);
      }
export function useCreateContinuationModal_ExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateContinuationModal_ExhibitionsQuery, CreateContinuationModal_ExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateContinuationModal_ExhibitionsQuery, CreateContinuationModal_ExhibitionsQueryVariables>(CreateContinuationModal_ExhibitionsDocument, options);
        }
export type CreateContinuationModal_ExhibitionsQueryHookResult = ReturnType<typeof useCreateContinuationModal_ExhibitionsQuery>;
export type CreateContinuationModal_ExhibitionsLazyQueryHookResult = ReturnType<typeof useCreateContinuationModal_ExhibitionsLazyQuery>;
export type CreateContinuationModal_ExhibitionsQueryResult = Apollo.QueryResult<CreateContinuationModal_ExhibitionsQuery, CreateContinuationModal_ExhibitionsQueryVariables>;
export const CreateContinuationModal_ShufflePeriodsDocument = gql`
    query CreateContinuationModal_ShufflePeriods($conferenceId: uuid!) {
  room_ShufflePeriod(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
  }
}
    `;

/**
 * __useCreateContinuationModal_ShufflePeriodsQuery__
 *
 * To run a query within a React component, call `useCreateContinuationModal_ShufflePeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateContinuationModal_ShufflePeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateContinuationModal_ShufflePeriodsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateContinuationModal_ShufflePeriodsQuery(baseOptions: Apollo.QueryHookOptions<CreateContinuationModal_ShufflePeriodsQuery, CreateContinuationModal_ShufflePeriodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateContinuationModal_ShufflePeriodsQuery, CreateContinuationModal_ShufflePeriodsQueryVariables>(CreateContinuationModal_ShufflePeriodsDocument, options);
      }
export function useCreateContinuationModal_ShufflePeriodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateContinuationModal_ShufflePeriodsQuery, CreateContinuationModal_ShufflePeriodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateContinuationModal_ShufflePeriodsQuery, CreateContinuationModal_ShufflePeriodsQueryVariables>(CreateContinuationModal_ShufflePeriodsDocument, options);
        }
export type CreateContinuationModal_ShufflePeriodsQueryHookResult = ReturnType<typeof useCreateContinuationModal_ShufflePeriodsQuery>;
export type CreateContinuationModal_ShufflePeriodsLazyQueryHookResult = ReturnType<typeof useCreateContinuationModal_ShufflePeriodsLazyQuery>;
export type CreateContinuationModal_ShufflePeriodsQueryResult = Apollo.QueryResult<CreateContinuationModal_ShufflePeriodsQuery, CreateContinuationModal_ShufflePeriodsQueryVariables>;
export const CreateContinuationModal_TagsDocument = gql`
    query CreateContinuationModal_Tags($conferenceId: uuid!) {
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
  }
}
    `;

/**
 * __useCreateContinuationModal_TagsQuery__
 *
 * To run a query within a React component, call `useCreateContinuationModal_TagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateContinuationModal_TagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateContinuationModal_TagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateContinuationModal_TagsQuery(baseOptions: Apollo.QueryHookOptions<CreateContinuationModal_TagsQuery, CreateContinuationModal_TagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateContinuationModal_TagsQuery, CreateContinuationModal_TagsQueryVariables>(CreateContinuationModal_TagsDocument, options);
      }
export function useCreateContinuationModal_TagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateContinuationModal_TagsQuery, CreateContinuationModal_TagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateContinuationModal_TagsQuery, CreateContinuationModal_TagsQueryVariables>(CreateContinuationModal_TagsDocument, options);
        }
export type CreateContinuationModal_TagsQueryHookResult = ReturnType<typeof useCreateContinuationModal_TagsQuery>;
export type CreateContinuationModal_TagsLazyQueryHookResult = ReturnType<typeof useCreateContinuationModal_TagsLazyQuery>;
export type CreateContinuationModal_TagsQueryResult = Apollo.QueryResult<CreateContinuationModal_TagsQuery, CreateContinuationModal_TagsQueryVariables>;
export const CreateContinuationModal_ProfileDocument = gql`
    query CreateContinuationModal_Profile($conferenceId: uuid!) {
  registrant_Registrant(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    displayName
  }
}
    `;

/**
 * __useCreateContinuationModal_ProfileQuery__
 *
 * To run a query within a React component, call `useCreateContinuationModal_ProfileQuery` and pass it any options that fit your needs.
 * When your component renders, `useCreateContinuationModal_ProfileQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCreateContinuationModal_ProfileQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateContinuationModal_ProfileQuery(baseOptions: Apollo.QueryHookOptions<CreateContinuationModal_ProfileQuery, CreateContinuationModal_ProfileQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CreateContinuationModal_ProfileQuery, CreateContinuationModal_ProfileQueryVariables>(CreateContinuationModal_ProfileDocument, options);
      }
export function useCreateContinuationModal_ProfileLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CreateContinuationModal_ProfileQuery, CreateContinuationModal_ProfileQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CreateContinuationModal_ProfileQuery, CreateContinuationModal_ProfileQueryVariables>(CreateContinuationModal_ProfileDocument, options);
        }
export type CreateContinuationModal_ProfileQueryHookResult = ReturnType<typeof useCreateContinuationModal_ProfileQuery>;
export type CreateContinuationModal_ProfileLazyQueryHookResult = ReturnType<typeof useCreateContinuationModal_ProfileLazyQuery>;
export type CreateContinuationModal_ProfileQueryResult = Apollo.QueryResult<CreateContinuationModal_ProfileQuery, CreateContinuationModal_ProfileQueryVariables>;
export const InsertEventProgramPersonDocument = gql`
    mutation InsertEventProgramPerson($newEventProgramPerson: schedule_EventProgramPerson_insert_input!) {
  insert_schedule_EventProgramPerson_one(
    object: $newEventProgramPerson
    on_conflict: {constraint: EventProgramPerson_eventId_personId_roleName_key, update_columns: []}
  ) {
    ...EventProgramPersonInfo
  }
}
    ${EventProgramPersonInfoFragmentDoc}`;
export type InsertEventProgramPersonMutationFn = Apollo.MutationFunction<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>;

/**
 * __useInsertEventProgramPersonMutation__
 *
 * To run a mutation, you first call `useInsertEventProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventProgramPersonMutation, { data, loading, error }] = useInsertEventProgramPersonMutation({
 *   variables: {
 *      newEventProgramPerson: // value for 'newEventProgramPerson'
 *   },
 * });
 */
export function useInsertEventProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>(InsertEventProgramPersonDocument, options);
      }
export type InsertEventProgramPersonMutationHookResult = ReturnType<typeof useInsertEventProgramPersonMutation>;
export type InsertEventProgramPersonMutationResult = Apollo.MutationResult<InsertEventProgramPersonMutation>;
export type InsertEventProgramPersonMutationOptions = Apollo.BaseMutationOptions<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>;
export const DeleteEventProgramPersonsDocument = gql`
    mutation DeleteEventProgramPersons($deleteEventPeopleIds: [uuid!]!) {
  delete_schedule_EventProgramPerson(where: {id: {_in: $deleteEventPeopleIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventProgramPersonsMutationFn = Apollo.MutationFunction<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>;

/**
 * __useDeleteEventProgramPersonsMutation__
 *
 * To run a mutation, you first call `useDeleteEventProgramPersonsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventProgramPersonsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventProgramPersonsMutation, { data, loading, error }] = useDeleteEventProgramPersonsMutation({
 *   variables: {
 *      deleteEventPeopleIds: // value for 'deleteEventPeopleIds'
 *   },
 * });
 */
export function useDeleteEventProgramPersonsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>(DeleteEventProgramPersonsDocument, options);
      }
export type DeleteEventProgramPersonsMutationHookResult = ReturnType<typeof useDeleteEventProgramPersonsMutation>;
export type DeleteEventProgramPersonsMutationResult = Apollo.MutationResult<DeleteEventProgramPersonsMutation>;
export type DeleteEventProgramPersonsMutationOptions = Apollo.BaseMutationOptions<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>;
export const UpdateEventProgramPersonDocument = gql`
    mutation UpdateEventProgramPerson($id: uuid!, $personId: uuid!, $roleName: schedule_EventProgramPersonRole_enum!) {
  update_schedule_EventProgramPerson_by_pk(
    pk_columns: {id: $id}
    _set: {personId: $personId, roleName: $roleName}
  ) {
    ...EventProgramPersonInfo
  }
}
    ${EventProgramPersonInfoFragmentDoc}`;
export type UpdateEventProgramPersonMutationFn = Apollo.MutationFunction<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>;

/**
 * __useUpdateEventProgramPersonMutation__
 *
 * To run a mutation, you first call `useUpdateEventProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventProgramPersonMutation, { data, loading, error }] = useUpdateEventProgramPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      personId: // value for 'personId'
 *      roleName: // value for 'roleName'
 *   },
 * });
 */
export function useUpdateEventProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>(UpdateEventProgramPersonDocument, options);
      }
export type UpdateEventProgramPersonMutationHookResult = ReturnType<typeof useUpdateEventProgramPersonMutation>;
export type UpdateEventProgramPersonMutationResult = Apollo.MutationResult<UpdateEventProgramPersonMutation>;
export type UpdateEventProgramPersonMutationOptions = Apollo.BaseMutationOptions<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>;
export const ManageSchedule_ShufflePeriodsDocument = gql`
    query ManageSchedule_ShufflePeriods($conferenceId: uuid!, $now: timestamptz!) {
  room_ShufflePeriod(
    where: {conferenceId: {_eq: $conferenceId}, endAt: {_gt: $now}}
  ) {
    ...ShufflePeriodInfo
  }
}
    ${ShufflePeriodInfoFragmentDoc}`;

/**
 * __useManageSchedule_ShufflePeriodsQuery__
 *
 * To run a query within a React component, call `useManageSchedule_ShufflePeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageSchedule_ShufflePeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageSchedule_ShufflePeriodsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      now: // value for 'now'
 *   },
 * });
 */
export function useManageSchedule_ShufflePeriodsQuery(baseOptions: Apollo.QueryHookOptions<ManageSchedule_ShufflePeriodsQuery, ManageSchedule_ShufflePeriodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageSchedule_ShufflePeriodsQuery, ManageSchedule_ShufflePeriodsQueryVariables>(ManageSchedule_ShufflePeriodsDocument, options);
      }
export function useManageSchedule_ShufflePeriodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageSchedule_ShufflePeriodsQuery, ManageSchedule_ShufflePeriodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageSchedule_ShufflePeriodsQuery, ManageSchedule_ShufflePeriodsQueryVariables>(ManageSchedule_ShufflePeriodsDocument, options);
        }
export type ManageSchedule_ShufflePeriodsQueryHookResult = ReturnType<typeof useManageSchedule_ShufflePeriodsQuery>;
export type ManageSchedule_ShufflePeriodsLazyQueryHookResult = ReturnType<typeof useManageSchedule_ShufflePeriodsLazyQuery>;
export type ManageSchedule_ShufflePeriodsQueryResult = Apollo.QueryResult<ManageSchedule_ShufflePeriodsQuery, ManageSchedule_ShufflePeriodsQueryVariables>;
export const InsertEventInfoDocument = gql`
    mutation InsertEventInfo($id: uuid!, $roomId: uuid!, $conferenceId: uuid!, $intendedRoomModeName: room_Mode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $itemId: uuid = null, $exhibitionId: uuid = null, $shufflePeriodId: uuid = null, $insertContinuation: Boolean!, $enableRecording: Boolean!) {
  insert_schedule_Event_one(
    object: {id: $id, roomId: $roomId, conferenceId: $conferenceId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, itemId: $itemId, exhibitionId: $exhibitionId, shufflePeriodId: $shufflePeriodId, enableRecording: $enableRecording}
  ) {
    ...EventInfo
  }
  insert_schedule_Continuation_one(
    object: {colour: "#4471de", defaultFor: "Presenters", description: "Join the discussion room", fromEvent: $id, isActiveChoice: false, priority: 0, to: {type: "AutoDiscussionRoom", id: null}}
  ) @include(if: $insertContinuation) {
    id
  }
}
    ${EventInfoFragmentDoc}`;
export type InsertEventInfoMutationFn = Apollo.MutationFunction<InsertEventInfoMutation, InsertEventInfoMutationVariables>;

/**
 * __useInsertEventInfoMutation__
 *
 * To run a mutation, you first call `useInsertEventInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventInfoMutation, { data, loading, error }] = useInsertEventInfoMutation({
 *   variables: {
 *      id: // value for 'id'
 *      roomId: // value for 'roomId'
 *      conferenceId: // value for 'conferenceId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      itemId: // value for 'itemId'
 *      exhibitionId: // value for 'exhibitionId'
 *      shufflePeriodId: // value for 'shufflePeriodId'
 *      insertContinuation: // value for 'insertContinuation'
 *      enableRecording: // value for 'enableRecording'
 *   },
 * });
 */
export function useInsertEventInfoMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventInfoMutation, InsertEventInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventInfoMutation, InsertEventInfoMutationVariables>(InsertEventInfoDocument, options);
      }
export type InsertEventInfoMutationHookResult = ReturnType<typeof useInsertEventInfoMutation>;
export type InsertEventInfoMutationResult = Apollo.MutationResult<InsertEventInfoMutation>;
export type InsertEventInfoMutationOptions = Apollo.BaseMutationOptions<InsertEventInfoMutation, InsertEventInfoMutationVariables>;
export const UpdateEventInfoDocument = gql`
    mutation UpdateEventInfo($eventId: uuid!, $roomId: uuid!, $intendedRoomModeName: room_Mode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $itemId: uuid = null, $exhibitionId: uuid = null, $shufflePeriodId: uuid = null, $enableRecording: Boolean!) {
  update_schedule_Event_by_pk(
    pk_columns: {id: $eventId}
    _set: {roomId: $roomId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, itemId: $itemId, exhibitionId: $exhibitionId, shufflePeriodId: $shufflePeriodId, enableRecording: $enableRecording}
  ) {
    ...EventInfo
  }
}
    ${EventInfoFragmentDoc}`;
export type UpdateEventInfoMutationFn = Apollo.MutationFunction<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>;

/**
 * __useUpdateEventInfoMutation__
 *
 * To run a mutation, you first call `useUpdateEventInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventInfoMutation, { data, loading, error }] = useUpdateEventInfoMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      roomId: // value for 'roomId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      itemId: // value for 'itemId'
 *      exhibitionId: // value for 'exhibitionId'
 *      shufflePeriodId: // value for 'shufflePeriodId'
 *      enableRecording: // value for 'enableRecording'
 *   },
 * });
 */
export function useUpdateEventInfoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>(UpdateEventInfoDocument, options);
      }
export type UpdateEventInfoMutationHookResult = ReturnType<typeof useUpdateEventInfoMutation>;
export type UpdateEventInfoMutationResult = Apollo.MutationResult<UpdateEventInfoMutation>;
export type UpdateEventInfoMutationOptions = Apollo.BaseMutationOptions<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>;
export const DeleteEventInfosDocument = gql`
    mutation DeleteEventInfos($eventIds: [uuid!]!) {
  delete_schedule_Event(where: {id: {_in: $eventIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventInfosMutationFn = Apollo.MutationFunction<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>;

/**
 * __useDeleteEventInfosMutation__
 *
 * To run a mutation, you first call `useDeleteEventInfosMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventInfosMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventInfosMutation, { data, loading, error }] = useDeleteEventInfosMutation({
 *   variables: {
 *      eventIds: // value for 'eventIds'
 *   },
 * });
 */
export function useDeleteEventInfosMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>(DeleteEventInfosDocument, options);
      }
export type DeleteEventInfosMutationHookResult = ReturnType<typeof useDeleteEventInfosMutation>;
export type DeleteEventInfosMutationResult = Apollo.MutationResult<DeleteEventInfosMutation>;
export type DeleteEventInfosMutationOptions = Apollo.BaseMutationOptions<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>;
export const SelectWholeScheduleDocument = gql`
    query SelectWholeSchedule($conferenceId: uuid!) {
  room_Room(
    where: {conferenceId: {_eq: $conferenceId}, managementModeName: {_in: [PUBLIC, PRIVATE]}}
  ) {
    ...RoomInfo
  }
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: [{startTime: asc}, {endTime: asc}]
  ) {
    ...EventInfo
  }
  conference_OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ExhibitionInfo
  }
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ItemFullNestedInfo
  }
  collection_ProgramPersonWithAccessToken(
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    ...ProgramPersonInfo
  }
}
    ${RoomInfoFragmentDoc}
${EventInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${ExhibitionInfoFragmentDoc}
${ItemFullNestedInfoFragmentDoc}
${ProgramPersonInfoFragmentDoc}`;

/**
 * __useSelectWholeScheduleQuery__
 *
 * To run a query within a React component, call `useSelectWholeScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectWholeScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectWholeScheduleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectWholeScheduleQuery(baseOptions: Apollo.QueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, options);
      }
export function useSelectWholeScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, options);
        }
export type SelectWholeScheduleQueryHookResult = ReturnType<typeof useSelectWholeScheduleQuery>;
export type SelectWholeScheduleLazyQueryHookResult = ReturnType<typeof useSelectWholeScheduleLazyQuery>;
export type SelectWholeScheduleQueryResult = Apollo.QueryResult<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>;
export const InsertRoomsDocument = gql`
    mutation InsertRooms($newRooms: [room_Room_insert_input!]!) {
  insert_room_Room(objects: $newRooms) {
    returning {
      ...RoomInfo
    }
  }
}
    ${RoomInfoFragmentDoc}`;
export type InsertRoomsMutationFn = Apollo.MutationFunction<InsertRoomsMutation, InsertRoomsMutationVariables>;

/**
 * __useInsertRoomsMutation__
 *
 * To run a mutation, you first call `useInsertRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomsMutation, { data, loading, error }] = useInsertRoomsMutation({
 *   variables: {
 *      newRooms: // value for 'newRooms'
 *   },
 * });
 */
export function useInsertRoomsMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomsMutation, InsertRoomsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRoomsMutation, InsertRoomsMutationVariables>(InsertRoomsDocument, options);
      }
export type InsertRoomsMutationHookResult = ReturnType<typeof useInsertRoomsMutation>;
export type InsertRoomsMutationResult = Apollo.MutationResult<InsertRoomsMutation>;
export type InsertRoomsMutationOptions = Apollo.BaseMutationOptions<InsertRoomsMutation, InsertRoomsMutationVariables>;
export const DeleteRoomsDocument = gql`
    mutation DeleteRooms($deleteRoomIds: [uuid!]!) {
  delete_room_Room(where: {id: {_in: $deleteRoomIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteRoomsMutationFn = Apollo.MutationFunction<DeleteRoomsMutation, DeleteRoomsMutationVariables>;

/**
 * __useDeleteRoomsMutation__
 *
 * To run a mutation, you first call `useDeleteRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRoomsMutation, { data, loading, error }] = useDeleteRoomsMutation({
 *   variables: {
 *      deleteRoomIds: // value for 'deleteRoomIds'
 *   },
 * });
 */
export function useDeleteRoomsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRoomsMutation, DeleteRoomsMutationVariables>(DeleteRoomsDocument, options);
      }
export type DeleteRoomsMutationHookResult = ReturnType<typeof useDeleteRoomsMutation>;
export type DeleteRoomsMutationResult = Apollo.MutationResult<DeleteRoomsMutation>;
export type DeleteRoomsMutationOptions = Apollo.BaseMutationOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>;
export const UpdateRoomDocument = gql`
    mutation UpdateRoom($id: uuid!, $name: String!, $capacity: Int = null, $originatingDataId: uuid = null, $priority: Int!) {
  update_room_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, originatingDataId: $originatingDataId, priority: $priority}
  ) {
    ...RoomInfo
  }
}
    ${RoomInfoFragmentDoc}`;
export type UpdateRoomMutationFn = Apollo.MutationFunction<UpdateRoomMutation, UpdateRoomMutationVariables>;

/**
 * __useUpdateRoomMutation__
 *
 * To run a mutation, you first call `useUpdateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomMutation, { data, loading, error }] = useUpdateRoomMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      originatingDataId: // value for 'originatingDataId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateRoomMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomMutation, UpdateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoomMutation, UpdateRoomMutationVariables>(UpdateRoomDocument, options);
      }
export type UpdateRoomMutationHookResult = ReturnType<typeof useUpdateRoomMutation>;
export type UpdateRoomMutationResult = Apollo.MutationResult<UpdateRoomMutation>;
export type UpdateRoomMutationOptions = Apollo.BaseMutationOptions<UpdateRoomMutation, UpdateRoomMutationVariables>;
export const DeleteEventsDocument = gql`
    mutation DeleteEvents($deleteEventIds: [uuid!]!) {
  delete_schedule_Event(where: {id: {_in: $deleteEventIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventsMutationFn = Apollo.MutationFunction<DeleteEventsMutation, DeleteEventsMutationVariables>;

/**
 * __useDeleteEventsMutation__
 *
 * To run a mutation, you first call `useDeleteEventsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventsMutation, { data, loading, error }] = useDeleteEventsMutation({
 *   variables: {
 *      deleteEventIds: // value for 'deleteEventIds'
 *   },
 * });
 */
export function useDeleteEventsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventsMutation, DeleteEventsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventsMutation, DeleteEventsMutationVariables>(DeleteEventsDocument, options);
      }
export type DeleteEventsMutationHookResult = ReturnType<typeof useDeleteEventsMutation>;
export type DeleteEventsMutationResult = Apollo.MutationResult<DeleteEventsMutation>;
export type DeleteEventsMutationOptions = Apollo.BaseMutationOptions<DeleteEventsMutation, DeleteEventsMutationVariables>;
export const InsertEventDocument = gql`
    mutation InsertEvent($newEvent: schedule_Event_insert_input!, $newEventId: uuid!, $insertContinuation: Boolean!) {
  insert_schedule_Event_one(object: $newEvent) {
    ...EventInfo
  }
  insert_schedule_Continuation_one(
    object: {colour: "#4471de", defaultFor: "Presenters", description: "Join the discussion room", fromEvent: $newEventId, isActiveChoice: false, priority: 0, to: {type: "AutoDiscussionRoom", id: null}}
  ) @include(if: $insertContinuation) {
    id
  }
}
    ${EventInfoFragmentDoc}`;
export type InsertEventMutationFn = Apollo.MutationFunction<InsertEventMutation, InsertEventMutationVariables>;

/**
 * __useInsertEventMutation__
 *
 * To run a mutation, you first call `useInsertEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventMutation, { data, loading, error }] = useInsertEventMutation({
 *   variables: {
 *      newEvent: // value for 'newEvent'
 *      newEventId: // value for 'newEventId'
 *      insertContinuation: // value for 'insertContinuation'
 *   },
 * });
 */
export function useInsertEventMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventMutation, InsertEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventMutation, InsertEventMutationVariables>(InsertEventDocument, options);
      }
export type InsertEventMutationHookResult = ReturnType<typeof useInsertEventMutation>;
export type InsertEventMutationResult = Apollo.MutationResult<InsertEventMutation>;
export type InsertEventMutationOptions = Apollo.BaseMutationOptions<InsertEventMutation, InsertEventMutationVariables>;
export const UpdateEventDocument = gql`
    mutation UpdateEvent($eventId: uuid!, $roomId: uuid!, $intendedRoomModeName: room_Mode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $itemId: uuid = null, $exhibitionId: uuid = null, $newEventTags: [schedule_EventTag_insert_input!]!, $deleteEventTagIds: [uuid!]!) {
  insert_schedule_EventTag(objects: $newEventTags) {
    returning {
      ...EventTagInfo
    }
  }
  update_schedule_Event_by_pk(
    pk_columns: {id: $eventId}
    _set: {roomId: $roomId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, itemId: $itemId, exhibitionId: $exhibitionId}
  ) {
    ...EventInfo
  }
  delete_schedule_EventTag(
    where: {eventId: {_eq: $eventId}, tagId: {_in: $deleteEventTagIds}}
  ) {
    returning {
      id
    }
  }
}
    ${EventTagInfoFragmentDoc}
${EventInfoFragmentDoc}`;
export type UpdateEventMutationFn = Apollo.MutationFunction<UpdateEventMutation, UpdateEventMutationVariables>;

/**
 * __useUpdateEventMutation__
 *
 * To run a mutation, you first call `useUpdateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventMutation, { data, loading, error }] = useUpdateEventMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      roomId: // value for 'roomId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      itemId: // value for 'itemId'
 *      exhibitionId: // value for 'exhibitionId'
 *      newEventTags: // value for 'newEventTags'
 *      deleteEventTagIds: // value for 'deleteEventTagIds'
 *   },
 * });
 */
export function useUpdateEventMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventMutation, UpdateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventMutation, UpdateEventMutationVariables>(UpdateEventDocument, options);
      }
export type UpdateEventMutationHookResult = ReturnType<typeof useUpdateEventMutation>;
export type UpdateEventMutationResult = Apollo.MutationResult<UpdateEventMutation>;
export type UpdateEventMutationOptions = Apollo.BaseMutationOptions<UpdateEventMutation, UpdateEventMutationVariables>;
export const UpdateShufflePeriodDocument = gql`
    mutation UpdateShufflePeriod($id: uuid!, $object: room_ShufflePeriod_set_input!) {
  update_room_ShufflePeriod_by_pk(pk_columns: {id: $id}, _set: $object) {
    id
    created_at
    updated_at
    conferenceId
    startAt
    endAt
    roomDurationMinutes
    targetRegistrantsPerRoom
    maxRegistrantsPerRoom
    waitRoomMaxDurationSeconds
    name
    organiserId
    algorithm
  }
}
    `;
export type UpdateShufflePeriodMutationFn = Apollo.MutationFunction<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>;

/**
 * __useUpdateShufflePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateShufflePeriodMutation, { data, loading, error }] = useUpdateShufflePeriodMutation({
 *   variables: {
 *      id: // value for 'id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function useUpdateShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>(UpdateShufflePeriodDocument, options);
      }
export type UpdateShufflePeriodMutationHookResult = ReturnType<typeof useUpdateShufflePeriodMutation>;
export type UpdateShufflePeriodMutationResult = Apollo.MutationResult<UpdateShufflePeriodMutation>;
export type UpdateShufflePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>;
export const InsertShufflePeriodDocument = gql`
    mutation InsertShufflePeriod($object: room_ShufflePeriod_insert_input!) {
  insert_room_ShufflePeriod_one(object: $object) {
    id
    created_at
    updated_at
    conferenceId
    startAt
    endAt
    roomDurationMinutes
    targetRegistrantsPerRoom
    maxRegistrantsPerRoom
    waitRoomMaxDurationSeconds
    name
    organiserId
    algorithm
  }
}
    `;
export type InsertShufflePeriodMutationFn = Apollo.MutationFunction<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>;

/**
 * __useInsertShufflePeriodMutation__
 *
 * To run a mutation, you first call `useInsertShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertShufflePeriodMutation, { data, loading, error }] = useInsertShufflePeriodMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>(InsertShufflePeriodDocument, options);
      }
export type InsertShufflePeriodMutationHookResult = ReturnType<typeof useInsertShufflePeriodMutation>;
export type InsertShufflePeriodMutationResult = Apollo.MutationResult<InsertShufflePeriodMutation>;
export type InsertShufflePeriodMutationOptions = Apollo.BaseMutationOptions<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>;
export const ManageShufflePeriods_SelectAllDocument = gql`
    query ManageShufflePeriods_SelectAll($conferenceId: uuid!) {
  room_ShufflePeriod(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageShufflePeriods_ShufflePeriod
  }
}
    ${ManageShufflePeriods_ShufflePeriodFragmentDoc}`;

/**
 * __useManageShufflePeriods_SelectAllQuery__
 *
 * To run a query within a React component, call `useManageShufflePeriods_SelectAllQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageShufflePeriods_SelectAllQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageShufflePeriods_SelectAllQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageShufflePeriods_SelectAllQuery(baseOptions: Apollo.QueryHookOptions<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>(ManageShufflePeriods_SelectAllDocument, options);
      }
export function useManageShufflePeriods_SelectAllLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>(ManageShufflePeriods_SelectAllDocument, options);
        }
export type ManageShufflePeriods_SelectAllQueryHookResult = ReturnType<typeof useManageShufflePeriods_SelectAllQuery>;
export type ManageShufflePeriods_SelectAllLazyQueryHookResult = ReturnType<typeof useManageShufflePeriods_SelectAllLazyQuery>;
export type ManageShufflePeriods_SelectAllQueryResult = Apollo.QueryResult<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>;
export const DeleteShufflePeriodDocument = gql`
    mutation DeleteShufflePeriod($id: uuid!) {
  delete_room_ShufflePeriod_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteShufflePeriodMutationFn = Apollo.MutationFunction<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>;

/**
 * __useDeleteShufflePeriodMutation__
 *
 * To run a mutation, you first call `useDeleteShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteShufflePeriodMutation, { data, loading, error }] = useDeleteShufflePeriodMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>(DeleteShufflePeriodDocument, options);
      }
export type DeleteShufflePeriodMutationHookResult = ReturnType<typeof useDeleteShufflePeriodMutation>;
export type DeleteShufflePeriodMutationResult = Apollo.MutationResult<DeleteShufflePeriodMutation>;
export type DeleteShufflePeriodMutationOptions = Apollo.BaseMutationOptions<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>;
export const ConferenceTakenDocument = gql`
    query ConferenceTaken($name: String!, $shortName: String!, $slug: String!) {
  conference_Conference(
    where: {_or: [{name: {_eq: $name}}, {shortName: {_eq: $shortName}}, {slug: {_eq: $slug}}]}
  ) {
    id
    name
    shortName
    slug
  }
}
    `;

/**
 * __useConferenceTakenQuery__
 *
 * To run a query within a React component, call `useConferenceTakenQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceTakenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceTakenQuery({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceTakenQuery(baseOptions: Apollo.QueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, options);
      }
export function useConferenceTakenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, options);
        }
export type ConferenceTakenQueryHookResult = ReturnType<typeof useConferenceTakenQuery>;
export type ConferenceTakenLazyQueryHookResult = ReturnType<typeof useConferenceTakenLazyQuery>;
export type ConferenceTakenQueryResult = Apollo.QueryResult<ConferenceTakenQuery, ConferenceTakenQueryVariables>;
export const CreateConferenceDocument = gql`
    mutation CreateConference($name: String!, $shortName: String!, $slug: String!, $demoCode: uuid!) {
  insert_conference_Conference(
    objects: [{name: $name, shortName: $shortName, slug: $slug, demoCodeId: $demoCode}]
  ) {
    returning {
      id
      slug
    }
  }
  update_conference_DemoCode(
    where: {id: {_eq: $demoCode}}
    _set: {note: "Code has been used."}
  ) {
    affected_rows
  }
}
    `;
export type CreateConferenceMutationFn = Apollo.MutationFunction<CreateConferenceMutation, CreateConferenceMutationVariables>;

/**
 * __useCreateConferenceMutation__
 *
 * To run a mutation, you first call `useCreateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferenceMutation, { data, loading, error }] = useCreateConferenceMutation({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *      demoCode: // value for 'demoCode'
 *   },
 * });
 */
export function useCreateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferenceMutation, CreateConferenceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConferenceMutation, CreateConferenceMutationVariables>(CreateConferenceDocument, options);
      }
export type CreateConferenceMutationHookResult = ReturnType<typeof useCreateConferenceMutation>;
export type CreateConferenceMutationResult = Apollo.MutationResult<CreateConferenceMutation>;
export type CreateConferenceMutationOptions = Apollo.BaseMutationOptions<CreateConferenceMutation, CreateConferenceMutationVariables>;
export const CreateNewConferenceMetaStructureDocument = gql`
    mutation CreateNewConferenceMetaStructure($conferenceId: uuid!, $registrantDisplayName: String!, $userId: String!, $abstractData: jsonb!, $itemListData: jsonb!) {
  insert_registrant_Registrant(
    objects: [{displayName: $registrantDisplayName, userId: $userId, conferenceId: $conferenceId, groupRegistrants: {data: {group: {data: {conferenceId: $conferenceId, includeUnauthenticated: false, name: "Organisers", groupRoles: {data: {role: {data: {conferenceId: $conferenceId, name: "Organiser", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_NAME}, {permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_MANAGE_ROLES}, {permissionName: CONFERENCE_MANAGE_GROUPS}, {permissionName: CONFERENCE_MANAGE_CONTENT}, {permissionName: CONFERENCE_MANAGE_SCHEDULE}, {permissionName: CONFERENCE_MANAGE_SHUFFLE}]}}}}}}}}}}]
  ) {
    affected_rows
  }
  insert_permissions_Group(
    objects: [{conferenceId: $conferenceId, enabled: false, name: "Registrants", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Registrant", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Public", includeUnauthenticated: true, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Public", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Registrars", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Registrar", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Moderators", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Moderator", rolePermissions: {data: [{permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Social Chairs", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Social Chair", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_SHUFFLE}]}}}}]}}]
  ) {
    returning {
      id
      conferenceId
      name
      enabled
      groupRoles {
        id
        roleId
        groupId
        role {
          id
          name
          conferenceId
          rolePermissions {
            id
            roleId
            permissionName
          }
        }
      }
    }
  }
  insert_content_Item(
    objects: {conferenceId: $conferenceId, typeName: LANDING_PAGE, elements: {data: [{conferenceId: $conferenceId, typeName: ABSTRACT, data: $abstractData, isHidden: false, layoutData: null, name: "Welcome text"}, {conferenceId: $conferenceId, typeName: CONTENT_GROUP_LIST, data: $itemListData, isHidden: false, layoutData: null, name: "Content group list"}]}, shortTitle: "Landing", title: "Landing page"}
  ) {
    affected_rows
  }
}
    `;
export type CreateNewConferenceMetaStructureMutationFn = Apollo.MutationFunction<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;

/**
 * __useCreateNewConferenceMetaStructureMutation__
 *
 * To run a mutation, you first call `useCreateNewConferenceMetaStructureMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNewConferenceMetaStructureMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNewConferenceMetaStructureMutation, { data, loading, error }] = useCreateNewConferenceMetaStructureMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantDisplayName: // value for 'registrantDisplayName'
 *      userId: // value for 'userId'
 *      abstractData: // value for 'abstractData'
 *      itemListData: // value for 'itemListData'
 *   },
 * });
 */
export function useCreateNewConferenceMetaStructureMutation(baseOptions?: Apollo.MutationHookOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>(CreateNewConferenceMetaStructureDocument, options);
      }
export type CreateNewConferenceMetaStructureMutationHookResult = ReturnType<typeof useCreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationResult = Apollo.MutationResult<CreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationOptions = Apollo.BaseMutationOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;
export const RegistrantsByIdDocument = gql`
    query RegistrantsById($conferenceId: uuid!, $registrantIds: [uuid!]!) {
  registrant_Registrant(
    where: {id: {_in: $registrantIds}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useRegistrantsByIdQuery__
 *
 * To run a query within a React component, call `useRegistrantsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantsByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantIds: // value for 'registrantIds'
 *   },
 * });
 */
export function useRegistrantsByIdQuery(baseOptions: Apollo.QueryHookOptions<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>(RegistrantsByIdDocument, options);
      }
export function useRegistrantsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>(RegistrantsByIdDocument, options);
        }
export type RegistrantsByIdQueryHookResult = ReturnType<typeof useRegistrantsByIdQuery>;
export type RegistrantsByIdLazyQueryHookResult = ReturnType<typeof useRegistrantsByIdLazyQuery>;
export type RegistrantsByIdQueryResult = Apollo.QueryResult<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>;
export const RegistrantsByUserIdDocument = gql`
    query RegistrantsByUserId($conferenceId: uuid!, $userIds: [String!]!) {
  registrant_Registrant(
    where: {userId: {_in: $userIds}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useRegistrantsByUserIdQuery__
 *
 * To run a query within a React component, call `useRegistrantsByUserIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantsByUserIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantsByUserIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useRegistrantsByUserIdQuery(baseOptions: Apollo.QueryHookOptions<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>(RegistrantsByUserIdDocument, options);
      }
export function useRegistrantsByUserIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>(RegistrantsByUserIdDocument, options);
        }
export type RegistrantsByUserIdQueryHookResult = ReturnType<typeof useRegistrantsByUserIdQuery>;
export type RegistrantsByUserIdLazyQueryHookResult = ReturnType<typeof useRegistrantsByUserIdLazyQuery>;
export type RegistrantsByUserIdQueryResult = Apollo.QueryResult<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>;
export const ConferenceBySlug_WithUserDocument = gql`
    query ConferenceBySlug_WithUser($slug: String!, $userId: String!) {
  conference_Conference(where: {slug: {_eq: $slug}}) {
    ...PublicConferenceInfo
    ...AuthdConferenceInfo
  }
}
    ${PublicConferenceInfoFragmentDoc}
${AuthdConferenceInfoFragmentDoc}`;

/**
 * __useConferenceBySlug_WithUserQuery__
 *
 * To run a query within a React component, call `useConferenceBySlug_WithUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceBySlug_WithUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceBySlug_WithUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useConferenceBySlug_WithUserQuery(baseOptions: Apollo.QueryHookOptions<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>(ConferenceBySlug_WithUserDocument, options);
      }
export function useConferenceBySlug_WithUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>(ConferenceBySlug_WithUserDocument, options);
        }
export type ConferenceBySlug_WithUserQueryHookResult = ReturnType<typeof useConferenceBySlug_WithUserQuery>;
export type ConferenceBySlug_WithUserLazyQueryHookResult = ReturnType<typeof useConferenceBySlug_WithUserLazyQuery>;
export type ConferenceBySlug_WithUserQueryResult = Apollo.QueryResult<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>;
export const ConferenceBySlug_WithoutUserDocument = gql`
    query ConferenceBySlug_WithoutUser($slug: String!) {
  conference_Conference(where: {slug: {_eq: $slug}}) {
    ...PublicConferenceInfo
  }
}
    ${PublicConferenceInfoFragmentDoc}`;

/**
 * __useConferenceBySlug_WithoutUserQuery__
 *
 * To run a query within a React component, call `useConferenceBySlug_WithoutUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceBySlug_WithoutUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceBySlug_WithoutUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceBySlug_WithoutUserQuery(baseOptions: Apollo.QueryHookOptions<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>(ConferenceBySlug_WithoutUserDocument, options);
      }
export function useConferenceBySlug_WithoutUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>(ConferenceBySlug_WithoutUserDocument, options);
        }
export type ConferenceBySlug_WithoutUserQueryHookResult = ReturnType<typeof useConferenceBySlug_WithoutUserQuery>;
export type ConferenceBySlug_WithoutUserLazyQueryHookResult = ReturnType<typeof useConferenceBySlug_WithoutUserLazyQuery>;
export type ConferenceBySlug_WithoutUserQueryResult = Apollo.QueryResult<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>;
export const UpdateSubtitlesDocument = gql`
    mutation UpdateSubtitles($elementId: String!, $magicToken: String!, $subtitleText: String!) {
  updateSubtitles(
    elementId: $elementId
    magicToken: $magicToken
    subtitleText: $subtitleText
  ) {
    message
    success
  }
}
    `;
export type UpdateSubtitlesMutationFn = Apollo.MutationFunction<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;

/**
 * __useUpdateSubtitlesMutation__
 *
 * To run a mutation, you first call `useUpdateSubtitlesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubtitlesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubtitlesMutation, { data, loading, error }] = useUpdateSubtitlesMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *      magicToken: // value for 'magicToken'
 *      subtitleText: // value for 'subtitleText'
 *   },
 * });
 */
export function useUpdateSubtitlesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>(UpdateSubtitlesDocument, options);
      }
export type UpdateSubtitlesMutationHookResult = ReturnType<typeof useUpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationResult = Apollo.MutationResult<UpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationOptions = Apollo.BaseMutationOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;
export const Submissions_ListUploadersDocument = gql`
    query Submissions_ListUploaders($elementId: uuid!) {
  content_Uploader(where: {elementId: {_eq: $elementId}}) {
    id
    name
    email
  }
}
    `;

/**
 * __useSubmissions_ListUploadersQuery__
 *
 * To run a query within a React component, call `useSubmissions_ListUploadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissions_ListUploadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissions_ListUploadersQuery({
 *   variables: {
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useSubmissions_ListUploadersQuery(baseOptions: Apollo.QueryHookOptions<Submissions_ListUploadersQuery, Submissions_ListUploadersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Submissions_ListUploadersQuery, Submissions_ListUploadersQueryVariables>(Submissions_ListUploadersDocument, options);
      }
export function useSubmissions_ListUploadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Submissions_ListUploadersQuery, Submissions_ListUploadersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Submissions_ListUploadersQuery, Submissions_ListUploadersQueryVariables>(Submissions_ListUploadersDocument, options);
        }
export type Submissions_ListUploadersQueryHookResult = ReturnType<typeof useSubmissions_ListUploadersQuery>;
export type Submissions_ListUploadersLazyQueryHookResult = ReturnType<typeof useSubmissions_ListUploadersLazyQuery>;
export type Submissions_ListUploadersQueryResult = Apollo.QueryResult<Submissions_ListUploadersQuery, Submissions_ListUploadersQueryVariables>;
export const Submissions_GetProgramPersonAccessTokenDocument = gql`
    query Submissions_GetProgramPersonAccessToken($elementId: uuid!, $uploaderEmail: String!, $elementAccessToken: String!) {
  getProgramPersonAccessToken(
    elementId: $elementId
    uploaderEmail: $uploaderEmail
    elementAccessToken: $elementAccessToken
  ) {
    accessToken
  }
}
    `;

/**
 * __useSubmissions_GetProgramPersonAccessTokenQuery__
 *
 * To run a query within a React component, call `useSubmissions_GetProgramPersonAccessTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissions_GetProgramPersonAccessTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissions_GetProgramPersonAccessTokenQuery({
 *   variables: {
 *      elementId: // value for 'elementId'
 *      uploaderEmail: // value for 'uploaderEmail'
 *      elementAccessToken: // value for 'elementAccessToken'
 *   },
 * });
 */
export function useSubmissions_GetProgramPersonAccessTokenQuery(baseOptions: Apollo.QueryHookOptions<Submissions_GetProgramPersonAccessTokenQuery, Submissions_GetProgramPersonAccessTokenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Submissions_GetProgramPersonAccessTokenQuery, Submissions_GetProgramPersonAccessTokenQueryVariables>(Submissions_GetProgramPersonAccessTokenDocument, options);
      }
export function useSubmissions_GetProgramPersonAccessTokenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Submissions_GetProgramPersonAccessTokenQuery, Submissions_GetProgramPersonAccessTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Submissions_GetProgramPersonAccessTokenQuery, Submissions_GetProgramPersonAccessTokenQueryVariables>(Submissions_GetProgramPersonAccessTokenDocument, options);
        }
export type Submissions_GetProgramPersonAccessTokenQueryHookResult = ReturnType<typeof useSubmissions_GetProgramPersonAccessTokenQuery>;
export type Submissions_GetProgramPersonAccessTokenLazyQueryHookResult = ReturnType<typeof useSubmissions_GetProgramPersonAccessTokenLazyQuery>;
export type Submissions_GetProgramPersonAccessTokenQueryResult = Apollo.QueryResult<Submissions_GetProgramPersonAccessTokenQuery, Submissions_GetProgramPersonAccessTokenQueryVariables>;
export const ItemByPersonAccessTokenDocument = gql`
    query ItemByPersonAccessToken($accessToken: String!, $itemId: uuid!) {
  collection_ProgramPersonByAccessToken(where: {accessToken: {_eq: $accessToken}}) {
    id
    name
  }
  content_ItemByPersonAccessToken(where: {id: {_eq: $itemId}}) {
    id
    title
    elements {
      id
      accessToken
      name
      data
      uploadsRemaining
      layoutData
    }
  }
}
    `;

/**
 * __useItemByPersonAccessTokenQuery__
 *
 * To run a query within a React component, call `useItemByPersonAccessTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useItemByPersonAccessTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useItemByPersonAccessTokenQuery({
 *   variables: {
 *      accessToken: // value for 'accessToken'
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useItemByPersonAccessTokenQuery(baseOptions: Apollo.QueryHookOptions<ItemByPersonAccessTokenQuery, ItemByPersonAccessTokenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ItemByPersonAccessTokenQuery, ItemByPersonAccessTokenQueryVariables>(ItemByPersonAccessTokenDocument, options);
      }
export function useItemByPersonAccessTokenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ItemByPersonAccessTokenQuery, ItemByPersonAccessTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ItemByPersonAccessTokenQuery, ItemByPersonAccessTokenQueryVariables>(ItemByPersonAccessTokenDocument, options);
        }
export type ItemByPersonAccessTokenQueryHookResult = ReturnType<typeof useItemByPersonAccessTokenQuery>;
export type ItemByPersonAccessTokenLazyQueryHookResult = ReturnType<typeof useItemByPersonAccessTokenLazyQuery>;
export type ItemByPersonAccessTokenQueryResult = Apollo.QueryResult<ItemByPersonAccessTokenQuery, ItemByPersonAccessTokenQueryVariables>;
export const ItemsByPersonAccessTokenDocument = gql`
    query ItemsByPersonAccessToken($accessToken: String!) {
  collection_ProgramPersonByAccessToken(where: {accessToken: {_eq: $accessToken}}) {
    id
    name
    itemPeople(order_by: {item: {title: asc}}) {
      id
      item {
        id
        title
      }
    }
  }
}
    `;

/**
 * __useItemsByPersonAccessTokenQuery__
 *
 * To run a query within a React component, call `useItemsByPersonAccessTokenQuery` and pass it any options that fit your needs.
 * When your component renders, `useItemsByPersonAccessTokenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useItemsByPersonAccessTokenQuery({
 *   variables: {
 *      accessToken: // value for 'accessToken'
 *   },
 * });
 */
export function useItemsByPersonAccessTokenQuery(baseOptions: Apollo.QueryHookOptions<ItemsByPersonAccessTokenQuery, ItemsByPersonAccessTokenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ItemsByPersonAccessTokenQuery, ItemsByPersonAccessTokenQueryVariables>(ItemsByPersonAccessTokenDocument, options);
      }
export function useItemsByPersonAccessTokenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ItemsByPersonAccessTokenQuery, ItemsByPersonAccessTokenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ItemsByPersonAccessTokenQuery, ItemsByPersonAccessTokenQueryVariables>(ItemsByPersonAccessTokenDocument, options);
        }
export type ItemsByPersonAccessTokenQueryHookResult = ReturnType<typeof useItemsByPersonAccessTokenQuery>;
export type ItemsByPersonAccessTokenLazyQueryHookResult = ReturnType<typeof useItemsByPersonAccessTokenLazyQuery>;
export type ItemsByPersonAccessTokenQueryResult = Apollo.QueryResult<ItemsByPersonAccessTokenQuery, ItemsByPersonAccessTokenQueryVariables>;
export const GetElementDocument = gql`
    query GetElement($accessToken: String!, $elementId: uuid!) {
  content_ElementByPersonAccessToken(where: {id: {_eq: $elementId}}) {
    typeName
    data
    name
    id
    uploadsRemaining
    accessToken
    item {
      title
    }
  }
  collection_ProgramPersonByAccessToken(where: {accessToken: {_eq: $accessToken}}) {
    id
    name
  }
}
    `;

/**
 * __useGetElementQuery__
 *
 * To run a query within a React component, call `useGetElementQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetElementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetElementQuery({
 *   variables: {
 *      accessToken: // value for 'accessToken'
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useGetElementQuery(baseOptions: Apollo.QueryHookOptions<GetElementQuery, GetElementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetElementQuery, GetElementQueryVariables>(GetElementDocument, options);
      }
export function useGetElementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetElementQuery, GetElementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetElementQuery, GetElementQueryVariables>(GetElementDocument, options);
        }
export type GetElementQueryHookResult = ReturnType<typeof useGetElementQuery>;
export type GetElementLazyQueryHookResult = ReturnType<typeof useGetElementLazyQuery>;
export type GetElementQueryResult = Apollo.QueryResult<GetElementQuery, GetElementQueryVariables>;
export const SubmitUploadableElementDocument = gql`
    mutation submitUploadableElement($elementData: jsonb!, $magicToken: String!) {
  submitUploadableElement(data: $elementData, magicToken: $magicToken) {
    message
    success
  }
}
    `;
export type SubmitUploadableElementMutationFn = Apollo.MutationFunction<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>;

/**
 * __useSubmitUploadableElementMutation__
 *
 * To run a mutation, you first call `useSubmitUploadableElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitUploadableElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitUploadableElementMutation, { data, loading, error }] = useSubmitUploadableElementMutation({
 *   variables: {
 *      elementData: // value for 'elementData'
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useSubmitUploadableElementMutation(baseOptions?: Apollo.MutationHookOptions<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>(SubmitUploadableElementDocument, options);
      }
export type SubmitUploadableElementMutationHookResult = ReturnType<typeof useSubmitUploadableElementMutation>;
export type SubmitUploadableElementMutationResult = Apollo.MutationResult<SubmitUploadableElementMutation>;
export type SubmitUploadableElementMutationOptions = Apollo.BaseMutationOptions<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>;
export const GetUploadAgreementDocument = gql`
    query GetUploadAgreement($magicToken: String!) {
  getUploadAgreement(magicToken: $magicToken) {
    agreementText
    agreementUrl
  }
}
    `;

/**
 * __useGetUploadAgreementQuery__
 *
 * To run a query within a React component, call `useGetUploadAgreementQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUploadAgreementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUploadAgreementQuery({
 *   variables: {
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useGetUploadAgreementQuery(baseOptions: Apollo.QueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, options);
      }
export function useGetUploadAgreementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, options);
        }
export type GetUploadAgreementQueryHookResult = ReturnType<typeof useGetUploadAgreementQuery>;
export type GetUploadAgreementLazyQueryHookResult = ReturnType<typeof useGetUploadAgreementLazyQuery>;
export type GetUploadAgreementQueryResult = Apollo.QueryResult<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>;
export const GetForceUserRefreshConfigDocument = gql`
    query GetForceUserRefreshConfig($conferenceId: uuid!) {
  conference_Configuration_by_pk(
    conferenceId: $conferenceId
    key: CLOWDR_APP_VERSION
  ) {
    conferenceId
    key
    value
  }
}
    `;

/**
 * __useGetForceUserRefreshConfigQuery__
 *
 * To run a query within a React component, call `useGetForceUserRefreshConfigQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetForceUserRefreshConfigQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetForceUserRefreshConfigQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetForceUserRefreshConfigQuery(baseOptions: Apollo.QueryHookOptions<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>(GetForceUserRefreshConfigDocument, options);
      }
export function useGetForceUserRefreshConfigLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>(GetForceUserRefreshConfigDocument, options);
        }
export type GetForceUserRefreshConfigQueryHookResult = ReturnType<typeof useGetForceUserRefreshConfigQuery>;
export type GetForceUserRefreshConfigLazyQueryHookResult = ReturnType<typeof useGetForceUserRefreshConfigLazyQuery>;
export type GetForceUserRefreshConfigQueryResult = Apollo.QueryResult<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>;
export const GoogleOAuth_SubmitGoogleOAuthCodeDocument = gql`
    mutation GoogleOAuth_SubmitGoogleOAuthCode($code: String!, $state: String!) {
  submitGoogleOAuthCode(code: $code, state: $state) {
    message
    success
  }
}
    `;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationFn = Apollo.MutationFunction<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>;

/**
 * __useGoogleOAuth_SubmitGoogleOAuthCodeMutation__
 *
 * To run a mutation, you first call `useGoogleOAuth_SubmitGoogleOAuthCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleOAuth_SubmitGoogleOAuthCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleOAuthSubmitGoogleOAuthCodeMutation, { data, loading, error }] = useGoogleOAuth_SubmitGoogleOAuthCodeMutation({
 *   variables: {
 *      code: // value for 'code'
 *      state: // value for 'state'
 *   },
 * });
 */
export function useGoogleOAuth_SubmitGoogleOAuthCodeMutation(baseOptions?: Apollo.MutationHookOptions<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>(GoogleOAuth_SubmitGoogleOAuthCodeDocument, options);
      }
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationHookResult = ReturnType<typeof useGoogleOAuth_SubmitGoogleOAuthCodeMutation>;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationResult = Apollo.MutationResult<GoogleOAuth_SubmitGoogleOAuthCodeMutation>;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationOptions = Apollo.BaseMutationOptions<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>;
export const SelectInvitationForAcceptDocument = gql`
    query SelectInvitationForAccept($inviteCode: uuid!) {
  registrant_Invitation(where: {inviteCode: {_eq: $inviteCode}}) {
    id
    invitedEmailAddress
  }
}
    `;

/**
 * __useSelectInvitationForAcceptQuery__
 *
 * To run a query within a React component, call `useSelectInvitationForAcceptQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInvitationForAcceptQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInvitationForAcceptQuery({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSelectInvitationForAcceptQuery(baseOptions: Apollo.QueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, options);
      }
export function useSelectInvitationForAcceptLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, options);
        }
export type SelectInvitationForAcceptQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptQuery>;
export type SelectInvitationForAcceptLazyQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptLazyQuery>;
export type SelectInvitationForAcceptQueryResult = Apollo.QueryResult<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>;
export const Invitation_ConfirmCurrentDocument = gql`
    mutation Invitation_ConfirmCurrent($inviteCode: uuid!) {
  invitationConfirmCurrent(inviteCode: $inviteCode) {
    confSlug
    ok
  }
}
    `;
export type Invitation_ConfirmCurrentMutationFn = Apollo.MutationFunction<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;

/**
 * __useInvitation_ConfirmCurrentMutation__
 *
 * To run a mutation, you first call `useInvitation_ConfirmCurrentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvitation_ConfirmCurrentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invitationConfirmCurrentMutation, { data, loading, error }] = useInvitation_ConfirmCurrentMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useInvitation_ConfirmCurrentMutation(baseOptions?: Apollo.MutationHookOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>(Invitation_ConfirmCurrentDocument, options);
      }
export type Invitation_ConfirmCurrentMutationHookResult = ReturnType<typeof useInvitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationResult = Apollo.MutationResult<Invitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationOptions = Apollo.BaseMutationOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;
export const GetEventsInNextHourDocument = gql`
    query GetEventsInNextHour($conferenceId: uuid!, $now: timestamptz!, $cutoff: timestamptz!) {
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, endTime: {_gte: $now}, startTime: {_lte: $cutoff}}
  ) {
    ...MinimalEventInfo
  }
}
    ${MinimalEventInfoFragmentDoc}`;

/**
 * __useGetEventsInNextHourQuery__
 *
 * To run a query within a React component, call `useGetEventsInNextHourQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventsInNextHourQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventsInNextHourQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      now: // value for 'now'
 *      cutoff: // value for 'cutoff'
 *   },
 * });
 */
export function useGetEventsInNextHourQuery(baseOptions: Apollo.QueryHookOptions<GetEventsInNextHourQuery, GetEventsInNextHourQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventsInNextHourQuery, GetEventsInNextHourQueryVariables>(GetEventsInNextHourDocument, options);
      }
export function useGetEventsInNextHourLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventsInNextHourQuery, GetEventsInNextHourQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventsInNextHourQuery, GetEventsInNextHourQueryVariables>(GetEventsInNextHourDocument, options);
        }
export type GetEventsInNextHourQueryHookResult = ReturnType<typeof useGetEventsInNextHourQuery>;
export type GetEventsInNextHourLazyQueryHookResult = ReturnType<typeof useGetEventsInNextHourLazyQuery>;
export type GetEventsInNextHourQueryResult = Apollo.QueryResult<GetEventsInNextHourQuery, GetEventsInNextHourQueryVariables>;
export const MenuScheduleDocument = gql`
    query MenuSchedule($now: timestamptz!, $inOneHour: timestamptz!, $conferenceId: uuid!) {
  schedule_Event(
    where: {startTime: {_lte: $inOneHour}, endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, room: {}}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuScheduleQuery__
 *
 * To run a query within a React component, call `useMenuScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuScheduleQuery({
 *   variables: {
 *      now: // value for 'now'
 *      inOneHour: // value for 'inOneHour'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMenuScheduleQuery(baseOptions: Apollo.QueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, options);
      }
export function useMenuScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, options);
        }
export type MenuScheduleQueryHookResult = ReturnType<typeof useMenuScheduleQuery>;
export type MenuScheduleLazyQueryHookResult = ReturnType<typeof useMenuScheduleLazyQuery>;
export type MenuScheduleQueryResult = Apollo.QueryResult<MenuScheduleQuery, MenuScheduleQueryVariables>;
export const MenuSchedule_SearchEventsDocument = gql`
    query MenuSchedule_SearchEvents($conferenceId: uuid!, $search: String!) {
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, room: {}, _or: [{name: {_ilike: $search}}, {item: {_or: [{title: {_ilike: $search}}, {itemPeople: {person: {_or: [{name: {_ilike: $search}}, {affiliation: {_ilike: $search}}]}}}]}}, {eventPeople: {person: {_or: [{name: {_ilike: $search}}, {affiliation: {_ilike: $search}}]}}}, {eventTags: {tag: {name: {_ilike: $search}}}}]}
    limit: 10
    order_by: {startTime: asc}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuSchedule_SearchEventsQuery__
 *
 * To run a query within a React component, call `useMenuSchedule_SearchEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuSchedule_SearchEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuSchedule_SearchEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useMenuSchedule_SearchEventsQuery(baseOptions: Apollo.QueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, options);
      }
export function useMenuSchedule_SearchEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, options);
        }
export type MenuSchedule_SearchEventsQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsQuery>;
export type MenuSchedule_SearchEventsLazyQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsLazyQuery>;
export type MenuSchedule_SearchEventsQueryResult = Apollo.QueryResult<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>;
export const MainMenuSponsors_GetSponsorsDocument = gql`
    query MainMenuSponsors_GetSponsors($conferenceId: uuid!) {
  content_Item(
    where: {conferenceId: {_eq: $conferenceId}, typeName: {_eq: SPONSOR}}
    order_by: {title: asc}
  ) {
    ...MainMenuSponsors_ItemData
  }
}
    ${MainMenuSponsors_ItemDataFragmentDoc}`;

/**
 * __useMainMenuSponsors_GetSponsorsQuery__
 *
 * To run a query within a React component, call `useMainMenuSponsors_GetSponsorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMainMenuSponsors_GetSponsorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMainMenuSponsors_GetSponsorsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMainMenuSponsors_GetSponsorsQuery(baseOptions: Apollo.QueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, options);
      }
export function useMainMenuSponsors_GetSponsorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, options);
        }
export type MainMenuSponsors_GetSponsorsQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsQuery>;
export type MainMenuSponsors_GetSponsorsLazyQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsLazyQuery>;
export type MainMenuSponsors_GetSponsorsQueryResult = Apollo.QueryResult<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>;
export const CreateDmDocument = gql`
    mutation CreateDm($registrantIds: [uuid]!, $conferenceId: uuid!) {
  createRoomDm(registrantIds: $registrantIds, conferenceId: $conferenceId) {
    message
    roomId
    chatId
  }
}
    `;
export type CreateDmMutationFn = Apollo.MutationFunction<CreateDmMutation, CreateDmMutationVariables>;

/**
 * __useCreateDmMutation__
 *
 * To run a mutation, you first call `useCreateDmMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDmMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDmMutation, { data, loading, error }] = useCreateDmMutation({
 *   variables: {
 *      registrantIds: // value for 'registrantIds'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateDmMutation(baseOptions?: Apollo.MutationHookOptions<CreateDmMutation, CreateDmMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDmMutation, CreateDmMutationVariables>(CreateDmDocument, options);
      }
export type CreateDmMutationHookResult = ReturnType<typeof useCreateDmMutation>;
export type CreateDmMutationResult = Apollo.MutationResult<CreateDmMutation>;
export type CreateDmMutationOptions = Apollo.BaseMutationOptions<CreateDmMutation, CreateDmMutationVariables>;
export const GetItemChatIdDocument = gql`
    query GetItemChatId($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    id
    title
    chatId
  }
}
    `;

/**
 * __useGetItemChatIdQuery__
 *
 * To run a query within a React component, call `useGetItemChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetItemChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetItemChatIdQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useGetItemChatIdQuery(baseOptions: Apollo.QueryHookOptions<GetItemChatIdQuery, GetItemChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetItemChatIdQuery, GetItemChatIdQueryVariables>(GetItemChatIdDocument, options);
      }
export function useGetItemChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetItemChatIdQuery, GetItemChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetItemChatIdQuery, GetItemChatIdQueryVariables>(GetItemChatIdDocument, options);
        }
export type GetItemChatIdQueryHookResult = ReturnType<typeof useGetItemChatIdQuery>;
export type GetItemChatIdLazyQueryHookResult = ReturnType<typeof useGetItemChatIdLazyQuery>;
export type GetItemChatIdQueryResult = Apollo.QueryResult<GetItemChatIdQuery, GetItemChatIdQueryVariables>;
export const GetRoomChatIdDocument = gql`
    query GetRoomChatId($roomId: uuid!) {
  room_Room_by_pk(id: $roomId) {
    id
    chatId
    name
  }
}
    `;

/**
 * __useGetRoomChatIdQuery__
 *
 * To run a query within a React component, call `useGetRoomChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomChatIdQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomChatIdQuery(baseOptions: Apollo.QueryHookOptions<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>(GetRoomChatIdDocument, options);
      }
export function useGetRoomChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>(GetRoomChatIdDocument, options);
        }
export type GetRoomChatIdQueryHookResult = ReturnType<typeof useGetRoomChatIdQuery>;
export type GetRoomChatIdLazyQueryHookResult = ReturnType<typeof useGetRoomChatIdLazyQuery>;
export type GetRoomChatIdQueryResult = Apollo.QueryResult<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>;
export const GetVapidPublicKeyDocument = gql`
    query GetVAPIDPublicKey {
  vapidPublicKey {
    key
  }
}
    `;

/**
 * __useGetVapidPublicKeyQuery__
 *
 * To run a query within a React component, call `useGetVapidPublicKeyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVapidPublicKeyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVapidPublicKeyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetVapidPublicKeyQuery(baseOptions?: Apollo.QueryHookOptions<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>(GetVapidPublicKeyDocument, options);
      }
export function useGetVapidPublicKeyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>(GetVapidPublicKeyDocument, options);
        }
export type GetVapidPublicKeyQueryHookResult = ReturnType<typeof useGetVapidPublicKeyQuery>;
export type GetVapidPublicKeyLazyQueryHookResult = ReturnType<typeof useGetVapidPublicKeyLazyQuery>;
export type GetVapidPublicKeyQueryResult = Apollo.QueryResult<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>;
export const UpsertPushNotificationSubscriptionDocument = gql`
    mutation UpsertPushNotificationSubscription($object: PushNotificationSubscription_insert_input!) {
  insert_PushNotificationSubscription_one(
    object: $object
    on_conflict: {constraint: PushNotificationSubscription_pkey, update_columns: [auth, endpoint, p256dh]}
  ) {
    endpoint
  }
}
    `;
export type UpsertPushNotificationSubscriptionMutationFn = Apollo.MutationFunction<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>;

/**
 * __useUpsertPushNotificationSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpsertPushNotificationSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertPushNotificationSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertPushNotificationSubscriptionMutation, { data, loading, error }] = useUpsertPushNotificationSubscriptionMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useUpsertPushNotificationSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>(UpsertPushNotificationSubscriptionDocument, options);
      }
export type UpsertPushNotificationSubscriptionMutationHookResult = ReturnType<typeof useUpsertPushNotificationSubscriptionMutation>;
export type UpsertPushNotificationSubscriptionMutationResult = Apollo.MutationResult<UpsertPushNotificationSubscriptionMutation>;
export type UpsertPushNotificationSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>;
export const DeletePushNotificationSubscriptionDocument = gql`
    mutation DeletePushNotificationSubscription($endpoint: String!) {
  delete_PushNotificationSubscription(where: {endpoint: {_eq: $endpoint}}) {
    affected_rows
  }
}
    `;
export type DeletePushNotificationSubscriptionMutationFn = Apollo.MutationFunction<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>;

/**
 * __useDeletePushNotificationSubscriptionMutation__
 *
 * To run a mutation, you first call `useDeletePushNotificationSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePushNotificationSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePushNotificationSubscriptionMutation, { data, loading, error }] = useDeletePushNotificationSubscriptionMutation({
 *   variables: {
 *      endpoint: // value for 'endpoint'
 *   },
 * });
 */
export function useDeletePushNotificationSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>(DeletePushNotificationSubscriptionDocument, options);
      }
export type DeletePushNotificationSubscriptionMutationHookResult = ReturnType<typeof useDeletePushNotificationSubscriptionMutation>;
export type DeletePushNotificationSubscriptionMutationResult = Apollo.MutationResult<DeletePushNotificationSubscriptionMutation>;
export type DeletePushNotificationSubscriptionMutationOptions = Apollo.BaseMutationOptions<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>;
export const GetRoomMembersDocument = gql`
    query GetRoomMembers($roomId: uuid!) {
  room_RoomPerson(where: {roomId: {_eq: $roomId}}) {
    ...RoomMember
  }
}
    ${RoomMemberFragmentDoc}`;

/**
 * __useGetRoomMembersQuery__
 *
 * To run a query within a React component, call `useGetRoomMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomMembersQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomMembersQuery(baseOptions: Apollo.QueryHookOptions<GetRoomMembersQuery, GetRoomMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomMembersQuery, GetRoomMembersQueryVariables>(GetRoomMembersDocument, options);
      }
export function useGetRoomMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomMembersQuery, GetRoomMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomMembersQuery, GetRoomMembersQueryVariables>(GetRoomMembersDocument, options);
        }
export type GetRoomMembersQueryHookResult = ReturnType<typeof useGetRoomMembersQuery>;
export type GetRoomMembersLazyQueryHookResult = ReturnType<typeof useGetRoomMembersLazyQuery>;
export type GetRoomMembersQueryResult = Apollo.QueryResult<GetRoomMembersQuery, GetRoomMembersQueryVariables>;
export const GetAllRoomParticipantsDocument = gql`
    query GetAllRoomParticipants($conferenceId: uuid!) {
  room_Participant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomParticipantDetails
  }
}
    ${RoomParticipantDetailsFragmentDoc}`;

/**
 * __useGetAllRoomParticipantsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetAllRoomParticipantsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, options);
      }
export function useGetAllRoomParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, options);
        }
export type GetAllRoomParticipantsQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsQuery>;
export type GetAllRoomParticipantsLazyQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsLazyQuery>;
export type GetAllRoomParticipantsQueryResult = Apollo.QueryResult<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>;
export const MyShuffleQueueEntryDocument = gql`
    query MyShuffleQueueEntry($id: bigint!) {
  room_ShuffleQueueEntry_by_pk(id: $id) {
    ...SubdShuffleQueueEntryData
  }
}
    ${SubdShuffleQueueEntryDataFragmentDoc}`;

/**
 * __useMyShuffleQueueEntryQuery__
 *
 * To run a query within a React component, call `useMyShuffleQueueEntryQuery` and pass it any options that fit your needs.
 * When your component renders, `useMyShuffleQueueEntryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyShuffleQueueEntryQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMyShuffleQueueEntryQuery(baseOptions: Apollo.QueryHookOptions<MyShuffleQueueEntryQuery, MyShuffleQueueEntryQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MyShuffleQueueEntryQuery, MyShuffleQueueEntryQueryVariables>(MyShuffleQueueEntryDocument, options);
      }
export function useMyShuffleQueueEntryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MyShuffleQueueEntryQuery, MyShuffleQueueEntryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MyShuffleQueueEntryQuery, MyShuffleQueueEntryQueryVariables>(MyShuffleQueueEntryDocument, options);
        }
export type MyShuffleQueueEntryQueryHookResult = ReturnType<typeof useMyShuffleQueueEntryQuery>;
export type MyShuffleQueueEntryLazyQueryHookResult = ReturnType<typeof useMyShuffleQueueEntryLazyQuery>;
export type MyShuffleQueueEntryQueryResult = Apollo.QueryResult<MyShuffleQueueEntryQuery, MyShuffleQueueEntryQueryVariables>;
export const ShufflePeriodsDocument = gql`
    query ShufflePeriods($conferenceId: uuid!, $end: timestamptz!) {
  room_ShufflePeriod(
    where: {conferenceId: {_eq: $conferenceId}, endAt: {_gte: $end}}
  ) {
    ...ShufflePeriodData
  }
}
    ${ShufflePeriodDataFragmentDoc}`;

/**
 * __useShufflePeriodsQuery__
 *
 * To run a query within a React component, call `useShufflePeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useShufflePeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useShufflePeriodsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      end: // value for 'end'
 *   },
 * });
 */
export function useShufflePeriodsQuery(baseOptions: Apollo.QueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, options);
      }
export function useShufflePeriodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, options);
        }
export type ShufflePeriodsQueryHookResult = ReturnType<typeof useShufflePeriodsQuery>;
export type ShufflePeriodsLazyQueryHookResult = ReturnType<typeof useShufflePeriodsLazyQuery>;
export type ShufflePeriodsQueryResult = Apollo.QueryResult<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>;
export const JoinShuffleQueueDocument = gql`
    mutation JoinShuffleQueue($shufflePeriodId: uuid!, $registrantId: uuid!) {
  insert_room_ShuffleQueueEntry_one(
    object: {registrantId: $registrantId, shufflePeriodId: $shufflePeriodId}
  ) {
    ...PrefetchShuffleQueueEntryData
  }
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export type JoinShuffleQueueMutationFn = Apollo.MutationFunction<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;

/**
 * __useJoinShuffleQueueMutation__
 *
 * To run a mutation, you first call `useJoinShuffleQueueMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinShuffleQueueMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinShuffleQueueMutation, { data, loading, error }] = useJoinShuffleQueueMutation({
 *   variables: {
 *      shufflePeriodId: // value for 'shufflePeriodId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useJoinShuffleQueueMutation(baseOptions?: Apollo.MutationHookOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>(JoinShuffleQueueDocument, options);
      }
export type JoinShuffleQueueMutationHookResult = ReturnType<typeof useJoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationResult = Apollo.MutationResult<JoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationOptions = Apollo.BaseMutationOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;
export const GetShuffleRoomsParticipantsCountDocument = gql`
    query GetShuffleRoomsParticipantsCount($conferenceId: uuid!) {
  room_Participant_aggregate(
    where: {conferenceId: {_eq: $conferenceId}, room: {shuffleRooms: {isEnded: {_eq: false}}}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetShuffleRoomsParticipantsCountQuery__
 *
 * To run a query within a React component, call `useGetShuffleRoomsParticipantsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShuffleRoomsParticipantsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShuffleRoomsParticipantsCountQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetShuffleRoomsParticipantsCountQuery(baseOptions: Apollo.QueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, options);
      }
export function useGetShuffleRoomsParticipantsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, options);
        }
export type GetShuffleRoomsParticipantsCountQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountQuery>;
export type GetShuffleRoomsParticipantsCountLazyQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountLazyQuery>;
export type GetShuffleRoomsParticipantsCountQueryResult = Apollo.QueryResult<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>;
export const SelectCurrentUserDocument = gql`
    query SelectCurrentUser($userId: String!) {
  User_by_pk(id: $userId) {
    ...UserInfo
  }
}
    ${UserInfoFragmentDoc}`;

/**
 * __useSelectCurrentUserQuery__
 *
 * To run a query within a React component, call `useSelectCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectCurrentUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSelectCurrentUserQuery(baseOptions: Apollo.QueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, options);
      }
export function useSelectCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, options);
        }
export type SelectCurrentUserQueryHookResult = ReturnType<typeof useSelectCurrentUserQuery>;
export type SelectCurrentUserLazyQueryHookResult = ReturnType<typeof useSelectCurrentUserLazyQuery>;
export type SelectCurrentUserQueryResult = Apollo.QueryResult<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>;
export const TermsConfigsDocument = gql`
    query TermsConfigs {
  hostOrganisationName: system_Configuration_by_pk(key: HOST_ORGANISATION_NAME) {
    key
    value
    updated_at
  }
  termsTimestamp: system_Configuration_by_pk(key: TERMS_LATEST_REVISION_TIMESTAMP) {
    key
    value
    updated_at
  }
  termsURL: system_Configuration_by_pk(key: TERMS_URL) {
    key
    value
    updated_at
  }
  ppTimestamp: system_Configuration_by_pk(
    key: PRIVACY_POLICY_LATEST_REVISION_TIMESTAMP
  ) {
    key
    value
    updated_at
  }
  ppURL: system_Configuration_by_pk(key: PRIVACY_POLICY_URL) {
    key
    value
    updated_at
  }
  cookiesTimestamp: system_Configuration_by_pk(
    key: COOKIE_POLICY_LATEST_REVISION_TIMESTAMP
  ) {
    key
    value
    updated_at
  }
  cookiesURL: system_Configuration_by_pk(key: COOKIE_POLICY_URL) {
    key
    value
    updated_at
  }
}
    `;

/**
 * __useTermsConfigsQuery__
 *
 * To run a query within a React component, call `useTermsConfigsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTermsConfigsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTermsConfigsQuery({
 *   variables: {
 *   },
 * });
 */
export function useTermsConfigsQuery(baseOptions?: Apollo.QueryHookOptions<TermsConfigsQuery, TermsConfigsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TermsConfigsQuery, TermsConfigsQueryVariables>(TermsConfigsDocument, options);
      }
export function useTermsConfigsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TermsConfigsQuery, TermsConfigsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TermsConfigsQuery, TermsConfigsQueryVariables>(TermsConfigsDocument, options);
        }
export type TermsConfigsQueryHookResult = ReturnType<typeof useTermsConfigsQuery>;
export type TermsConfigsLazyQueryHookResult = ReturnType<typeof useTermsConfigsLazyQuery>;
export type TermsConfigsQueryResult = Apollo.QueryResult<TermsConfigsQuery, TermsConfigsQueryVariables>;
export const AgreeToTermsDocument = gql`
    mutation AgreeToTerms($userId: String!, $at: timestamptz!) {
  update_User_by_pk(
    pk_columns: {id: $userId}
    _set: {acceptedTermsAt: $at, acceptedPrivacyPolicyAt: $at}
  ) {
    id
    acceptedTermsAt
    acceptedPrivacyPolicyAt
  }
}
    `;
export type AgreeToTermsMutationFn = Apollo.MutationFunction<AgreeToTermsMutation, AgreeToTermsMutationVariables>;

/**
 * __useAgreeToTermsMutation__
 *
 * To run a mutation, you first call `useAgreeToTermsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAgreeToTermsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [agreeToTermsMutation, { data, loading, error }] = useAgreeToTermsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      at: // value for 'at'
 *   },
 * });
 */
export function useAgreeToTermsMutation(baseOptions?: Apollo.MutationHookOptions<AgreeToTermsMutation, AgreeToTermsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AgreeToTermsMutation, AgreeToTermsMutationVariables>(AgreeToTermsDocument, options);
      }
export type AgreeToTermsMutationHookResult = ReturnType<typeof useAgreeToTermsMutation>;
export type AgreeToTermsMutationResult = Apollo.MutationResult<AgreeToTermsMutation>;
export type AgreeToTermsMutationOptions = Apollo.BaseMutationOptions<AgreeToTermsMutation, AgreeToTermsMutationVariables>;