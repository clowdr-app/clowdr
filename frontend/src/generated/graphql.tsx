import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  json: any;
  jsonb: any;
  numeric: any;
  timestamptz: any;
  uuid: any;
};

/** expression to compare columns of type Boolean. All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Boolean']>;
  readonly _gt?: Maybe<Scalars['Boolean']>;
  readonly _gte?: Maybe<Scalars['Boolean']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Boolean']>;
  readonly _lte?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Scalars['Boolean']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
};

export type ChatRemoteToken = {
  readonly __typename?: 'ChatRemoteToken';
  readonly expiry: Scalars['Int'];
  readonly jwt: Scalars['String'];
};

export type ConferencePrepareOutput = {
  readonly __typename?: 'ConferencePrepareOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type ConfirmInvitationInput = {
  readonly confirmationCode: Scalars['String'];
  readonly inviteCode: Scalars['uuid'];
};

export type ConfirmInvitationOutput = {
  readonly __typename?: 'ConfirmInvitationOutput';
  readonly confSlug?: Maybe<Scalars['String']>;
  readonly ok: Scalars['String'];
};

export type CreateContentGroupRoomOutput = {
  readonly __typename?: 'CreateContentGroupRoomOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['String']>;
};

export type CreateItemRoomOutput = {
  readonly __typename?: 'CreateItemRoomOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Room>;
  readonly roomId?: Maybe<Scalars['String']>;
};

export type CreateRoomDmOutput = {
  readonly __typename?: 'CreateRoomDmOutput';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

/** columns and relationships of "Email" */
export type Email = {
  readonly __typename?: 'Email';
  readonly createdAt: Scalars['timestamptz'];
  readonly emailAddress: Scalars['String'];
  readonly htmlContents: Scalars['String'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Registrant_Invitation>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents: Scalars['String'];
  readonly reason: Scalars['String'];
  readonly retriesCount: Scalars['Int'];
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregated selection of "Email" */
export type Email_Aggregate = {
  readonly __typename?: 'Email_aggregate';
  readonly aggregate?: Maybe<Email_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Email>;
};

/** aggregate fields of "Email" */
export type Email_Aggregate_Fields = {
  readonly __typename?: 'Email_aggregate_fields';
  readonly avg?: Maybe<Email_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Email_Max_Fields>;
  readonly min?: Maybe<Email_Min_Fields>;
  readonly stddev?: Maybe<Email_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Email_Sum_Fields>;
  readonly var_pop?: Maybe<Email_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Email_Var_Samp_Fields>;
  readonly variance?: Maybe<Email_Variance_Fields>;
};


/** aggregate fields of "Email" */
export type Email_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Email_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Email" */
export type Email_Aggregate_Order_By = {
  readonly avg?: Maybe<Email_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Email_Max_Order_By>;
  readonly min?: Maybe<Email_Min_Order_By>;
  readonly stddev?: Maybe<Email_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Email_Sum_Order_By>;
  readonly var_pop?: Maybe<Email_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Email_Var_Samp_Order_By>;
  readonly variance?: Maybe<Email_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Email" */
export type Email_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Email_Insert_Input>;
  readonly on_conflict?: Maybe<Email_On_Conflict>;
};

/** aggregate avg on columns */
export type Email_Avg_Fields = {
  readonly __typename?: 'Email_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Email" */
export type Email_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Email". All fields are combined with a logical 'AND'. */
export type Email_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Email_Bool_Exp>>>;
  readonly _not?: Maybe<Email_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Email_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emailAddress?: Maybe<String_Comparison_Exp>;
  readonly htmlContents?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly invitationId?: Maybe<Uuid_Comparison_Exp>;
  readonly plainTextContents?: Maybe<String_Comparison_Exp>;
  readonly reason?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly sentAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly subject?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Email" */
export enum Email_Constraint {
  /** unique or primary key constraint */
  EmailPkey = 'Email_pkey'
}

/** input type for incrementing integer column in table "Email" */
export type Email_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Email" */
export type Email_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Registrant_Invitation_Obj_Rel_Insert_Input>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Email_Max_Fields = {
  readonly __typename?: 'Email_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Email" */
export type Email_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Email_Min_Fields = {
  readonly __typename?: 'Email_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Email" */
export type Email_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "Email" */
export type Email_Mutation_Response = {
  readonly __typename?: 'Email_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Email>;
};

/** input type for inserting object relation for remote table "Email" */
export type Email_Obj_Rel_Insert_Input = {
  readonly data: Email_Insert_Input;
  readonly on_conflict?: Maybe<Email_On_Conflict>;
};

/** on conflict condition type for table "Email" */
export type Email_On_Conflict = {
  readonly constraint: Email_Constraint;
  readonly update_columns: ReadonlyArray<Email_Update_Column>;
  readonly where?: Maybe<Email_Bool_Exp>;
};

/** ordering options when selecting data from "Email" */
export type Email_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Registrant_Invitation_Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "Email" */
export type Email_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Email" */
export enum Email_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "Email" */
export type Email_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Email_Stddev_Fields = {
  readonly __typename?: 'Email_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Email" */
export type Email_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Email_Stddev_Pop_Fields = {
  readonly __typename?: 'Email_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Email" */
export type Email_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Email_Stddev_Samp_Fields = {
  readonly __typename?: 'Email_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Email" */
export type Email_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Email_Sum_Fields = {
  readonly __typename?: 'Email_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Email" */
export type Email_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "Email" */
export enum Email_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** aggregate var_pop on columns */
export type Email_Var_Pop_Fields = {
  readonly __typename?: 'Email_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Email" */
export type Email_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Email_Var_Samp_Fields = {
  readonly __typename?: 'Email_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Email" */
export type Email_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Email_Variance_Fields = {
  readonly __typename?: 'Email_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Email" */
export type Email_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** columns and relationships of "FlatUnauthPermission" */
export type FlatUnauthPermission = {
  readonly __typename?: 'FlatUnauthPermission';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate = {
  readonly __typename?: 'FlatUnauthPermission_aggregate';
  readonly aggregate?: Maybe<FlatUnauthPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUnauthPermission>;
};

/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUnauthPermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<FlatUnauthPermission_Max_Fields>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Fields>;
};


/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUnauthPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "FlatUnauthPermission". All fields are combined with a logical 'AND'. */
export type FlatUnauthPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<FlatUnauthPermission_Bool_Exp>>>;
  readonly _not?: Maybe<FlatUnauthPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<FlatUnauthPermission_Bool_Exp>>>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type FlatUnauthPermission_Max_Fields = {
  readonly __typename?: 'FlatUnauthPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUnauthPermission_Min_Fields = {
  readonly __typename?: 'FlatUnauthPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** ordering options when selecting data from "FlatUnauthPermission" */
export type FlatUnauthPermission_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** select columns of table "FlatUnauthPermission" */
export enum FlatUnauthPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug'
}

/** columns and relationships of "FlatUserPermission" */
export type FlatUserPermission = {
  readonly __typename?: 'FlatUserPermission';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  /** An object relationship */
  readonly permission?: Maybe<Permissions_Permission>;
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUserPermission" */
export type FlatUserPermission_Aggregate = {
  readonly __typename?: 'FlatUserPermission_aggregate';
  readonly aggregate?: Maybe<FlatUserPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUserPermission>;
};

/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUserPermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<FlatUserPermission_Max_Fields>;
  readonly min?: Maybe<FlatUserPermission_Min_Fields>;
};


/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUserPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUserPermission_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "FlatUserPermission". All fields are combined with a logical 'AND'. */
export type FlatUserPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<FlatUserPermission_Bool_Exp>>>;
  readonly _not?: Maybe<FlatUserPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<FlatUserPermission_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly permission?: Maybe<Permissions_Permission_Bool_Exp>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly user_id?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type FlatUserPermission_Max_Fields = {
  readonly __typename?: 'FlatUserPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUserPermission_Min_Fields = {
  readonly __typename?: 'FlatUserPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** ordering options when selecting data from "FlatUserPermission" */
export type FlatUserPermission_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly permission?: Maybe<Permissions_Permission_Order_By>;
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** select columns of table "FlatUserPermission" */
export enum FlatUserPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug',
  /** column name */
  UserId = 'user_id'
}

/** expression to compare columns of type Float. All fields are combined with logical 'AND'. */
export type Float_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Float']>;
  readonly _gt?: Maybe<Scalars['Float']>;
  readonly _gte?: Maybe<Scalars['Float']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Float']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Float']>;
  readonly _lte?: Maybe<Scalars['Float']>;
  readonly _neq?: Maybe<Scalars['Float']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Float']>>;
};

export type GenerateChatRemoteServiceIdsOutput = {
  readonly __typename?: 'GenerateChatRemoteServiceIdsOutput';
  readonly error?: Maybe<Scalars['String']>;
};

export type GenerateChatRemoteUserIdsOutput = {
  readonly __typename?: 'GenerateChatRemoteUserIdsOutput';
  readonly error?: Maybe<Scalars['String']>;
};

export type GetContentItemOutput = {
  readonly __typename?: 'GetContentItemOutput';
  readonly contentGroupTitle: Scalars['String'];
  readonly contentTypeName: Scalars['String'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['String'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name: Scalars['String'];
};

export type GetGoogleOAuthUrlOutput = {
  readonly __typename?: 'GetGoogleOAuthUrlOutput';
  readonly url: Scalars['String'];
};

export type GetUploadAgreementOutput = {
  readonly __typename?: 'GetUploadAgreementOutput';
  readonly agreementText?: Maybe<Scalars['String']>;
};

/** expression to compare columns of type Int. All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Int']>;
  readonly _gt?: Maybe<Scalars['Int']>;
  readonly _gte?: Maybe<Scalars['Int']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Int']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Int']>;
  readonly _lte?: Maybe<Scalars['Int']>;
  readonly _neq?: Maybe<Scalars['Int']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Int']>>;
};

export type InvitationConfirmationEmailInput = {
  readonly inviteCode: Scalars['uuid'];
};

export type InvitationConfirmationEmailOutput = {
  readonly __typename?: 'InvitationConfirmationEmailOutput';
  readonly sent: Scalars['Boolean'];
};

export type InvitationSendEmailResult = {
  readonly __typename?: 'InvitationSendEmailResult';
  readonly attendeeId: Scalars['String'];
  readonly sent: Scalars['Boolean'];
};

export type JoinEventVonageSessionOutput = {
  readonly __typename?: 'JoinEventVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
};

export type JoinRoomChimeSessionOutput = {
  readonly __typename?: 'JoinRoomChimeSessionOutput';
  readonly meeting?: Maybe<Scalars['jsonb']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly registrant?: Maybe<Scalars['jsonb']>;
};

export type JoinRoomVonageSessionOutput = {
  readonly __typename?: 'JoinRoomVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sessionId?: Maybe<Scalars['String']>;
};

export type PresenceFlushOutput = {
  readonly __typename?: 'PresenceFlushOutput';
  readonly ok?: Maybe<Scalars['String']>;
};

export type PresenceSummaryOutput = {
  readonly __typename?: 'PresenceSummaryOutput';
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs: Scalars['Int'];
  readonly total_unique_user_ids: Scalars['Int'];
};

export type ProfilePhotoUrlResponse = {
  readonly __typename?: 'ProfilePhotoURLResponse';
  readonly url: Scalars['String'];
};

/** columns and relationships of "PushNotificationSubscription" */
export type PushNotificationSubscription = {
  readonly __typename?: 'PushNotificationSubscription';
  readonly auth: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  readonly endpoint: Scalars['String'];
  readonly p256dh: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly user: User;
  readonly userId: Scalars['String'];
};

/** aggregated selection of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate = {
  readonly __typename?: 'PushNotificationSubscription_aggregate';
  readonly aggregate?: Maybe<PushNotificationSubscription_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<PushNotificationSubscription>;
};

/** aggregate fields of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_Fields = {
  readonly __typename?: 'PushNotificationSubscription_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<PushNotificationSubscription_Max_Fields>;
  readonly min?: Maybe<PushNotificationSubscription_Min_Fields>;
};


/** aggregate fields of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<PushNotificationSubscription_Max_Order_By>;
  readonly min?: Maybe<PushNotificationSubscription_Min_Order_By>;
};

/** input type for inserting array relation for remote table "PushNotificationSubscription" */
export type PushNotificationSubscription_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<PushNotificationSubscription_Insert_Input>;
  readonly on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};

/** Boolean expression to filter rows from the table "PushNotificationSubscription". All fields are combined with a logical 'AND'. */
export type PushNotificationSubscription_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<PushNotificationSubscription_Bool_Exp>>>;
  readonly _not?: Maybe<PushNotificationSubscription_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<PushNotificationSubscription_Bool_Exp>>>;
  readonly auth?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpoint?: Maybe<String_Comparison_Exp>;
  readonly p256dh?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Constraint {
  /** unique or primary key constraint */
  PushNotificationSubscriptionPkey = 'PushNotificationSubscription_pkey'
}

/** input type for inserting data into table "PushNotificationSubscription" */
export type PushNotificationSubscription_Insert_Input = {
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PushNotificationSubscription_Max_Fields = {
  readonly __typename?: 'PushNotificationSubscription_max_fields';
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Max_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type PushNotificationSubscription_Min_Fields = {
  readonly __typename?: 'PushNotificationSubscription_min_fields';
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Min_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "PushNotificationSubscription" */
export type PushNotificationSubscription_Mutation_Response = {
  readonly __typename?: 'PushNotificationSubscription_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<PushNotificationSubscription>;
};

/** input type for inserting object relation for remote table "PushNotificationSubscription" */
export type PushNotificationSubscription_Obj_Rel_Insert_Input = {
  readonly data: PushNotificationSubscription_Insert_Input;
  readonly on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};

/** on conflict condition type for table "PushNotificationSubscription" */
export type PushNotificationSubscription_On_Conflict = {
  readonly constraint: PushNotificationSubscription_Constraint;
  readonly update_columns: ReadonlyArray<PushNotificationSubscription_Update_Column>;
  readonly where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};

/** ordering options when selecting data from "PushNotificationSubscription" */
export type PushNotificationSubscription_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "PushNotificationSubscription" */
export type PushNotificationSubscription_Pk_Columns_Input = {
  readonly endpoint: Scalars['String'];
};

/** select columns of table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Select_Column {
  /** column name */
  Auth = 'auth',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  P256dh = 'p256dh',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "PushNotificationSubscription" */
export type PushNotificationSubscription_Set_Input = {
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Update_Column {
  /** column name */
  Auth = 'auth',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  P256dh = 'p256dh',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

export type RefreshYouTubeDataOutput = {
  readonly __typename?: 'RefreshYouTubeDataOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type StopEventBroadcastOutput = {
  readonly __typename?: 'StopEventBroadcastOutput';
  readonly broadcastsStopped: Scalars['Int'];
};

/** expression to compare columns of type String. All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['String']>;
  readonly _gt?: Maybe<Scalars['String']>;
  readonly _gte?: Maybe<Scalars['String']>;
  readonly _ilike?: Maybe<Scalars['String']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _like?: Maybe<Scalars['String']>;
  readonly _lt?: Maybe<Scalars['String']>;
  readonly _lte?: Maybe<Scalars['String']>;
  readonly _neq?: Maybe<Scalars['String']>;
  readonly _nilike?: Maybe<Scalars['String']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _nlike?: Maybe<Scalars['String']>;
  readonly _nsimilar?: Maybe<Scalars['String']>;
  readonly _similar?: Maybe<Scalars['String']>;
};

export type SubmitContentItemInput = {
  readonly contentItemData: Scalars['jsonb'];
};

export type SubmitContentItemOutput = {
  readonly __typename?: 'SubmitContentItemOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

export type SubmitGoogleOAuthCodeOutput = {
  readonly __typename?: 'SubmitGoogleOAuthCodeOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type SubmitGoogleOAuthTokenOutput = {
  readonly __typename?: 'SubmitGoogleOAuthTokenOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type SubmitUpdatedSubtitlesInput = {
  readonly accessToken: Scalars['String'];
  readonly contentItemId: Scalars['String'];
  readonly subtitleText: Scalars['String'];
};

export type SubmitUpdatedSubtitlesOutput = {
  readonly __typename?: 'SubmitUpdatedSubtitlesOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

export type SubmitUploadableElementOutput = {
  readonly __typename?: 'SubmitUploadableElementOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

export type UpdateProfilePhotoResponse = {
  readonly __typename?: 'UpdateProfilePhotoResponse';
  readonly ok: Scalars['Boolean'];
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
};

export type UploaderSendSubmissionRequestResult = {
  readonly __typename?: 'UploaderSendSubmissionRequestResult';
  readonly sent: Scalars['Boolean'];
  readonly uploaderId: Scalars['uuid'];
};

/** columns and relationships of "User" */
export type User = {
  readonly __typename?: 'User';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly conferenceDemoCodes: ReadonlyArray<Conference_DemoCode>;
  /** An aggregated array relationship */
  readonly conferenceDemoCodes_aggregate: Conference_DemoCode_Aggregate;
  /** An array relationship */
  readonly conferencesCreated: ReadonlyArray<Conference_Conference>;
  /** An aggregated array relationship */
  readonly conferencesCreated_aggregate: Conference_Conference_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregated array relationship */
  readonly emails_aggregate: Email_Aggregate;
  readonly id: Scalars['String'];
  /** An array relationship */
  readonly invitationsPendingConfirmation: ReadonlyArray<Registrant_Invitation>;
  /** An aggregated array relationship */
  readonly invitationsPendingConfirmation_aggregate: Registrant_Invitation_Aggregate;
  /** An array relationship */
  readonly pushNotificationSubscriptions: ReadonlyArray<PushNotificationSubscription>;
  /** An aggregated array relationship */
  readonly pushNotificationSubscriptions_aggregate: PushNotificationSubscription_Aggregate;
  /** An array relationship */
  readonly registrants: ReadonlyArray<Registrant_Registrant>;
  /** An aggregated array relationship */
  readonly registrants_aggregate: Registrant_Registrant_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodes_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreatedArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreated_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserPushNotificationSubscriptionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserPushNotificationSubscriptions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};

/** aggregated selection of "User" */
export type User_Aggregate = {
  readonly __typename?: 'User_aggregate';
  readonly aggregate?: Maybe<User_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<User>;
};

/** aggregate fields of "User" */
export type User_Aggregate_Fields = {
  readonly __typename?: 'User_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<User_Max_Fields>;
  readonly min?: Maybe<User_Min_Fields>;
};


/** aggregate fields of "User" */
export type User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "User" */
export type User_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<User_Max_Order_By>;
  readonly min?: Maybe<User_Min_Order_By>;
};

/** input type for inserting array relation for remote table "User" */
export type User_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<User_Insert_Input>;
  readonly on_conflict?: Maybe<User_On_Conflict>;
};

/** Boolean expression to filter rows from the table "User". All fields are combined with a logical 'AND'. */
export type User_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<User_Bool_Exp>>>;
  readonly _not?: Maybe<User_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<User_Bool_Exp>>>;
  readonly acceptedPrivacyPolicyAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly acceptedTermsAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly conferenceDemoCodes?: Maybe<Conference_DemoCode_Bool_Exp>;
  readonly conferencesCreated?: Maybe<Conference_Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly id?: Maybe<String_Comparison_Exp>;
  readonly invitationsPendingConfirmation?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly pushNotificationSubscriptions?: Maybe<PushNotificationSubscription_Bool_Exp>;
  readonly registrants?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "User" */
export enum User_Constraint {
  /** unique or primary key constraint */
  UserEmailKey = 'user_email_key',
  /** unique or primary key constraint */
  UserPkey = 'user_pkey'
}

/** input type for inserting data into table "User" */
export type User_Insert_Input = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly conferenceDemoCodes?: Maybe<Conference_DemoCode_Arr_Rel_Insert_Input>;
  readonly conferencesCreated?: Maybe<Conference_Conference_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['String']>;
  readonly invitationsPendingConfirmation?: Maybe<Registrant_Invitation_Arr_Rel_Insert_Input>;
  readonly pushNotificationSubscriptions?: Maybe<PushNotificationSubscription_Arr_Rel_Insert_Input>;
  readonly registrants?: Maybe<Registrant_Registrant_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type User_Max_Fields = {
  readonly __typename?: 'User_max_fields';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "User" */
export type User_Max_Order_By = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Order_By>;
  readonly acceptedTermsAt?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Min_Fields = {
  readonly __typename?: 'User_min_fields';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "User" */
export type User_Min_Order_By = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Order_By>;
  readonly acceptedTermsAt?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "User" */
export type User_Mutation_Response = {
  readonly __typename?: 'User_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<User>;
};

/** input type for inserting object relation for remote table "User" */
export type User_Obj_Rel_Insert_Input = {
  readonly data: User_Insert_Input;
  readonly on_conflict?: Maybe<User_On_Conflict>;
};

/** on conflict condition type for table "User" */
export type User_On_Conflict = {
  readonly constraint: User_Constraint;
  readonly update_columns: ReadonlyArray<User_Update_Column>;
  readonly where?: Maybe<User_Bool_Exp>;
};

/** ordering options when selecting data from "User" */
export type User_Order_By = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Order_By>;
  readonly acceptedTermsAt?: Maybe<Order_By>;
  readonly conferenceDemoCodes_aggregate?: Maybe<Conference_DemoCode_Aggregate_Order_By>;
  readonly conferencesCreated_aggregate?: Maybe<Conference_Conference_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationsPendingConfirmation_aggregate?: Maybe<Registrant_Invitation_Aggregate_Order_By>;
  readonly pushNotificationSubscriptions_aggregate?: Maybe<PushNotificationSubscription_Aggregate_Order_By>;
  readonly registrants_aggregate?: Maybe<Registrant_Registrant_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "User" */
export type User_Pk_Columns_Input = {
  readonly id: Scalars['String'];
};

/** select columns of table "User" */
export enum User_Select_Column {
  /** column name */
  AcceptedPrivacyPolicyAt = 'acceptedPrivacyPolicyAt',
  /** column name */
  AcceptedTermsAt = 'acceptedTermsAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "User" */
export type User_Set_Input = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "User" */
export enum User_Update_Column {
  /** column name */
  AcceptedPrivacyPolicyAt = 'acceptedPrivacyPolicyAt',
  /** column name */
  AcceptedTermsAt = 'acceptedTermsAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type VapidPublicKeyOutput = {
  readonly __typename?: 'VAPIDPublicKeyOutput';
  readonly key: Scalars['String'];
};

/** columns and relationships of "analytics.AppStats" */
export type Analytics_AppStats = {
  readonly __typename?: 'analytics_AppStats';
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['Int'];
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs: Scalars['Int'];
  readonly total_unique_user_ids: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "analytics.AppStats" */
export type Analytics_AppStatsPagesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate = {
  readonly __typename?: 'analytics_AppStats_aggregate';
  readonly aggregate?: Maybe<Analytics_AppStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_AppStats>;
};

/** aggregate fields of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_AppStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_AppStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_AppStats_Max_Fields>;
  readonly min?: Maybe<Analytics_AppStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_AppStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_AppStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_AppStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_AppStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_AppStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_AppStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_AppStats_Variance_Fields>;
};


/** aggregate fields of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_AppStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_AppStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_AppStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_AppStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_AppStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_AppStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_AppStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_AppStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_AppStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_AppStats_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Analytics_AppStats_Append_Input = {
  readonly pages?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "analytics.AppStats" */
export type Analytics_AppStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_AppStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_AppStats_Avg_Fields = {
  readonly __typename?: 'analytics_AppStats_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.AppStats". All fields are combined with a logical 'AND'. */
export type Analytics_AppStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_AppStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_AppStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_AppStats_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly pages?: Maybe<Jsonb_Comparison_Exp>;
  readonly total_unique_tabs?: Maybe<Int_Comparison_Exp>;
  readonly total_unique_user_ids?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.AppStats" */
export enum Analytics_AppStats_Constraint {
  /** unique or primary key constraint */
  AppStatsPkey = 'AppStats_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Analytics_AppStats_Delete_At_Path_Input = {
  readonly pages?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Analytics_AppStats_Delete_Elem_Input = {
  readonly pages?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Analytics_AppStats_Delete_Key_Input = {
  readonly pages?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "analytics.AppStats" */
export type Analytics_AppStats_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.AppStats" */
export type Analytics_AppStats_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Analytics_AppStats_Max_Fields = {
  readonly __typename?: 'analytics_AppStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_AppStats_Min_Fields = {
  readonly __typename?: 'analytics_AppStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.AppStats" */
export type Analytics_AppStats_Mutation_Response = {
  readonly __typename?: 'analytics_AppStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_AppStats>;
};

/** input type for inserting object relation for remote table "analytics.AppStats" */
export type Analytics_AppStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_AppStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.AppStats" */
export type Analytics_AppStats_On_Conflict = {
  readonly constraint: Analytics_AppStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_AppStats_Update_Column>;
  readonly where?: Maybe<Analytics_AppStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.AppStats" */
export type Analytics_AppStats_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly pages?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.AppStats" */
export type Analytics_AppStats_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Analytics_AppStats_Prepend_Input = {
  readonly pages?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "analytics.AppStats" */
export enum Analytics_AppStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pages = 'pages',
  /** column name */
  TotalUniqueTabs = 'total_unique_tabs',
  /** column name */
  TotalUniqueUserIds = 'total_unique_user_ids',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "analytics.AppStats" */
export type Analytics_AppStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Analytics_AppStats_Stddev_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_AppStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_AppStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_AppStats_Sum_Fields = {
  readonly __typename?: 'analytics_AppStats_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** update columns of table "analytics.AppStats" */
export enum Analytics_AppStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pages = 'pages',
  /** column name */
  TotalUniqueTabs = 'total_unique_tabs',
  /** column name */
  TotalUniqueUserIds = 'total_unique_user_ids',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Analytics_AppStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_AppStats_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_AppStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_AppStats_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_AppStats_Variance_Fields = {
  readonly __typename?: 'analytics_AppStats_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats = {
  readonly __typename?: 'analytics_ContentElementStats';
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly element: Content_Element;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
  readonly viewCount: Scalars['Int'];
};

/** aggregated selection of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate = {
  readonly __typename?: 'analytics_ContentElementStats_aggregate';
  readonly aggregate?: Maybe<Analytics_ContentElementStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ContentElementStats>;
};

/** aggregate fields of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_ContentElementStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_ContentElementStats_Max_Fields>;
  readonly min?: Maybe<Analytics_ContentElementStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ContentElementStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ContentElementStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ContentElementStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ContentElementStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ContentElementStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ContentElementStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ContentElementStats_Variance_Fields>;
};


/** aggregate fields of "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_ContentElementStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_ContentElementStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_ContentElementStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_ContentElementStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_ContentElementStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_ContentElementStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_ContentElementStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_ContentElementStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_ContentElementStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_ContentElementStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_ContentElementStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_ContentElementStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_ContentElementStats_Avg_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_avg_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Avg_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.ContentElementStats". All fields are combined with a logical 'AND'. */
export type Analytics_ContentElementStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_ContentElementStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_ContentElementStats_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly viewCount?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.ContentElementStats" */
export enum Analytics_ContentElementStats_Constraint {
  /** unique or primary key constraint */
  ContentElementStatsIdKey = 'ContentElementStats_id_key',
  /** unique or primary key constraint */
  ContentElementStatsPkey = 'ContentElementStats_pkey'
}

/** input type for incrementing integer column in table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Inc_Input = {
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Analytics_ContentElementStats_Max_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_ContentElementStats_Min_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Mutation_Response = {
  readonly __typename?: 'analytics_ContentElementStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_ContentElementStats>;
};

/** input type for inserting object relation for remote table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_ContentElementStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_ContentElementStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_On_Conflict = {
  readonly constraint: Analytics_ContentElementStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_ContentElementStats_Update_Column>;
  readonly where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "analytics.ContentElementStats" */
export enum Analytics_ContentElementStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** input type for updating data in table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Analytics_ContentElementStats_Stddev_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_stddev_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Stddev_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ContentElementStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_stddev_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Stddev_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ContentElementStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_stddev_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Stddev_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_ContentElementStats_Sum_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_sum_fields';
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Sum_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.ContentElementStats" */
export enum Analytics_ContentElementStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** aggregate var_pop on columns */
export type Analytics_ContentElementStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_var_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Var_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_ContentElementStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_var_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Var_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_ContentElementStats_Variance_Fields = {
  readonly __typename?: 'analytics_ContentElementStats_variance_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.ContentElementStats" */
export type Analytics_ContentElementStats_Variance_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats = {
  readonly __typename?: 'analytics_ContentItemStats';
  /** An object relationship */
  readonly contentGroup: Content_Item;
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly itemId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
  readonly viewCount: Scalars['Int'];
};

/** aggregated selection of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate = {
  readonly __typename?: 'analytics_ContentItemStats_aggregate';
  readonly aggregate?: Maybe<Analytics_ContentItemStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ContentItemStats>;
};

/** aggregate fields of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_ContentItemStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_ContentItemStats_Max_Fields>;
  readonly min?: Maybe<Analytics_ContentItemStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ContentItemStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ContentItemStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ContentItemStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ContentItemStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ContentItemStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ContentItemStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ContentItemStats_Variance_Fields>;
};


/** aggregate fields of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_ContentItemStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_ContentItemStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_ContentItemStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_ContentItemStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_ContentItemStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_ContentItemStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_ContentItemStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_ContentItemStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_ContentItemStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_ContentItemStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_ContentItemStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_ContentItemStats_Avg_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_avg_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Avg_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.ContentItemStats". All fields are combined with a logical 'AND'. */
export type Analytics_ContentItemStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_ContentItemStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_ContentItemStats_Bool_Exp>>>;
  readonly contentGroup?: Maybe<Content_Item_Bool_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly viewCount?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Constraint {
  /** unique or primary key constraint */
  ContentItemStatsIdKey = 'ContentItemStats_id_key',
  /** unique or primary key constraint */
  ContentItemStatsPkey = 'ContentItemStats_pkey'
}

/** input type for incrementing integer column in table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Inc_Input = {
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Insert_Input = {
  readonly contentGroup?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Analytics_ContentItemStats_Max_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_ContentItemStats_Min_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Mutation_Response = {
  readonly __typename?: 'analytics_ContentItemStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_ContentItemStats>;
};

/** input type for inserting object relation for remote table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_ContentItemStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_On_Conflict = {
  readonly constraint: Analytics_ContentItemStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_ContentItemStats_Update_Column>;
  readonly where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Order_By = {
  readonly contentGroup?: Maybe<Content_Item_Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** input type for updating data in table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Analytics_ContentItemStats_Stddev_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ContentItemStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ContentItemStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_ContentItemStats_Sum_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_sum_fields';
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Sum_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ViewCount = 'viewCount'
}

/** aggregate var_pop on columns */
export type Analytics_ContentItemStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_var_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Var_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_ContentItemStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_var_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Var_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_ContentItemStats_Variance_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_variance_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Variance_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.RoomStats" */
export type Analytics_RoomStats = {
  readonly __typename?: 'analytics_RoomStats';
  readonly created_at: Scalars['timestamptz'];
  readonly hlsViewCount: Scalars['Int'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate = {
  readonly __typename?: 'analytics_RoomStats_aggregate';
  readonly aggregate?: Maybe<Analytics_RoomStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_RoomStats>;
};

/** aggregate fields of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_RoomStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_RoomStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_RoomStats_Max_Fields>;
  readonly min?: Maybe<Analytics_RoomStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_RoomStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_RoomStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_RoomStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_RoomStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_RoomStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_RoomStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_RoomStats_Variance_Fields>;
};


/** aggregate fields of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_RoomStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_RoomStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_RoomStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_RoomStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_RoomStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_RoomStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_RoomStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_RoomStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_RoomStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_RoomStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.RoomStats" */
export type Analytics_RoomStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_RoomStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_RoomStats_Avg_Fields = {
  readonly __typename?: 'analytics_RoomStats_avg_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Avg_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.RoomStats". All fields are combined with a logical 'AND'. */
export type Analytics_RoomStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_RoomStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_RoomStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_RoomStats_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly hlsViewCount?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.RoomStats" */
export enum Analytics_RoomStats_Constraint {
  /** unique or primary key constraint */
  RoomStatsPkey = 'RoomStats_pkey'
}

/** input type for incrementing integer column in table "analytics.RoomStats" */
export type Analytics_RoomStats_Inc_Input = {
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.RoomStats" */
export type Analytics_RoomStats_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Analytics_RoomStats_Max_Fields = {
  readonly __typename?: 'analytics_RoomStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_RoomStats_Min_Fields = {
  readonly __typename?: 'analytics_RoomStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.RoomStats" */
export type Analytics_RoomStats_Mutation_Response = {
  readonly __typename?: 'analytics_RoomStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_RoomStats>;
};

/** input type for inserting object relation for remote table "analytics.RoomStats" */
export type Analytics_RoomStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_RoomStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.RoomStats" */
export type Analytics_RoomStats_On_Conflict = {
  readonly constraint: Analytics_RoomStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_RoomStats_Update_Column>;
  readonly where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.RoomStats" */
export type Analytics_RoomStats_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.RoomStats" */
export type Analytics_RoomStats_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "analytics.RoomStats" */
export enum Analytics_RoomStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HlsViewCount = 'hlsViewCount',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "analytics.RoomStats" */
export type Analytics_RoomStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Analytics_RoomStats_Stddev_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_RoomStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_pop_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Pop_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_RoomStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_samp_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Samp_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_RoomStats_Sum_Fields = {
  readonly __typename?: 'analytics_RoomStats_sum_fields';
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Sum_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.RoomStats" */
export enum Analytics_RoomStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HlsViewCount = 'hlsViewCount',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Analytics_RoomStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_RoomStats_var_pop_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Var_Pop_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_RoomStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_RoomStats_var_samp_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Var_Samp_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_RoomStats_Variance_Fields = {
  readonly __typename?: 'analytics_RoomStats_variance_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Variance_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};


/** expression to compare columns of type bigint. All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['bigint']>;
  readonly _gt?: Maybe<Scalars['bigint']>;
  readonly _gte?: Maybe<Scalars['bigint']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['bigint']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['bigint']>;
  readonly _lte?: Maybe<Scalars['bigint']>;
  readonly _neq?: Maybe<Scalars['bigint']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['bigint']>>;
};

/** columns and relationships of "chat.Chat" */
export type Chat_Chat = {
  readonly __typename?: 'chat_Chat';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly duplicateTo?: Maybe<Chat_Chat>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly duplicatesFrom: ReadonlyArray<Chat_Chat>;
  /** An aggregated array relationship */
  readonly duplicatesFrom_aggregate: Chat_Chat_Aggregate;
  readonly enableAutoPin: Scalars['Boolean'];
  readonly enableAutoSubscribe: Scalars['Boolean'];
  readonly enableMandatoryPin: Scalars['Boolean'];
  readonly enableMandatorySubscribe: Scalars['Boolean'];
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregated array relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_Item>;
  /** An aggregated array relationship */
  readonly items_aggregate: Content_Item_Aggregate;
  /** An array relationship */
  readonly messages: ReadonlyArray<Chat_Message>;
  /** An aggregated array relationship */
  readonly messages_aggregate: Chat_Message_Aggregate;
  /** An array relationship */
  readonly pins: ReadonlyArray<Chat_Pin>;
  /** An aggregated array relationship */
  readonly pins_aggregate: Chat_Pin_Aggregate;
  /** An array relationship */
  readonly readUpToIndices: ReadonlyArray<Chat_ReadUpToIndex>;
  /** An aggregated array relationship */
  readonly readUpToIndices_aggregate: Chat_ReadUpToIndex_Aggregate;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins: Scalars['Boolean'];
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  /** An array relationship */
  readonly subscriptions: ReadonlyArray<Chat_Subscription>;
  /** An aggregated array relationship */
  readonly subscriptions_aggregate: Chat_Subscription_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFromArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFrom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessagesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessages_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPinsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPins_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndicesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndices_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};

/** aggregated selection of "chat.Chat" */
export type Chat_Chat_Aggregate = {
  readonly __typename?: 'chat_Chat_aggregate';
  readonly aggregate?: Maybe<Chat_Chat_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Chat>;
};

/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_Fields = {
  readonly __typename?: 'chat_Chat_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Chat_Max_Fields>;
  readonly min?: Maybe<Chat_Chat_Min_Fields>;
};


/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Chat" */
export type Chat_Chat_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Chat_Max_Order_By>;
  readonly min?: Maybe<Chat_Chat_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Chat" */
export type Chat_Chat_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Chat_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Chat". All fields are combined with a logical 'AND'. */
export type Chat_Chat_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Chat_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Chat_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Chat_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly duplicateTo?: Maybe<Chat_Chat_Bool_Exp>;
  readonly duplicateToId?: Maybe<Uuid_Comparison_Exp>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Bool_Exp>;
  readonly enableAutoPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableAutoSubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatoryPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatorySubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly items?: Maybe<Content_Item_Bool_Exp>;
  readonly messages?: Maybe<Chat_Message_Bool_Exp>;
  readonly pins?: Maybe<Chat_Pin_Bool_Exp>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly remoteServiceId?: Maybe<String_Comparison_Exp>;
  readonly restrictToAdmins?: Maybe<Boolean_Comparison_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly subscriptions?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Chat" */
export enum Chat_Chat_Constraint {
  /** unique or primary key constraint */
  ChatPkey = 'Chat_pkey'
}

/** input type for inserting data into table "chat.Chat" */
export type Chat_Chat_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateTo?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly items?: Maybe<Content_Item_Arr_Rel_Insert_Input>;
  readonly messages?: Maybe<Chat_Message_Arr_Rel_Insert_Input>;
  readonly pins?: Maybe<Chat_Pin_Arr_Rel_Insert_Input>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Arr_Rel_Insert_Input>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly subscriptions?: Maybe<Chat_Subscription_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Chat_Max_Fields = {
  readonly __typename?: 'chat_Chat_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Chat" */
export type Chat_Chat_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Chat_Min_Fields = {
  readonly __typename?: 'chat_Chat_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Chat" */
export type Chat_Chat_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Chat" */
export type Chat_Chat_Mutation_Response = {
  readonly __typename?: 'chat_Chat_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Chat>;
};

/** input type for inserting object relation for remote table "chat.Chat" */
export type Chat_Chat_Obj_Rel_Insert_Input = {
  readonly data: Chat_Chat_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** on conflict condition type for table "chat.Chat" */
export type Chat_Chat_On_Conflict = {
  readonly constraint: Chat_Chat_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Chat_Update_Column>;
  readonly where?: Maybe<Chat_Chat_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Chat" */
export type Chat_Chat_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateTo?: Maybe<Chat_Chat_Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly duplicatesFrom_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly enableAutoPin?: Maybe<Order_By>;
  readonly enableAutoSubscribe?: Maybe<Order_By>;
  readonly enableMandatoryPin?: Maybe<Order_By>;
  readonly enableMandatorySubscribe?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_Item_Aggregate_Order_By>;
  readonly messages_aggregate?: Maybe<Chat_Message_Aggregate_Order_By>;
  readonly pins_aggregate?: Maybe<Chat_Pin_Aggregate_Order_By>;
  readonly readUpToIndices_aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly restrictToAdmins?: Maybe<Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly subscriptions_aggregate?: Maybe<Chat_Subscription_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Chat" */
export type Chat_Chat_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "chat.Chat" */
export enum Chat_Chat_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RemoteServiceId = 'remoteServiceId',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Chat" */
export type Chat_Chat_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Chat" */
export enum Chat_Chat_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RemoteServiceId = 'remoteServiceId',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "chat.Flag" */
export type Chat_Flag = {
  readonly __typename?: 'chat_Flag';
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly discussionChat?: Maybe<Chat_Chat>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly flaggedBy?: Maybe<Registrant_Registrant>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['Int'];
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageSId: Scalars['uuid'];
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type: Chat_FlagType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "chat.FlagType" */
export type Chat_FlagType = {
  readonly __typename?: 'chat_FlagType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.FlagType" */
export type Chat_FlagType_Aggregate = {
  readonly __typename?: 'chat_FlagType_aggregate';
  readonly aggregate?: Maybe<Chat_FlagType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_FlagType>;
};

/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_Fields = {
  readonly __typename?: 'chat_FlagType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_FlagType_Max_Fields>;
  readonly min?: Maybe<Chat_FlagType_Min_Fields>;
};


/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.FlagType" */
export type Chat_FlagType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_FlagType_Max_Order_By>;
  readonly min?: Maybe<Chat_FlagType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.FlagType" */
export type Chat_FlagType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_FlagType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.FlagType". All fields are combined with a logical 'AND'. */
export type Chat_FlagType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_FlagType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_FlagType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_FlagType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.FlagType" */
export enum Chat_FlagType_Constraint {
  /** unique or primary key constraint */
  FlagTypePkey = 'FlagType_pkey'
}

export enum Chat_FlagType_Enum {
  /** It's abusive or harmful. */
  Abusive = 'Abusive',
  /** It contains false information and is intended to mislead readers. */
  Disinformation = 'Disinformation',
  /** It gives the wrong idea or impression. */
  Misleading = 'Misleading',
  /** It expresses intentions of self-harm or suicide. */
  RiskToLife = 'Risk_To_Life',
  /** It's spam, suspicious or annoying. */
  Spam = 'Spam'
}

/** expression to compare columns of type chat_FlagType_enum. All fields are combined with logical 'AND'. */
export type Chat_FlagType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_FlagType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_FlagType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
};

/** input type for inserting data into table "chat.FlagType" */
export type Chat_FlagType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_FlagType_Max_Fields = {
  readonly __typename?: 'chat_FlagType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.FlagType" */
export type Chat_FlagType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_FlagType_Min_Fields = {
  readonly __typename?: 'chat_FlagType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.FlagType" */
export type Chat_FlagType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.FlagType" */
export type Chat_FlagType_Mutation_Response = {
  readonly __typename?: 'chat_FlagType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_FlagType>;
};

/** input type for inserting object relation for remote table "chat.FlagType" */
export type Chat_FlagType_Obj_Rel_Insert_Input = {
  readonly data: Chat_FlagType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};

/** on conflict condition type for table "chat.FlagType" */
export type Chat_FlagType_On_Conflict = {
  readonly constraint: Chat_FlagType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_FlagType_Update_Column>;
  readonly where?: Maybe<Chat_FlagType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.FlagType" */
export type Chat_FlagType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.FlagType" */
export type Chat_FlagType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.FlagType" */
export enum Chat_FlagType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.FlagType" */
export type Chat_FlagType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.FlagType" */
export enum Chat_FlagType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Flag" */
export type Chat_Flag_Aggregate = {
  readonly __typename?: 'chat_Flag_aggregate';
  readonly aggregate?: Maybe<Chat_Flag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Flag>;
};

/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_Fields = {
  readonly __typename?: 'chat_Flag_aggregate_fields';
  readonly avg?: Maybe<Chat_Flag_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Flag_Max_Fields>;
  readonly min?: Maybe<Chat_Flag_Min_Fields>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Flag_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Flag_Variance_Fields>;
};


/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Flag" */
export type Chat_Flag_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Flag_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Flag_Max_Order_By>;
  readonly min?: Maybe<Chat_Flag_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Flag_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Flag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Flag" */
export type Chat_Flag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Flag_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Flag_Avg_Fields = {
  readonly __typename?: 'chat_Flag_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Flag" */
export type Chat_Flag_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Flag". All fields are combined with a logical 'AND'. */
export type Chat_Flag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Flag_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Flag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Flag_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly discussionChat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly discussionChatId?: Maybe<Uuid_Comparison_Exp>;
  readonly flaggedBy?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly flaggedById?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly notes?: Maybe<String_Comparison_Exp>;
  readonly resolution?: Maybe<String_Comparison_Exp>;
  readonly resolved_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly type?: Maybe<Chat_FlagType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Flag" */
export enum Chat_Flag_Constraint {
  /** unique or primary key constraint */
  FlagMessageSIdFlaggedByIdTypeKey = 'Flag_messageSId_flaggedById_type_key',
  /** unique or primary key constraint */
  FlagPkey = 'Flag_pkey'
}

/** input type for incrementing integer column in table "chat.Flag" */
export type Chat_Flag_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Flag" */
export type Chat_Flag_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedBy?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Flag_Max_Fields = {
  readonly __typename?: 'chat_Flag_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Flag" */
export type Chat_Flag_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Flag_Min_Fields = {
  readonly __typename?: 'chat_Flag_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Flag" */
export type Chat_Flag_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Flag" */
export type Chat_Flag_Mutation_Response = {
  readonly __typename?: 'chat_Flag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Flag>;
};

/** input type for inserting object relation for remote table "chat.Flag" */
export type Chat_Flag_Obj_Rel_Insert_Input = {
  readonly data: Chat_Flag_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};

/** on conflict condition type for table "chat.Flag" */
export type Chat_Flag_On_Conflict = {
  readonly constraint: Chat_Flag_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Flag_Update_Column>;
  readonly where?: Maybe<Chat_Flag_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Flag" */
export type Chat_Flag_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChat?: Maybe<Chat_Chat_Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedBy?: Maybe<Registrant_Registrant_Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Flag" */
export type Chat_Flag_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** select columns of table "chat.Flag" */
export enum Chat_Flag_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Flag" */
export type Chat_Flag_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Flag_Stddev_Fields = {
  readonly __typename?: 'chat_Flag_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Flag_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Flag_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Flag_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Flag_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Flag_Sum_Fields = {
  readonly __typename?: 'chat_Flag_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Flag" */
export type Chat_Flag_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "chat.Flag" */
export enum Chat_Flag_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Flag_Var_Pop_Fields = {
  readonly __typename?: 'chat_Flag_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Flag_Var_Samp_Fields = {
  readonly __typename?: 'chat_Flag_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Flag_Variance_Fields = {
  readonly __typename?: 'chat_Flag_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Flag" */
export type Chat_Flag_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_Message = {
  readonly __typename?: 'chat_Message';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicateIncoming?: Maybe<Chat_Message>;
  /** An object relationship */
  readonly duplicateOutgoing?: Maybe<Chat_Message>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregated array relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['Int'];
  readonly isPinned: Scalars['Boolean'];
  readonly message: Scalars['String'];
  /** An array relationship */
  readonly reactions: ReadonlyArray<Chat_Reaction>;
  /** An aggregated array relationship */
  readonly reactions_aggregate: Chat_Reaction_Aggregate;
  readonly sId: Scalars['uuid'];
  /** An object relationship */
  readonly sender?: Maybe<Registrant_Registrant>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type: Chat_MessageType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageReactionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageReactions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.MessageType" */
export type Chat_MessageType = {
  readonly __typename?: 'chat_MessageType';
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.MessageType" */
export type Chat_MessageType_Aggregate = {
  readonly __typename?: 'chat_MessageType_aggregate';
  readonly aggregate?: Maybe<Chat_MessageType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_MessageType>;
};

/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_Fields = {
  readonly __typename?: 'chat_MessageType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_MessageType_Max_Fields>;
  readonly min?: Maybe<Chat_MessageType_Min_Fields>;
};


/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.MessageType" */
export type Chat_MessageType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_MessageType_Max_Order_By>;
  readonly min?: Maybe<Chat_MessageType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.MessageType" */
export type Chat_MessageType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_MessageType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.MessageType". All fields are combined with a logical 'AND'. */
export type Chat_MessageType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_MessageType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_MessageType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_MessageType_Bool_Exp>>>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.MessageType" */
export enum Chat_MessageType_Constraint {
  /** unique or primary key constraint */
  MessageTypePkey = 'MessageType_pkey'
}

export enum Chat_MessageType_Enum {
  Answer = 'ANSWER',
  DuplicationMarker = 'DUPLICATION_MARKER',
  Emote = 'EMOTE',
  Message = 'MESSAGE',
  Poll = 'POLL',
  PollResults = 'POLL_RESULTS',
  Question = 'QUESTION'
}

/** expression to compare columns of type chat_MessageType_enum. All fields are combined with logical 'AND'. */
export type Chat_MessageType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_MessageType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_MessageType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
};

/** input type for inserting data into table "chat.MessageType" */
export type Chat_MessageType_Insert_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_MessageType_Max_Fields = {
  readonly __typename?: 'chat_MessageType_max_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.MessageType" */
export type Chat_MessageType_Max_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_MessageType_Min_Fields = {
  readonly __typename?: 'chat_MessageType_min_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.MessageType" */
export type Chat_MessageType_Min_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.MessageType" */
export type Chat_MessageType_Mutation_Response = {
  readonly __typename?: 'chat_MessageType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_MessageType>;
};

/** input type for inserting object relation for remote table "chat.MessageType" */
export type Chat_MessageType_Obj_Rel_Insert_Input = {
  readonly data: Chat_MessageType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};

/** on conflict condition type for table "chat.MessageType" */
export type Chat_MessageType_On_Conflict = {
  readonly constraint: Chat_MessageType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_MessageType_Update_Column>;
  readonly where?: Maybe<Chat_MessageType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.MessageType" */
export type Chat_MessageType_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.MessageType" */
export type Chat_MessageType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.MessageType" */
export enum Chat_MessageType_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.MessageType" */
export type Chat_MessageType_Set_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.MessageType" */
export enum Chat_MessageType_Update_Column {
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Message" */
export type Chat_Message_Aggregate = {
  readonly __typename?: 'chat_Message_aggregate';
  readonly aggregate?: Maybe<Chat_Message_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Message>;
};

/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_Fields = {
  readonly __typename?: 'chat_Message_aggregate_fields';
  readonly avg?: Maybe<Chat_Message_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Message_Max_Fields>;
  readonly min?: Maybe<Chat_Message_Min_Fields>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Message_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Message_Variance_Fields>;
};


/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Message" */
export type Chat_Message_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Message_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Message_Max_Order_By>;
  readonly min?: Maybe<Chat_Message_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Message_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Message_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Message" */
export type Chat_Message_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Message_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Message_Avg_Fields = {
  readonly __typename?: 'chat_Message_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Message" */
export type Chat_Message_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Message". All fields are combined with a logical 'AND'. */
export type Chat_Message_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Message_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Message_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Message_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicatedMessageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly isPinned?: Maybe<Boolean_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly reactions?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly sId?: Maybe<Uuid_Comparison_Exp>;
  readonly sender?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly systemId?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_MessageType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Message" */
export enum Chat_Message_Constraint {
  /** unique or primary key constraint */
  MessageDuplicatedMessageSIdKey = 'Message_duplicatedMessageSId_key',
  /** unique or primary key constraint */
  MessagePkey = 'Message_pkey',
  /** unique or primary key constraint */
  MessageSIdChatIdKey = 'Message_sId_chatId_key',
  /** unique or primary key constraint */
  MessageSIdKey = 'Message_sId_key',
  /** unique or primary key constraint */
  MessageSystemIdKey = 'Message_systemId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Message_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Message_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Message_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "chat.Message" */
export type Chat_Message_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Message" */
export type Chat_Message_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly reactions?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly sender?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Message_Max_Fields = {
  readonly __typename?: 'chat_Message_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Message" */
export type Chat_Message_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Message_Min_Fields = {
  readonly __typename?: 'chat_Message_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Message" */
export type Chat_Message_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Message" */
export type Chat_Message_Mutation_Response = {
  readonly __typename?: 'chat_Message_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Message>;
};

/** input type for inserting object relation for remote table "chat.Message" */
export type Chat_Message_Obj_Rel_Insert_Input = {
  readonly data: Chat_Message_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** on conflict condition type for table "chat.Message" */
export type Chat_Message_On_Conflict = {
  readonly constraint: Chat_Message_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Message_Update_Column>;
  readonly where?: Maybe<Chat_Message_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Message" */
export type Chat_Message_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Order_By>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isPinned?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly reactions_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly sender?: Maybe<Registrant_Registrant_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Message" */
export type Chat_Message_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Message" */
export enum Chat_Message_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageSId = 'duplicatedMessageSId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Message" */
export type Chat_Message_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Message_Stddev_Fields = {
  readonly __typename?: 'chat_Message_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Message_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Message_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Message_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Message_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Message_Sum_Fields = {
  readonly __typename?: 'chat_Message_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Message" */
export type Chat_Message_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "chat.Message" */
export enum Chat_Message_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageSId = 'duplicatedMessageSId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Message_Var_Pop_Fields = {
  readonly __typename?: 'chat_Message_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Message" */
export type Chat_Message_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Message_Var_Samp_Fields = {
  readonly __typename?: 'chat_Message_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Message" */
export type Chat_Message_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Message_Variance_Fields = {
  readonly __typename?: 'chat_Message_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Message" */
export type Chat_Message_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/**
 * Pin a chat to the sidebar.
 *
 *
 * columns and relationships of "chat.Pin"
 */
export type Chat_Pin = {
  readonly __typename?: 'chat_Pin';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly wasManuallyPinned: Scalars['Boolean'];
};

/** aggregated selection of "chat.Pin" */
export type Chat_Pin_Aggregate = {
  readonly __typename?: 'chat_Pin_aggregate';
  readonly aggregate?: Maybe<Chat_Pin_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Pin>;
};

/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_Fields = {
  readonly __typename?: 'chat_Pin_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Pin_Max_Fields>;
  readonly min?: Maybe<Chat_Pin_Min_Fields>;
};


/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Pin" */
export type Chat_Pin_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Pin_Max_Order_By>;
  readonly min?: Maybe<Chat_Pin_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Pin" */
export type Chat_Pin_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Pin_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Pin". All fields are combined with a logical 'AND'. */
export type Chat_Pin_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Pin_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Pin_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Pin_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly wasManuallyPinned?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Pin" */
export enum Chat_Pin_Constraint {
  /** unique or primary key constraint */
  ChatPinPkey = 'ChatPin_pkey'
}

/** input type for inserting data into table "chat.Pin" */
export type Chat_Pin_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Pin_Max_Fields = {
  readonly __typename?: 'chat_Pin_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "chat.Pin" */
export type Chat_Pin_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Pin_Min_Fields = {
  readonly __typename?: 'chat_Pin_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "chat.Pin" */
export type Chat_Pin_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Pin" */
export type Chat_Pin_Mutation_Response = {
  readonly __typename?: 'chat_Pin_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Pin>;
};

/** input type for inserting object relation for remote table "chat.Pin" */
export type Chat_Pin_Obj_Rel_Insert_Input = {
  readonly data: Chat_Pin_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};

/** on conflict condition type for table "chat.Pin" */
export type Chat_Pin_On_Conflict = {
  readonly constraint: Chat_Pin_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Pin_Update_Column>;
  readonly where?: Maybe<Chat_Pin_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Pin" */
export type Chat_Pin_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly wasManuallyPinned?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Pin" */
export type Chat_Pin_Pk_Columns_Input = {
  readonly chatId: Scalars['uuid'];
  readonly registrantId: Scalars['uuid'];
};

/** select columns of table "chat.Pin" */
export enum Chat_Pin_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** input type for updating data in table "chat.Pin" */
export type Chat_Pin_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Pin" */
export enum Chat_Pin_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** columns and relationships of "chat.Reaction" */
export type Chat_Reaction = {
  readonly __typename?: 'chat_Reaction';
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicate?: Maybe<Chat_Reaction>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly duplicates: ReadonlyArray<Chat_Reaction>;
  /** An aggregated array relationship */
  readonly duplicates_aggregate: Chat_Reaction_Aggregate;
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageSId: Scalars['uuid'];
  readonly sId: Scalars['uuid'];
  /** An object relationship */
  readonly sender: Registrant_Registrant;
  readonly senderId: Scalars['uuid'];
  readonly symbol: Scalars['String'];
  readonly type: Chat_ReactionType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicatesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicates_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.ReactionType" */
export type Chat_ReactionType = {
  readonly __typename?: 'chat_ReactionType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate = {
  readonly __typename?: 'chat_ReactionType_aggregate';
  readonly aggregate?: Maybe<Chat_ReactionType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReactionType>;
};

/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_Fields = {
  readonly __typename?: 'chat_ReactionType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_ReactionType_Max_Fields>;
  readonly min?: Maybe<Chat_ReactionType_Min_Fields>;
};


/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_ReactionType_Max_Order_By>;
  readonly min?: Maybe<Chat_ReactionType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.ReactionType" */
export type Chat_ReactionType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_ReactionType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.ReactionType". All fields are combined with a logical 'AND'. */
export type Chat_ReactionType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_ReactionType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_ReactionType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_ReactionType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReactionType" */
export enum Chat_ReactionType_Constraint {
  /** unique or primary key constraint */
  ReactionTypePkey = 'ReactionType_pkey'
}

export enum Chat_ReactionType_Enum {
  /** Link to a message that answers the question. */
  Answer = 'ANSWER',
  /** A plain emoji reaction */
  Emoji = 'EMOJI',
  /** A vote in a poll */
  PollChoice = 'POLL_CHOICE',
  /** Stop accepting new responses to the poll */
  PollClosed = 'POLL_CLOSED',
  /** Make the poll results visible */
  PollComplete = 'POLL_COMPLETE'
}

/** expression to compare columns of type chat_ReactionType_enum. All fields are combined with logical 'AND'. */
export type Chat_ReactionType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_ReactionType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_ReactionType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
};

/** input type for inserting data into table "chat.ReactionType" */
export type Chat_ReactionType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_ReactionType_Max_Fields = {
  readonly __typename?: 'chat_ReactionType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.ReactionType" */
export type Chat_ReactionType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_ReactionType_Min_Fields = {
  readonly __typename?: 'chat_ReactionType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.ReactionType" */
export type Chat_ReactionType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.ReactionType" */
export type Chat_ReactionType_Mutation_Response = {
  readonly __typename?: 'chat_ReactionType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_ReactionType>;
};

/** input type for inserting object relation for remote table "chat.ReactionType" */
export type Chat_ReactionType_Obj_Rel_Insert_Input = {
  readonly data: Chat_ReactionType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};

/** on conflict condition type for table "chat.ReactionType" */
export type Chat_ReactionType_On_Conflict = {
  readonly constraint: Chat_ReactionType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_ReactionType_Update_Column>;
  readonly where?: Maybe<Chat_ReactionType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.ReactionType" */
export type Chat_ReactionType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.ReactionType" */
export type Chat_ReactionType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.ReactionType" */
export type Chat_ReactionType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Reaction" */
export type Chat_Reaction_Aggregate = {
  readonly __typename?: 'chat_Reaction_aggregate';
  readonly aggregate?: Maybe<Chat_Reaction_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Reaction>;
};

/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_Fields = {
  readonly __typename?: 'chat_Reaction_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Reaction_Max_Fields>;
  readonly min?: Maybe<Chat_Reaction_Min_Fields>;
};


/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Reaction" */
export type Chat_Reaction_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Reaction_Max_Order_By>;
  readonly min?: Maybe<Chat_Reaction_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Reaction" */
export type Chat_Reaction_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Reaction_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Reaction". All fields are combined with a logical 'AND'. */
export type Chat_Reaction_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Reaction_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Reaction_Bool_Exp>>>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicate?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly duplicateSId?: Maybe<Uuid_Comparison_Exp>;
  readonly duplicates?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly sId?: Maybe<Uuid_Comparison_Exp>;
  readonly sender?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly symbol?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_ReactionType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Reaction" */
export enum Chat_Reaction_Constraint {
  /** unique or primary key constraint */
  ReactionPkey = 'Reaction_pkey',
  /** unique or primary key constraint */
  ReactionSIdKey = 'Reaction_sId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Reaction_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Reaction_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Reaction_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "chat.Reaction" */
export type Chat_Reaction_Insert_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicate?: Maybe<Chat_Reaction_Obj_Rel_Insert_Input>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly duplicates?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly sender?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Reaction_Max_Fields = {
  readonly __typename?: 'chat_Reaction_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Reaction" */
export type Chat_Reaction_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Reaction_Min_Fields = {
  readonly __typename?: 'chat_Reaction_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Reaction" */
export type Chat_Reaction_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Reaction" */
export type Chat_Reaction_Mutation_Response = {
  readonly __typename?: 'chat_Reaction_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Reaction>;
};

/** input type for inserting object relation for remote table "chat.Reaction" */
export type Chat_Reaction_Obj_Rel_Insert_Input = {
  readonly data: Chat_Reaction_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** on conflict condition type for table "chat.Reaction" */
export type Chat_Reaction_On_Conflict = {
  readonly constraint: Chat_Reaction_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Reaction_Update_Column>;
  readonly where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Reaction" */
export type Chat_Reaction_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicate?: Maybe<Chat_Reaction_Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly duplicates_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly sender?: Maybe<Registrant_Registrant_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Reaction" */
export type Chat_Reaction_Pk_Columns_Input = {
  readonly sId: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Reaction" */
export enum Chat_Reaction_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateSId = 'duplicateSId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Reaction" */
export type Chat_Reaction_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Reaction" */
export enum Chat_Reaction_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateSId = 'duplicateSId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex = {
  readonly __typename?: 'chat_ReadUpToIndex';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly messageSId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate';
  readonly aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Fields>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Fields>;
};


/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Order_By>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.ReadUpToIndex". All fields are combined with a logical 'AND'. */
export type Chat_ReadUpToIndex_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_ReadUpToIndex_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_ReadUpToIndex_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Constraint {
  /** unique or primary key constraint */
  ReadUpToIndexPkey = 'ReadUpToIndex_pkey'
}

/** input type for inserting data into table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_ReadUpToIndex_Max_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_ReadUpToIndex_Min_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Mutation_Response = {
  readonly __typename?: 'chat_ReadUpToIndex_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** input type for inserting object relation for remote table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Obj_Rel_Insert_Input = {
  readonly data: Chat_ReadUpToIndex_Insert_Input;
  readonly on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};

/** on conflict condition type for table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_On_Conflict = {
  readonly constraint: Chat_ReadUpToIndex_Constraint;
  readonly update_columns: ReadonlyArray<Chat_ReadUpToIndex_Update_Column>;
  readonly where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};

/** ordering options when selecting data from "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Pk_Columns_Input = {
  readonly chatId: Scalars['uuid'];
  readonly registrantId: Scalars['uuid'];
};

/** select columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/**
 * Subscribe to chat notifications.
 *
 *
 * columns and relationships of "chat.Subscription"
 */
export type Chat_Subscription = {
  readonly __typename?: 'chat_Subscription';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly wasManuallySubscribed: Scalars['Boolean'];
};

/** aggregated selection of "chat.Subscription" */
export type Chat_Subscription_Aggregate = {
  readonly __typename?: 'chat_Subscription_aggregate';
  readonly aggregate?: Maybe<Chat_Subscription_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Subscription>;
};

/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_Fields = {
  readonly __typename?: 'chat_Subscription_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Subscription_Max_Fields>;
  readonly min?: Maybe<Chat_Subscription_Min_Fields>;
};


/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Subscription" */
export type Chat_Subscription_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Subscription_Max_Order_By>;
  readonly min?: Maybe<Chat_Subscription_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Subscription" */
export type Chat_Subscription_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Subscription_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Subscription". All fields are combined with a logical 'AND'. */
export type Chat_Subscription_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Subscription_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Subscription_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly wasManuallySubscribed?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Subscription" */
export enum Chat_Subscription_Constraint {
  /** unique or primary key constraint */
  SubscriptionPkey = 'Subscription_pkey'
}

/** input type for inserting data into table "chat.Subscription" */
export type Chat_Subscription_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Subscription_Max_Fields = {
  readonly __typename?: 'chat_Subscription_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "chat.Subscription" */
export type Chat_Subscription_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Subscription_Min_Fields = {
  readonly __typename?: 'chat_Subscription_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "chat.Subscription" */
export type Chat_Subscription_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Subscription" */
export type Chat_Subscription_Mutation_Response = {
  readonly __typename?: 'chat_Subscription_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Subscription>;
};

/** input type for inserting object relation for remote table "chat.Subscription" */
export type Chat_Subscription_Obj_Rel_Insert_Input = {
  readonly data: Chat_Subscription_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};

/** on conflict condition type for table "chat.Subscription" */
export type Chat_Subscription_On_Conflict = {
  readonly constraint: Chat_Subscription_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Subscription_Update_Column>;
  readonly where?: Maybe<Chat_Subscription_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Subscription" */
export type Chat_Subscription_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly wasManuallySubscribed?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Subscription" */
export type Chat_Subscription_Pk_Columns_Input = {
  readonly chatId: Scalars['uuid'];
  readonly registrantId: Scalars['uuid'];
};

/** select columns of table "chat.Subscription" */
export enum Chat_Subscription_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** input type for updating data in table "chat.Subscription" */
export type Chat_Subscription_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Subscription" */
export enum Chat_Subscription_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** columns and relationships of "collection.Exhibition" */
export type Collection_Exhibition = {
  readonly __typename?: 'collection_Exhibition';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_ItemExhibition>;
  /** An aggregated array relationship */
  readonly items_aggregate: Content_ItemExhibition_Aggregate;
  readonly name: Scalars['String'];
  readonly priority: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "collection.Exhibition" */
export type Collection_ExhibitionItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** columns and relationships of "collection.Exhibition" */
export type Collection_ExhibitionItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};

/** aggregated selection of "collection.Exhibition" */
export type Collection_Exhibition_Aggregate = {
  readonly __typename?: 'collection_Exhibition_aggregate';
  readonly aggregate?: Maybe<Collection_Exhibition_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_Exhibition>;
};

/** aggregate fields of "collection.Exhibition" */
export type Collection_Exhibition_Aggregate_Fields = {
  readonly __typename?: 'collection_Exhibition_aggregate_fields';
  readonly avg?: Maybe<Collection_Exhibition_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Collection_Exhibition_Max_Fields>;
  readonly min?: Maybe<Collection_Exhibition_Min_Fields>;
  readonly stddev?: Maybe<Collection_Exhibition_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Collection_Exhibition_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Collection_Exhibition_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Collection_Exhibition_Sum_Fields>;
  readonly var_pop?: Maybe<Collection_Exhibition_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Collection_Exhibition_Var_Samp_Fields>;
  readonly variance?: Maybe<Collection_Exhibition_Variance_Fields>;
};


/** aggregate fields of "collection.Exhibition" */
export type Collection_Exhibition_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "collection.Exhibition" */
export type Collection_Exhibition_Aggregate_Order_By = {
  readonly avg?: Maybe<Collection_Exhibition_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Collection_Exhibition_Max_Order_By>;
  readonly min?: Maybe<Collection_Exhibition_Min_Order_By>;
  readonly stddev?: Maybe<Collection_Exhibition_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Collection_Exhibition_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Collection_Exhibition_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Collection_Exhibition_Sum_Order_By>;
  readonly var_pop?: Maybe<Collection_Exhibition_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Collection_Exhibition_Var_Samp_Order_By>;
  readonly variance?: Maybe<Collection_Exhibition_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "collection.Exhibition" */
export type Collection_Exhibition_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Collection_Exhibition_Insert_Input>;
  readonly on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};

/** aggregate avg on columns */
export type Collection_Exhibition_Avg_Fields = {
  readonly __typename?: 'collection_Exhibition_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "collection.Exhibition". All fields are combined with a logical 'AND'. */
export type Collection_Exhibition_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Collection_Exhibition_Bool_Exp>>>;
  readonly _not?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Collection_Exhibition_Bool_Exp>>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly items?: Maybe<Content_ItemExhibition_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "collection.Exhibition" */
export enum Collection_Exhibition_Constraint {
  /** unique or primary key constraint */
  ExhibitionNameConferenceIdFkey = 'Exhibition_name_conferenceId_fkey',
  /** unique or primary key constraint */
  ExhibitionPkey = 'Exhibition_pkey'
}

/** input type for incrementing integer column in table "collection.Exhibition" */
export type Collection_Exhibition_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "collection.Exhibition" */
export type Collection_Exhibition_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly items?: Maybe<Content_ItemExhibition_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Collection_Exhibition_Max_Fields = {
  readonly __typename?: 'collection_Exhibition_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Collection_Exhibition_Min_Fields = {
  readonly __typename?: 'collection_Exhibition_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "collection.Exhibition" */
export type Collection_Exhibition_Mutation_Response = {
  readonly __typename?: 'collection_Exhibition_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Collection_Exhibition>;
};

/** input type for inserting object relation for remote table "collection.Exhibition" */
export type Collection_Exhibition_Obj_Rel_Insert_Input = {
  readonly data: Collection_Exhibition_Insert_Input;
  readonly on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};

/** on conflict condition type for table "collection.Exhibition" */
export type Collection_Exhibition_On_Conflict = {
  readonly constraint: Collection_Exhibition_Constraint;
  readonly update_columns: ReadonlyArray<Collection_Exhibition_Update_Column>;
  readonly where?: Maybe<Collection_Exhibition_Bool_Exp>;
};

/** ordering options when selecting data from "collection.Exhibition" */
export type Collection_Exhibition_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_ItemExhibition_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "collection.Exhibition" */
export type Collection_Exhibition_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "collection.Exhibition" */
export enum Collection_Exhibition_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "collection.Exhibition" */
export type Collection_Exhibition_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Collection_Exhibition_Stddev_Fields = {
  readonly __typename?: 'collection_Exhibition_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Collection_Exhibition_Stddev_Pop_Fields = {
  readonly __typename?: 'collection_Exhibition_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Collection_Exhibition_Stddev_Samp_Fields = {
  readonly __typename?: 'collection_Exhibition_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Collection_Exhibition_Sum_Fields = {
  readonly __typename?: 'collection_Exhibition_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "collection.Exhibition" */
export enum Collection_Exhibition_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Collection_Exhibition_Var_Pop_Fields = {
  readonly __typename?: 'collection_Exhibition_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Collection_Exhibition_Var_Samp_Fields = {
  readonly __typename?: 'collection_Exhibition_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Collection_Exhibition_Variance_Fields = {
  readonly __typename?: 'collection_Exhibition_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "collection.Exhibition" */
export type Collection_Exhibition_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPerson = {
  readonly __typename?: 'collection_ProgramPerson';
  readonly affiliation?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<Schedule_EventProgramPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: Schedule_EventProgramPerson_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly itemPeople: ReadonlyArray<Content_ItemProgramPerson>;
  /** An aggregated array relationship */
  readonly itemPeople_aggregate: Content_ItemProgramPerson_Aggregate;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** columns and relationships of "collection.ProgramPerson" */
export type Collection_ProgramPersonItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};

/** aggregated selection of "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate = {
  readonly __typename?: 'collection_ProgramPerson_aggregate';
  readonly aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_ProgramPerson>;
};

/** aggregate fields of "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate_Fields = {
  readonly __typename?: 'collection_ProgramPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Collection_ProgramPerson_Max_Fields>;
  readonly min?: Maybe<Collection_ProgramPerson_Min_Fields>;
};


/** aggregate fields of "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Collection_ProgramPerson_Max_Order_By>;
  readonly min?: Maybe<Collection_ProgramPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Collection_ProgramPerson_Insert_Input>;
  readonly on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "collection.ProgramPerson". All fields are combined with a logical 'AND'. */
export type Collection_ProgramPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Collection_ProgramPerson_Bool_Exp>>>;
  readonly _not?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Collection_ProgramPerson_Bool_Exp>>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "collection.ProgramPerson" */
export enum Collection_ProgramPerson_Constraint {
  /** unique or primary key constraint */
  ProgramPersonConferenceIdNameAffiliationKey = 'ProgramPerson_conferenceId_name_affiliation_key',
  /** unique or primary key constraint */
  ProgramPersonPkey = 'ProgramPerson_pkey'
}

/** input type for inserting data into table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Collection_ProgramPerson_Max_Fields = {
  readonly __typename?: 'collection_ProgramPerson_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Max_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Collection_ProgramPerson_Min_Fields = {
  readonly __typename?: 'collection_ProgramPerson_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Min_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** response of any mutation on the table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Mutation_Response = {
  readonly __typename?: 'collection_ProgramPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Collection_ProgramPerson>;
};

/** input type for inserting object relation for remote table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Obj_Rel_Insert_Input = {
  readonly data: Collection_ProgramPerson_Insert_Input;
  readonly on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};

/** on conflict condition type for table "collection.ProgramPerson" */
export type Collection_ProgramPerson_On_Conflict = {
  readonly constraint: Collection_ProgramPerson_Constraint;
  readonly update_columns: ReadonlyArray<Collection_ProgramPerson_Update_Column>;
  readonly where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};

/** ordering options when selecting data from "collection.ProgramPerson" */
export type Collection_ProgramPerson_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemPeople_aggregate?: Maybe<Content_ItemProgramPerson_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** primary key columns input for table: "collection.ProgramPerson" */
export type Collection_ProgramPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "collection.ProgramPerson" */
export enum Collection_ProgramPerson_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RegistrantId = 'registrantId'
}

/** input type for updating data in table "collection.ProgramPerson" */
export type Collection_ProgramPerson_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "collection.ProgramPerson" */
export enum Collection_ProgramPerson_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RegistrantId = 'registrantId'
}

/** columns and relationships of "collection.Tag" */
export type Collection_Tag = {
  readonly __typename?: 'collection_Tag';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly eventTags: ReadonlyArray<Schedule_EventTag>;
  /** An aggregated array relationship */
  readonly eventTags_aggregate: Schedule_EventTag_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly itemTags: ReadonlyArray<Content_ItemTag>;
  /** An aggregated array relationship */
  readonly itemTags_aggregate: Content_ItemTag_Aggregate;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority: Scalars['Int'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagItemTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** columns and relationships of "collection.Tag" */
export type Collection_TagItemTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};

/** aggregated selection of "collection.Tag" */
export type Collection_Tag_Aggregate = {
  readonly __typename?: 'collection_Tag_aggregate';
  readonly aggregate?: Maybe<Collection_Tag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Collection_Tag>;
};

/** aggregate fields of "collection.Tag" */
export type Collection_Tag_Aggregate_Fields = {
  readonly __typename?: 'collection_Tag_aggregate_fields';
  readonly avg?: Maybe<Collection_Tag_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Collection_Tag_Max_Fields>;
  readonly min?: Maybe<Collection_Tag_Min_Fields>;
  readonly stddev?: Maybe<Collection_Tag_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Collection_Tag_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Collection_Tag_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Collection_Tag_Sum_Fields>;
  readonly var_pop?: Maybe<Collection_Tag_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Collection_Tag_Var_Samp_Fields>;
  readonly variance?: Maybe<Collection_Tag_Variance_Fields>;
};


/** aggregate fields of "collection.Tag" */
export type Collection_Tag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "collection.Tag" */
export type Collection_Tag_Aggregate_Order_By = {
  readonly avg?: Maybe<Collection_Tag_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Collection_Tag_Max_Order_By>;
  readonly min?: Maybe<Collection_Tag_Min_Order_By>;
  readonly stddev?: Maybe<Collection_Tag_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Collection_Tag_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Collection_Tag_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Collection_Tag_Sum_Order_By>;
  readonly var_pop?: Maybe<Collection_Tag_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Collection_Tag_Var_Samp_Order_By>;
  readonly variance?: Maybe<Collection_Tag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "collection.Tag" */
export type Collection_Tag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Collection_Tag_Insert_Input>;
  readonly on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};

/** aggregate avg on columns */
export type Collection_Tag_Avg_Fields = {
  readonly __typename?: 'collection_Tag_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "collection.Tag" */
export type Collection_Tag_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "collection.Tag". All fields are combined with a logical 'AND'. */
export type Collection_Tag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Collection_Tag_Bool_Exp>>>;
  readonly _not?: Maybe<Collection_Tag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Collection_Tag_Bool_Exp>>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventTags?: Maybe<Schedule_EventTag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemTags?: Maybe<Content_ItemTag_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "collection.Tag" */
export enum Collection_Tag_Constraint {
  /** unique or primary key constraint */
  TagPkey = 'Tag_pkey'
}

/** input type for incrementing integer column in table "collection.Tag" */
export type Collection_Tag_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "collection.Tag" */
export type Collection_Tag_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventTags?: Maybe<Schedule_EventTag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTags?: Maybe<Content_ItemTag_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Collection_Tag_Max_Fields = {
  readonly __typename?: 'collection_Tag_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "collection.Tag" */
export type Collection_Tag_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Collection_Tag_Min_Fields = {
  readonly __typename?: 'collection_Tag_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "collection.Tag" */
export type Collection_Tag_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "collection.Tag" */
export type Collection_Tag_Mutation_Response = {
  readonly __typename?: 'collection_Tag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Collection_Tag>;
};

/** input type for inserting object relation for remote table "collection.Tag" */
export type Collection_Tag_Obj_Rel_Insert_Input = {
  readonly data: Collection_Tag_Insert_Input;
  readonly on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};

/** on conflict condition type for table "collection.Tag" */
export type Collection_Tag_On_Conflict = {
  readonly constraint: Collection_Tag_Constraint;
  readonly update_columns: ReadonlyArray<Collection_Tag_Update_Column>;
  readonly where?: Maybe<Collection_Tag_Bool_Exp>;
};

/** ordering options when selecting data from "collection.Tag" */
export type Collection_Tag_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventTags_aggregate?: Maybe<Schedule_EventTag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemTags_aggregate?: Maybe<Content_ItemTag_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "collection.Tag" */
export type Collection_Tag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "collection.Tag" */
export enum Collection_Tag_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "collection.Tag" */
export type Collection_Tag_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Collection_Tag_Stddev_Fields = {
  readonly __typename?: 'collection_Tag_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "collection.Tag" */
export type Collection_Tag_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Collection_Tag_Stddev_Pop_Fields = {
  readonly __typename?: 'collection_Tag_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "collection.Tag" */
export type Collection_Tag_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Collection_Tag_Stddev_Samp_Fields = {
  readonly __typename?: 'collection_Tag_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "collection.Tag" */
export type Collection_Tag_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Collection_Tag_Sum_Fields = {
  readonly __typename?: 'collection_Tag_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "collection.Tag" */
export type Collection_Tag_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "collection.Tag" */
export enum Collection_Tag_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Collection_Tag_Var_Pop_Fields = {
  readonly __typename?: 'collection_Tag_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "collection.Tag" */
export type Collection_Tag_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Collection_Tag_Var_Samp_Fields = {
  readonly __typename?: 'collection_Tag_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "collection.Tag" */
export type Collection_Tag_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Collection_Tag_Variance_Fields = {
  readonly __typename?: 'collection_Tag_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "collection.Tag" */
export type Collection_Tag_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "conference.Conference" */
export type Conference_Conference = {
  readonly __typename?: 'conference_Conference';
  /** An array relationship */
  readonly chats: ReadonlyArray<Chat_Chat>;
  /** An aggregated array relationship */
  readonly chats_aggregate: Chat_Chat_Aggregate;
  /** An array relationship */
  readonly configurations: ReadonlyArray<Conference_Configuration>;
  /** An aggregated array relationship */
  readonly configurations_aggregate: Conference_Configuration_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly createdBy: Scalars['String'];
  /** An object relationship */
  readonly creator: User;
  /** An object relationship */
  readonly demoCode: Conference_DemoCode;
  readonly demoCodeId: Scalars['uuid'];
  /** An array relationship */
  readonly exhibitions: ReadonlyArray<Collection_Exhibition>;
  /** An aggregated array relationship */
  readonly exhibitions_aggregate: Collection_Exhibition_Aggregate;
  /** An array relationship */
  readonly groups: ReadonlyArray<Permissions_Group>;
  /** An aggregated array relationship */
  readonly groups_aggregate: Permissions_Group_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_Item>;
  /** An aggregated array relationship */
  readonly items_aggregate: Content_Item_Aggregate;
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly originatingDatas: ReadonlyArray<Conference_OriginatingData>;
  /** An aggregated array relationship */
  readonly originatingDatas_aggregate: Conference_OriginatingData_Aggregate;
  /** An array relationship */
  readonly programPeople: ReadonlyArray<Collection_ProgramPerson>;
  /** An aggregated array relationship */
  readonly programPeople_aggregate: Collection_ProgramPerson_Aggregate;
  /** An array relationship */
  readonly publicPermissions: ReadonlyArray<FlatUnauthPermission>;
  /** An aggregated array relationship */
  readonly publicPermissions_aggregate: FlatUnauthPermission_Aggregate;
  /** An array relationship */
  readonly registrants: ReadonlyArray<Registrant_Registrant>;
  /** An aggregated array relationship */
  readonly registrants_aggregate: Registrant_Registrant_Aggregate;
  /** An array relationship */
  readonly roles: ReadonlyArray<Permissions_Role>;
  /** An aggregated array relationship */
  readonly roles_aggregate: Permissions_Role_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  readonly shortName: Scalars['String'];
  /** An array relationship */
  readonly shufflePeriods: ReadonlyArray<Room_ShufflePeriod>;
  /** An aggregated array relationship */
  readonly shufflePeriods_aggregate: Room_ShufflePeriod_Aggregate;
  readonly slug: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Collection_Tag>;
  /** An aggregated array relationship */
  readonly tags_aggregate: Collection_Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly userPermissions: ReadonlyArray<FlatUserPermission>;
  /** An aggregated array relationship */
  readonly userPermissions_aggregate: FlatUserPermission_Aggregate;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceChatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceChats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceConfigurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceConfigurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceExhibitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceExhibitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceOriginatingDatasArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceOriginatingDatas_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceProgramPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceProgramPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferencePublicPermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferencePublicPermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceShufflePeriodsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceShufflePeriods_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceUserPermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** columns and relationships of "conference.Conference" */
export type Conference_ConferenceUserPermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};

/** aggregated selection of "conference.Conference" */
export type Conference_Conference_Aggregate = {
  readonly __typename?: 'conference_Conference_aggregate';
  readonly aggregate?: Maybe<Conference_Conference_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_Conference>;
};

/** aggregate fields of "conference.Conference" */
export type Conference_Conference_Aggregate_Fields = {
  readonly __typename?: 'conference_Conference_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Conference_Conference_Max_Fields>;
  readonly min?: Maybe<Conference_Conference_Min_Fields>;
};


/** aggregate fields of "conference.Conference" */
export type Conference_Conference_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.Conference" */
export type Conference_Conference_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_Conference_Max_Order_By>;
  readonly min?: Maybe<Conference_Conference_Min_Order_By>;
};

/** input type for inserting array relation for remote table "conference.Conference" */
export type Conference_Conference_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_Conference_Insert_Input>;
  readonly on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.Conference". All fields are combined with a logical 'AND'. */
export type Conference_Conference_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Conference_Conference_Bool_Exp>>>;
  readonly _not?: Maybe<Conference_Conference_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Conference_Conference_Bool_Exp>>>;
  readonly chats?: Maybe<Chat_Chat_Bool_Exp>;
  readonly configurations?: Maybe<Conference_Configuration_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly createdBy?: Maybe<String_Comparison_Exp>;
  readonly creator?: Maybe<User_Bool_Exp>;
  readonly demoCode?: Maybe<Conference_DemoCode_Bool_Exp>;
  readonly demoCodeId?: Maybe<Uuid_Comparison_Exp>;
  readonly exhibitions?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly groups?: Maybe<Permissions_Group_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly items?: Maybe<Content_Item_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingDatas?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly publicPermissions?: Maybe<FlatUnauthPermission_Bool_Exp>;
  readonly registrants?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly roles?: Maybe<Permissions_Role_Bool_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly shortName?: Maybe<String_Comparison_Exp>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Collection_Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly userPermissions?: Maybe<FlatUserPermission_Bool_Exp>;
};

/** unique or primary key constraints on table "conference.Conference" */
export enum Conference_Conference_Constraint {
  /** unique or primary key constraint */
  ConferenceDemoCodeIdKey = 'Conference_demoCodeId_key',
  /** unique or primary key constraint */
  ConferenceNameKey = 'Conference_name_key',
  /** unique or primary key constraint */
  ConferencePkey = 'Conference_pkey',
  /** unique or primary key constraint */
  ConferenceShortNameKey = 'Conference_shortName_key',
  /** unique or primary key constraint */
  ConferenceSlugKey = 'Conference_slug_key'
}

/** input type for inserting data into table "conference.Conference" */
export type Conference_Conference_Insert_Input = {
  readonly chats?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly configurations?: Maybe<Conference_Configuration_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly creator?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly demoCode?: Maybe<Conference_DemoCode_Obj_Rel_Insert_Input>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly exhibitions?: Maybe<Collection_Exhibition_Arr_Rel_Insert_Input>;
  readonly groups?: Maybe<Permissions_Group_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly items?: Maybe<Content_Item_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDatas?: Maybe<Conference_OriginatingData_Arr_Rel_Insert_Input>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Arr_Rel_Insert_Input>;
  readonly registrants?: Maybe<Registrant_Registrant_Arr_Rel_Insert_Input>;
  readonly roles?: Maybe<Permissions_Role_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Arr_Rel_Insert_Input>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Collection_Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Conference_Conference_Max_Fields = {
  readonly __typename?: 'conference_Conference_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "conference.Conference" */
export type Conference_Conference_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_Conference_Min_Fields = {
  readonly __typename?: 'conference_Conference_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "conference.Conference" */
export type Conference_Conference_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.Conference" */
export type Conference_Conference_Mutation_Response = {
  readonly __typename?: 'conference_Conference_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Conference_Conference>;
};

/** input type for inserting object relation for remote table "conference.Conference" */
export type Conference_Conference_Obj_Rel_Insert_Input = {
  readonly data: Conference_Conference_Insert_Input;
  readonly on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};

/** on conflict condition type for table "conference.Conference" */
export type Conference_Conference_On_Conflict = {
  readonly constraint: Conference_Conference_Constraint;
  readonly update_columns: ReadonlyArray<Conference_Conference_Update_Column>;
  readonly where?: Maybe<Conference_Conference_Bool_Exp>;
};

/** ordering options when selecting data from "conference.Conference" */
export type Conference_Conference_Order_By = {
  readonly chats_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly configurations_aggregate?: Maybe<Conference_Configuration_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly creator?: Maybe<User_Order_By>;
  readonly demoCode?: Maybe<Conference_DemoCode_Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly exhibitions_aggregate?: Maybe<Collection_Exhibition_Aggregate_Order_By>;
  readonly groups_aggregate?: Maybe<Permissions_Group_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_Item_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDatas_aggregate?: Maybe<Conference_OriginatingData_Aggregate_Order_By>;
  readonly programPeople_aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Order_By>;
  readonly publicPermissions_aggregate?: Maybe<FlatUnauthPermission_Aggregate_Order_By>;
  readonly registrants_aggregate?: Maybe<Registrant_Registrant_Aggregate_Order_By>;
  readonly roles_aggregate?: Maybe<Permissions_Role_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly shufflePeriods_aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Collection_Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userPermissions_aggregate?: Maybe<FlatUserPermission_Aggregate_Order_By>;
};

/** primary key columns input for table: "conference.Conference" */
export type Conference_Conference_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "conference.Conference" */
export enum Conference_Conference_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "conference.Conference" */
export type Conference_Conference_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "conference.Conference" */
export enum Conference_Conference_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "conference.Configuration" */
export type Conference_Configuration = {
  readonly __typename?: 'conference_Configuration';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly key: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly value: Scalars['jsonb'];
};


/** columns and relationships of "conference.Configuration" */
export type Conference_ConfigurationValueArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "conference.Configuration" */
export type Conference_Configuration_Aggregate = {
  readonly __typename?: 'conference_Configuration_aggregate';
  readonly aggregate?: Maybe<Conference_Configuration_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_Configuration>;
};

/** aggregate fields of "conference.Configuration" */
export type Conference_Configuration_Aggregate_Fields = {
  readonly __typename?: 'conference_Configuration_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Conference_Configuration_Max_Fields>;
  readonly min?: Maybe<Conference_Configuration_Min_Fields>;
};


/** aggregate fields of "conference.Configuration" */
export type Conference_Configuration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.Configuration" */
export type Conference_Configuration_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_Configuration_Max_Order_By>;
  readonly min?: Maybe<Conference_Configuration_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conference_Configuration_Append_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "conference.Configuration" */
export type Conference_Configuration_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_Configuration_Insert_Input>;
  readonly on_conflict?: Maybe<Conference_Configuration_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.Configuration". All fields are combined with a logical 'AND'. */
export type Conference_Configuration_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Conference_Configuration_Bool_Exp>>>;
  readonly _not?: Maybe<Conference_Configuration_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Conference_Configuration_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly key?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly value?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "conference.Configuration" */
export enum Conference_Configuration_Constraint {
  /** unique or primary key constraint */
  ConfigurationConferenceIdKeyKey = 'Configuration_conferenceId_key_key',
  /** unique or primary key constraint */
  ConfigurationPkey = 'Configuration_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conference_Configuration_Delete_At_Path_Input = {
  readonly value?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conference_Configuration_Delete_Elem_Input = {
  readonly value?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conference_Configuration_Delete_Key_Input = {
  readonly value?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "conference.Configuration" */
export type Conference_Configuration_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Conference_Configuration_Max_Fields = {
  readonly __typename?: 'conference_Configuration_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "conference.Configuration" */
export type Conference_Configuration_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_Configuration_Min_Fields = {
  readonly __typename?: 'conference_Configuration_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "conference.Configuration" */
export type Conference_Configuration_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.Configuration" */
export type Conference_Configuration_Mutation_Response = {
  readonly __typename?: 'conference_Configuration_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Conference_Configuration>;
};

/** input type for inserting object relation for remote table "conference.Configuration" */
export type Conference_Configuration_Obj_Rel_Insert_Input = {
  readonly data: Conference_Configuration_Insert_Input;
  readonly on_conflict?: Maybe<Conference_Configuration_On_Conflict>;
};

/** on conflict condition type for table "conference.Configuration" */
export type Conference_Configuration_On_Conflict = {
  readonly constraint: Conference_Configuration_Constraint;
  readonly update_columns: ReadonlyArray<Conference_Configuration_Update_Column>;
  readonly where?: Maybe<Conference_Configuration_Bool_Exp>;
};

/** ordering options when selecting data from "conference.Configuration" */
export type Conference_Configuration_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly value?: Maybe<Order_By>;
};

/** primary key columns input for table: "conference.Configuration" */
export type Conference_Configuration_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conference_Configuration_Prepend_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "conference.Configuration" */
export enum Conference_Configuration_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "conference.Configuration" */
export type Conference_Configuration_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "conference.Configuration" */
export enum Conference_Configuration_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** columns and relationships of "conference.DemoCode" */
export type Conference_DemoCode = {
  readonly __typename?: 'conference_DemoCode';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly usedBy?: Maybe<User>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregated selection of "conference.DemoCode" */
export type Conference_DemoCode_Aggregate = {
  readonly __typename?: 'conference_DemoCode_aggregate';
  readonly aggregate?: Maybe<Conference_DemoCode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_DemoCode>;
};

/** aggregate fields of "conference.DemoCode" */
export type Conference_DemoCode_Aggregate_Fields = {
  readonly __typename?: 'conference_DemoCode_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Conference_DemoCode_Max_Fields>;
  readonly min?: Maybe<Conference_DemoCode_Min_Fields>;
};


/** aggregate fields of "conference.DemoCode" */
export type Conference_DemoCode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.DemoCode" */
export type Conference_DemoCode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_DemoCode_Max_Order_By>;
  readonly min?: Maybe<Conference_DemoCode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "conference.DemoCode" */
export type Conference_DemoCode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_DemoCode_Insert_Input>;
  readonly on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.DemoCode". All fields are combined with a logical 'AND'. */
export type Conference_DemoCode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Conference_DemoCode_Bool_Exp>>>;
  readonly _not?: Maybe<Conference_DemoCode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Conference_DemoCode_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly note?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly usedBy?: Maybe<User_Bool_Exp>;
  readonly usedById?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "conference.DemoCode" */
export enum Conference_DemoCode_Constraint {
  /** unique or primary key constraint */
  DemoCodePkey = 'DemoCode_pkey'
}

/** input type for inserting data into table "conference.DemoCode" */
export type Conference_DemoCode_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedBy?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Conference_DemoCode_Max_Fields = {
  readonly __typename?: 'conference_DemoCode_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "conference.DemoCode" */
export type Conference_DemoCode_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_DemoCode_Min_Fields = {
  readonly __typename?: 'conference_DemoCode_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "conference.DemoCode" */
export type Conference_DemoCode_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.DemoCode" */
export type Conference_DemoCode_Mutation_Response = {
  readonly __typename?: 'conference_DemoCode_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Conference_DemoCode>;
};

/** input type for inserting object relation for remote table "conference.DemoCode" */
export type Conference_DemoCode_Obj_Rel_Insert_Input = {
  readonly data: Conference_DemoCode_Insert_Input;
  readonly on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};

/** on conflict condition type for table "conference.DemoCode" */
export type Conference_DemoCode_On_Conflict = {
  readonly constraint: Conference_DemoCode_Constraint;
  readonly update_columns: ReadonlyArray<Conference_DemoCode_Update_Column>;
  readonly where?: Maybe<Conference_DemoCode_Bool_Exp>;
};

/** ordering options when selecting data from "conference.DemoCode" */
export type Conference_DemoCode_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedBy?: Maybe<User_Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** primary key columns input for table: "conference.DemoCode" */
export type Conference_DemoCode_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "conference.DemoCode" */
export enum Conference_DemoCode_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** input type for updating data in table "conference.DemoCode" */
export type Conference_DemoCode_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** update columns of table "conference.DemoCode" */
export enum Conference_DemoCode_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingData = {
  readonly __typename?: 'conference_OriginatingData';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  readonly elements: ReadonlyArray<Content_Element>;
  /** An aggregated array relationship */
  readonly elements_aggregate: Content_Element_Aggregate;
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly items: ReadonlyArray<Content_Item>;
  /** An aggregated array relationship */
  readonly items_aggregate: Content_Item_Aggregate;
  /** An array relationship */
  readonly programPeople: ReadonlyArray<Collection_ProgramPerson>;
  /** An aggregated array relationship */
  readonly programPeople_aggregate: Collection_ProgramPerson_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  readonly sourceId: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Collection_Tag>;
  /** An aggregated array relationship */
  readonly tags_aggregate: Collection_Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly uploadableElements: ReadonlyArray<Content_UploadableElement>;
  /** An aggregated array relationship */
  readonly uploadableElements_aggregate: Content_UploadableElement_Aggregate;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataElementsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataElements_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataProgramPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataProgramPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataUploadableElementsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};


/** columns and relationships of "conference.OriginatingData" */
export type Conference_OriginatingDataUploadableElements_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};

/** aggregated selection of "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate = {
  readonly __typename?: 'conference_OriginatingData_aggregate';
  readonly aggregate?: Maybe<Conference_OriginatingData_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_OriginatingData>;
};

/** aggregate fields of "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate_Fields = {
  readonly __typename?: 'conference_OriginatingData_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Conference_OriginatingData_Max_Fields>;
  readonly min?: Maybe<Conference_OriginatingData_Min_Fields>;
};


/** aggregate fields of "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.OriginatingData" */
export type Conference_OriginatingData_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_OriginatingData_Max_Order_By>;
  readonly min?: Maybe<Conference_OriginatingData_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Conference_OriginatingData_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "conference.OriginatingData" */
export type Conference_OriginatingData_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_OriginatingData_Insert_Input>;
  readonly on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.OriginatingData". All fields are combined with a logical 'AND'. */
export type Conference_OriginatingData_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Conference_OriginatingData_Bool_Exp>>>;
  readonly _not?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Conference_OriginatingData_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly elements?: Maybe<Content_Element_Bool_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly items?: Maybe<Content_Item_Bool_Exp>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly sourceId?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Collection_Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadableElements?: Maybe<Content_UploadableElement_Bool_Exp>;
};

/** unique or primary key constraints on table "conference.OriginatingData" */
export enum Conference_OriginatingData_Constraint {
  /** unique or primary key constraint */
  OriginatingDataPkey = 'OriginatingData_pkey',
  /** unique or primary key constraint */
  OriginatingDataSourceIdConferenceIdKey = 'OriginatingData_sourceId_conferenceId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Conference_OriginatingData_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Conference_OriginatingData_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Conference_OriginatingData_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "conference.OriginatingData" */
export type Conference_OriginatingData_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly elements?: Maybe<Content_Element_Arr_Rel_Insert_Input>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly items?: Maybe<Content_Item_Arr_Rel_Insert_Input>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Collection_Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableElements?: Maybe<Content_UploadableElement_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Conference_OriginatingData_Max_Fields = {
  readonly __typename?: 'conference_OriginatingData_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "conference.OriginatingData" */
export type Conference_OriginatingData_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_OriginatingData_Min_Fields = {
  readonly __typename?: 'conference_OriginatingData_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "conference.OriginatingData" */
export type Conference_OriginatingData_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.OriginatingData" */
export type Conference_OriginatingData_Mutation_Response = {
  readonly __typename?: 'conference_OriginatingData_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Conference_OriginatingData>;
};

/** input type for inserting object relation for remote table "conference.OriginatingData" */
export type Conference_OriginatingData_Obj_Rel_Insert_Input = {
  readonly data: Conference_OriginatingData_Insert_Input;
  readonly on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};

/** on conflict condition type for table "conference.OriginatingData" */
export type Conference_OriginatingData_On_Conflict = {
  readonly constraint: Conference_OriginatingData_Constraint;
  readonly update_columns: ReadonlyArray<Conference_OriginatingData_Update_Column>;
  readonly where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};

/** ordering options when selecting data from "conference.OriginatingData" */
export type Conference_OriginatingData_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly elements_aggregate?: Maybe<Content_Element_Aggregate_Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly items_aggregate?: Maybe<Content_Item_Aggregate_Order_By>;
  readonly programPeople_aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Collection_Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableElements_aggregate?: Maybe<Content_UploadableElement_Aggregate_Order_By>;
};

/** primary key columns input for table: "conference.OriginatingData" */
export type Conference_OriginatingData_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Conference_OriginatingData_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "conference.OriginatingData" */
export enum Conference_OriginatingData_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "conference.OriginatingData" */
export type Conference_OriginatingData_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "conference.OriginatingData" */
export enum Conference_OriginatingData_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "conference.PrepareJob" */
export type Conference_PrepareJob = {
  readonly __typename?: 'conference_PrepareJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly videoRenderJobs: ReadonlyArray<Video_VideoRenderJob>;
  /** An aggregated array relationship */
  readonly videoRenderJobs_aggregate: Video_VideoRenderJob_Aggregate;
};


/** columns and relationships of "conference.PrepareJob" */
export type Conference_PrepareJobVideoRenderJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


/** columns and relationships of "conference.PrepareJob" */
export type Conference_PrepareJobVideoRenderJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};

/** aggregated selection of "conference.PrepareJob" */
export type Conference_PrepareJob_Aggregate = {
  readonly __typename?: 'conference_PrepareJob_aggregate';
  readonly aggregate?: Maybe<Conference_PrepareJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference_PrepareJob>;
};

/** aggregate fields of "conference.PrepareJob" */
export type Conference_PrepareJob_Aggregate_Fields = {
  readonly __typename?: 'conference_PrepareJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Conference_PrepareJob_Max_Fields>;
  readonly min?: Maybe<Conference_PrepareJob_Min_Fields>;
};


/** aggregate fields of "conference.PrepareJob" */
export type Conference_PrepareJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "conference.PrepareJob" */
export type Conference_PrepareJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_PrepareJob_Max_Order_By>;
  readonly min?: Maybe<Conference_PrepareJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "conference.PrepareJob" */
export type Conference_PrepareJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_PrepareJob_Insert_Input>;
  readonly on_conflict?: Maybe<Conference_PrepareJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "conference.PrepareJob". All fields are combined with a logical 'AND'. */
export type Conference_PrepareJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Conference_PrepareJob_Bool_Exp>>>;
  readonly _not?: Maybe<Conference_PrepareJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Conference_PrepareJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoRenderJobs?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};

/** unique or primary key constraints on table "conference.PrepareJob" */
export enum Conference_PrepareJob_Constraint {
  /** unique or primary key constraint */
  PrepareJobPkey = 'PrepareJob_pkey'
}

/** input type for inserting data into table "conference.PrepareJob" */
export type Conference_PrepareJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoRenderJobs?: Maybe<Video_VideoRenderJob_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Conference_PrepareJob_Max_Fields = {
  readonly __typename?: 'conference_PrepareJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "conference.PrepareJob" */
export type Conference_PrepareJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_PrepareJob_Min_Fields = {
  readonly __typename?: 'conference_PrepareJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "conference.PrepareJob" */
export type Conference_PrepareJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "conference.PrepareJob" */
export type Conference_PrepareJob_Mutation_Response = {
  readonly __typename?: 'conference_PrepareJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Conference_PrepareJob>;
};

/** input type for inserting object relation for remote table "conference.PrepareJob" */
export type Conference_PrepareJob_Obj_Rel_Insert_Input = {
  readonly data: Conference_PrepareJob_Insert_Input;
  readonly on_conflict?: Maybe<Conference_PrepareJob_On_Conflict>;
};

/** on conflict condition type for table "conference.PrepareJob" */
export type Conference_PrepareJob_On_Conflict = {
  readonly constraint: Conference_PrepareJob_Constraint;
  readonly update_columns: ReadonlyArray<Conference_PrepareJob_Update_Column>;
  readonly where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};

/** ordering options when selecting data from "conference.PrepareJob" */
export type Conference_PrepareJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoRenderJobs_aggregate?: Maybe<Video_VideoRenderJob_Aggregate_Order_By>;
};

/** primary key columns input for table: "conference.PrepareJob" */
export type Conference_PrepareJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "conference.PrepareJob" */
export enum Conference_PrepareJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "conference.PrepareJob" */
export type Conference_PrepareJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "conference.PrepareJob" */
export enum Conference_PrepareJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "content.Element" */
export type Content_Element = {
  readonly __typename?: 'content_Element';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly permissionGrants: ReadonlyArray<Content_ElementPermissionGrant>;
  /** An aggregated array relationship */
  readonly permissionGrants_aggregate: Content_ElementPermissionGrant_Aggregate;
  /** An array relationship */
  readonly stats: ReadonlyArray<Analytics_ContentElementStats>;
  /** An aggregated array relationship */
  readonly stats_aggregate: Analytics_ContentElementStats_Aggregate;
  /** An object relationship */
  readonly type: Content_ElementType;
  readonly typeName: Content_ElementType_Enum;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly uploadableElement?: Maybe<Content_UploadableElement>;
  readonly uploadableId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly youTubeUploads: ReadonlyArray<Video_YouTubeUpload>;
  /** An aggregated array relationship */
  readonly youTubeUploads_aggregate: Video_YouTubeUpload_Aggregate;
};


/** columns and relationships of "content.Element" */
export type Content_ElementDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementPermissionGrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementPermissionGrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementYouTubeUploadsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


/** columns and relationships of "content.Element" */
export type Content_ElementYouTubeUploads_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};

/** columns and relationships of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken = {
  readonly __typename?: 'content_ElementByAccessToken';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.ElementByAccessToken" */
export type Content_ElementByAccessTokenDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "content.ElementByAccessToken" */
export type Content_ElementByAccessTokenLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Aggregate = {
  readonly __typename?: 'content_ElementByAccessToken_aggregate';
  readonly aggregate?: Maybe<Content_ElementByAccessToken_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ElementByAccessToken>;
};

/** aggregate fields of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Aggregate_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_ElementByAccessToken_Max_Fields>;
  readonly min?: Maybe<Content_ElementByAccessToken_Min_Fields>;
};


/** aggregate fields of "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ElementByAccessToken_Max_Order_By>;
  readonly min?: Maybe<Content_ElementByAccessToken_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Content_ElementByAccessToken_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** Boolean expression to filter rows from the table "content.ElementByAccessToken". All fields are combined with a logical 'AND'. */
export type Content_ElementByAccessToken_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_ElementByAccessToken_Bool_Exp>>>;
  readonly _not?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_ElementByAccessToken_Bool_Exp>>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemTitle?: Maybe<String_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly typeName?: Maybe<String_Comparison_Exp>;
};

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Content_ElementByAccessToken_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly layoutData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Content_ElementByAccessToken_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Content_ElementByAccessToken_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ElementByAccessToken_Max_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Max_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemTitle?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ElementByAccessToken_Min_Fields = {
  readonly __typename?: 'content_ElementByAccessToken_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Min_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemTitle?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
};

/** ordering options when selecting data from "content.ElementByAccessToken" */
export type Content_ElementByAccessToken_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemTitle?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly typeName?: Maybe<Order_By>;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Content_ElementByAccessToken_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "content.ElementByAccessToken" */
export enum Content_ElementByAccessToken_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  ItemTitle = 'itemTitle',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  TypeName = 'typeName'
}

/** columns and relationships of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant = {
  readonly __typename?: 'content_ElementPermissionGrant';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceSlug: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly entity?: Maybe<Content_Element>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly group?: Maybe<Permissions_Group>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly permissionSet: Permissions_Role;
  readonly permissionSetId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate = {
  readonly __typename?: 'content_ElementPermissionGrant_aggregate';
  readonly aggregate?: Maybe<Content_ElementPermissionGrant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ElementPermissionGrant>;
};

/** aggregate fields of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate_Fields = {
  readonly __typename?: 'content_ElementPermissionGrant_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_ElementPermissionGrant_Max_Fields>;
  readonly min?: Maybe<Content_ElementPermissionGrant_Min_Fields>;
};


/** aggregate fields of "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ElementPermissionGrant_Max_Order_By>;
  readonly min?: Maybe<Content_ElementPermissionGrant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ElementPermissionGrant_Insert_Input>;
  readonly on_conflict?: Maybe<Content_ElementPermissionGrant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.ElementPermissionGrant". All fields are combined with a logical 'AND'. */
export type Content_ElementPermissionGrant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_ElementPermissionGrant_Bool_Exp>>>;
  readonly _not?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_ElementPermissionGrant_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceSlug?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly entity?: Maybe<Content_Element_Bool_Exp>;
  readonly entityId?: Maybe<Uuid_Comparison_Exp>;
  readonly group?: Maybe<Permissions_Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly permissionSet?: Maybe<Permissions_Role_Bool_Exp>;
  readonly permissionSetId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ElementPermissionGrant" */
export enum Content_ElementPermissionGrant_Constraint {
  /** unique or primary key constraint */
  ElementPermissionGrantPermissionSetIdGroupIdEntityIdKey = 'ElementPermissionGrant_permissionSetId_groupId_entityId_key',
  /** unique or primary key constraint */
  ElementPermissionGrantPkey = 'ElementPermissionGrant_pkey'
}

/** input type for inserting data into table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entity?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly group?: Maybe<Permissions_Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSet?: Maybe<Permissions_Role_Obj_Rel_Insert_Input>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Content_ElementPermissionGrant_Max_Fields = {
  readonly __typename?: 'content_ElementPermissionGrant_max_fields';
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Max_Order_By = {
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ElementPermissionGrant_Min_Fields = {
  readonly __typename?: 'content_ElementPermissionGrant_min_fields';
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Min_Order_By = {
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Mutation_Response = {
  readonly __typename?: 'content_ElementPermissionGrant_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_ElementPermissionGrant>;
};

/** input type for inserting object relation for remote table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Obj_Rel_Insert_Input = {
  readonly data: Content_ElementPermissionGrant_Insert_Input;
  readonly on_conflict?: Maybe<Content_ElementPermissionGrant_On_Conflict>;
};

/** on conflict condition type for table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_On_Conflict = {
  readonly constraint: Content_ElementPermissionGrant_Constraint;
  readonly update_columns: ReadonlyArray<Content_ElementPermissionGrant_Update_Column>;
  readonly where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};

/** ordering options when selecting data from "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entity?: Maybe<Content_Element_Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly group?: Maybe<Permissions_Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSet?: Maybe<Permissions_Role_Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.ElementPermissionGrant" */
export enum Content_ElementPermissionGrant_Select_Column {
  /** column name */
  ConferenceSlug = 'conferenceSlug',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntityId = 'entityId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionSetId = 'permissionSetId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "content.ElementPermissionGrant" */
export type Content_ElementPermissionGrant_Set_Input = {
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "content.ElementPermissionGrant" */
export enum Content_ElementPermissionGrant_Update_Column {
  /** column name */
  ConferenceSlug = 'conferenceSlug',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntityId = 'entityId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionSetId = 'permissionSetId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "content.ElementType" */
export type Content_ElementType = {
  readonly __typename?: 'content_ElementType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "content.ElementType" */
export type Content_ElementType_Aggregate = {
  readonly __typename?: 'content_ElementType_aggregate';
  readonly aggregate?: Maybe<Content_ElementType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ElementType>;
};

/** aggregate fields of "content.ElementType" */
export type Content_ElementType_Aggregate_Fields = {
  readonly __typename?: 'content_ElementType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_ElementType_Max_Fields>;
  readonly min?: Maybe<Content_ElementType_Min_Fields>;
};


/** aggregate fields of "content.ElementType" */
export type Content_ElementType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ElementType" */
export type Content_ElementType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ElementType_Max_Order_By>;
  readonly min?: Maybe<Content_ElementType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.ElementType" */
export type Content_ElementType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ElementType_Insert_Input>;
  readonly on_conflict?: Maybe<Content_ElementType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.ElementType". All fields are combined with a logical 'AND'. */
export type Content_ElementType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_ElementType_Bool_Exp>>>;
  readonly _not?: Maybe<Content_ElementType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_ElementType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ElementType" */
export enum Content_ElementType_Constraint {
  /** unique or primary key constraint */
  ElementTypePkey = 'ElementType_pkey'
}

export enum Content_ElementType_Enum {
  /** Abstract Markdown text. */
  Abstract = 'ABSTRACT',
  /** List of content groups in the system. */
  ContentGroupList = 'CONTENT_GROUP_LIST',
  /** File for an image (stored by Clowdr). */
  ImageFile = 'IMAGE_FILE',
  /** URL to an image (embedded in Clowdr UI). */
  ImageUrl = 'IMAGE_URL',
  /** A generic URL. */
  Link = 'LINK',
  /** A URL for a link button. */
  LinkButton = 'LINK_BUTTON',
  /** File for a paper (stored by Clowdr). */
  PaperFile = 'PAPER_FILE',
  /** Link for a paper (preview is not embedded in Clowdr UI). */
  PaperLink = 'PAPER_LINK',
  /** URL to a paper (preview may be embedded in Clowdr UI e.g. PDF JS viewer). */
  PaperUrl = 'PAPER_URL',
  /** File for a poster image (stored by Clowdr). */
  PosterFile = 'POSTER_FILE',
  /** URL to a poster image (embedded in Clowdr UI). */
  PosterUrl = 'POSTER_URL',
  /** General-purpose Markdown text. */
  Text = 'TEXT',
  /** Video file to be broadcast. */
  VideoBroadcast = 'VIDEO_BROADCAST',
  /** Video file for counting down to a transition in a broadcast. */
  VideoCountdown = 'VIDEO_COUNTDOWN',
  /** File for a video (stored by Clowdr). */
  VideoFile = 'VIDEO_FILE',
  /** Video file for filler loop between events/during breaks in a broadcast. */
  VideoFiller = 'VIDEO_FILLER',
  /** Link to a video (video is not embedded in Clowdr UI). */
  VideoLink = 'VIDEO_LINK',
  /** Video file to be published in advance of the conference. */
  VideoPrepublish = 'VIDEO_PREPUBLISH',
  /** Video file for sponsors filler loop between events/during breaks in a broadcast. */
  VideoSponsorsFiller = 'VIDEO_SPONSORS_FILLER',
  /** Video file for titles introducing an event during a broadcast. */
  VideoTitles = 'VIDEO_TITLES',
  /** URL for a video (video is embedded in Clowdr UI). */
  VideoUrl = 'VIDEO_URL',
  /** Schedule view for the whole conference. */
  WholeSchedule = 'WHOLE_SCHEDULE',
  /** Data for a Zoom meeting. */
  Zoom = 'ZOOM'
}

/** expression to compare columns of type content_ElementType_enum. All fields are combined with logical 'AND'. */
export type Content_ElementType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Content_ElementType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Content_ElementType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Content_ElementType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Content_ElementType_Enum>>;
};

/** input type for inserting data into table "content.ElementType" */
export type Content_ElementType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ElementType_Max_Fields = {
  readonly __typename?: 'content_ElementType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "content.ElementType" */
export type Content_ElementType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ElementType_Min_Fields = {
  readonly __typename?: 'content_ElementType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "content.ElementType" */
export type Content_ElementType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ElementType" */
export type Content_ElementType_Mutation_Response = {
  readonly __typename?: 'content_ElementType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_ElementType>;
};

/** input type for inserting object relation for remote table "content.ElementType" */
export type Content_ElementType_Obj_Rel_Insert_Input = {
  readonly data: Content_ElementType_Insert_Input;
  readonly on_conflict?: Maybe<Content_ElementType_On_Conflict>;
};

/** on conflict condition type for table "content.ElementType" */
export type Content_ElementType_On_Conflict = {
  readonly constraint: Content_ElementType_Constraint;
  readonly update_columns: ReadonlyArray<Content_ElementType_Update_Column>;
  readonly where?: Maybe<Content_ElementType_Bool_Exp>;
};

/** ordering options when selecting data from "content.ElementType" */
export type Content_ElementType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.ElementType" */
export type Content_ElementType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "content.ElementType" */
export enum Content_ElementType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "content.ElementType" */
export type Content_ElementType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "content.ElementType" */
export enum Content_ElementType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "content.Element" */
export type Content_Element_Aggregate = {
  readonly __typename?: 'content_Element_aggregate';
  readonly aggregate?: Maybe<Content_Element_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_Element>;
};

/** aggregate fields of "content.Element" */
export type Content_Element_Aggregate_Fields = {
  readonly __typename?: 'content_Element_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_Element_Max_Fields>;
  readonly min?: Maybe<Content_Element_Min_Fields>;
};


/** aggregate fields of "content.Element" */
export type Content_Element_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.Element" */
export type Content_Element_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_Element_Max_Order_By>;
  readonly min?: Maybe<Content_Element_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Content_Element_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "content.Element" */
export type Content_Element_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_Element_Insert_Input>;
  readonly on_conflict?: Maybe<Content_Element_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.Element". All fields are combined with a logical 'AND'. */
export type Content_Element_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_Element_Bool_Exp>>>;
  readonly _not?: Maybe<Content_Element_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_Element_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly permissionGrants?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
  readonly stats?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
  readonly type?: Maybe<Content_ElementType_Bool_Exp>;
  readonly typeName?: Maybe<Content_ElementType_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadableElement?: Maybe<Content_UploadableElement_Bool_Exp>;
  readonly uploadableId?: Maybe<Uuid_Comparison_Exp>;
  readonly youTubeUploads?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};

/** unique or primary key constraints on table "content.Element" */
export enum Content_Element_Constraint {
  /** unique or primary key constraint */
  ElementPkey = 'Element_pkey',
  /** unique or primary key constraint */
  ElementRequiredContentIdKey = 'Element_requiredContentId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Content_Element_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly layoutData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Content_Element_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Content_Element_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "content.Element" */
export type Content_Element_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly permissionGrants?: Maybe<Content_ElementPermissionGrant_Arr_Rel_Insert_Input>;
  readonly stats?: Maybe<Analytics_ContentElementStats_Arr_Rel_Insert_Input>;
  readonly type?: Maybe<Content_ElementType_Obj_Rel_Insert_Input>;
  readonly typeName?: Maybe<Content_ElementType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableElement?: Maybe<Content_UploadableElement_Obj_Rel_Insert_Input>;
  readonly uploadableId?: Maybe<Scalars['uuid']>;
  readonly youTubeUploads?: Maybe<Video_YouTubeUpload_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Content_Element_Max_Fields = {
  readonly __typename?: 'content_Element_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "content.Element" */
export type Content_Element_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_Element_Min_Fields = {
  readonly __typename?: 'content_Element_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "content.Element" */
export type Content_Element_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableId?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.Element" */
export type Content_Element_Mutation_Response = {
  readonly __typename?: 'content_Element_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_Element>;
};

/** input type for inserting object relation for remote table "content.Element" */
export type Content_Element_Obj_Rel_Insert_Input = {
  readonly data: Content_Element_Insert_Input;
  readonly on_conflict?: Maybe<Content_Element_On_Conflict>;
};

/** on conflict condition type for table "content.Element" */
export type Content_Element_On_Conflict = {
  readonly constraint: Content_Element_Constraint;
  readonly update_columns: ReadonlyArray<Content_Element_Update_Column>;
  readonly where?: Maybe<Content_Element_Bool_Exp>;
};

/** ordering options when selecting data from "content.Element" */
export type Content_Element_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly permissionGrants_aggregate?: Maybe<Content_ElementPermissionGrant_Aggregate_Order_By>;
  readonly stats_aggregate?: Maybe<Analytics_ContentElementStats_Aggregate_Order_By>;
  readonly type?: Maybe<Content_ElementType_Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableElement?: Maybe<Content_UploadableElement_Order_By>;
  readonly uploadableId?: Maybe<Order_By>;
  readonly youTubeUploads_aggregate?: Maybe<Video_YouTubeUpload_Aggregate_Order_By>;
};

/** primary key columns input for table: "content.Element" */
export type Content_Element_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Content_Element_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "content.Element" */
export enum Content_Element_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadableId = 'uploadableId'
}

/** input type for updating data in table "content.Element" */
export type Content_Element_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Content_ElementType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "content.Element" */
export enum Content_Element_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadableId = 'uploadableId'
}

/** columns and relationships of "content.Item" */
export type Content_Item = {
  readonly __typename?: 'content_Item';
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly elements: ReadonlyArray<Content_Element>;
  /** An aggregated array relationship */
  readonly elements_aggregate: Content_Element_Aggregate;
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly itemExhibitions: ReadonlyArray<Content_ItemExhibition>;
  /** An aggregated array relationship */
  readonly itemExhibitions_aggregate: Content_ItemExhibition_Aggregate;
  /** An array relationship */
  readonly itemPeople: ReadonlyArray<Content_ItemProgramPerson>;
  /** An aggregated array relationship */
  readonly itemPeople_aggregate: Content_ItemProgramPerson_Aggregate;
  /** An array relationship */
  readonly itemTags: ReadonlyArray<Content_ItemTag>;
  /** An aggregated array relationship */
  readonly itemTags_aggregate: Content_ItemTag_Aggregate;
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
  readonly shortTitle?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly stats: ReadonlyArray<Analytics_ContentItemStats>;
  /** An aggregated array relationship */
  readonly stats_aggregate: Analytics_ContentItemStats_Aggregate;
  readonly title: Scalars['String'];
  /** An object relationship */
  readonly type: Content_ItemType;
  readonly typeName: Content_ItemType_Enum;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly uploadableElements: ReadonlyArray<Content_UploadableElement>;
  /** An aggregated array relationship */
  readonly uploadableElements_aggregate: Content_UploadableElement_Aggregate;
};


/** columns and relationships of "content.Item" */
export type Content_ItemElementsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemElements_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemExhibitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemExhibitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemItemTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemUploadableElementsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};


/** columns and relationships of "content.Item" */
export type Content_ItemUploadableElements_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};

/** columns and relationships of "content.ItemExhibition" */
export type Content_ItemExhibition = {
  readonly __typename?: 'content_ItemExhibition';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly exhibition: Collection_Exhibition;
  readonly exhibitionId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "content.ItemExhibition" */
export type Content_ItemExhibitionLayoutArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate = {
  readonly __typename?: 'content_ItemExhibition_aggregate';
  readonly aggregate?: Maybe<Content_ItemExhibition_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemExhibition>;
};

/** aggregate fields of "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate_Fields = {
  readonly __typename?: 'content_ItemExhibition_aggregate_fields';
  readonly avg?: Maybe<Content_ItemExhibition_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_ItemExhibition_Max_Fields>;
  readonly min?: Maybe<Content_ItemExhibition_Min_Fields>;
  readonly stddev?: Maybe<Content_ItemExhibition_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_ItemExhibition_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_ItemExhibition_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_ItemExhibition_Sum_Fields>;
  readonly var_pop?: Maybe<Content_ItemExhibition_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_ItemExhibition_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_ItemExhibition_Variance_Fields>;
};


/** aggregate fields of "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemExhibition" */
export type Content_ItemExhibition_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_ItemExhibition_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemExhibition_Max_Order_By>;
  readonly min?: Maybe<Content_ItemExhibition_Min_Order_By>;
  readonly stddev?: Maybe<Content_ItemExhibition_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_ItemExhibition_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_ItemExhibition_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_ItemExhibition_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_ItemExhibition_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_ItemExhibition_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_ItemExhibition_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Content_ItemExhibition_Append_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "content.ItemExhibition" */
export type Content_ItemExhibition_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemExhibition_Insert_Input>;
  readonly on_conflict?: Maybe<Content_ItemExhibition_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_ItemExhibition_Avg_Fields = {
  readonly __typename?: 'content_ItemExhibition_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.ItemExhibition". All fields are combined with a logical 'AND'. */
export type Content_ItemExhibition_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_ItemExhibition_Bool_Exp>>>;
  readonly _not?: Maybe<Content_ItemExhibition_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_ItemExhibition_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly exhibition?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly exhibitionId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly layout?: Maybe<Jsonb_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemExhibition" */
export enum Content_ItemExhibition_Constraint {
  /** unique or primary key constraint */
  ItemExhibitionPkey = 'ItemExhibition_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Content_ItemExhibition_Delete_At_Path_Input = {
  readonly layout?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Content_ItemExhibition_Delete_Elem_Input = {
  readonly layout?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Content_ItemExhibition_Delete_Key_Input = {
  readonly layout?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "content.ItemExhibition" */
export type Content_ItemExhibition_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.ItemExhibition" */
export type Content_ItemExhibition_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibition?: Maybe<Collection_Exhibition_Obj_Rel_Insert_Input>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Content_ItemExhibition_Max_Fields = {
  readonly __typename?: 'content_ItemExhibition_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemExhibition_Min_Fields = {
  readonly __typename?: 'content_ItemExhibition_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemExhibition" */
export type Content_ItemExhibition_Mutation_Response = {
  readonly __typename?: 'content_ItemExhibition_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_ItemExhibition>;
};

/** input type for inserting object relation for remote table "content.ItemExhibition" */
export type Content_ItemExhibition_Obj_Rel_Insert_Input = {
  readonly data: Content_ItemExhibition_Insert_Input;
  readonly on_conflict?: Maybe<Content_ItemExhibition_On_Conflict>;
};

/** on conflict condition type for table "content.ItemExhibition" */
export type Content_ItemExhibition_On_Conflict = {
  readonly constraint: Content_ItemExhibition_Constraint;
  readonly update_columns: ReadonlyArray<Content_ItemExhibition_Update_Column>;
  readonly where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};

/** ordering options when selecting data from "content.ItemExhibition" */
export type Content_ItemExhibition_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly exhibition?: Maybe<Collection_Exhibition_Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly layout?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.ItemExhibition" */
export type Content_ItemExhibition_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Content_ItemExhibition_Prepend_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "content.ItemExhibition" */
export enum Content_ItemExhibition_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** input type for updating data in table "content.ItemExhibition" */
export type Content_ItemExhibition_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Content_ItemExhibition_Stddev_Fields = {
  readonly __typename?: 'content_ItemExhibition_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_ItemExhibition_Stddev_Pop_Fields = {
  readonly __typename?: 'content_ItemExhibition_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_ItemExhibition_Stddev_Samp_Fields = {
  readonly __typename?: 'content_ItemExhibition_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_ItemExhibition_Sum_Fields = {
  readonly __typename?: 'content_ItemExhibition_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "content.ItemExhibition" */
export enum Content_ItemExhibition_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** aggregate var_pop on columns */
export type Content_ItemExhibition_Var_Pop_Fields = {
  readonly __typename?: 'content_ItemExhibition_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_ItemExhibition_Var_Samp_Fields = {
  readonly __typename?: 'content_ItemExhibition_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_ItemExhibition_Variance_Fields = {
  readonly __typename?: 'content_ItemExhibition_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.ItemExhibition" */
export type Content_ItemExhibition_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson = {
  readonly __typename?: 'content_ItemProgramPerson';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  /** An object relationship */
  readonly person: Collection_ProgramPerson;
  readonly personId: Scalars['uuid'];
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName: Scalars['String'];
};

/** aggregated selection of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate = {
  readonly __typename?: 'content_ItemProgramPerson_aggregate';
  readonly aggregate?: Maybe<Content_ItemProgramPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemProgramPerson>;
};

/** aggregate fields of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_aggregate_fields';
  readonly avg?: Maybe<Content_ItemProgramPerson_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_ItemProgramPerson_Max_Fields>;
  readonly min?: Maybe<Content_ItemProgramPerson_Min_Fields>;
  readonly stddev?: Maybe<Content_ItemProgramPerson_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_ItemProgramPerson_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_ItemProgramPerson_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_ItemProgramPerson_Sum_Fields>;
  readonly var_pop?: Maybe<Content_ItemProgramPerson_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_ItemProgramPerson_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_ItemProgramPerson_Variance_Fields>;
};


/** aggregate fields of "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_ItemProgramPerson_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemProgramPerson_Max_Order_By>;
  readonly min?: Maybe<Content_ItemProgramPerson_Min_Order_By>;
  readonly stddev?: Maybe<Content_ItemProgramPerson_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_ItemProgramPerson_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_ItemProgramPerson_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_ItemProgramPerson_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_ItemProgramPerson_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_ItemProgramPerson_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_ItemProgramPerson_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemProgramPerson_Insert_Input>;
  readonly on_conflict?: Maybe<Content_ItemProgramPerson_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_ItemProgramPerson_Avg_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.ItemProgramPerson". All fields are combined with a logical 'AND'. */
export type Content_ItemProgramPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_ItemProgramPerson_Bool_Exp>>>;
  readonly _not?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_ItemProgramPerson_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly roleName?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemProgramPerson" */
export enum Content_ItemProgramPerson_Constraint {
  /** unique or primary key constraint */
  ItemProgramPersonPkey = 'ItemProgramPerson_pkey',
  /** unique or primary key constraint */
  ItemProgramPersonRoleNamePersonIdItemIdKey = 'ItemProgramPerson_roleName_personId_itemId_key'
}

/** input type for incrementing integer column in table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<Collection_ProgramPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ItemProgramPerson_Max_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemProgramPerson_Min_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Mutation_Response = {
  readonly __typename?: 'content_ItemProgramPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_ItemProgramPerson>;
};

/** input type for inserting object relation for remote table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Obj_Rel_Insert_Input = {
  readonly data: Content_ItemProgramPerson_Insert_Input;
  readonly on_conflict?: Maybe<Content_ItemProgramPerson_On_Conflict>;
};

/** on conflict condition type for table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_On_Conflict = {
  readonly constraint: Content_ItemProgramPerson_Constraint;
  readonly update_columns: ReadonlyArray<Content_ItemProgramPerson_Update_Column>;
  readonly where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};

/** ordering options when selecting data from "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly person?: Maybe<Collection_ProgramPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.ItemProgramPerson" */
export enum Content_ItemProgramPerson_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** input type for updating data in table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Content_ItemProgramPerson_Stddev_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_ItemProgramPerson_Stddev_Pop_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_ItemProgramPerson_Stddev_Samp_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_ItemProgramPerson_Sum_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "content.ItemProgramPerson" */
export enum Content_ItemProgramPerson_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** aggregate var_pop on columns */
export type Content_ItemProgramPerson_Var_Pop_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_ItemProgramPerson_Var_Samp_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_ItemProgramPerson_Variance_Fields = {
  readonly __typename?: 'content_ItemProgramPerson_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.ItemProgramPerson" */
export type Content_ItemProgramPerson_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "content.ItemTag" */
export type Content_ItemTag = {
  readonly __typename?: 'content_ItemTag';
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Collection_Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "content.ItemTag" */
export type Content_ItemTag_Aggregate = {
  readonly __typename?: 'content_ItemTag_aggregate';
  readonly aggregate?: Maybe<Content_ItemTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemTag>;
};

/** aggregate fields of "content.ItemTag" */
export type Content_ItemTag_Aggregate_Fields = {
  readonly __typename?: 'content_ItemTag_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_ItemTag_Max_Fields>;
  readonly min?: Maybe<Content_ItemTag_Min_Fields>;
};


/** aggregate fields of "content.ItemTag" */
export type Content_ItemTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemTag" */
export type Content_ItemTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemTag_Max_Order_By>;
  readonly min?: Maybe<Content_ItemTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.ItemTag" */
export type Content_ItemTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemTag_Insert_Input>;
  readonly on_conflict?: Maybe<Content_ItemTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.ItemTag". All fields are combined with a logical 'AND'. */
export type Content_ItemTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_ItemTag_Bool_Exp>>>;
  readonly _not?: Maybe<Content_ItemTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_ItemTag_Bool_Exp>>>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Collection_Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemTag" */
export enum Content_ItemTag_Constraint {
  /** unique or primary key constraint */
  ItemTagItemIdTagIdKey = 'ItemTag_itemId_tagId_key',
  /** unique or primary key constraint */
  ItemTagPkey = 'ItemTag_pkey'
}

/** input type for inserting data into table "content.ItemTag" */
export type Content_ItemTag_Insert_Input = {
  readonly id?: Maybe<Scalars['uuid']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Collection_Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Content_ItemTag_Max_Fields = {
  readonly __typename?: 'content_ItemTag_max_fields';
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "content.ItemTag" */
export type Content_ItemTag_Max_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemTag_Min_Fields = {
  readonly __typename?: 'content_ItemTag_min_fields';
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "content.ItemTag" */
export type Content_ItemTag_Min_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemTag" */
export type Content_ItemTag_Mutation_Response = {
  readonly __typename?: 'content_ItemTag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_ItemTag>;
};

/** input type for inserting object relation for remote table "content.ItemTag" */
export type Content_ItemTag_Obj_Rel_Insert_Input = {
  readonly data: Content_ItemTag_Insert_Input;
  readonly on_conflict?: Maybe<Content_ItemTag_On_Conflict>;
};

/** on conflict condition type for table "content.ItemTag" */
export type Content_ItemTag_On_Conflict = {
  readonly constraint: Content_ItemTag_Constraint;
  readonly update_columns: ReadonlyArray<Content_ItemTag_Update_Column>;
  readonly where?: Maybe<Content_ItemTag_Bool_Exp>;
};

/** ordering options when selecting data from "content.ItemTag" */
export type Content_ItemTag_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly tag?: Maybe<Collection_Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.ItemTag" */
export type Content_ItemTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.ItemTag" */
export enum Content_ItemTag_Select_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "content.ItemTag" */
export type Content_ItemTag_Set_Input = {
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "content.ItemTag" */
export enum Content_ItemTag_Update_Column {
  /** column name */
  Id = 'id',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  TagId = 'tagId'
}

/** columns and relationships of "content.ItemType" */
export type Content_ItemType = {
  readonly __typename?: 'content_ItemType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "content.ItemType" */
export type Content_ItemType_Aggregate = {
  readonly __typename?: 'content_ItemType_aggregate';
  readonly aggregate?: Maybe<Content_ItemType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_ItemType>;
};

/** aggregate fields of "content.ItemType" */
export type Content_ItemType_Aggregate_Fields = {
  readonly __typename?: 'content_ItemType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_ItemType_Max_Fields>;
  readonly min?: Maybe<Content_ItemType_Min_Fields>;
};


/** aggregate fields of "content.ItemType" */
export type Content_ItemType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.ItemType" */
export type Content_ItemType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_ItemType_Max_Order_By>;
  readonly min?: Maybe<Content_ItemType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.ItemType" */
export type Content_ItemType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_ItemType_Insert_Input>;
  readonly on_conflict?: Maybe<Content_ItemType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.ItemType". All fields are combined with a logical 'AND'. */
export type Content_ItemType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_ItemType_Bool_Exp>>>;
  readonly _not?: Maybe<Content_ItemType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_ItemType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.ItemType" */
export enum Content_ItemType_Constraint {
  /** unique or primary key constraint */
  ItemTypePkey = 'ItemType_pkey'
}

export enum Content_ItemType_Enum {
  /** A demonstration. */
  Demonstration = 'DEMONSTRATION',
  /** A keynote. */
  Keynote = 'KEYNOTE',
  /** Conference main landing page. */
  LandingPage = 'LANDING_PAGE',
  /** A generic group type - use sparingly. */
  Other = 'OTHER',
  /** A paper. */
  Paper = 'PAPER',
  /** A poster. */
  Poster = 'POSTER',
  /** A presentation. */
  Presentation = 'PRESENTATION',
  /** A Q&A covering the whole session. */
  SessionQAndA = 'SESSION_Q_AND_A',
  /** A scheduled social. */
  Social = 'SOCIAL',
  /** A sponsor. */
  Sponsor = 'SPONSOR',
  /** A symposium. */
  Symposium = 'SYMPOSIUM',
  /** A tutorial. */
  Tutorial = 'TUTORIAL',
  /** A workshop. */
  Workshop = 'WORKSHOP'
}

/** expression to compare columns of type content_ItemType_enum. All fields are combined with logical 'AND'. */
export type Content_ItemType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Content_ItemType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Content_ItemType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Content_ItemType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Content_ItemType_Enum>>;
};

/** input type for inserting data into table "content.ItemType" */
export type Content_ItemType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Content_ItemType_Max_Fields = {
  readonly __typename?: 'content_ItemType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "content.ItemType" */
export type Content_ItemType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_ItemType_Min_Fields = {
  readonly __typename?: 'content_ItemType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "content.ItemType" */
export type Content_ItemType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.ItemType" */
export type Content_ItemType_Mutation_Response = {
  readonly __typename?: 'content_ItemType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_ItemType>;
};

/** input type for inserting object relation for remote table "content.ItemType" */
export type Content_ItemType_Obj_Rel_Insert_Input = {
  readonly data: Content_ItemType_Insert_Input;
  readonly on_conflict?: Maybe<Content_ItemType_On_Conflict>;
};

/** on conflict condition type for table "content.ItemType" */
export type Content_ItemType_On_Conflict = {
  readonly constraint: Content_ItemType_Constraint;
  readonly update_columns: ReadonlyArray<Content_ItemType_Update_Column>;
  readonly where?: Maybe<Content_ItemType_Bool_Exp>;
};

/** ordering options when selecting data from "content.ItemType" */
export type Content_ItemType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.ItemType" */
export type Content_ItemType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "content.ItemType" */
export enum Content_ItemType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "content.ItemType" */
export type Content_ItemType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "content.ItemType" */
export enum Content_ItemType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "content.Item" */
export type Content_Item_Aggregate = {
  readonly __typename?: 'content_Item_aggregate';
  readonly aggregate?: Maybe<Content_Item_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_Item>;
};

/** aggregate fields of "content.Item" */
export type Content_Item_Aggregate_Fields = {
  readonly __typename?: 'content_Item_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_Item_Max_Fields>;
  readonly min?: Maybe<Content_Item_Min_Fields>;
};


/** aggregate fields of "content.Item" */
export type Content_Item_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.Item" */
export type Content_Item_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_Item_Max_Order_By>;
  readonly min?: Maybe<Content_Item_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.Item" */
export type Content_Item_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_Item_Insert_Input>;
  readonly on_conflict?: Maybe<Content_Item_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.Item". All fields are combined with a logical 'AND'. */
export type Content_Item_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_Item_Bool_Exp>>>;
  readonly _not?: Maybe<Content_Item_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_Item_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly elements?: Maybe<Content_Element_Bool_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly itemExhibitions?: Maybe<Content_ItemExhibition_Bool_Exp>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
  readonly itemTags?: Maybe<Content_ItemTag_Bool_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
  readonly shortTitle?: Maybe<String_Comparison_Exp>;
  readonly stats?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
  readonly title?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Content_ItemType_Bool_Exp>;
  readonly typeName?: Maybe<Content_ItemType_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadableElements?: Maybe<Content_UploadableElement_Bool_Exp>;
};

/** unique or primary key constraints on table "content.Item" */
export enum Content_Item_Constraint {
  /** unique or primary key constraint */
  ItemPkey = 'Item_pkey'
}

/** input type for inserting data into table "content.Item" */
export type Content_Item_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elements?: Maybe<Content_Element_Arr_Rel_Insert_Input>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemExhibitions?: Maybe<Content_ItemExhibition_Arr_Rel_Insert_Input>;
  readonly itemPeople?: Maybe<Content_ItemProgramPerson_Arr_Rel_Insert_Input>;
  readonly itemTags?: Maybe<Content_ItemTag_Arr_Rel_Insert_Input>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly stats?: Maybe<Analytics_ContentItemStats_Arr_Rel_Insert_Input>;
  readonly title?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Content_ItemType_Obj_Rel_Insert_Input>;
  readonly typeName?: Maybe<Content_ItemType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableElements?: Maybe<Content_UploadableElement_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Content_Item_Max_Fields = {
  readonly __typename?: 'content_Item_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "content.Item" */
export type Content_Item_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_Item_Min_Fields = {
  readonly __typename?: 'content_Item_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "content.Item" */
export type Content_Item_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.Item" */
export type Content_Item_Mutation_Response = {
  readonly __typename?: 'content_Item_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_Item>;
};

/** input type for inserting object relation for remote table "content.Item" */
export type Content_Item_Obj_Rel_Insert_Input = {
  readonly data: Content_Item_Insert_Input;
  readonly on_conflict?: Maybe<Content_Item_On_Conflict>;
};

/** on conflict condition type for table "content.Item" */
export type Content_Item_On_Conflict = {
  readonly constraint: Content_Item_Constraint;
  readonly update_columns: ReadonlyArray<Content_Item_Update_Column>;
  readonly where?: Maybe<Content_Item_Bool_Exp>;
};

/** ordering options when selecting data from "content.Item" */
export type Content_Item_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elements_aggregate?: Maybe<Content_Element_Aggregate_Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemExhibitions_aggregate?: Maybe<Content_ItemExhibition_Aggregate_Order_By>;
  readonly itemPeople_aggregate?: Maybe<Content_ItemProgramPerson_Aggregate_Order_By>;
  readonly itemTags_aggregate?: Maybe<Content_ItemTag_Aggregate_Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly stats_aggregate?: Maybe<Analytics_ContentItemStats_Aggregate_Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly type?: Maybe<Content_ItemType_Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableElements_aggregate?: Maybe<Content_UploadableElement_Aggregate_Order_By>;
};

/** primary key columns input for table: "content.Item" */
export type Content_Item_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.Item" */
export enum Content_Item_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "content.Item" */
export type Content_Item_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly typeName?: Maybe<Content_ItemType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "content.Item" */
export enum Content_Item_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "content.UploadableElement" */
export type Content_UploadableElement = {
  readonly __typename?: 'content_UploadableElement';
  readonly accessToken: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element?: Maybe<Content_Element>;
  /** A computed field, executes function "content.hasBeenUploaded" */
  readonly hasBeenUploaded?: Maybe<Scalars['Boolean']>;
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  /** An object relationship */
  readonly item: Content_Item;
  readonly itemId: Scalars['uuid'];
  /** A computed field, executes function "content.UploadableElement_itemTitle" */
  readonly itemTitle?: Maybe<Scalars['String']>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly permissionGrants: ReadonlyArray<Content_UploadableElementPermissionGrant>;
  /** An aggregated array relationship */
  readonly permissionGrants_aggregate: Content_UploadableElementPermissionGrant_Aggregate;
  /** An object relationship */
  readonly type: Content_ElementType;
  readonly typeName: Content_ElementType_Enum;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly uploaders: ReadonlyArray<Content_Uploader>;
  /** An aggregated array relationship */
  readonly uploaders_aggregate: Content_Uploader_Aggregate;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "content.UploadableElement" */
export type Content_UploadableElementPermissionGrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
};


/** columns and relationships of "content.UploadableElement" */
export type Content_UploadableElementPermissionGrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
};


/** columns and relationships of "content.UploadableElement" */
export type Content_UploadableElementUploadersArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


/** columns and relationships of "content.UploadableElement" */
export type Content_UploadableElementUploaders_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};

/** columns and relationships of "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant = {
  readonly __typename?: 'content_UploadableElementPermissionGrant';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceSlug: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly entity?: Maybe<Content_UploadableElement>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly group?: Maybe<Permissions_Group>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly permissionSet: Permissions_Role;
  readonly permissionSetId: Scalars['uuid'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Aggregate = {
  readonly __typename?: 'content_UploadableElementPermissionGrant_aggregate';
  readonly aggregate?: Maybe<Content_UploadableElementPermissionGrant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_UploadableElementPermissionGrant>;
};

/** aggregate fields of "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Aggregate_Fields = {
  readonly __typename?: 'content_UploadableElementPermissionGrant_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_UploadableElementPermissionGrant_Max_Fields>;
  readonly min?: Maybe<Content_UploadableElementPermissionGrant_Min_Fields>;
};


/** aggregate fields of "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_UploadableElementPermissionGrant_Max_Order_By>;
  readonly min?: Maybe<Content_UploadableElementPermissionGrant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_UploadableElementPermissionGrant_Insert_Input>;
  readonly on_conflict?: Maybe<Content_UploadableElementPermissionGrant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "content.UploadableElementPermissionGrant". All fields are combined with a logical 'AND'. */
export type Content_UploadableElementPermissionGrant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>>>;
  readonly _not?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceSlug?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly entity?: Maybe<Content_UploadableElement_Bool_Exp>;
  readonly entityId?: Maybe<Uuid_Comparison_Exp>;
  readonly group?: Maybe<Permissions_Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly permissionSet?: Maybe<Permissions_Role_Bool_Exp>;
  readonly permissionSetId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.UploadableElementPermissionGrant" */
export enum Content_UploadableElementPermissionGrant_Constraint {
  /** unique or primary key constraint */
  UploadableElementPermissionGrPermissionSetIdGroupIdEntitKey = 'UploadableElementPermissionGr_permissionSetId_groupId_entit_key',
  /** unique or primary key constraint */
  UploadableElementPermissionGrantPkey = 'UploadableElementPermissionGrant_pkey'
}

/** input type for inserting data into table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entity?: Maybe<Content_UploadableElement_Obj_Rel_Insert_Input>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly group?: Maybe<Permissions_Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSet?: Maybe<Permissions_Role_Obj_Rel_Insert_Input>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Content_UploadableElementPermissionGrant_Max_Fields = {
  readonly __typename?: 'content_UploadableElementPermissionGrant_max_fields';
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Max_Order_By = {
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_UploadableElementPermissionGrant_Min_Fields = {
  readonly __typename?: 'content_UploadableElementPermissionGrant_min_fields';
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Min_Order_By = {
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Mutation_Response = {
  readonly __typename?: 'content_UploadableElementPermissionGrant_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_UploadableElementPermissionGrant>;
};

/** input type for inserting object relation for remote table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Obj_Rel_Insert_Input = {
  readonly data: Content_UploadableElementPermissionGrant_Insert_Input;
  readonly on_conflict?: Maybe<Content_UploadableElementPermissionGrant_On_Conflict>;
};

/** on conflict condition type for table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_On_Conflict = {
  readonly constraint: Content_UploadableElementPermissionGrant_Constraint;
  readonly update_columns: ReadonlyArray<Content_UploadableElementPermissionGrant_Update_Column>;
  readonly where?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
};

/** ordering options when selecting data from "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceSlug?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly entity?: Maybe<Content_UploadableElement_Order_By>;
  readonly entityId?: Maybe<Order_By>;
  readonly group?: Maybe<Permissions_Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permissionSet?: Maybe<Permissions_Role_Order_By>;
  readonly permissionSetId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.UploadableElementPermissionGrant" */
export enum Content_UploadableElementPermissionGrant_Select_Column {
  /** column name */
  ConferenceSlug = 'conferenceSlug',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntityId = 'entityId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionSetId = 'permissionSetId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "content.UploadableElementPermissionGrant" */
export type Content_UploadableElementPermissionGrant_Set_Input = {
  readonly conferenceSlug?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly entityId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionSetId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "content.UploadableElementPermissionGrant" */
export enum Content_UploadableElementPermissionGrant_Update_Column {
  /** column name */
  ConferenceSlug = 'conferenceSlug',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EntityId = 'entityId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionSetId = 'permissionSetId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregated selection of "content.UploadableElement" */
export type Content_UploadableElement_Aggregate = {
  readonly __typename?: 'content_UploadableElement_aggregate';
  readonly aggregate?: Maybe<Content_UploadableElement_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_UploadableElement>;
};

/** aggregate fields of "content.UploadableElement" */
export type Content_UploadableElement_Aggregate_Fields = {
  readonly __typename?: 'content_UploadableElement_aggregate_fields';
  readonly avg?: Maybe<Content_UploadableElement_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_UploadableElement_Max_Fields>;
  readonly min?: Maybe<Content_UploadableElement_Min_Fields>;
  readonly stddev?: Maybe<Content_UploadableElement_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_UploadableElement_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_UploadableElement_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_UploadableElement_Sum_Fields>;
  readonly var_pop?: Maybe<Content_UploadableElement_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_UploadableElement_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_UploadableElement_Variance_Fields>;
};


/** aggregate fields of "content.UploadableElement" */
export type Content_UploadableElement_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.UploadableElement" */
export type Content_UploadableElement_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_UploadableElement_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_UploadableElement_Max_Order_By>;
  readonly min?: Maybe<Content_UploadableElement_Min_Order_By>;
  readonly stddev?: Maybe<Content_UploadableElement_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_UploadableElement_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_UploadableElement_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_UploadableElement_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_UploadableElement_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_UploadableElement_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_UploadableElement_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "content.UploadableElement" */
export type Content_UploadableElement_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_UploadableElement_Insert_Input>;
  readonly on_conflict?: Maybe<Content_UploadableElement_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_UploadableElement_Avg_Fields = {
  readonly __typename?: 'content_UploadableElement_avg_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Avg_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.UploadableElement". All fields are combined with a logical 'AND'. */
export type Content_UploadableElement_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_UploadableElement_Bool_Exp>>>;
  readonly _not?: Maybe<Content_UploadableElement_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_UploadableElement_Bool_Exp>>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly permissionGrants?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
  readonly type?: Maybe<Content_ElementType_Bool_Exp>;
  readonly typeName?: Maybe<Content_ElementType_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploaders?: Maybe<Content_Uploader_Bool_Exp>;
  readonly uploadsRemaining?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.UploadableElement" */
export enum Content_UploadableElement_Constraint {
  /** unique or primary key constraint */
  UploadableElementPkey = 'UploadableElement_pkey'
}

/** input type for incrementing integer column in table "content.UploadableElement" */
export type Content_UploadableElement_Inc_Input = {
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.UploadableElement" */
export type Content_UploadableElement_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly permissionGrants?: Maybe<Content_UploadableElementPermissionGrant_Arr_Rel_Insert_Input>;
  readonly type?: Maybe<Content_ElementType_Obj_Rel_Insert_Input>;
  readonly typeName?: Maybe<Content_ElementType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploaders?: Maybe<Content_Uploader_Arr_Rel_Insert_Input>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Content_UploadableElement_Max_Fields = {
  readonly __typename?: 'content_UploadableElement_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Max_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_UploadableElement_Min_Fields = {
  readonly __typename?: 'content_UploadableElement_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Min_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.UploadableElement" */
export type Content_UploadableElement_Mutation_Response = {
  readonly __typename?: 'content_UploadableElement_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_UploadableElement>;
};

/** input type for inserting object relation for remote table "content.UploadableElement" */
export type Content_UploadableElement_Obj_Rel_Insert_Input = {
  readonly data: Content_UploadableElement_Insert_Input;
  readonly on_conflict?: Maybe<Content_UploadableElement_On_Conflict>;
};

/** on conflict condition type for table "content.UploadableElement" */
export type Content_UploadableElement_On_Conflict = {
  readonly constraint: Content_UploadableElement_Constraint;
  readonly update_columns: ReadonlyArray<Content_UploadableElement_Update_Column>;
  readonly where?: Maybe<Content_UploadableElement_Bool_Exp>;
};

/** ordering options when selecting data from "content.UploadableElement" */
export type Content_UploadableElement_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly permissionGrants_aggregate?: Maybe<Content_UploadableElementPermissionGrant_Aggregate_Order_By>;
  readonly type?: Maybe<Content_ElementType_Order_By>;
  readonly typeName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploaders_aggregate?: Maybe<Content_Uploader_Aggregate_Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.UploadableElement" */
export type Content_UploadableElement_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.UploadableElement" */
export enum Content_UploadableElement_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** input type for updating data in table "content.UploadableElement" */
export type Content_UploadableElement_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly typeName?: Maybe<Content_ElementType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Content_UploadableElement_Stddev_Fields = {
  readonly __typename?: 'content_UploadableElement_stddev_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Stddev_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_UploadableElement_Stddev_Pop_Fields = {
  readonly __typename?: 'content_UploadableElement_stddev_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Stddev_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_UploadableElement_Stddev_Samp_Fields = {
  readonly __typename?: 'content_UploadableElement_stddev_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Stddev_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_UploadableElement_Sum_Fields = {
  readonly __typename?: 'content_UploadableElement_sum_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Sum_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** update columns of table "content.UploadableElement" */
export enum Content_UploadableElement_Update_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  TypeName = 'typeName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** aggregate var_pop on columns */
export type Content_UploadableElement_Var_Pop_Fields = {
  readonly __typename?: 'content_UploadableElement_var_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Var_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_UploadableElement_Var_Samp_Fields = {
  readonly __typename?: 'content_UploadableElement_var_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Var_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_UploadableElement_Variance_Fields = {
  readonly __typename?: 'content_UploadableElement_variance_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.UploadableElement" */
export type Content_UploadableElement_Variance_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** columns and relationships of "content.Uploader" */
export type Content_Uploader = {
  readonly __typename?: 'content_Uploader';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly email: Scalars['String'];
  readonly emailsSentCount: Scalars['Int'];
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly uploadableElement: Content_UploadableElement;
  readonly uploadableElementId: Scalars['uuid'];
};

/** aggregated selection of "content.Uploader" */
export type Content_Uploader_Aggregate = {
  readonly __typename?: 'content_Uploader_aggregate';
  readonly aggregate?: Maybe<Content_Uploader_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Content_Uploader>;
};

/** aggregate fields of "content.Uploader" */
export type Content_Uploader_Aggregate_Fields = {
  readonly __typename?: 'content_Uploader_aggregate_fields';
  readonly avg?: Maybe<Content_Uploader_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Content_Uploader_Max_Fields>;
  readonly min?: Maybe<Content_Uploader_Min_Fields>;
  readonly stddev?: Maybe<Content_Uploader_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Content_Uploader_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Content_Uploader_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Content_Uploader_Sum_Fields>;
  readonly var_pop?: Maybe<Content_Uploader_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Content_Uploader_Var_Samp_Fields>;
  readonly variance?: Maybe<Content_Uploader_Variance_Fields>;
};


/** aggregate fields of "content.Uploader" */
export type Content_Uploader_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "content.Uploader" */
export type Content_Uploader_Aggregate_Order_By = {
  readonly avg?: Maybe<Content_Uploader_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Content_Uploader_Max_Order_By>;
  readonly min?: Maybe<Content_Uploader_Min_Order_By>;
  readonly stddev?: Maybe<Content_Uploader_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Content_Uploader_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Content_Uploader_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Content_Uploader_Sum_Order_By>;
  readonly var_pop?: Maybe<Content_Uploader_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Content_Uploader_Var_Samp_Order_By>;
  readonly variance?: Maybe<Content_Uploader_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "content.Uploader" */
export type Content_Uploader_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Content_Uploader_Insert_Input>;
  readonly on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};

/** aggregate avg on columns */
export type Content_Uploader_Avg_Fields = {
  readonly __typename?: 'content_Uploader_avg_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "content.Uploader" */
export type Content_Uploader_Avg_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "content.Uploader". All fields are combined with a logical 'AND'. */
export type Content_Uploader_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Content_Uploader_Bool_Exp>>>;
  readonly _not?: Maybe<Content_Uploader_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Content_Uploader_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emailsSentCount?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadableElement?: Maybe<Content_UploadableElement_Bool_Exp>;
  readonly uploadableElementId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "content.Uploader" */
export enum Content_Uploader_Constraint {
  /** unique or primary key constraint */
  UploaderEmailUploadableElementIdKey = 'Uploader_email_uploadableElementId_key',
  /** unique or primary key constraint */
  UploaderPkey = 'Uploader_pkey'
}

/** input type for incrementing integer column in table "content.Uploader" */
export type Content_Uploader_Inc_Input = {
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "content.Uploader" */
export type Content_Uploader_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableElement?: Maybe<Content_UploadableElement_Obj_Rel_Insert_Input>;
  readonly uploadableElementId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Content_Uploader_Max_Fields = {
  readonly __typename?: 'content_Uploader_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableElementId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "content.Uploader" */
export type Content_Uploader_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableElementId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Content_Uploader_Min_Fields = {
  readonly __typename?: 'content_Uploader_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableElementId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "content.Uploader" */
export type Content_Uploader_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableElementId?: Maybe<Order_By>;
};

/** response of any mutation on the table "content.Uploader" */
export type Content_Uploader_Mutation_Response = {
  readonly __typename?: 'content_Uploader_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Content_Uploader>;
};

/** input type for inserting object relation for remote table "content.Uploader" */
export type Content_Uploader_Obj_Rel_Insert_Input = {
  readonly data: Content_Uploader_Insert_Input;
  readonly on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};

/** on conflict condition type for table "content.Uploader" */
export type Content_Uploader_On_Conflict = {
  readonly constraint: Content_Uploader_Constraint;
  readonly update_columns: ReadonlyArray<Content_Uploader_Update_Column>;
  readonly where?: Maybe<Content_Uploader_Bool_Exp>;
};

/** ordering options when selecting data from "content.Uploader" */
export type Content_Uploader_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadableElement?: Maybe<Content_UploadableElement_Order_By>;
  readonly uploadableElementId?: Maybe<Order_By>;
};

/** primary key columns input for table: "content.Uploader" */
export type Content_Uploader_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "content.Uploader" */
export enum Content_Uploader_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadableElementId = 'uploadableElementId'
}

/** input type for updating data in table "content.Uploader" */
export type Content_Uploader_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadableElementId?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Content_Uploader_Stddev_Fields = {
  readonly __typename?: 'content_Uploader_stddev_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "content.Uploader" */
export type Content_Uploader_Stddev_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Content_Uploader_Stddev_Pop_Fields = {
  readonly __typename?: 'content_Uploader_stddev_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "content.Uploader" */
export type Content_Uploader_Stddev_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Content_Uploader_Stddev_Samp_Fields = {
  readonly __typename?: 'content_Uploader_stddev_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "content.Uploader" */
export type Content_Uploader_Stddev_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Content_Uploader_Sum_Fields = {
  readonly __typename?: 'content_Uploader_sum_fields';
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "content.Uploader" */
export type Content_Uploader_Sum_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** update columns of table "content.Uploader" */
export enum Content_Uploader_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadableElementId = 'uploadableElementId'
}

/** aggregate var_pop on columns */
export type Content_Uploader_Var_Pop_Fields = {
  readonly __typename?: 'content_Uploader_var_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "content.Uploader" */
export type Content_Uploader_Var_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Content_Uploader_Var_Samp_Fields = {
  readonly __typename?: 'content_Uploader_var_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "content.Uploader" */
export type Content_Uploader_Var_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Content_Uploader_Variance_Fields = {
  readonly __typename?: 'content_Uploader_variance_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "content.Uploader" */
export type Content_Uploader_Variance_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** columns and relationships of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly stackLogicalResourceId: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_ChannelStackCreateJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
};

/** aggregate fields of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_ChannelStackCreateJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_ChannelStackCreateJob_Min_Fields>;
};


/** aggregate fields of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_ChannelStackCreateJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_ChannelStackCreateJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.ChannelStackCreateJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_ChannelStackCreateJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly stackLogicalResourceId?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Constraint {
  /** unique or primary key constraint */
  ChannelStackCreateJobPkey = 'ChannelStackCreateJob_pkey',
  /** unique or primary key constraint */
  ChannelStackCreateJobStackLogicalResourceIdKey = 'ChannelStackCreateJob_stackLogicalResourceId_key'
}

/** input type for inserting data into table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_ChannelStackCreateJob_Max_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_ChannelStackCreateJob_Min_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Mutation_Response = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
};

/** input type for inserting object relation for remote table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_ChannelStackCreateJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_On_Conflict = {
  readonly constraint: Job_Queues_ChannelStackCreateJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StackLogicalResourceId = 'stackLogicalResourceId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StackLogicalResourceId = 'stackLogicalResourceId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob';
  readonly cloudFormationStackArn: Scalars['String'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly mediaLiveChannelId: Scalars['String'];
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Aggregate = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_ChannelStackDeleteJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
};

/** aggregate fields of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_ChannelStackDeleteJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_ChannelStackDeleteJob_Min_Fields>;
};


/** aggregate fields of "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_ChannelStackDeleteJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_ChannelStackDeleteJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackDeleteJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.ChannelStackDeleteJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_ChannelStackDeleteJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>>>;
  readonly cloudFormationStackArn?: Maybe<String_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.ChannelStackDeleteJob" */
export enum Job_Queues_ChannelStackDeleteJob_Constraint {
  /** unique or primary key constraint */
  ChannelStackDeleteJobPkey = 'ChannelStackDeleteJob_pkey'
}

/** input type for inserting data into table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Insert_Input = {
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_ChannelStackDeleteJob_Max_Fields = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_max_fields';
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Max_Order_By = {
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_ChannelStackDeleteJob_Min_Fields = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_min_fields';
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Min_Order_By = {
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Mutation_Response = {
  readonly __typename?: 'job_queues_ChannelStackDeleteJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
};

/** input type for inserting object relation for remote table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_ChannelStackDeleteJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackDeleteJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_On_Conflict = {
  readonly constraint: Job_Queues_ChannelStackDeleteJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Order_By = {
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.ChannelStackDeleteJob" */
export enum Job_Queues_ChannelStackDeleteJob_Select_Column {
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "job_queues.ChannelStackDeleteJob" */
export type Job_Queues_ChannelStackDeleteJob_Set_Input = {
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.ChannelStackDeleteJob" */
export enum Job_Queues_ChannelStackDeleteJob_Update_Column {
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob = {
  readonly __typename?: 'job_queues_CombineVideosJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName: Scalars['String'];
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJobDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate = {
  readonly __typename?: 'job_queues_CombineVideosJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_CombineVideosJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_CombineVideosJob>;
};

/** aggregate fields of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_CombineVideosJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_CombineVideosJob_Min_Fields>;
};


/** aggregate fields of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_CombineVideosJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_CombineVideosJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CombineVideosJob_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_CombineVideosJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.CombineVideosJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_CombineVideosJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_CombineVideosJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_CombineVideosJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdByRegistrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly mediaConvertJobId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly outputName?: Maybe<String_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Constraint {
  /** unique or primary key constraint */
  CombineVideosJobPkey = 'CombineVideosJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_CombineVideosJob_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_CombineVideosJob_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_CombineVideosJob_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_CombineVideosJob_Max_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdByRegistrantId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaConvertJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly outputName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_CombineVideosJob_Min_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdByRegistrantId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaConvertJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly outputName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Mutation_Response = {
  readonly __typename?: 'job_queues_CombineVideosJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_CombineVideosJob>;
};

/** input type for inserting object relation for remote table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_CombineVideosJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_On_Conflict = {
  readonly constraint: Job_Queues_CombineVideosJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_CombineVideosJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdByRegistrantId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaConvertJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly outputName?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CombineVideosJob_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedByRegistrantId = 'createdByRegistrantId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaConvertJobId = 'mediaConvertJobId',
  /** column name */
  Message = 'message',
  /** column name */
  OutputName = 'outputName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByRegistrantId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedByRegistrantId = 'createdByRegistrantId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaConvertJobId = 'mediaConvertJobId',
  /** column name */
  Message = 'message',
  /** column name */
  OutputName = 'outputName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob = {
  readonly __typename?: 'job_queues_CustomEmailJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly htmlBody: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly registrantIds: Scalars['jsonb'];
  readonly subject: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJobRegistrantIdsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_CustomEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_CustomEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_CustomEmailJob>;
};

/** aggregate fields of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_CustomEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_CustomEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_CustomEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_CustomEmailJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CustomEmailJob_Append_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_CustomEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.CustomEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_CustomEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_CustomEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_CustomEmailJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly htmlBody?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly registrantIds?: Maybe<Jsonb_Comparison_Exp>;
  readonly subject?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Constraint {
  /** unique or primary key constraint */
  CustomEmailJobPkey = 'CustomEmailJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_CustomEmailJob_Delete_At_Path_Input = {
  readonly registrantIds?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_CustomEmailJob_Delete_Elem_Input = {
  readonly registrantIds?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_CustomEmailJob_Delete_Key_Input = {
  readonly registrantIds?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_CustomEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly htmlBody?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_CustomEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly htmlBody?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_CustomEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_CustomEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_CustomEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_CustomEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_CustomEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly htmlBody?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly registrantIds?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CustomEmailJob_Prepend_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HtmlBody = 'htmlBody',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HtmlBody = 'htmlBody',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob = {
  readonly __typename?: 'job_queues_InvitationEmailJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly registrantIds: Scalars['jsonb'];
  readonly sendRepeat: Scalars['Boolean'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJobRegistrantIdsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_InvitationEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_InvitationEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_InvitationEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_InvitationEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_InvitationEmailJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Append_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_InvitationEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.InvitationEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_InvitationEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly registrantIds?: Maybe<Jsonb_Comparison_Exp>;
  readonly sendRepeat?: Maybe<Boolean_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Constraint {
  /** unique or primary key constraint */
  InvitationEmailJobsPkey = 'InvitationEmailJobs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_InvitationEmailJob_Delete_At_Path_Input = {
  readonly registrantIds?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_InvitationEmailJob_Delete_Elem_Input = {
  readonly registrantIds?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_InvitationEmailJob_Delete_Key_Input = {
  readonly registrantIds?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_InvitationEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_InvitationEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_InvitationEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_InvitationEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_InvitationEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly registrantIds?: Maybe<Order_By>;
  readonly sendRepeat?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Prepend_Input = {
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly registrantIds?: Maybe<Scalars['jsonb']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  RegistrantIds = 'registrantIds',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_MediaPackageHarvestJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_MediaPackageHarvestJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_MediaPackageHarvestJob_Min_Fields>;
};


/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_MediaPackageHarvestJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_MediaPackageHarvestJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.MediaPackageHarvestJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_MediaPackageHarvestJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly mediaPackageHarvestJobId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Constraint {
  /** unique or primary key constraint */
  MediaPackageHarvestJobMediaPackageHarvestJobIdKey = 'MediaPackageHarvestJob_mediaPackageHarvestJobId_key',
  /** unique or primary key constraint */
  MediaPackageHarvestJobPkey = 'MediaPackageHarvestJob_pkey'
}

/** input type for inserting data into table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_MediaPackageHarvestJob_Max_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_MediaPackageHarvestJob_Min_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Mutation_Response = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** input type for inserting object relation for remote table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_MediaPackageHarvestJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_On_Conflict = {
  readonly constraint: Job_Queues_MediaPackageHarvestJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob = {
  readonly __typename?: 'job_queues_PublishVideoJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element: Content_Element;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly jobStatusName: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_PublishVideoJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_PublishVideoJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_PublishVideoJob_Min_Fields>;
};


/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_PublishVideoJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_PublishVideoJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_PublishVideoJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.PublishVideoJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_PublishVideoJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_PublishVideoJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_PublishVideoJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatusName?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vimeoVideoUrl?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Constraint {
  /** unique or primary key constraint */
  PublishVideoJobPkey = 'PublishVideoJob_pkey'
}

/** input type for inserting data into table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Job_Queues_PublishVideoJob_Max_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_PublishVideoJob_Min_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Mutation_Response = {
  readonly __typename?: 'job_queues_PublishVideoJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** input type for inserting object relation for remote table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_PublishVideoJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_On_Conflict = {
  readonly constraint: Job_Queues_PublishVideoJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_PublishVideoJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** input type for updating data in table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** update columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** columns and relationships of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob';
  readonly created_at: Scalars['timestamptz'];
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly updated_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly uploader: Content_Uploader;
  readonly uploaderId: Scalars['uuid'];
};


/** columns and relationships of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJobEmailTemplateArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_SubmissionRequestEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_SubmissionRequestEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_SubmissionRequestEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_SubmissionRequestEmailJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_SubmissionRequestEmailJob_Append_Input = {
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.SubmissionRequestEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_SubmissionRequestEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emailTemplate?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploader?: Maybe<Content_Uploader_Bool_Exp>;
  readonly uploaderId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Constraint {
  /** unique or primary key constraint */
  SubmissionRequestEmailJobPkey = 'SubmissionRequestEmailJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input = {
  readonly emailTemplate?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input = {
  readonly emailTemplate?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input = {
  readonly emailTemplate?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploader?: Maybe<Content_Uploader_Obj_Rel_Insert_Input>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Job_Queues_SubmissionRequestEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_SubmissionRequestEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_SubmissionRequestEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_SubmissionRequestEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly emailTemplate?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploader?: Maybe<Content_Uploader_Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_SubmissionRequestEmailJob_Prepend_Input = {
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailTemplate = 'emailTemplate',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}

/** input type for updating data in table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailTemplate = 'emailTemplate',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}

/** columns and relationships of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element: Content_Element;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly registrantGoogleAccount: Registrant_GoogleAccount;
  readonly registrantGoogleAccountId: Scalars['uuid'];
  readonly retriesCount: Scalars['Int'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly videoDescription: Scalars['String'];
  readonly videoPrivacyStatus: Scalars['String'];
  readonly videoTitle: Scalars['String'];
};

/** aggregated selection of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_UploadYouTubeVideoJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
};

/** aggregate fields of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_aggregate_fields';
  readonly avg?: Maybe<Job_Queues_UploadYouTubeVideoJob_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_UploadYouTubeVideoJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_UploadYouTubeVideoJob_Min_Fields>;
  readonly stddev?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Job_Queues_UploadYouTubeVideoJob_Sum_Fields>;
  readonly var_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Samp_Fields>;
  readonly variance?: Maybe<Job_Queues_UploadYouTubeVideoJob_Variance_Fields>;
};


/** aggregate fields of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_Order_By = {
  readonly avg?: Maybe<Job_Queues_UploadYouTubeVideoJob_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_UploadYouTubeVideoJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_UploadYouTubeVideoJob_Min_Order_By>;
  readonly stddev?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Job_Queues_UploadYouTubeVideoJob_Sum_Order_By>;
  readonly var_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Samp_Order_By>;
  readonly variance?: Maybe<Job_Queues_UploadYouTubeVideoJob_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};

/** aggregate avg on columns */
export type Job_Queues_UploadYouTubeVideoJob_Avg_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "job_queues.UploadYouTubeVideoJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_UploadYouTubeVideoJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly playlistId?: Maybe<String_Comparison_Exp>;
  readonly registrantGoogleAccount?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
  readonly registrantGoogleAccountId?: Maybe<Uuid_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoDescription?: Maybe<String_Comparison_Exp>;
  readonly videoPrivacyStatus?: Maybe<String_Comparison_Exp>;
  readonly videoTitle?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Constraint {
  /** unique or primary key constraint */
  UploadYouTubeVideoJobPkey = 'UploadYouTubeVideoJob_pkey'
}

/** input type for incrementing integer column in table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccount?: Maybe<Registrant_GoogleAccount_Obj_Rel_Insert_Input>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Job_Queues_UploadYouTubeVideoJob_Max_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly playlistId?: Maybe<Order_By>;
  readonly registrantGoogleAccountId?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoDescription?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_UploadYouTubeVideoJob_Min_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly playlistId?: Maybe<Order_By>;
  readonly registrantGoogleAccountId?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoDescription?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Mutation_Response = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
};

/** input type for inserting object relation for remote table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_UploadYouTubeVideoJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_On_Conflict = {
  readonly constraint: Job_Queues_UploadYouTubeVideoJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly playlistId?: Maybe<Order_By>;
  readonly registrantGoogleAccount?: Maybe<Registrant_GoogleAccount_Order_By>;
  readonly registrantGoogleAccountId?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoDescription?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  PlaylistId = 'playlistId',
  /** column name */
  RegistrantGoogleAccountId = 'registrantGoogleAccountId',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoDescription = 'videoDescription',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** input type for updating data in table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly registrantGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Job_Queues_UploadYouTubeVideoJob_Sum_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  PlaylistId = 'playlistId',
  /** column name */
  RegistrantGoogleAccountId = 'registrantGoogleAccountId',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoDescription = 'videoDescription',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** aggregate var_pop on columns */
export type Job_Queues_UploadYouTubeVideoJob_Var_Pop_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Job_Queues_UploadYouTubeVideoJob_Var_Samp_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Job_Queues_UploadYouTubeVideoJob_Variance_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};


/** expression to compare columns of type json. All fields are combined with logical 'AND'. */
export type Json_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['json']>;
  readonly _gt?: Maybe<Scalars['json']>;
  readonly _gte?: Maybe<Scalars['json']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['json']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['json']>;
  readonly _lte?: Maybe<Scalars['json']>;
  readonly _neq?: Maybe<Scalars['json']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['json']>>;
};


/** expression to compare columns of type jsonb. All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  /** is the column contained in the given json value */
  readonly _contained_in?: Maybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  readonly _contains?: Maybe<Scalars['jsonb']>;
  readonly _eq?: Maybe<Scalars['jsonb']>;
  readonly _gt?: Maybe<Scalars['jsonb']>;
  readonly _gte?: Maybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  readonly _has_key?: Maybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  readonly _has_keys_all?: Maybe<ReadonlyArray<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  readonly _has_keys_any?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['jsonb']>;
  readonly _lte?: Maybe<Scalars['jsonb']>;
  readonly _neq?: Maybe<Scalars['jsonb']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
};

/** mutation root */
export type Mutation_Root = {
  readonly __typename?: 'mutation_root';
  /** perform the action: "createItemRoom" */
  readonly createItemRoom?: Maybe<CreateItemRoomOutput>;
  /** perform the action: "createRoomDm" */
  readonly createRoomDm?: Maybe<CreateRoomDmOutput>;
  /** delete data from the table: "Email" */
  readonly delete_Email?: Maybe<Email_Mutation_Response>;
  /** delete single row from the table: "Email" */
  readonly delete_Email_by_pk?: Maybe<Email>;
  /** delete data from the table: "PushNotificationSubscription" */
  readonly delete_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** delete single row from the table: "PushNotificationSubscription" */
  readonly delete_PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** delete data from the table: "User" */
  readonly delete_User?: Maybe<User_Mutation_Response>;
  /** delete single row from the table: "User" */
  readonly delete_User_by_pk?: Maybe<User>;
  /** delete data from the table: "analytics.AppStats" */
  readonly delete_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** delete single row from the table: "analytics.AppStats" */
  readonly delete_analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** delete data from the table: "analytics.ContentElementStats" */
  readonly delete_analytics_ContentElementStats?: Maybe<Analytics_ContentElementStats_Mutation_Response>;
  /** delete single row from the table: "analytics.ContentElementStats" */
  readonly delete_analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** delete data from the table: "analytics.ContentItemStats" */
  readonly delete_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** delete single row from the table: "analytics.ContentItemStats" */
  readonly delete_analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** delete data from the table: "analytics.RoomStats" */
  readonly delete_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** delete single row from the table: "analytics.RoomStats" */
  readonly delete_analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** delete data from the table: "chat.Chat" */
  readonly delete_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** delete single row from the table: "chat.Chat" */
  readonly delete_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** delete data from the table: "chat.Flag" */
  readonly delete_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** delete data from the table: "chat.FlagType" */
  readonly delete_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** delete single row from the table: "chat.FlagType" */
  readonly delete_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** delete single row from the table: "chat.Flag" */
  readonly delete_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** delete data from the table: "chat.Message" */
  readonly delete_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** delete data from the table: "chat.MessageType" */
  readonly delete_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** delete single row from the table: "chat.MessageType" */
  readonly delete_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** delete single row from the table: "chat.Message" */
  readonly delete_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** delete data from the table: "chat.Pin" */
  readonly delete_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** delete single row from the table: "chat.Pin" */
  readonly delete_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** delete data from the table: "chat.Reaction" */
  readonly delete_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** delete data from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** delete single row from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** delete single row from the table: "chat.Reaction" */
  readonly delete_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** delete data from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** delete single row from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** delete data from the table: "chat.Subscription" */
  readonly delete_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** delete single row from the table: "chat.Subscription" */
  readonly delete_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** delete data from the table: "collection.Exhibition" */
  readonly delete_collection_Exhibition?: Maybe<Collection_Exhibition_Mutation_Response>;
  /** delete single row from the table: "collection.Exhibition" */
  readonly delete_collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** delete data from the table: "collection.ProgramPerson" */
  readonly delete_collection_ProgramPerson?: Maybe<Collection_ProgramPerson_Mutation_Response>;
  /** delete single row from the table: "collection.ProgramPerson" */
  readonly delete_collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** delete data from the table: "collection.Tag" */
  readonly delete_collection_Tag?: Maybe<Collection_Tag_Mutation_Response>;
  /** delete single row from the table: "collection.Tag" */
  readonly delete_collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** delete data from the table: "conference.Conference" */
  readonly delete_conference_Conference?: Maybe<Conference_Conference_Mutation_Response>;
  /** delete single row from the table: "conference.Conference" */
  readonly delete_conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** delete data from the table: "conference.Configuration" */
  readonly delete_conference_Configuration?: Maybe<Conference_Configuration_Mutation_Response>;
  /** delete single row from the table: "conference.Configuration" */
  readonly delete_conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** delete data from the table: "conference.DemoCode" */
  readonly delete_conference_DemoCode?: Maybe<Conference_DemoCode_Mutation_Response>;
  /** delete single row from the table: "conference.DemoCode" */
  readonly delete_conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** delete data from the table: "conference.OriginatingData" */
  readonly delete_conference_OriginatingData?: Maybe<Conference_OriginatingData_Mutation_Response>;
  /** delete single row from the table: "conference.OriginatingData" */
  readonly delete_conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** delete data from the table: "conference.PrepareJob" */
  readonly delete_conference_PrepareJob?: Maybe<Conference_PrepareJob_Mutation_Response>;
  /** delete single row from the table: "conference.PrepareJob" */
  readonly delete_conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** delete data from the table: "content.Element" */
  readonly delete_content_Element?: Maybe<Content_Element_Mutation_Response>;
  /** delete data from the table: "content.ElementPermissionGrant" */
  readonly delete_content_ElementPermissionGrant?: Maybe<Content_ElementPermissionGrant_Mutation_Response>;
  /** delete single row from the table: "content.ElementPermissionGrant" */
  readonly delete_content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** delete data from the table: "content.ElementType" */
  readonly delete_content_ElementType?: Maybe<Content_ElementType_Mutation_Response>;
  /** delete single row from the table: "content.ElementType" */
  readonly delete_content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** delete single row from the table: "content.Element" */
  readonly delete_content_Element_by_pk?: Maybe<Content_Element>;
  /** delete data from the table: "content.Item" */
  readonly delete_content_Item?: Maybe<Content_Item_Mutation_Response>;
  /** delete data from the table: "content.ItemExhibition" */
  readonly delete_content_ItemExhibition?: Maybe<Content_ItemExhibition_Mutation_Response>;
  /** delete single row from the table: "content.ItemExhibition" */
  readonly delete_content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** delete data from the table: "content.ItemProgramPerson" */
  readonly delete_content_ItemProgramPerson?: Maybe<Content_ItemProgramPerson_Mutation_Response>;
  /** delete single row from the table: "content.ItemProgramPerson" */
  readonly delete_content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** delete data from the table: "content.ItemTag" */
  readonly delete_content_ItemTag?: Maybe<Content_ItemTag_Mutation_Response>;
  /** delete single row from the table: "content.ItemTag" */
  readonly delete_content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** delete data from the table: "content.ItemType" */
  readonly delete_content_ItemType?: Maybe<Content_ItemType_Mutation_Response>;
  /** delete single row from the table: "content.ItemType" */
  readonly delete_content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** delete single row from the table: "content.Item" */
  readonly delete_content_Item_by_pk?: Maybe<Content_Item>;
  /** delete data from the table: "content.UploadableElement" */
  readonly delete_content_UploadableElement?: Maybe<Content_UploadableElement_Mutation_Response>;
  /** delete data from the table: "content.UploadableElementPermissionGrant" */
  readonly delete_content_UploadableElementPermissionGrant?: Maybe<Content_UploadableElementPermissionGrant_Mutation_Response>;
  /** delete single row from the table: "content.UploadableElementPermissionGrant" */
  readonly delete_content_UploadableElementPermissionGrant_by_pk?: Maybe<Content_UploadableElementPermissionGrant>;
  /** delete single row from the table: "content.UploadableElement" */
  readonly delete_content_UploadableElement_by_pk?: Maybe<Content_UploadableElement>;
  /** delete data from the table: "content.Uploader" */
  readonly delete_content_Uploader?: Maybe<Content_Uploader_Mutation_Response>;
  /** delete single row from the table: "content.Uploader" */
  readonly delete_content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** delete data from the table: "job_queues.ChannelStackCreateJob" */
  readonly delete_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.ChannelStackCreateJob" */
  readonly delete_job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** delete data from the table: "job_queues.ChannelStackDeleteJob" */
  readonly delete_job_queues_ChannelStackDeleteJob?: Maybe<Job_Queues_ChannelStackDeleteJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.ChannelStackDeleteJob" */
  readonly delete_job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** delete data from the table: "job_queues.CombineVideosJob" */
  readonly delete_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.CombineVideosJob" */
  readonly delete_job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** delete data from the table: "job_queues.CustomEmailJob" */
  readonly delete_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.CustomEmailJob" */
  readonly delete_job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** delete data from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** delete data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** delete data from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** delete data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** delete data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly delete_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly delete_job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** delete data from the table: "permissions.Group" */
  readonly delete_permissions_Group?: Maybe<Permissions_Group_Mutation_Response>;
  /** delete data from the table: "permissions.GroupRegistrant" */
  readonly delete_permissions_GroupRegistrant?: Maybe<Permissions_GroupRegistrant_Mutation_Response>;
  /** delete single row from the table: "permissions.GroupRegistrant" */
  readonly delete_permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** delete data from the table: "permissions.GroupRole" */
  readonly delete_permissions_GroupRole?: Maybe<Permissions_GroupRole_Mutation_Response>;
  /** delete single row from the table: "permissions.GroupRole" */
  readonly delete_permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** delete single row from the table: "permissions.Group" */
  readonly delete_permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** delete data from the table: "permissions.Permission" */
  readonly delete_permissions_Permission?: Maybe<Permissions_Permission_Mutation_Response>;
  /** delete single row from the table: "permissions.Permission" */
  readonly delete_permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** delete data from the table: "permissions.Role" */
  readonly delete_permissions_Role?: Maybe<Permissions_Role_Mutation_Response>;
  /** delete data from the table: "permissions.RolePermission" */
  readonly delete_permissions_RolePermission?: Maybe<Permissions_RolePermission_Mutation_Response>;
  /** delete single row from the table: "permissions.RolePermission" */
  readonly delete_permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** delete single row from the table: "permissions.Role" */
  readonly delete_permissions_Role_by_pk?: Maybe<Permissions_Role>;
  /** delete data from the table: "registrant.GoogleAccount" */
  readonly delete_registrant_GoogleAccount?: Maybe<Registrant_GoogleAccount_Mutation_Response>;
  /** delete single row from the table: "registrant.GoogleAccount" */
  readonly delete_registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** delete data from the table: "registrant.Invitation" */
  readonly delete_registrant_Invitation?: Maybe<Registrant_Invitation_Mutation_Response>;
  /** delete single row from the table: "registrant.Invitation" */
  readonly delete_registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** delete data from the table: "registrant.Profile" */
  readonly delete_registrant_Profile?: Maybe<Registrant_Profile_Mutation_Response>;
  /** delete single row from the table: "registrant.Profile" */
  readonly delete_registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** delete data from the table: "registrant.Registrant" */
  readonly delete_registrant_Registrant?: Maybe<Registrant_Registrant_Mutation_Response>;
  /** delete single row from the table: "registrant.Registrant" */
  readonly delete_registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** delete data from the table: "room.Backend" */
  readonly delete_room_Backend?: Maybe<Room_Backend_Mutation_Response>;
  /** delete single row from the table: "room.Backend" */
  readonly delete_room_Backend_by_pk?: Maybe<Room_Backend>;
  /** delete data from the table: "room.ChimeMeeting" */
  readonly delete_room_ChimeMeeting?: Maybe<Room_ChimeMeeting_Mutation_Response>;
  /** delete single row from the table: "room.ChimeMeeting" */
  readonly delete_room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** delete data from the table: "room.ManagementMode" */
  readonly delete_room_ManagementMode?: Maybe<Room_ManagementMode_Mutation_Response>;
  /** delete single row from the table: "room.ManagementMode" */
  readonly delete_room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** delete data from the table: "room.Mode" */
  readonly delete_room_Mode?: Maybe<Room_Mode_Mutation_Response>;
  /** delete single row from the table: "room.Mode" */
  readonly delete_room_Mode_by_pk?: Maybe<Room_Mode>;
  /** delete data from the table: "room.Participant" */
  readonly delete_room_Participant?: Maybe<Room_Participant_Mutation_Response>;
  /** delete single row from the table: "room.Participant" */
  readonly delete_room_Participant_by_pk?: Maybe<Room_Participant>;
  /** delete data from the table: "room.PersonRole" */
  readonly delete_room_PersonRole?: Maybe<Room_PersonRole_Mutation_Response>;
  /** delete single row from the table: "room.PersonRole" */
  readonly delete_room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** delete data from the table: "room.Room" */
  readonly delete_room_Room?: Maybe<Room_Room_Mutation_Response>;
  /** delete data from the table: "room.RoomPerson" */
  readonly delete_room_RoomPerson?: Maybe<Room_RoomPerson_Mutation_Response>;
  /** delete single row from the table: "room.RoomPerson" */
  readonly delete_room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** delete single row from the table: "room.Room" */
  readonly delete_room_Room_by_pk?: Maybe<Room_Room>;
  /** delete data from the table: "room.ShuffleAlgorithm" */
  readonly delete_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleAlgorithm" */
  readonly delete_room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** delete data from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** delete single row from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** delete data from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** delete data from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** delete data from the table: "schedule.Event" */
  readonly delete_schedule_Event?: Maybe<Schedule_Event_Mutation_Response>;
  /** delete data from the table: "schedule.EventProgramPerson" */
  readonly delete_schedule_EventProgramPerson?: Maybe<Schedule_EventProgramPerson_Mutation_Response>;
  /** delete data from the table: "schedule.EventProgramPersonRole" */
  readonly delete_schedule_EventProgramPersonRole?: Maybe<Schedule_EventProgramPersonRole_Mutation_Response>;
  /** delete single row from the table: "schedule.EventProgramPersonRole" */
  readonly delete_schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** delete single row from the table: "schedule.EventProgramPerson" */
  readonly delete_schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** delete data from the table: "schedule.EventRoomJoinRequest" */
  readonly delete_schedule_EventRoomJoinRequest?: Maybe<Schedule_EventRoomJoinRequest_Mutation_Response>;
  /** delete single row from the table: "schedule.EventRoomJoinRequest" */
  readonly delete_schedule_EventRoomJoinRequest_by_pk?: Maybe<Schedule_EventRoomJoinRequest>;
  /** delete data from the table: "schedule.EventTag" */
  readonly delete_schedule_EventTag?: Maybe<Schedule_EventTag_Mutation_Response>;
  /** delete single row from the table: "schedule.EventTag" */
  readonly delete_schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** delete single row from the table: "schedule.Event" */
  readonly delete_schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** delete data from the table: "system.Configuration" */
  readonly delete_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** delete data from the table: "system.ConfigurationKey" */
  readonly delete_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** delete single row from the table: "system.ConfigurationKey" */
  readonly delete_system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** delete single row from the table: "system.Configuration" */
  readonly delete_system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** delete data from the table: "video.ChannelStack" */
  readonly delete_video_ChannelStack?: Maybe<Video_ChannelStack_Mutation_Response>;
  /** delete single row from the table: "video.ChannelStack" */
  readonly delete_video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** delete data from the table: "video.EventParticipantStream" */
  readonly delete_video_EventParticipantStream?: Maybe<Video_EventParticipantStream_Mutation_Response>;
  /** delete single row from the table: "video.EventParticipantStream" */
  readonly delete_video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** delete data from the table: "video.EventVonageSession" */
  readonly delete_video_EventVonageSession?: Maybe<Video_EventVonageSession_Mutation_Response>;
  /** delete single row from the table: "video.EventVonageSession" */
  readonly delete_video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** delete data from the table: "video.ImmediateSwitch" */
  readonly delete_video_ImmediateSwitch?: Maybe<Video_ImmediateSwitch_Mutation_Response>;
  /** delete single row from the table: "video.ImmediateSwitch" */
  readonly delete_video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** delete data from the table: "video.InputType" */
  readonly delete_video_InputType?: Maybe<Video_InputType_Mutation_Response>;
  /** delete single row from the table: "video.InputType" */
  readonly delete_video_InputType_by_pk?: Maybe<Video_InputType>;
  /** delete data from the table: "video.JobStatus" */
  readonly delete_video_JobStatus?: Maybe<Video_JobStatus_Mutation_Response>;
  /** delete single row from the table: "video.JobStatus" */
  readonly delete_video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** delete data from the table: "video.MediaLiveChannelStatus" */
  readonly delete_video_MediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Mutation_Response>;
  /** delete single row from the table: "video.MediaLiveChannelStatus" */
  readonly delete_video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** delete data from the table: "video.RtmpInput" */
  readonly delete_video_RtmpInput?: Maybe<Video_RtmpInput_Mutation_Response>;
  /** delete single row from the table: "video.RtmpInput" */
  readonly delete_video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** delete data from the table: "video.TranscriptionJob" */
  readonly delete_video_TranscriptionJob?: Maybe<Video_TranscriptionJob_Mutation_Response>;
  /** delete single row from the table: "video.TranscriptionJob" */
  readonly delete_video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** delete data from the table: "video.VideoRenderJob" */
  readonly delete_video_VideoRenderJob?: Maybe<Video_VideoRenderJob_Mutation_Response>;
  /** delete single row from the table: "video.VideoRenderJob" */
  readonly delete_video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** delete data from the table: "video.YouTubeUpload" */
  readonly delete_video_YouTubeUpload?: Maybe<Video_YouTubeUpload_Mutation_Response>;
  /** delete single row from the table: "video.YouTubeUpload" */
  readonly delete_video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
  /** perform the action: "getGoogleOAuthUrl" */
  readonly getGoogleOAuthUrl?: Maybe<GetGoogleOAuthUrlOutput>;
  /** insert data into the table: "Email" */
  readonly insert_Email?: Maybe<Email_Mutation_Response>;
  /** insert a single row into the table: "Email" */
  readonly insert_Email_one?: Maybe<Email>;
  /** insert data into the table: "PushNotificationSubscription" */
  readonly insert_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** insert a single row into the table: "PushNotificationSubscription" */
  readonly insert_PushNotificationSubscription_one?: Maybe<PushNotificationSubscription>;
  /** insert data into the table: "User" */
  readonly insert_User?: Maybe<User_Mutation_Response>;
  /** insert a single row into the table: "User" */
  readonly insert_User_one?: Maybe<User>;
  /** insert data into the table: "analytics.AppStats" */
  readonly insert_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.AppStats" */
  readonly insert_analytics_AppStats_one?: Maybe<Analytics_AppStats>;
  /** insert data into the table: "analytics.ContentElementStats" */
  readonly insert_analytics_ContentElementStats?: Maybe<Analytics_ContentElementStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.ContentElementStats" */
  readonly insert_analytics_ContentElementStats_one?: Maybe<Analytics_ContentElementStats>;
  /** insert data into the table: "analytics.ContentItemStats" */
  readonly insert_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.ContentItemStats" */
  readonly insert_analytics_ContentItemStats_one?: Maybe<Analytics_ContentItemStats>;
  /** insert data into the table: "analytics.RoomStats" */
  readonly insert_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.RoomStats" */
  readonly insert_analytics_RoomStats_one?: Maybe<Analytics_RoomStats>;
  /** insert data into the table: "chat.Chat" */
  readonly insert_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** insert a single row into the table: "chat.Chat" */
  readonly insert_chat_Chat_one?: Maybe<Chat_Chat>;
  /** insert data into the table: "chat.Flag" */
  readonly insert_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** insert data into the table: "chat.FlagType" */
  readonly insert_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** insert a single row into the table: "chat.FlagType" */
  readonly insert_chat_FlagType_one?: Maybe<Chat_FlagType>;
  /** insert a single row into the table: "chat.Flag" */
  readonly insert_chat_Flag_one?: Maybe<Chat_Flag>;
  /** insert data into the table: "chat.Message" */
  readonly insert_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** insert data into the table: "chat.MessageType" */
  readonly insert_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** insert a single row into the table: "chat.MessageType" */
  readonly insert_chat_MessageType_one?: Maybe<Chat_MessageType>;
  /** insert a single row into the table: "chat.Message" */
  readonly insert_chat_Message_one?: Maybe<Chat_Message>;
  /** insert data into the table: "chat.Pin" */
  readonly insert_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** insert a single row into the table: "chat.Pin" */
  readonly insert_chat_Pin_one?: Maybe<Chat_Pin>;
  /** insert data into the table: "chat.Reaction" */
  readonly insert_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** insert data into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** insert a single row into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType_one?: Maybe<Chat_ReactionType>;
  /** insert a single row into the table: "chat.Reaction" */
  readonly insert_chat_Reaction_one?: Maybe<Chat_Reaction>;
  /** insert data into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** insert a single row into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex_one?: Maybe<Chat_ReadUpToIndex>;
  /** insert data into the table: "chat.Subscription" */
  readonly insert_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** insert a single row into the table: "chat.Subscription" */
  readonly insert_chat_Subscription_one?: Maybe<Chat_Subscription>;
  /** insert data into the table: "collection.Exhibition" */
  readonly insert_collection_Exhibition?: Maybe<Collection_Exhibition_Mutation_Response>;
  /** insert a single row into the table: "collection.Exhibition" */
  readonly insert_collection_Exhibition_one?: Maybe<Collection_Exhibition>;
  /** insert data into the table: "collection.ProgramPerson" */
  readonly insert_collection_ProgramPerson?: Maybe<Collection_ProgramPerson_Mutation_Response>;
  /** insert a single row into the table: "collection.ProgramPerson" */
  readonly insert_collection_ProgramPerson_one?: Maybe<Collection_ProgramPerson>;
  /** insert data into the table: "collection.Tag" */
  readonly insert_collection_Tag?: Maybe<Collection_Tag_Mutation_Response>;
  /** insert a single row into the table: "collection.Tag" */
  readonly insert_collection_Tag_one?: Maybe<Collection_Tag>;
  /** insert data into the table: "conference.Conference" */
  readonly insert_conference_Conference?: Maybe<Conference_Conference_Mutation_Response>;
  /** insert a single row into the table: "conference.Conference" */
  readonly insert_conference_Conference_one?: Maybe<Conference_Conference>;
  /** insert data into the table: "conference.Configuration" */
  readonly insert_conference_Configuration?: Maybe<Conference_Configuration_Mutation_Response>;
  /** insert a single row into the table: "conference.Configuration" */
  readonly insert_conference_Configuration_one?: Maybe<Conference_Configuration>;
  /** insert data into the table: "conference.DemoCode" */
  readonly insert_conference_DemoCode?: Maybe<Conference_DemoCode_Mutation_Response>;
  /** insert a single row into the table: "conference.DemoCode" */
  readonly insert_conference_DemoCode_one?: Maybe<Conference_DemoCode>;
  /** insert data into the table: "conference.OriginatingData" */
  readonly insert_conference_OriginatingData?: Maybe<Conference_OriginatingData_Mutation_Response>;
  /** insert a single row into the table: "conference.OriginatingData" */
  readonly insert_conference_OriginatingData_one?: Maybe<Conference_OriginatingData>;
  /** insert data into the table: "conference.PrepareJob" */
  readonly insert_conference_PrepareJob?: Maybe<Conference_PrepareJob_Mutation_Response>;
  /** insert a single row into the table: "conference.PrepareJob" */
  readonly insert_conference_PrepareJob_one?: Maybe<Conference_PrepareJob>;
  /** insert data into the table: "content.Element" */
  readonly insert_content_Element?: Maybe<Content_Element_Mutation_Response>;
  /** insert data into the table: "content.ElementPermissionGrant" */
  readonly insert_content_ElementPermissionGrant?: Maybe<Content_ElementPermissionGrant_Mutation_Response>;
  /** insert a single row into the table: "content.ElementPermissionGrant" */
  readonly insert_content_ElementPermissionGrant_one?: Maybe<Content_ElementPermissionGrant>;
  /** insert data into the table: "content.ElementType" */
  readonly insert_content_ElementType?: Maybe<Content_ElementType_Mutation_Response>;
  /** insert a single row into the table: "content.ElementType" */
  readonly insert_content_ElementType_one?: Maybe<Content_ElementType>;
  /** insert a single row into the table: "content.Element" */
  readonly insert_content_Element_one?: Maybe<Content_Element>;
  /** insert data into the table: "content.Item" */
  readonly insert_content_Item?: Maybe<Content_Item_Mutation_Response>;
  /** insert data into the table: "content.ItemExhibition" */
  readonly insert_content_ItemExhibition?: Maybe<Content_ItemExhibition_Mutation_Response>;
  /** insert a single row into the table: "content.ItemExhibition" */
  readonly insert_content_ItemExhibition_one?: Maybe<Content_ItemExhibition>;
  /** insert data into the table: "content.ItemProgramPerson" */
  readonly insert_content_ItemProgramPerson?: Maybe<Content_ItemProgramPerson_Mutation_Response>;
  /** insert a single row into the table: "content.ItemProgramPerson" */
  readonly insert_content_ItemProgramPerson_one?: Maybe<Content_ItemProgramPerson>;
  /** insert data into the table: "content.ItemTag" */
  readonly insert_content_ItemTag?: Maybe<Content_ItemTag_Mutation_Response>;
  /** insert a single row into the table: "content.ItemTag" */
  readonly insert_content_ItemTag_one?: Maybe<Content_ItemTag>;
  /** insert data into the table: "content.ItemType" */
  readonly insert_content_ItemType?: Maybe<Content_ItemType_Mutation_Response>;
  /** insert a single row into the table: "content.ItemType" */
  readonly insert_content_ItemType_one?: Maybe<Content_ItemType>;
  /** insert a single row into the table: "content.Item" */
  readonly insert_content_Item_one?: Maybe<Content_Item>;
  /** insert data into the table: "content.UploadableElement" */
  readonly insert_content_UploadableElement?: Maybe<Content_UploadableElement_Mutation_Response>;
  /** insert data into the table: "content.UploadableElementPermissionGrant" */
  readonly insert_content_UploadableElementPermissionGrant?: Maybe<Content_UploadableElementPermissionGrant_Mutation_Response>;
  /** insert a single row into the table: "content.UploadableElementPermissionGrant" */
  readonly insert_content_UploadableElementPermissionGrant_one?: Maybe<Content_UploadableElementPermissionGrant>;
  /** insert a single row into the table: "content.UploadableElement" */
  readonly insert_content_UploadableElement_one?: Maybe<Content_UploadableElement>;
  /** insert data into the table: "content.Uploader" */
  readonly insert_content_Uploader?: Maybe<Content_Uploader_Mutation_Response>;
  /** insert a single row into the table: "content.Uploader" */
  readonly insert_content_Uploader_one?: Maybe<Content_Uploader>;
  /** insert data into the table: "job_queues.ChannelStackCreateJob" */
  readonly insert_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.ChannelStackCreateJob" */
  readonly insert_job_queues_ChannelStackCreateJob_one?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** insert data into the table: "job_queues.ChannelStackDeleteJob" */
  readonly insert_job_queues_ChannelStackDeleteJob?: Maybe<Job_Queues_ChannelStackDeleteJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.ChannelStackDeleteJob" */
  readonly insert_job_queues_ChannelStackDeleteJob_one?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** insert data into the table: "job_queues.CombineVideosJob" */
  readonly insert_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.CombineVideosJob" */
  readonly insert_job_queues_CombineVideosJob_one?: Maybe<Job_Queues_CombineVideosJob>;
  /** insert data into the table: "job_queues.CustomEmailJob" */
  readonly insert_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.CustomEmailJob" */
  readonly insert_job_queues_CustomEmailJob_one?: Maybe<Job_Queues_CustomEmailJob>;
  /** insert data into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob_one?: Maybe<Job_Queues_InvitationEmailJob>;
  /** insert data into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob_one?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** insert data into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob_one?: Maybe<Job_Queues_PublishVideoJob>;
  /** insert data into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob_one?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** insert data into the table: "job_queues.UploadYouTubeVideoJob" */
  readonly insert_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.UploadYouTubeVideoJob" */
  readonly insert_job_queues_UploadYouTubeVideoJob_one?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** insert data into the table: "permissions.Group" */
  readonly insert_permissions_Group?: Maybe<Permissions_Group_Mutation_Response>;
  /** insert data into the table: "permissions.GroupRegistrant" */
  readonly insert_permissions_GroupRegistrant?: Maybe<Permissions_GroupRegistrant_Mutation_Response>;
  /** insert a single row into the table: "permissions.GroupRegistrant" */
  readonly insert_permissions_GroupRegistrant_one?: Maybe<Permissions_GroupRegistrant>;
  /** insert data into the table: "permissions.GroupRole" */
  readonly insert_permissions_GroupRole?: Maybe<Permissions_GroupRole_Mutation_Response>;
  /** insert a single row into the table: "permissions.GroupRole" */
  readonly insert_permissions_GroupRole_one?: Maybe<Permissions_GroupRole>;
  /** insert a single row into the table: "permissions.Group" */
  readonly insert_permissions_Group_one?: Maybe<Permissions_Group>;
  /** insert data into the table: "permissions.Permission" */
  readonly insert_permissions_Permission?: Maybe<Permissions_Permission_Mutation_Response>;
  /** insert a single row into the table: "permissions.Permission" */
  readonly insert_permissions_Permission_one?: Maybe<Permissions_Permission>;
  /** insert data into the table: "permissions.Role" */
  readonly insert_permissions_Role?: Maybe<Permissions_Role_Mutation_Response>;
  /** insert data into the table: "permissions.RolePermission" */
  readonly insert_permissions_RolePermission?: Maybe<Permissions_RolePermission_Mutation_Response>;
  /** insert a single row into the table: "permissions.RolePermission" */
  readonly insert_permissions_RolePermission_one?: Maybe<Permissions_RolePermission>;
  /** insert a single row into the table: "permissions.Role" */
  readonly insert_permissions_Role_one?: Maybe<Permissions_Role>;
  /** insert data into the table: "registrant.GoogleAccount" */
  readonly insert_registrant_GoogleAccount?: Maybe<Registrant_GoogleAccount_Mutation_Response>;
  /** insert a single row into the table: "registrant.GoogleAccount" */
  readonly insert_registrant_GoogleAccount_one?: Maybe<Registrant_GoogleAccount>;
  /** insert data into the table: "registrant.Invitation" */
  readonly insert_registrant_Invitation?: Maybe<Registrant_Invitation_Mutation_Response>;
  /** insert a single row into the table: "registrant.Invitation" */
  readonly insert_registrant_Invitation_one?: Maybe<Registrant_Invitation>;
  /** insert data into the table: "registrant.Profile" */
  readonly insert_registrant_Profile?: Maybe<Registrant_Profile_Mutation_Response>;
  /** insert a single row into the table: "registrant.Profile" */
  readonly insert_registrant_Profile_one?: Maybe<Registrant_Profile>;
  /** insert data into the table: "registrant.Registrant" */
  readonly insert_registrant_Registrant?: Maybe<Registrant_Registrant_Mutation_Response>;
  /** insert a single row into the table: "registrant.Registrant" */
  readonly insert_registrant_Registrant_one?: Maybe<Registrant_Registrant>;
  /** insert data into the table: "room.Backend" */
  readonly insert_room_Backend?: Maybe<Room_Backend_Mutation_Response>;
  /** insert a single row into the table: "room.Backend" */
  readonly insert_room_Backend_one?: Maybe<Room_Backend>;
  /** insert data into the table: "room.ChimeMeeting" */
  readonly insert_room_ChimeMeeting?: Maybe<Room_ChimeMeeting_Mutation_Response>;
  /** insert a single row into the table: "room.ChimeMeeting" */
  readonly insert_room_ChimeMeeting_one?: Maybe<Room_ChimeMeeting>;
  /** insert data into the table: "room.ManagementMode" */
  readonly insert_room_ManagementMode?: Maybe<Room_ManagementMode_Mutation_Response>;
  /** insert a single row into the table: "room.ManagementMode" */
  readonly insert_room_ManagementMode_one?: Maybe<Room_ManagementMode>;
  /** insert data into the table: "room.Mode" */
  readonly insert_room_Mode?: Maybe<Room_Mode_Mutation_Response>;
  /** insert a single row into the table: "room.Mode" */
  readonly insert_room_Mode_one?: Maybe<Room_Mode>;
  /** insert data into the table: "room.Participant" */
  readonly insert_room_Participant?: Maybe<Room_Participant_Mutation_Response>;
  /** insert a single row into the table: "room.Participant" */
  readonly insert_room_Participant_one?: Maybe<Room_Participant>;
  /** insert data into the table: "room.PersonRole" */
  readonly insert_room_PersonRole?: Maybe<Room_PersonRole_Mutation_Response>;
  /** insert a single row into the table: "room.PersonRole" */
  readonly insert_room_PersonRole_one?: Maybe<Room_PersonRole>;
  /** insert data into the table: "room.Room" */
  readonly insert_room_Room?: Maybe<Room_Room_Mutation_Response>;
  /** insert data into the table: "room.RoomPerson" */
  readonly insert_room_RoomPerson?: Maybe<Room_RoomPerson_Mutation_Response>;
  /** insert a single row into the table: "room.RoomPerson" */
  readonly insert_room_RoomPerson_one?: Maybe<Room_RoomPerson>;
  /** insert a single row into the table: "room.Room" */
  readonly insert_room_Room_one?: Maybe<Room_Room>;
  /** insert data into the table: "room.ShuffleAlgorithm" */
  readonly insert_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleAlgorithm" */
  readonly insert_room_ShuffleAlgorithm_one?: Maybe<Room_ShuffleAlgorithm>;
  /** insert data into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** insert a single row into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod_one?: Maybe<Room_ShufflePeriod>;
  /** insert data into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry_one?: Maybe<Room_ShuffleQueueEntry>;
  /** insert data into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom_one?: Maybe<Room_ShuffleRoom>;
  /** insert data into the table: "schedule.Event" */
  readonly insert_schedule_Event?: Maybe<Schedule_Event_Mutation_Response>;
  /** insert data into the table: "schedule.EventProgramPerson" */
  readonly insert_schedule_EventProgramPerson?: Maybe<Schedule_EventProgramPerson_Mutation_Response>;
  /** insert data into the table: "schedule.EventProgramPersonRole" */
  readonly insert_schedule_EventProgramPersonRole?: Maybe<Schedule_EventProgramPersonRole_Mutation_Response>;
  /** insert a single row into the table: "schedule.EventProgramPersonRole" */
  readonly insert_schedule_EventProgramPersonRole_one?: Maybe<Schedule_EventProgramPersonRole>;
  /** insert a single row into the table: "schedule.EventProgramPerson" */
  readonly insert_schedule_EventProgramPerson_one?: Maybe<Schedule_EventProgramPerson>;
  /** insert data into the table: "schedule.EventRoomJoinRequest" */
  readonly insert_schedule_EventRoomJoinRequest?: Maybe<Schedule_EventRoomJoinRequest_Mutation_Response>;
  /** insert a single row into the table: "schedule.EventRoomJoinRequest" */
  readonly insert_schedule_EventRoomJoinRequest_one?: Maybe<Schedule_EventRoomJoinRequest>;
  /** insert data into the table: "schedule.EventTag" */
  readonly insert_schedule_EventTag?: Maybe<Schedule_EventTag_Mutation_Response>;
  /** insert a single row into the table: "schedule.EventTag" */
  readonly insert_schedule_EventTag_one?: Maybe<Schedule_EventTag>;
  /** insert a single row into the table: "schedule.Event" */
  readonly insert_schedule_Event_one?: Maybe<Schedule_Event>;
  /** insert data into the table: "system.Configuration" */
  readonly insert_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** insert data into the table: "system.ConfigurationKey" */
  readonly insert_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** insert a single row into the table: "system.ConfigurationKey" */
  readonly insert_system_ConfigurationKey_one?: Maybe<System_ConfigurationKey>;
  /** insert a single row into the table: "system.Configuration" */
  readonly insert_system_Configuration_one?: Maybe<System_Configuration>;
  /** insert data into the table: "video.ChannelStack" */
  readonly insert_video_ChannelStack?: Maybe<Video_ChannelStack_Mutation_Response>;
  /** insert a single row into the table: "video.ChannelStack" */
  readonly insert_video_ChannelStack_one?: Maybe<Video_ChannelStack>;
  /** insert data into the table: "video.EventParticipantStream" */
  readonly insert_video_EventParticipantStream?: Maybe<Video_EventParticipantStream_Mutation_Response>;
  /** insert a single row into the table: "video.EventParticipantStream" */
  readonly insert_video_EventParticipantStream_one?: Maybe<Video_EventParticipantStream>;
  /** insert data into the table: "video.EventVonageSession" */
  readonly insert_video_EventVonageSession?: Maybe<Video_EventVonageSession_Mutation_Response>;
  /** insert a single row into the table: "video.EventVonageSession" */
  readonly insert_video_EventVonageSession_one?: Maybe<Video_EventVonageSession>;
  /** insert data into the table: "video.ImmediateSwitch" */
  readonly insert_video_ImmediateSwitch?: Maybe<Video_ImmediateSwitch_Mutation_Response>;
  /** insert a single row into the table: "video.ImmediateSwitch" */
  readonly insert_video_ImmediateSwitch_one?: Maybe<Video_ImmediateSwitch>;
  /** insert data into the table: "video.InputType" */
  readonly insert_video_InputType?: Maybe<Video_InputType_Mutation_Response>;
  /** insert a single row into the table: "video.InputType" */
  readonly insert_video_InputType_one?: Maybe<Video_InputType>;
  /** insert data into the table: "video.JobStatus" */
  readonly insert_video_JobStatus?: Maybe<Video_JobStatus_Mutation_Response>;
  /** insert a single row into the table: "video.JobStatus" */
  readonly insert_video_JobStatus_one?: Maybe<Video_JobStatus>;
  /** insert data into the table: "video.MediaLiveChannelStatus" */
  readonly insert_video_MediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Mutation_Response>;
  /** insert a single row into the table: "video.MediaLiveChannelStatus" */
  readonly insert_video_MediaLiveChannelStatus_one?: Maybe<Video_MediaLiveChannelStatus>;
  /** insert data into the table: "video.RtmpInput" */
  readonly insert_video_RtmpInput?: Maybe<Video_RtmpInput_Mutation_Response>;
  /** insert a single row into the table: "video.RtmpInput" */
  readonly insert_video_RtmpInput_one?: Maybe<Video_RtmpInput>;
  /** insert data into the table: "video.TranscriptionJob" */
  readonly insert_video_TranscriptionJob?: Maybe<Video_TranscriptionJob_Mutation_Response>;
  /** insert a single row into the table: "video.TranscriptionJob" */
  readonly insert_video_TranscriptionJob_one?: Maybe<Video_TranscriptionJob>;
  /** insert data into the table: "video.VideoRenderJob" */
  readonly insert_video_VideoRenderJob?: Maybe<Video_VideoRenderJob_Mutation_Response>;
  /** insert a single row into the table: "video.VideoRenderJob" */
  readonly insert_video_VideoRenderJob_one?: Maybe<Video_VideoRenderJob>;
  /** insert data into the table: "video.YouTubeUpload" */
  readonly insert_video_YouTubeUpload?: Maybe<Video_YouTubeUpload_Mutation_Response>;
  /** insert a single row into the table: "video.YouTubeUpload" */
  readonly insert_video_YouTubeUpload_one?: Maybe<Video_YouTubeUpload>;
  /** perform the action: "invitationConfirmCurrent" */
  readonly invitationConfirmCurrent?: Maybe<ConfirmInvitationOutput>;
  /** perform the action: "invitationConfirmSendInitialEmail" */
  readonly invitationConfirmSendInitialEmail?: Maybe<InvitationConfirmationEmailOutput>;
  /** perform the action: "invitationConfirmSendRepeatEmail" */
  readonly invitationConfirmSendRepeatEmail?: Maybe<InvitationConfirmationEmailOutput>;
  /** perform the action: "invitationConfirmWithCode" */
  readonly invitationConfirmWithCode?: Maybe<ConfirmInvitationOutput>;
  /** perform the action: "joinEventVonageSession" */
  readonly joinEventVonageSession?: Maybe<JoinEventVonageSessionOutput>;
  /** perform the action: "joinRoomChimeSession" */
  readonly joinRoomChimeSession?: Maybe<JoinRoomChimeSessionOutput>;
  /** perform the action: "joinRoomVonageSession" */
  readonly joinRoomVonageSession?: Maybe<JoinRoomVonageSessionOutput>;
  /** perform the action: "presence_Flush" */
  readonly presence_Flush: PresenceFlushOutput;
  /** perform the action: "refreshYouTubeData" */
  readonly refreshYouTubeData?: Maybe<RefreshYouTubeDataOutput>;
  /** perform the action: "stopEventBroadcast" */
  readonly stopEventBroadcast?: Maybe<StopEventBroadcastOutput>;
  /** perform the action: "submitGoogleOAuthCode" */
  readonly submitGoogleOAuthCode?: Maybe<SubmitGoogleOAuthCodeOutput>;
  /** perform the action: "submitUploadableElement" */
  readonly submitUploadableElement?: Maybe<SubmitUploadableElementOutput>;
  /** perform the action: "updateProfilePhoto" */
  readonly updateProfilePhoto?: Maybe<UpdateProfilePhotoResponse>;
  /** perform the action: "updateSubtitles" */
  readonly updateSubtitles?: Maybe<SubmitUpdatedSubtitlesOutput>;
  /** update data of the table: "Email" */
  readonly update_Email?: Maybe<Email_Mutation_Response>;
  /** update single row of the table: "Email" */
  readonly update_Email_by_pk?: Maybe<Email>;
  /** update data of the table: "PushNotificationSubscription" */
  readonly update_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** update single row of the table: "PushNotificationSubscription" */
  readonly update_PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** update data of the table: "User" */
  readonly update_User?: Maybe<User_Mutation_Response>;
  /** update single row of the table: "User" */
  readonly update_User_by_pk?: Maybe<User>;
  /** update data of the table: "analytics.AppStats" */
  readonly update_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** update single row of the table: "analytics.AppStats" */
  readonly update_analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** update data of the table: "analytics.ContentElementStats" */
  readonly update_analytics_ContentElementStats?: Maybe<Analytics_ContentElementStats_Mutation_Response>;
  /** update single row of the table: "analytics.ContentElementStats" */
  readonly update_analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** update data of the table: "analytics.ContentItemStats" */
  readonly update_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** update single row of the table: "analytics.ContentItemStats" */
  readonly update_analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** update data of the table: "analytics.RoomStats" */
  readonly update_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** update single row of the table: "analytics.RoomStats" */
  readonly update_analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** update data of the table: "chat.Chat" */
  readonly update_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** update single row of the table: "chat.Chat" */
  readonly update_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** update data of the table: "chat.Flag" */
  readonly update_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** update data of the table: "chat.FlagType" */
  readonly update_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** update single row of the table: "chat.FlagType" */
  readonly update_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** update single row of the table: "chat.Flag" */
  readonly update_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** update data of the table: "chat.Message" */
  readonly update_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** update data of the table: "chat.MessageType" */
  readonly update_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** update single row of the table: "chat.MessageType" */
  readonly update_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** update single row of the table: "chat.Message" */
  readonly update_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** update data of the table: "chat.Pin" */
  readonly update_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** update single row of the table: "chat.Pin" */
  readonly update_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** update data of the table: "chat.Reaction" */
  readonly update_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** update data of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** update single row of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** update single row of the table: "chat.Reaction" */
  readonly update_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** update data of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** update single row of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** update data of the table: "chat.Subscription" */
  readonly update_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** update single row of the table: "chat.Subscription" */
  readonly update_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** update data of the table: "collection.Exhibition" */
  readonly update_collection_Exhibition?: Maybe<Collection_Exhibition_Mutation_Response>;
  /** update single row of the table: "collection.Exhibition" */
  readonly update_collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** update data of the table: "collection.ProgramPerson" */
  readonly update_collection_ProgramPerson?: Maybe<Collection_ProgramPerson_Mutation_Response>;
  /** update single row of the table: "collection.ProgramPerson" */
  readonly update_collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** update data of the table: "collection.Tag" */
  readonly update_collection_Tag?: Maybe<Collection_Tag_Mutation_Response>;
  /** update single row of the table: "collection.Tag" */
  readonly update_collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** update data of the table: "conference.Conference" */
  readonly update_conference_Conference?: Maybe<Conference_Conference_Mutation_Response>;
  /** update single row of the table: "conference.Conference" */
  readonly update_conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** update data of the table: "conference.Configuration" */
  readonly update_conference_Configuration?: Maybe<Conference_Configuration_Mutation_Response>;
  /** update single row of the table: "conference.Configuration" */
  readonly update_conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** update data of the table: "conference.DemoCode" */
  readonly update_conference_DemoCode?: Maybe<Conference_DemoCode_Mutation_Response>;
  /** update single row of the table: "conference.DemoCode" */
  readonly update_conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** update data of the table: "conference.OriginatingData" */
  readonly update_conference_OriginatingData?: Maybe<Conference_OriginatingData_Mutation_Response>;
  /** update single row of the table: "conference.OriginatingData" */
  readonly update_conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** update data of the table: "conference.PrepareJob" */
  readonly update_conference_PrepareJob?: Maybe<Conference_PrepareJob_Mutation_Response>;
  /** update single row of the table: "conference.PrepareJob" */
  readonly update_conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** update data of the table: "content.Element" */
  readonly update_content_Element?: Maybe<Content_Element_Mutation_Response>;
  /** update data of the table: "content.ElementPermissionGrant" */
  readonly update_content_ElementPermissionGrant?: Maybe<Content_ElementPermissionGrant_Mutation_Response>;
  /** update single row of the table: "content.ElementPermissionGrant" */
  readonly update_content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** update data of the table: "content.ElementType" */
  readonly update_content_ElementType?: Maybe<Content_ElementType_Mutation_Response>;
  /** update single row of the table: "content.ElementType" */
  readonly update_content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** update single row of the table: "content.Element" */
  readonly update_content_Element_by_pk?: Maybe<Content_Element>;
  /** update data of the table: "content.Item" */
  readonly update_content_Item?: Maybe<Content_Item_Mutation_Response>;
  /** update data of the table: "content.ItemExhibition" */
  readonly update_content_ItemExhibition?: Maybe<Content_ItemExhibition_Mutation_Response>;
  /** update single row of the table: "content.ItemExhibition" */
  readonly update_content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** update data of the table: "content.ItemProgramPerson" */
  readonly update_content_ItemProgramPerson?: Maybe<Content_ItemProgramPerson_Mutation_Response>;
  /** update single row of the table: "content.ItemProgramPerson" */
  readonly update_content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** update data of the table: "content.ItemTag" */
  readonly update_content_ItemTag?: Maybe<Content_ItemTag_Mutation_Response>;
  /** update single row of the table: "content.ItemTag" */
  readonly update_content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** update data of the table: "content.ItemType" */
  readonly update_content_ItemType?: Maybe<Content_ItemType_Mutation_Response>;
  /** update single row of the table: "content.ItemType" */
  readonly update_content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** update single row of the table: "content.Item" */
  readonly update_content_Item_by_pk?: Maybe<Content_Item>;
  /** update data of the table: "content.UploadableElement" */
  readonly update_content_UploadableElement?: Maybe<Content_UploadableElement_Mutation_Response>;
  /** update data of the table: "content.UploadableElementPermissionGrant" */
  readonly update_content_UploadableElementPermissionGrant?: Maybe<Content_UploadableElementPermissionGrant_Mutation_Response>;
  /** update single row of the table: "content.UploadableElementPermissionGrant" */
  readonly update_content_UploadableElementPermissionGrant_by_pk?: Maybe<Content_UploadableElementPermissionGrant>;
  /** update single row of the table: "content.UploadableElement" */
  readonly update_content_UploadableElement_by_pk?: Maybe<Content_UploadableElement>;
  /** update data of the table: "content.Uploader" */
  readonly update_content_Uploader?: Maybe<Content_Uploader_Mutation_Response>;
  /** update single row of the table: "content.Uploader" */
  readonly update_content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** update data of the table: "job_queues.ChannelStackCreateJob" */
  readonly update_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** update single row of the table: "job_queues.ChannelStackCreateJob" */
  readonly update_job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** update data of the table: "job_queues.ChannelStackDeleteJob" */
  readonly update_job_queues_ChannelStackDeleteJob?: Maybe<Job_Queues_ChannelStackDeleteJob_Mutation_Response>;
  /** update single row of the table: "job_queues.ChannelStackDeleteJob" */
  readonly update_job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** update data of the table: "job_queues.CombineVideosJob" */
  readonly update_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** update single row of the table: "job_queues.CombineVideosJob" */
  readonly update_job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** update data of the table: "job_queues.CustomEmailJob" */
  readonly update_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.CustomEmailJob" */
  readonly update_job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** update data of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** update data of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** update single row of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** update data of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** update single row of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** update data of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** update data of the table: "job_queues.UploadYouTubeVideoJob" */
  readonly update_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** update single row of the table: "job_queues.UploadYouTubeVideoJob" */
  readonly update_job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** update data of the table: "permissions.Group" */
  readonly update_permissions_Group?: Maybe<Permissions_Group_Mutation_Response>;
  /** update data of the table: "permissions.GroupRegistrant" */
  readonly update_permissions_GroupRegistrant?: Maybe<Permissions_GroupRegistrant_Mutation_Response>;
  /** update single row of the table: "permissions.GroupRegistrant" */
  readonly update_permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** update data of the table: "permissions.GroupRole" */
  readonly update_permissions_GroupRole?: Maybe<Permissions_GroupRole_Mutation_Response>;
  /** update single row of the table: "permissions.GroupRole" */
  readonly update_permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** update single row of the table: "permissions.Group" */
  readonly update_permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** update data of the table: "permissions.Permission" */
  readonly update_permissions_Permission?: Maybe<Permissions_Permission_Mutation_Response>;
  /** update single row of the table: "permissions.Permission" */
  readonly update_permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** update data of the table: "permissions.Role" */
  readonly update_permissions_Role?: Maybe<Permissions_Role_Mutation_Response>;
  /** update data of the table: "permissions.RolePermission" */
  readonly update_permissions_RolePermission?: Maybe<Permissions_RolePermission_Mutation_Response>;
  /** update single row of the table: "permissions.RolePermission" */
  readonly update_permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** update single row of the table: "permissions.Role" */
  readonly update_permissions_Role_by_pk?: Maybe<Permissions_Role>;
  /** update data of the table: "registrant.GoogleAccount" */
  readonly update_registrant_GoogleAccount?: Maybe<Registrant_GoogleAccount_Mutation_Response>;
  /** update single row of the table: "registrant.GoogleAccount" */
  readonly update_registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** update data of the table: "registrant.Invitation" */
  readonly update_registrant_Invitation?: Maybe<Registrant_Invitation_Mutation_Response>;
  /** update single row of the table: "registrant.Invitation" */
  readonly update_registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** update data of the table: "registrant.Profile" */
  readonly update_registrant_Profile?: Maybe<Registrant_Profile_Mutation_Response>;
  /** update single row of the table: "registrant.Profile" */
  readonly update_registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** update data of the table: "registrant.Registrant" */
  readonly update_registrant_Registrant?: Maybe<Registrant_Registrant_Mutation_Response>;
  /** update single row of the table: "registrant.Registrant" */
  readonly update_registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** update data of the table: "room.Backend" */
  readonly update_room_Backend?: Maybe<Room_Backend_Mutation_Response>;
  /** update single row of the table: "room.Backend" */
  readonly update_room_Backend_by_pk?: Maybe<Room_Backend>;
  /** update data of the table: "room.ChimeMeeting" */
  readonly update_room_ChimeMeeting?: Maybe<Room_ChimeMeeting_Mutation_Response>;
  /** update single row of the table: "room.ChimeMeeting" */
  readonly update_room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** update data of the table: "room.ManagementMode" */
  readonly update_room_ManagementMode?: Maybe<Room_ManagementMode_Mutation_Response>;
  /** update single row of the table: "room.ManagementMode" */
  readonly update_room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** update data of the table: "room.Mode" */
  readonly update_room_Mode?: Maybe<Room_Mode_Mutation_Response>;
  /** update single row of the table: "room.Mode" */
  readonly update_room_Mode_by_pk?: Maybe<Room_Mode>;
  /** update data of the table: "room.Participant" */
  readonly update_room_Participant?: Maybe<Room_Participant_Mutation_Response>;
  /** update single row of the table: "room.Participant" */
  readonly update_room_Participant_by_pk?: Maybe<Room_Participant>;
  /** update data of the table: "room.PersonRole" */
  readonly update_room_PersonRole?: Maybe<Room_PersonRole_Mutation_Response>;
  /** update single row of the table: "room.PersonRole" */
  readonly update_room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** update data of the table: "room.Room" */
  readonly update_room_Room?: Maybe<Room_Room_Mutation_Response>;
  /** update data of the table: "room.RoomPerson" */
  readonly update_room_RoomPerson?: Maybe<Room_RoomPerson_Mutation_Response>;
  /** update single row of the table: "room.RoomPerson" */
  readonly update_room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** update single row of the table: "room.Room" */
  readonly update_room_Room_by_pk?: Maybe<Room_Room>;
  /** update data of the table: "room.ShuffleAlgorithm" */
  readonly update_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** update single row of the table: "room.ShuffleAlgorithm" */
  readonly update_room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** update data of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** update single row of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** update data of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** update single row of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** update data of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** update single row of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** update data of the table: "schedule.Event" */
  readonly update_schedule_Event?: Maybe<Schedule_Event_Mutation_Response>;
  /** update data of the table: "schedule.EventProgramPerson" */
  readonly update_schedule_EventProgramPerson?: Maybe<Schedule_EventProgramPerson_Mutation_Response>;
  /** update data of the table: "schedule.EventProgramPersonRole" */
  readonly update_schedule_EventProgramPersonRole?: Maybe<Schedule_EventProgramPersonRole_Mutation_Response>;
  /** update single row of the table: "schedule.EventProgramPersonRole" */
  readonly update_schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** update single row of the table: "schedule.EventProgramPerson" */
  readonly update_schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** update data of the table: "schedule.EventRoomJoinRequest" */
  readonly update_schedule_EventRoomJoinRequest?: Maybe<Schedule_EventRoomJoinRequest_Mutation_Response>;
  /** update single row of the table: "schedule.EventRoomJoinRequest" */
  readonly update_schedule_EventRoomJoinRequest_by_pk?: Maybe<Schedule_EventRoomJoinRequest>;
  /** update data of the table: "schedule.EventTag" */
  readonly update_schedule_EventTag?: Maybe<Schedule_EventTag_Mutation_Response>;
  /** update single row of the table: "schedule.EventTag" */
  readonly update_schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** update single row of the table: "schedule.Event" */
  readonly update_schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** update data of the table: "system.Configuration" */
  readonly update_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** update data of the table: "system.ConfigurationKey" */
  readonly update_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** update single row of the table: "system.ConfigurationKey" */
  readonly update_system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** update single row of the table: "system.Configuration" */
  readonly update_system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** update data of the table: "video.ChannelStack" */
  readonly update_video_ChannelStack?: Maybe<Video_ChannelStack_Mutation_Response>;
  /** update single row of the table: "video.ChannelStack" */
  readonly update_video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** update data of the table: "video.EventParticipantStream" */
  readonly update_video_EventParticipantStream?: Maybe<Video_EventParticipantStream_Mutation_Response>;
  /** update single row of the table: "video.EventParticipantStream" */
  readonly update_video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** update data of the table: "video.EventVonageSession" */
  readonly update_video_EventVonageSession?: Maybe<Video_EventVonageSession_Mutation_Response>;
  /** update single row of the table: "video.EventVonageSession" */
  readonly update_video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** update data of the table: "video.ImmediateSwitch" */
  readonly update_video_ImmediateSwitch?: Maybe<Video_ImmediateSwitch_Mutation_Response>;
  /** update single row of the table: "video.ImmediateSwitch" */
  readonly update_video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** update data of the table: "video.InputType" */
  readonly update_video_InputType?: Maybe<Video_InputType_Mutation_Response>;
  /** update single row of the table: "video.InputType" */
  readonly update_video_InputType_by_pk?: Maybe<Video_InputType>;
  /** update data of the table: "video.JobStatus" */
  readonly update_video_JobStatus?: Maybe<Video_JobStatus_Mutation_Response>;
  /** update single row of the table: "video.JobStatus" */
  readonly update_video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** update data of the table: "video.MediaLiveChannelStatus" */
  readonly update_video_MediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Mutation_Response>;
  /** update single row of the table: "video.MediaLiveChannelStatus" */
  readonly update_video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** update data of the table: "video.RtmpInput" */
  readonly update_video_RtmpInput?: Maybe<Video_RtmpInput_Mutation_Response>;
  /** update single row of the table: "video.RtmpInput" */
  readonly update_video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** update data of the table: "video.TranscriptionJob" */
  readonly update_video_TranscriptionJob?: Maybe<Video_TranscriptionJob_Mutation_Response>;
  /** update single row of the table: "video.TranscriptionJob" */
  readonly update_video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** update data of the table: "video.VideoRenderJob" */
  readonly update_video_VideoRenderJob?: Maybe<Video_VideoRenderJob_Mutation_Response>;
  /** update single row of the table: "video.VideoRenderJob" */
  readonly update_video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** update data of the table: "video.YouTubeUpload" */
  readonly update_video_YouTubeUpload?: Maybe<Video_YouTubeUpload_Mutation_Response>;
  /** update single row of the table: "video.YouTubeUpload" */
  readonly update_video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
};


/** mutation root */
export type Mutation_RootCreateItemRoomArgs = {
  conferenceId: Scalars['uuid'];
  itemId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCreateRoomDmArgs = {
  conferenceId: Scalars['uuid'];
  registrantIds: ReadonlyArray<Maybe<Scalars['uuid']>>;
};


/** mutation root */
export type Mutation_RootDelete_EmailArgs = {
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Email_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_PushNotificationSubscriptionArgs = {
  where: PushNotificationSubscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_UserArgs = {
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_By_PkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_AppStatsArgs = {
  where: Analytics_AppStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentElementStatsArgs = {
  where: Analytics_ContentElementStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentElementStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentItemStatsArgs = {
  where: Analytics_ContentItemStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentItemStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_RoomStatsArgs = {
  where: Analytics_RoomStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_RoomStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ChatArgs = {
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagArgs = {
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagTypeArgs = {
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageArgs = {
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageTypeArgs = {
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_PinArgs = {
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Pin_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionArgs = {
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionTypeArgs = {
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndexArgs = {
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndex_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_SubscriptionArgs = {
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Subscription_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Collection_ExhibitionArgs = {
  where: Collection_Exhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_Exhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Collection_ProgramPersonArgs = {
  where: Collection_ProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_ProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Collection_TagArgs = {
  where: Collection_Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Collection_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_ConferenceArgs = {
  where: Conference_Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_ConfigurationArgs = {
  where: Conference_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_Configuration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_DemoCodeArgs = {
  where: Conference_DemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_DemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_OriginatingDataArgs = {
  where: Conference_OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_PrepareJobArgs = {
  where: Conference_PrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Conference_PrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementArgs = {
  where: Content_Element_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementPermissionGrantArgs = {
  where: Content_ElementPermissionGrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementTypeArgs = {
  where: Content_ElementType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ElementType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Content_Element_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemArgs = {
  where: Content_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemExhibitionArgs = {
  where: Content_ItemExhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemExhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemProgramPersonArgs = {
  where: Content_ItemProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemTagArgs = {
  where: Content_ItemTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemTypeArgs = {
  where: Content_ItemType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_ItemType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Content_Item_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_UploadableElementArgs = {
  where: Content_UploadableElement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_UploadableElementPermissionGrantArgs = {
  where: Content_UploadableElementPermissionGrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_UploadableElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_UploadableElement_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Content_UploaderArgs = {
  where: Content_Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Content_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackCreateJobArgs = {
  where: Job_Queues_ChannelStackCreateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackDeleteJobArgs = {
  where: Job_Queues_ChannelStackDeleteJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackDeleteJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CombineVideosJobArgs = {
  where: Job_Queues_CombineVideosJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CustomEmailJobArgs = {
  where: Job_Queues_CustomEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJobArgs = {
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJobArgs = {
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJobArgs = {
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJobArgs = {
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_UploadYouTubeVideoJobArgs = {
  where: Job_Queues_UploadYouTubeVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupArgs = {
  where: Permissions_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRegistrantArgs = {
  where: Permissions_GroupRegistrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRegistrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRoleArgs = {
  where: Permissions_GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_PermissionArgs = {
  where: Permissions_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_Permission_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_RoleArgs = {
  where: Permissions_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_RolePermissionArgs = {
  where: Permissions_RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permissions_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Permissions_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_GoogleAccountArgs = {
  where: Registrant_GoogleAccount_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_GoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_InvitationArgs = {
  where: Registrant_Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_ProfileArgs = {
  where: Registrant_Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_Profile_By_PkArgs = {
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Registrant_RegistrantArgs = {
  where: Registrant_Registrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Registrant_Registrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_BackendArgs = {
  where: Room_Backend_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_Backend_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ChimeMeetingArgs = {
  where: Room_ChimeMeeting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ManagementModeArgs = {
  where: Room_ManagementMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ManagementMode_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ModeArgs = {
  where: Room_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_Mode_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ParticipantArgs = {
  where: Room_Participant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_PersonRoleArgs = {
  where: Room_PersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_PersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomArgs = {
  where: Room_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomPersonArgs = {
  where: Room_RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleAlgorithmArgs = {
  where: Room_ShuffleAlgorithm_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriodArgs = {
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntryArgs = {
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoomArgs = {
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventArgs = {
  where: Schedule_Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPersonArgs = {
  where: Schedule_EventProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPersonRoleArgs = {
  where: Schedule_EventProgramPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventRoomJoinRequestArgs = {
  where: Schedule_EventRoomJoinRequest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventTagArgs = {
  where: Schedule_EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Schedule_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Schedule_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationArgs = {
  where: System_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationKeyArgs = {
  where: System_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_System_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};


/** mutation root */
export type Mutation_RootDelete_Video_ChannelStackArgs = {
  where: Video_ChannelStack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_ChannelStack_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_EventParticipantStreamArgs = {
  where: Video_EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_EventVonageSessionArgs = {
  where: Video_EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_ImmediateSwitchArgs = {
  where: Video_ImmediateSwitch_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_ImmediateSwitch_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_InputTypeArgs = {
  where: Video_InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_InputType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Video_JobStatusArgs = {
  where: Video_JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Video_MediaLiveChannelStatusArgs = {
  where: Video_MediaLiveChannelStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_MediaLiveChannelStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_RtmpInputArgs = {
  where: Video_RtmpInput_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_RtmpInput_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Video_TranscriptionJobArgs = {
  where: Video_TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_VideoRenderJobArgs = {
  where: Video_VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Video_YouTubeUploadArgs = {
  where: Video_YouTubeUpload_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Video_YouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootGetGoogleOAuthUrlArgs = {
  registrantId: Scalars['uuid'];
  scopes: ReadonlyArray<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootInsert_EmailArgs = {
  objects: ReadonlyArray<Email_Insert_Input>;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Email_OneArgs = {
  object: Email_Insert_Input;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PushNotificationSubscriptionArgs = {
  objects: ReadonlyArray<PushNotificationSubscription_Insert_Input>;
  on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PushNotificationSubscription_OneArgs = {
  object: PushNotificationSubscription_Insert_Input;
  on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserArgs = {
  objects: ReadonlyArray<User_Insert_Input>;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OneArgs = {
  object: User_Insert_Input;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_AppStatsArgs = {
  objects: ReadonlyArray<Analytics_AppStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_AppStats_OneArgs = {
  object: Analytics_AppStats_Insert_Input;
  on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentElementStatsArgs = {
  objects: ReadonlyArray<Analytics_ContentElementStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_ContentElementStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentElementStats_OneArgs = {
  object: Analytics_ContentElementStats_Insert_Input;
  on_conflict?: Maybe<Analytics_ContentElementStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentItemStatsArgs = {
  objects: ReadonlyArray<Analytics_ContentItemStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentItemStats_OneArgs = {
  object: Analytics_ContentItemStats_Insert_Input;
  on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_RoomStatsArgs = {
  objects: ReadonlyArray<Analytics_RoomStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_RoomStats_OneArgs = {
  object: Analytics_RoomStats_Insert_Input;
  on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ChatArgs = {
  objects: ReadonlyArray<Chat_Chat_Insert_Input>;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Chat_OneArgs = {
  object: Chat_Chat_Insert_Input;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagArgs = {
  objects: ReadonlyArray<Chat_Flag_Insert_Input>;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagTypeArgs = {
  objects: ReadonlyArray<Chat_FlagType_Insert_Input>;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagType_OneArgs = {
  object: Chat_FlagType_Insert_Input;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Flag_OneArgs = {
  object: Chat_Flag_Insert_Input;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageArgs = {
  objects: ReadonlyArray<Chat_Message_Insert_Input>;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageTypeArgs = {
  objects: ReadonlyArray<Chat_MessageType_Insert_Input>;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageType_OneArgs = {
  object: Chat_MessageType_Insert_Input;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Message_OneArgs = {
  object: Chat_Message_Insert_Input;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_PinArgs = {
  objects: ReadonlyArray<Chat_Pin_Insert_Input>;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Pin_OneArgs = {
  object: Chat_Pin_Insert_Input;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionArgs = {
  objects: ReadonlyArray<Chat_Reaction_Insert_Input>;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionTypeArgs = {
  objects: ReadonlyArray<Chat_ReactionType_Insert_Input>;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionType_OneArgs = {
  object: Chat_ReactionType_Insert_Input;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Reaction_OneArgs = {
  object: Chat_Reaction_Insert_Input;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndexArgs = {
  objects: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndex_OneArgs = {
  object: Chat_ReadUpToIndex_Insert_Input;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_SubscriptionArgs = {
  objects: ReadonlyArray<Chat_Subscription_Insert_Input>;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Subscription_OneArgs = {
  object: Chat_Subscription_Insert_Input;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ExhibitionArgs = {
  objects: ReadonlyArray<Collection_Exhibition_Insert_Input>;
  on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_Exhibition_OneArgs = {
  object: Collection_Exhibition_Insert_Input;
  on_conflict?: Maybe<Collection_Exhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPersonArgs = {
  objects: ReadonlyArray<Collection_ProgramPerson_Insert_Input>;
  on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_ProgramPerson_OneArgs = {
  object: Collection_ProgramPerson_Insert_Input;
  on_conflict?: Maybe<Collection_ProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_TagArgs = {
  objects: ReadonlyArray<Collection_Tag_Insert_Input>;
  on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Collection_Tag_OneArgs = {
  object: Collection_Tag_Insert_Input;
  on_conflict?: Maybe<Collection_Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_ConferenceArgs = {
  objects: ReadonlyArray<Conference_Conference_Insert_Input>;
  on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_Conference_OneArgs = {
  object: Conference_Conference_Insert_Input;
  on_conflict?: Maybe<Conference_Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_ConfigurationArgs = {
  objects: ReadonlyArray<Conference_Configuration_Insert_Input>;
  on_conflict?: Maybe<Conference_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_Configuration_OneArgs = {
  object: Conference_Configuration_Insert_Input;
  on_conflict?: Maybe<Conference_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_DemoCodeArgs = {
  objects: ReadonlyArray<Conference_DemoCode_Insert_Input>;
  on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_DemoCode_OneArgs = {
  object: Conference_DemoCode_Insert_Input;
  on_conflict?: Maybe<Conference_DemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_OriginatingDataArgs = {
  objects: ReadonlyArray<Conference_OriginatingData_Insert_Input>;
  on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_OriginatingData_OneArgs = {
  object: Conference_OriginatingData_Insert_Input;
  on_conflict?: Maybe<Conference_OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_PrepareJobArgs = {
  objects: ReadonlyArray<Conference_PrepareJob_Insert_Input>;
  on_conflict?: Maybe<Conference_PrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_PrepareJob_OneArgs = {
  object: Conference_PrepareJob_Insert_Input;
  on_conflict?: Maybe<Conference_PrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementArgs = {
  objects: ReadonlyArray<Content_Element_Insert_Input>;
  on_conflict?: Maybe<Content_Element_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementPermissionGrantArgs = {
  objects: ReadonlyArray<Content_ElementPermissionGrant_Insert_Input>;
  on_conflict?: Maybe<Content_ElementPermissionGrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementPermissionGrant_OneArgs = {
  object: Content_ElementPermissionGrant_Insert_Input;
  on_conflict?: Maybe<Content_ElementPermissionGrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementTypeArgs = {
  objects: ReadonlyArray<Content_ElementType_Insert_Input>;
  on_conflict?: Maybe<Content_ElementType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ElementType_OneArgs = {
  object: Content_ElementType_Insert_Input;
  on_conflict?: Maybe<Content_ElementType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_Element_OneArgs = {
  object: Content_Element_Insert_Input;
  on_conflict?: Maybe<Content_Element_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemArgs = {
  objects: ReadonlyArray<Content_Item_Insert_Input>;
  on_conflict?: Maybe<Content_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemExhibitionArgs = {
  objects: ReadonlyArray<Content_ItemExhibition_Insert_Input>;
  on_conflict?: Maybe<Content_ItemExhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemExhibition_OneArgs = {
  object: Content_ItemExhibition_Insert_Input;
  on_conflict?: Maybe<Content_ItemExhibition_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemProgramPersonArgs = {
  objects: ReadonlyArray<Content_ItemProgramPerson_Insert_Input>;
  on_conflict?: Maybe<Content_ItemProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemProgramPerson_OneArgs = {
  object: Content_ItemProgramPerson_Insert_Input;
  on_conflict?: Maybe<Content_ItemProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemTagArgs = {
  objects: ReadonlyArray<Content_ItemTag_Insert_Input>;
  on_conflict?: Maybe<Content_ItemTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemTag_OneArgs = {
  object: Content_ItemTag_Insert_Input;
  on_conflict?: Maybe<Content_ItemTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemTypeArgs = {
  objects: ReadonlyArray<Content_ItemType_Insert_Input>;
  on_conflict?: Maybe<Content_ItemType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_ItemType_OneArgs = {
  object: Content_ItemType_Insert_Input;
  on_conflict?: Maybe<Content_ItemType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_Item_OneArgs = {
  object: Content_Item_Insert_Input;
  on_conflict?: Maybe<Content_Item_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_UploadableElementArgs = {
  objects: ReadonlyArray<Content_UploadableElement_Insert_Input>;
  on_conflict?: Maybe<Content_UploadableElement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_UploadableElementPermissionGrantArgs = {
  objects: ReadonlyArray<Content_UploadableElementPermissionGrant_Insert_Input>;
  on_conflict?: Maybe<Content_UploadableElementPermissionGrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_UploadableElementPermissionGrant_OneArgs = {
  object: Content_UploadableElementPermissionGrant_Insert_Input;
  on_conflict?: Maybe<Content_UploadableElementPermissionGrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_UploadableElement_OneArgs = {
  object: Content_UploadableElement_Insert_Input;
  on_conflict?: Maybe<Content_UploadableElement_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_UploaderArgs = {
  objects: ReadonlyArray<Content_Uploader_Insert_Input>;
  on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Content_Uploader_OneArgs = {
  object: Content_Uploader_Insert_Input;
  on_conflict?: Maybe<Content_Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackCreateJobArgs = {
  objects: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackCreateJob_OneArgs = {
  object: Job_Queues_ChannelStackCreateJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackDeleteJobArgs = {
  objects: ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_ChannelStackDeleteJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackDeleteJob_OneArgs = {
  object: Job_Queues_ChannelStackDeleteJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_ChannelStackDeleteJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CombineVideosJobArgs = {
  objects: ReadonlyArray<Job_Queues_CombineVideosJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CombineVideosJob_OneArgs = {
  object: Job_Queues_CombineVideosJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CustomEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_CustomEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CustomEmailJob_OneArgs = {
  object: Job_Queues_CustomEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_InvitationEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJob_OneArgs = {
  object: Job_Queues_InvitationEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJobArgs = {
  objects: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJob_OneArgs = {
  object: Job_Queues_MediaPackageHarvestJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJobArgs = {
  objects: ReadonlyArray<Job_Queues_PublishVideoJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJob_OneArgs = {
  object: Job_Queues_PublishVideoJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJob_OneArgs = {
  object: Job_Queues_SubmissionRequestEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_UploadYouTubeVideoJobArgs = {
  objects: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_UploadYouTubeVideoJob_OneArgs = {
  object: Job_Queues_UploadYouTubeVideoJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupArgs = {
  objects: ReadonlyArray<Permissions_Group_Insert_Input>;
  on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRegistrantArgs = {
  objects: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input>;
  on_conflict?: Maybe<Permissions_GroupRegistrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRegistrant_OneArgs = {
  object: Permissions_GroupRegistrant_Insert_Input;
  on_conflict?: Maybe<Permissions_GroupRegistrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRoleArgs = {
  objects: ReadonlyArray<Permissions_GroupRole_Insert_Input>;
  on_conflict?: Maybe<Permissions_GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_GroupRole_OneArgs = {
  object: Permissions_GroupRole_Insert_Input;
  on_conflict?: Maybe<Permissions_GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_Group_OneArgs = {
  object: Permissions_Group_Insert_Input;
  on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_PermissionArgs = {
  objects: ReadonlyArray<Permissions_Permission_Insert_Input>;
  on_conflict?: Maybe<Permissions_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_Permission_OneArgs = {
  object: Permissions_Permission_Insert_Input;
  on_conflict?: Maybe<Permissions_Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_RoleArgs = {
  objects: ReadonlyArray<Permissions_Role_Insert_Input>;
  on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_RolePermissionArgs = {
  objects: ReadonlyArray<Permissions_RolePermission_Insert_Input>;
  on_conflict?: Maybe<Permissions_RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_RolePermission_OneArgs = {
  object: Permissions_RolePermission_Insert_Input;
  on_conflict?: Maybe<Permissions_RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permissions_Role_OneArgs = {
  object: Permissions_Role_Insert_Input;
  on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_GoogleAccountArgs = {
  objects: ReadonlyArray<Registrant_GoogleAccount_Insert_Input>;
  on_conflict?: Maybe<Registrant_GoogleAccount_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_GoogleAccount_OneArgs = {
  object: Registrant_GoogleAccount_Insert_Input;
  on_conflict?: Maybe<Registrant_GoogleAccount_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_InvitationArgs = {
  objects: ReadonlyArray<Registrant_Invitation_Insert_Input>;
  on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_Invitation_OneArgs = {
  object: Registrant_Invitation_Insert_Input;
  on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_ProfileArgs = {
  objects: ReadonlyArray<Registrant_Profile_Insert_Input>;
  on_conflict?: Maybe<Registrant_Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_Profile_OneArgs = {
  object: Registrant_Profile_Insert_Input;
  on_conflict?: Maybe<Registrant_Profile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_RegistrantArgs = {
  objects: ReadonlyArray<Registrant_Registrant_Insert_Input>;
  on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Registrant_Registrant_OneArgs = {
  object: Registrant_Registrant_Insert_Input;
  on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_BackendArgs = {
  objects: ReadonlyArray<Room_Backend_Insert_Input>;
  on_conflict?: Maybe<Room_Backend_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Backend_OneArgs = {
  object: Room_Backend_Insert_Input;
  on_conflict?: Maybe<Room_Backend_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ChimeMeetingArgs = {
  objects: ReadonlyArray<Room_ChimeMeeting_Insert_Input>;
  on_conflict?: Maybe<Room_ChimeMeeting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ChimeMeeting_OneArgs = {
  object: Room_ChimeMeeting_Insert_Input;
  on_conflict?: Maybe<Room_ChimeMeeting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ManagementModeArgs = {
  objects: ReadonlyArray<Room_ManagementMode_Insert_Input>;
  on_conflict?: Maybe<Room_ManagementMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ManagementMode_OneArgs = {
  object: Room_ManagementMode_Insert_Input;
  on_conflict?: Maybe<Room_ManagementMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ModeArgs = {
  objects: ReadonlyArray<Room_Mode_Insert_Input>;
  on_conflict?: Maybe<Room_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Mode_OneArgs = {
  object: Room_Mode_Insert_Input;
  on_conflict?: Maybe<Room_Mode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ParticipantArgs = {
  objects: ReadonlyArray<Room_Participant_Insert_Input>;
  on_conflict?: Maybe<Room_Participant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Participant_OneArgs = {
  object: Room_Participant_Insert_Input;
  on_conflict?: Maybe<Room_Participant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_PersonRoleArgs = {
  objects: ReadonlyArray<Room_PersonRole_Insert_Input>;
  on_conflict?: Maybe<Room_PersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_PersonRole_OneArgs = {
  object: Room_PersonRole_Insert_Input;
  on_conflict?: Maybe<Room_PersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomArgs = {
  objects: ReadonlyArray<Room_Room_Insert_Input>;
  on_conflict?: Maybe<Room_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomPersonArgs = {
  objects: ReadonlyArray<Room_RoomPerson_Insert_Input>;
  on_conflict?: Maybe<Room_RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomPerson_OneArgs = {
  object: Room_RoomPerson_Insert_Input;
  on_conflict?: Maybe<Room_RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_Room_OneArgs = {
  object: Room_Room_Insert_Input;
  on_conflict?: Maybe<Room_Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleAlgorithmArgs = {
  objects: ReadonlyArray<Room_ShuffleAlgorithm_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleAlgorithm_OneArgs = {
  object: Room_ShuffleAlgorithm_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriodArgs = {
  objects: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriod_OneArgs = {
  object: Room_ShufflePeriod_Insert_Input;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntryArgs = {
  objects: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntry_OneArgs = {
  object: Room_ShuffleQueueEntry_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoomArgs = {
  objects: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoom_OneArgs = {
  object: Room_ShuffleRoom_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventArgs = {
  objects: ReadonlyArray<Schedule_Event_Insert_Input>;
  on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPersonArgs = {
  objects: ReadonlyArray<Schedule_EventProgramPerson_Insert_Input>;
  on_conflict?: Maybe<Schedule_EventProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPersonRoleArgs = {
  objects: ReadonlyArray<Schedule_EventProgramPersonRole_Insert_Input>;
  on_conflict?: Maybe<Schedule_EventProgramPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPersonRole_OneArgs = {
  object: Schedule_EventProgramPersonRole_Insert_Input;
  on_conflict?: Maybe<Schedule_EventProgramPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventProgramPerson_OneArgs = {
  object: Schedule_EventProgramPerson_Insert_Input;
  on_conflict?: Maybe<Schedule_EventProgramPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventRoomJoinRequestArgs = {
  objects: ReadonlyArray<Schedule_EventRoomJoinRequest_Insert_Input>;
  on_conflict?: Maybe<Schedule_EventRoomJoinRequest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventRoomJoinRequest_OneArgs = {
  object: Schedule_EventRoomJoinRequest_Insert_Input;
  on_conflict?: Maybe<Schedule_EventRoomJoinRequest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventTagArgs = {
  objects: ReadonlyArray<Schedule_EventTag_Insert_Input>;
  on_conflict?: Maybe<Schedule_EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_EventTag_OneArgs = {
  object: Schedule_EventTag_Insert_Input;
  on_conflict?: Maybe<Schedule_EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Schedule_Event_OneArgs = {
  object: Schedule_Event_Insert_Input;
  on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationArgs = {
  objects: ReadonlyArray<System_Configuration_Insert_Input>;
  on_conflict?: Maybe<System_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationKeyArgs = {
  objects: ReadonlyArray<System_ConfigurationKey_Insert_Input>;
  on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationKey_OneArgs = {
  object: System_ConfigurationKey_Insert_Input;
  on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_Configuration_OneArgs = {
  object: System_Configuration_Insert_Input;
  on_conflict?: Maybe<System_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ChannelStackArgs = {
  objects: ReadonlyArray<Video_ChannelStack_Insert_Input>;
  on_conflict?: Maybe<Video_ChannelStack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ChannelStack_OneArgs = {
  object: Video_ChannelStack_Insert_Input;
  on_conflict?: Maybe<Video_ChannelStack_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventParticipantStreamArgs = {
  objects: ReadonlyArray<Video_EventParticipantStream_Insert_Input>;
  on_conflict?: Maybe<Video_EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventParticipantStream_OneArgs = {
  object: Video_EventParticipantStream_Insert_Input;
  on_conflict?: Maybe<Video_EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventVonageSessionArgs = {
  objects: ReadonlyArray<Video_EventVonageSession_Insert_Input>;
  on_conflict?: Maybe<Video_EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_EventVonageSession_OneArgs = {
  object: Video_EventVonageSession_Insert_Input;
  on_conflict?: Maybe<Video_EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ImmediateSwitchArgs = {
  objects: ReadonlyArray<Video_ImmediateSwitch_Insert_Input>;
  on_conflict?: Maybe<Video_ImmediateSwitch_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_ImmediateSwitch_OneArgs = {
  object: Video_ImmediateSwitch_Insert_Input;
  on_conflict?: Maybe<Video_ImmediateSwitch_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_InputTypeArgs = {
  objects: ReadonlyArray<Video_InputType_Insert_Input>;
  on_conflict?: Maybe<Video_InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_InputType_OneArgs = {
  object: Video_InputType_Insert_Input;
  on_conflict?: Maybe<Video_InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_JobStatusArgs = {
  objects: ReadonlyArray<Video_JobStatus_Insert_Input>;
  on_conflict?: Maybe<Video_JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_JobStatus_OneArgs = {
  object: Video_JobStatus_Insert_Input;
  on_conflict?: Maybe<Video_JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_MediaLiveChannelStatusArgs = {
  objects: ReadonlyArray<Video_MediaLiveChannelStatus_Insert_Input>;
  on_conflict?: Maybe<Video_MediaLiveChannelStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_MediaLiveChannelStatus_OneArgs = {
  object: Video_MediaLiveChannelStatus_Insert_Input;
  on_conflict?: Maybe<Video_MediaLiveChannelStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_RtmpInputArgs = {
  objects: ReadonlyArray<Video_RtmpInput_Insert_Input>;
  on_conflict?: Maybe<Video_RtmpInput_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_RtmpInput_OneArgs = {
  object: Video_RtmpInput_Insert_Input;
  on_conflict?: Maybe<Video_RtmpInput_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_TranscriptionJobArgs = {
  objects: ReadonlyArray<Video_TranscriptionJob_Insert_Input>;
  on_conflict?: Maybe<Video_TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_TranscriptionJob_OneArgs = {
  object: Video_TranscriptionJob_Insert_Input;
  on_conflict?: Maybe<Video_TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_VideoRenderJobArgs = {
  objects: ReadonlyArray<Video_VideoRenderJob_Insert_Input>;
  on_conflict?: Maybe<Video_VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_VideoRenderJob_OneArgs = {
  object: Video_VideoRenderJob_Insert_Input;
  on_conflict?: Maybe<Video_VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_YouTubeUploadArgs = {
  objects: ReadonlyArray<Video_YouTubeUpload_Insert_Input>;
  on_conflict?: Maybe<Video_YouTubeUpload_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Video_YouTubeUpload_OneArgs = {
  object: Video_YouTubeUpload_Insert_Input;
  on_conflict?: Maybe<Video_YouTubeUpload_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInvitationConfirmCurrentArgs = {
  inviteCode: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInvitationConfirmSendInitialEmailArgs = {
  inviteInput: InvitationConfirmationEmailInput;
};


/** mutation root */
export type Mutation_RootInvitationConfirmSendRepeatEmailArgs = {
  inviteInput: InvitationConfirmationEmailInput;
};


/** mutation root */
export type Mutation_RootInvitationConfirmWithCodeArgs = {
  inviteInput: ConfirmInvitationInput;
};


/** mutation root */
export type Mutation_RootJoinEventVonageSessionArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinRoomChimeSessionArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinRoomVonageSessionArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootRefreshYouTubeDataArgs = {
  registrantGoogleAccountId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootStopEventBroadcastArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootSubmitGoogleOAuthCodeArgs = {
  code: Scalars['String'];
  state: Scalars['String'];
};


/** mutation root */
export type Mutation_RootSubmitUploadableElementArgs = {
  data: Scalars['jsonb'];
  magicToken: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdateProfilePhotoArgs = {
  registrantId: Scalars['uuid'];
  s3URL?: Maybe<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootUpdateSubtitlesArgs = {
  elementId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdate_EmailArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Email_By_PkArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  pk_columns: Email_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PushNotificationSubscriptionArgs = {
  _set?: Maybe<PushNotificationSubscription_Set_Input>;
  where: PushNotificationSubscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_PushNotificationSubscription_By_PkArgs = {
  _set?: Maybe<PushNotificationSubscription_Set_Input>;
  pk_columns: PushNotificationSubscription_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UserArgs = {
  _set?: Maybe<User_Set_Input>;
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_By_PkArgs = {
  _set?: Maybe<User_Set_Input>;
  pk_columns: User_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_AppStatsArgs = {
  _append?: Maybe<Analytics_AppStats_Append_Input>;
  _delete_at_path?: Maybe<Analytics_AppStats_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Analytics_AppStats_Delete_Elem_Input>;
  _delete_key?: Maybe<Analytics_AppStats_Delete_Key_Input>;
  _inc?: Maybe<Analytics_AppStats_Inc_Input>;
  _prepend?: Maybe<Analytics_AppStats_Prepend_Input>;
  _set?: Maybe<Analytics_AppStats_Set_Input>;
  where: Analytics_AppStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_AppStats_By_PkArgs = {
  _append?: Maybe<Analytics_AppStats_Append_Input>;
  _delete_at_path?: Maybe<Analytics_AppStats_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Analytics_AppStats_Delete_Elem_Input>;
  _delete_key?: Maybe<Analytics_AppStats_Delete_Key_Input>;
  _inc?: Maybe<Analytics_AppStats_Inc_Input>;
  _prepend?: Maybe<Analytics_AppStats_Prepend_Input>;
  _set?: Maybe<Analytics_AppStats_Set_Input>;
  pk_columns: Analytics_AppStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentElementStatsArgs = {
  _inc?: Maybe<Analytics_ContentElementStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentElementStats_Set_Input>;
  where: Analytics_ContentElementStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentElementStats_By_PkArgs = {
  _inc?: Maybe<Analytics_ContentElementStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentElementStats_Set_Input>;
  pk_columns: Analytics_ContentElementStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentItemStatsArgs = {
  _inc?: Maybe<Analytics_ContentItemStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentItemStats_Set_Input>;
  where: Analytics_ContentItemStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentItemStats_By_PkArgs = {
  _inc?: Maybe<Analytics_ContentItemStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentItemStats_Set_Input>;
  pk_columns: Analytics_ContentItemStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_RoomStatsArgs = {
  _inc?: Maybe<Analytics_RoomStats_Inc_Input>;
  _set?: Maybe<Analytics_RoomStats_Set_Input>;
  where: Analytics_RoomStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_RoomStats_By_PkArgs = {
  _inc?: Maybe<Analytics_RoomStats_Inc_Input>;
  _set?: Maybe<Analytics_RoomStats_Set_Input>;
  pk_columns: Analytics_RoomStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ChatArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Chat_By_PkArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  pk_columns: Chat_Chat_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagTypeArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagType_By_PkArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  pk_columns: Chat_FlagType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Flag_By_PkArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  pk_columns: Chat_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageTypeArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageType_By_PkArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  pk_columns: Chat_MessageType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Message_By_PkArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  pk_columns: Chat_Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_PinArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Pin_By_PkArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  pk_columns: Chat_Pin_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionTypeArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionType_By_PkArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  pk_columns: Chat_ReactionType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Reaction_By_PkArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  pk_columns: Chat_Reaction_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndexArgs = {
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndex_By_PkArgs = {
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  pk_columns: Chat_ReadUpToIndex_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_SubscriptionArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Subscription_By_PkArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  pk_columns: Chat_Subscription_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ExhibitionArgs = {
  _inc?: Maybe<Collection_Exhibition_Inc_Input>;
  _set?: Maybe<Collection_Exhibition_Set_Input>;
  where: Collection_Exhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_Exhibition_By_PkArgs = {
  _inc?: Maybe<Collection_Exhibition_Inc_Input>;
  _set?: Maybe<Collection_Exhibition_Set_Input>;
  pk_columns: Collection_Exhibition_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ProgramPersonArgs = {
  _set?: Maybe<Collection_ProgramPerson_Set_Input>;
  where: Collection_ProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_ProgramPerson_By_PkArgs = {
  _set?: Maybe<Collection_ProgramPerson_Set_Input>;
  pk_columns: Collection_ProgramPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_TagArgs = {
  _inc?: Maybe<Collection_Tag_Inc_Input>;
  _set?: Maybe<Collection_Tag_Set_Input>;
  where: Collection_Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Collection_Tag_By_PkArgs = {
  _inc?: Maybe<Collection_Tag_Inc_Input>;
  _set?: Maybe<Collection_Tag_Set_Input>;
  pk_columns: Collection_Tag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_ConferenceArgs = {
  _set?: Maybe<Conference_Conference_Set_Input>;
  where: Conference_Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_Conference_By_PkArgs = {
  _set?: Maybe<Conference_Conference_Set_Input>;
  pk_columns: Conference_Conference_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_ConfigurationArgs = {
  _append?: Maybe<Conference_Configuration_Append_Input>;
  _delete_at_path?: Maybe<Conference_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<Conference_Configuration_Prepend_Input>;
  _set?: Maybe<Conference_Configuration_Set_Input>;
  where: Conference_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_Configuration_By_PkArgs = {
  _append?: Maybe<Conference_Configuration_Append_Input>;
  _delete_at_path?: Maybe<Conference_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<Conference_Configuration_Prepend_Input>;
  _set?: Maybe<Conference_Configuration_Set_Input>;
  pk_columns: Conference_Configuration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_DemoCodeArgs = {
  _set?: Maybe<Conference_DemoCode_Set_Input>;
  where: Conference_DemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_DemoCode_By_PkArgs = {
  _set?: Maybe<Conference_DemoCode_Set_Input>;
  pk_columns: Conference_DemoCode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_OriginatingDataArgs = {
  _append?: Maybe<Conference_OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<Conference_OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<Conference_OriginatingData_Prepend_Input>;
  _set?: Maybe<Conference_OriginatingData_Set_Input>;
  where: Conference_OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_OriginatingData_By_PkArgs = {
  _append?: Maybe<Conference_OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<Conference_OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Conference_OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<Conference_OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<Conference_OriginatingData_Prepend_Input>;
  _set?: Maybe<Conference_OriginatingData_Set_Input>;
  pk_columns: Conference_OriginatingData_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_PrepareJobArgs = {
  _set?: Maybe<Conference_PrepareJob_Set_Input>;
  where: Conference_PrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_PrepareJob_By_PkArgs = {
  _set?: Maybe<Conference_PrepareJob_Set_Input>;
  pk_columns: Conference_PrepareJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementArgs = {
  _append?: Maybe<Content_Element_Append_Input>;
  _delete_at_path?: Maybe<Content_Element_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_Element_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_Element_Delete_Key_Input>;
  _prepend?: Maybe<Content_Element_Prepend_Input>;
  _set?: Maybe<Content_Element_Set_Input>;
  where: Content_Element_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementPermissionGrantArgs = {
  _set?: Maybe<Content_ElementPermissionGrant_Set_Input>;
  where: Content_ElementPermissionGrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementPermissionGrant_By_PkArgs = {
  _set?: Maybe<Content_ElementPermissionGrant_Set_Input>;
  pk_columns: Content_ElementPermissionGrant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementTypeArgs = {
  _set?: Maybe<Content_ElementType_Set_Input>;
  where: Content_ElementType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ElementType_By_PkArgs = {
  _set?: Maybe<Content_ElementType_Set_Input>;
  pk_columns: Content_ElementType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_Element_By_PkArgs = {
  _append?: Maybe<Content_Element_Append_Input>;
  _delete_at_path?: Maybe<Content_Element_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_Element_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_Element_Delete_Key_Input>;
  _prepend?: Maybe<Content_Element_Prepend_Input>;
  _set?: Maybe<Content_Element_Set_Input>;
  pk_columns: Content_Element_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemArgs = {
  _set?: Maybe<Content_Item_Set_Input>;
  where: Content_Item_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemExhibitionArgs = {
  _append?: Maybe<Content_ItemExhibition_Append_Input>;
  _delete_at_path?: Maybe<Content_ItemExhibition_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_ItemExhibition_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_ItemExhibition_Delete_Key_Input>;
  _inc?: Maybe<Content_ItemExhibition_Inc_Input>;
  _prepend?: Maybe<Content_ItemExhibition_Prepend_Input>;
  _set?: Maybe<Content_ItemExhibition_Set_Input>;
  where: Content_ItemExhibition_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemExhibition_By_PkArgs = {
  _append?: Maybe<Content_ItemExhibition_Append_Input>;
  _delete_at_path?: Maybe<Content_ItemExhibition_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Content_ItemExhibition_Delete_Elem_Input>;
  _delete_key?: Maybe<Content_ItemExhibition_Delete_Key_Input>;
  _inc?: Maybe<Content_ItemExhibition_Inc_Input>;
  _prepend?: Maybe<Content_ItemExhibition_Prepend_Input>;
  _set?: Maybe<Content_ItemExhibition_Set_Input>;
  pk_columns: Content_ItemExhibition_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemProgramPersonArgs = {
  _inc?: Maybe<Content_ItemProgramPerson_Inc_Input>;
  _set?: Maybe<Content_ItemProgramPerson_Set_Input>;
  where: Content_ItemProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemProgramPerson_By_PkArgs = {
  _inc?: Maybe<Content_ItemProgramPerson_Inc_Input>;
  _set?: Maybe<Content_ItemProgramPerson_Set_Input>;
  pk_columns: Content_ItemProgramPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemTagArgs = {
  _set?: Maybe<Content_ItemTag_Set_Input>;
  where: Content_ItemTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemTag_By_PkArgs = {
  _set?: Maybe<Content_ItemTag_Set_Input>;
  pk_columns: Content_ItemTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemTypeArgs = {
  _set?: Maybe<Content_ItemType_Set_Input>;
  where: Content_ItemType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_ItemType_By_PkArgs = {
  _set?: Maybe<Content_ItemType_Set_Input>;
  pk_columns: Content_ItemType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_Item_By_PkArgs = {
  _set?: Maybe<Content_Item_Set_Input>;
  pk_columns: Content_Item_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_UploadableElementArgs = {
  _inc?: Maybe<Content_UploadableElement_Inc_Input>;
  _set?: Maybe<Content_UploadableElement_Set_Input>;
  where: Content_UploadableElement_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_UploadableElementPermissionGrantArgs = {
  _set?: Maybe<Content_UploadableElementPermissionGrant_Set_Input>;
  where: Content_UploadableElementPermissionGrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_UploadableElementPermissionGrant_By_PkArgs = {
  _set?: Maybe<Content_UploadableElementPermissionGrant_Set_Input>;
  pk_columns: Content_UploadableElementPermissionGrant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_UploadableElement_By_PkArgs = {
  _inc?: Maybe<Content_UploadableElement_Inc_Input>;
  _set?: Maybe<Content_UploadableElement_Set_Input>;
  pk_columns: Content_UploadableElement_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Content_UploaderArgs = {
  _inc?: Maybe<Content_Uploader_Inc_Input>;
  _set?: Maybe<Content_Uploader_Set_Input>;
  where: Content_Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Content_Uploader_By_PkArgs = {
  _inc?: Maybe<Content_Uploader_Inc_Input>;
  _set?: Maybe<Content_Uploader_Set_Input>;
  pk_columns: Content_Uploader_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackCreateJobArgs = {
  _set?: Maybe<Job_Queues_ChannelStackCreateJob_Set_Input>;
  where: Job_Queues_ChannelStackCreateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackCreateJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_ChannelStackCreateJob_Set_Input>;
  pk_columns: Job_Queues_ChannelStackCreateJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackDeleteJobArgs = {
  _set?: Maybe<Job_Queues_ChannelStackDeleteJob_Set_Input>;
  where: Job_Queues_ChannelStackDeleteJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackDeleteJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_ChannelStackDeleteJob_Set_Input>;
  pk_columns: Job_Queues_ChannelStackDeleteJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CombineVideosJobArgs = {
  _append?: Maybe<Job_Queues_CombineVideosJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CombineVideosJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CombineVideosJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CombineVideosJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CombineVideosJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CombineVideosJob_Set_Input>;
  where: Job_Queues_CombineVideosJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CombineVideosJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_CombineVideosJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CombineVideosJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CombineVideosJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CombineVideosJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CombineVideosJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CombineVideosJob_Set_Input>;
  pk_columns: Job_Queues_CombineVideosJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CustomEmailJobArgs = {
  _append?: Maybe<Job_Queues_CustomEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CustomEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CustomEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CustomEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CustomEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CustomEmailJob_Set_Input>;
  where: Job_Queues_CustomEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CustomEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_CustomEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CustomEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CustomEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CustomEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CustomEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CustomEmailJob_Set_Input>;
  pk_columns: Job_Queues_CustomEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJobArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  pk_columns: Job_Queues_InvitationEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJobArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  pk_columns: Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJobArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  pk_columns: Job_Queues_PublishVideoJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJobArgs = {
  _append?: Maybe<Job_Queues_SubmissionRequestEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_SubmissionRequestEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_SubmissionRequestEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_SubmissionRequestEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  pk_columns: Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_UploadYouTubeVideoJobArgs = {
  _inc?: Maybe<Job_Queues_UploadYouTubeVideoJob_Inc_Input>;
  _set?: Maybe<Job_Queues_UploadYouTubeVideoJob_Set_Input>;
  where: Job_Queues_UploadYouTubeVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  _inc?: Maybe<Job_Queues_UploadYouTubeVideoJob_Inc_Input>;
  _set?: Maybe<Job_Queues_UploadYouTubeVideoJob_Set_Input>;
  pk_columns: Job_Queues_UploadYouTubeVideoJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupArgs = {
  _set?: Maybe<Permissions_Group_Set_Input>;
  where: Permissions_Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRegistrantArgs = {
  _set?: Maybe<Permissions_GroupRegistrant_Set_Input>;
  where: Permissions_GroupRegistrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRegistrant_By_PkArgs = {
  _set?: Maybe<Permissions_GroupRegistrant_Set_Input>;
  pk_columns: Permissions_GroupRegistrant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRoleArgs = {
  _set?: Maybe<Permissions_GroupRole_Set_Input>;
  where: Permissions_GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_GroupRole_By_PkArgs = {
  _set?: Maybe<Permissions_GroupRole_Set_Input>;
  pk_columns: Permissions_GroupRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_Group_By_PkArgs = {
  _set?: Maybe<Permissions_Group_Set_Input>;
  pk_columns: Permissions_Group_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_PermissionArgs = {
  _set?: Maybe<Permissions_Permission_Set_Input>;
  where: Permissions_Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_Permission_By_PkArgs = {
  _set?: Maybe<Permissions_Permission_Set_Input>;
  pk_columns: Permissions_Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_RoleArgs = {
  _set?: Maybe<Permissions_Role_Set_Input>;
  where: Permissions_Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_RolePermissionArgs = {
  _set?: Maybe<Permissions_RolePermission_Set_Input>;
  where: Permissions_RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_RolePermission_By_PkArgs = {
  _set?: Maybe<Permissions_RolePermission_Set_Input>;
  pk_columns: Permissions_RolePermission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Permissions_Role_By_PkArgs = {
  _set?: Maybe<Permissions_Role_Set_Input>;
  pk_columns: Permissions_Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_GoogleAccountArgs = {
  _append?: Maybe<Registrant_GoogleAccount_Append_Input>;
  _delete_at_path?: Maybe<Registrant_GoogleAccount_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_GoogleAccount_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_GoogleAccount_Delete_Key_Input>;
  _prepend?: Maybe<Registrant_GoogleAccount_Prepend_Input>;
  _set?: Maybe<Registrant_GoogleAccount_Set_Input>;
  where: Registrant_GoogleAccount_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_GoogleAccount_By_PkArgs = {
  _append?: Maybe<Registrant_GoogleAccount_Append_Input>;
  _delete_at_path?: Maybe<Registrant_GoogleAccount_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_GoogleAccount_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_GoogleAccount_Delete_Key_Input>;
  _prepend?: Maybe<Registrant_GoogleAccount_Prepend_Input>;
  _set?: Maybe<Registrant_GoogleAccount_Set_Input>;
  pk_columns: Registrant_GoogleAccount_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_InvitationArgs = {
  _set?: Maybe<Registrant_Invitation_Set_Input>;
  where: Registrant_Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_Invitation_By_PkArgs = {
  _set?: Maybe<Registrant_Invitation_Set_Input>;
  pk_columns: Registrant_Invitation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_ProfileArgs = {
  _append?: Maybe<Registrant_Profile_Append_Input>;
  _delete_at_path?: Maybe<Registrant_Profile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_Profile_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_Profile_Delete_Key_Input>;
  _inc?: Maybe<Registrant_Profile_Inc_Input>;
  _prepend?: Maybe<Registrant_Profile_Prepend_Input>;
  _set?: Maybe<Registrant_Profile_Set_Input>;
  where: Registrant_Profile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_Profile_By_PkArgs = {
  _append?: Maybe<Registrant_Profile_Append_Input>;
  _delete_at_path?: Maybe<Registrant_Profile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Registrant_Profile_Delete_Elem_Input>;
  _delete_key?: Maybe<Registrant_Profile_Delete_Key_Input>;
  _inc?: Maybe<Registrant_Profile_Inc_Input>;
  _prepend?: Maybe<Registrant_Profile_Prepend_Input>;
  _set?: Maybe<Registrant_Profile_Set_Input>;
  pk_columns: Registrant_Profile_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_RegistrantArgs = {
  _set?: Maybe<Registrant_Registrant_Set_Input>;
  where: Registrant_Registrant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Registrant_Registrant_By_PkArgs = {
  _set?: Maybe<Registrant_Registrant_Set_Input>;
  pk_columns: Registrant_Registrant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_BackendArgs = {
  _set?: Maybe<Room_Backend_Set_Input>;
  where: Room_Backend_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Backend_By_PkArgs = {
  _set?: Maybe<Room_Backend_Set_Input>;
  pk_columns: Room_Backend_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ChimeMeetingArgs = {
  _append?: Maybe<Room_ChimeMeeting_Append_Input>;
  _delete_at_path?: Maybe<Room_ChimeMeeting_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Room_ChimeMeeting_Delete_Elem_Input>;
  _delete_key?: Maybe<Room_ChimeMeeting_Delete_Key_Input>;
  _prepend?: Maybe<Room_ChimeMeeting_Prepend_Input>;
  _set?: Maybe<Room_ChimeMeeting_Set_Input>;
  where: Room_ChimeMeeting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ChimeMeeting_By_PkArgs = {
  _append?: Maybe<Room_ChimeMeeting_Append_Input>;
  _delete_at_path?: Maybe<Room_ChimeMeeting_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Room_ChimeMeeting_Delete_Elem_Input>;
  _delete_key?: Maybe<Room_ChimeMeeting_Delete_Key_Input>;
  _prepend?: Maybe<Room_ChimeMeeting_Prepend_Input>;
  _set?: Maybe<Room_ChimeMeeting_Set_Input>;
  pk_columns: Room_ChimeMeeting_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ManagementModeArgs = {
  _set?: Maybe<Room_ManagementMode_Set_Input>;
  where: Room_ManagementMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ManagementMode_By_PkArgs = {
  _set?: Maybe<Room_ManagementMode_Set_Input>;
  pk_columns: Room_ManagementMode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ModeArgs = {
  _set?: Maybe<Room_Mode_Set_Input>;
  where: Room_Mode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Mode_By_PkArgs = {
  _set?: Maybe<Room_Mode_Set_Input>;
  pk_columns: Room_Mode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ParticipantArgs = {
  _set?: Maybe<Room_Participant_Set_Input>;
  where: Room_Participant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Participant_By_PkArgs = {
  _set?: Maybe<Room_Participant_Set_Input>;
  pk_columns: Room_Participant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_PersonRoleArgs = {
  _set?: Maybe<Room_PersonRole_Set_Input>;
  where: Room_PersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_PersonRole_By_PkArgs = {
  _set?: Maybe<Room_PersonRole_Set_Input>;
  pk_columns: Room_PersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomArgs = {
  _inc?: Maybe<Room_Room_Inc_Input>;
  _set?: Maybe<Room_Room_Set_Input>;
  where: Room_Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomPersonArgs = {
  _set?: Maybe<Room_RoomPerson_Set_Input>;
  where: Room_RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomPerson_By_PkArgs = {
  _set?: Maybe<Room_RoomPerson_Set_Input>;
  pk_columns: Room_RoomPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_Room_By_PkArgs = {
  _inc?: Maybe<Room_Room_Inc_Input>;
  _set?: Maybe<Room_Room_Set_Input>;
  pk_columns: Room_Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleAlgorithmArgs = {
  _set?: Maybe<Room_ShuffleAlgorithm_Set_Input>;
  where: Room_ShuffleAlgorithm_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleAlgorithm_By_PkArgs = {
  _set?: Maybe<Room_ShuffleAlgorithm_Set_Input>;
  pk_columns: Room_ShuffleAlgorithm_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriodArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriod_By_PkArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  pk_columns: Room_ShufflePeriod_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntryArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntry_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  pk_columns: Room_ShuffleQueueEntry_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoomArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoom_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  pk_columns: Room_ShuffleRoom_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventArgs = {
  _inc?: Maybe<Schedule_Event_Inc_Input>;
  _set?: Maybe<Schedule_Event_Set_Input>;
  where: Schedule_Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPersonArgs = {
  _set?: Maybe<Schedule_EventProgramPerson_Set_Input>;
  where: Schedule_EventProgramPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPersonRoleArgs = {
  _set?: Maybe<Schedule_EventProgramPersonRole_Set_Input>;
  where: Schedule_EventProgramPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPersonRole_By_PkArgs = {
  _set?: Maybe<Schedule_EventProgramPersonRole_Set_Input>;
  pk_columns: Schedule_EventProgramPersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventProgramPerson_By_PkArgs = {
  _set?: Maybe<Schedule_EventProgramPerson_Set_Input>;
  pk_columns: Schedule_EventProgramPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventRoomJoinRequestArgs = {
  _set?: Maybe<Schedule_EventRoomJoinRequest_Set_Input>;
  where: Schedule_EventRoomJoinRequest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventRoomJoinRequest_By_PkArgs = {
  _set?: Maybe<Schedule_EventRoomJoinRequest_Set_Input>;
  pk_columns: Schedule_EventRoomJoinRequest_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventTagArgs = {
  _set?: Maybe<Schedule_EventTag_Set_Input>;
  where: Schedule_EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_EventTag_By_PkArgs = {
  _set?: Maybe<Schedule_EventTag_Set_Input>;
  pk_columns: Schedule_EventTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Schedule_Event_By_PkArgs = {
  _inc?: Maybe<Schedule_Event_Inc_Input>;
  _set?: Maybe<Schedule_Event_Set_Input>;
  pk_columns: Schedule_Event_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationArgs = {
  _append?: Maybe<System_Configuration_Append_Input>;
  _delete_at_path?: Maybe<System_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<System_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<System_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<System_Configuration_Prepend_Input>;
  _set?: Maybe<System_Configuration_Set_Input>;
  where: System_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationKeyArgs = {
  _set?: Maybe<System_ConfigurationKey_Set_Input>;
  where: System_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationKey_By_PkArgs = {
  _set?: Maybe<System_ConfigurationKey_Set_Input>;
  pk_columns: System_ConfigurationKey_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_System_Configuration_By_PkArgs = {
  _append?: Maybe<System_Configuration_Append_Input>;
  _delete_at_path?: Maybe<System_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<System_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<System_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<System_Configuration_Prepend_Input>;
  _set?: Maybe<System_Configuration_Set_Input>;
  pk_columns: System_Configuration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ChannelStackArgs = {
  _set?: Maybe<Video_ChannelStack_Set_Input>;
  where: Video_ChannelStack_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ChannelStack_By_PkArgs = {
  _set?: Maybe<Video_ChannelStack_Set_Input>;
  pk_columns: Video_ChannelStack_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventParticipantStreamArgs = {
  _set?: Maybe<Video_EventParticipantStream_Set_Input>;
  where: Video_EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventParticipantStream_By_PkArgs = {
  _set?: Maybe<Video_EventParticipantStream_Set_Input>;
  pk_columns: Video_EventParticipantStream_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventVonageSessionArgs = {
  _append?: Maybe<Video_EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<Video_EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<Video_EventVonageSession_Prepend_Input>;
  _set?: Maybe<Video_EventVonageSession_Set_Input>;
  where: Video_EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_EventVonageSession_By_PkArgs = {
  _append?: Maybe<Video_EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<Video_EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<Video_EventVonageSession_Prepend_Input>;
  _set?: Maybe<Video_EventVonageSession_Set_Input>;
  pk_columns: Video_EventVonageSession_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ImmediateSwitchArgs = {
  _append?: Maybe<Video_ImmediateSwitch_Append_Input>;
  _delete_at_path?: Maybe<Video_ImmediateSwitch_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_ImmediateSwitch_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_ImmediateSwitch_Delete_Key_Input>;
  _prepend?: Maybe<Video_ImmediateSwitch_Prepend_Input>;
  _set?: Maybe<Video_ImmediateSwitch_Set_Input>;
  where: Video_ImmediateSwitch_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_ImmediateSwitch_By_PkArgs = {
  _append?: Maybe<Video_ImmediateSwitch_Append_Input>;
  _delete_at_path?: Maybe<Video_ImmediateSwitch_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_ImmediateSwitch_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_ImmediateSwitch_Delete_Key_Input>;
  _prepend?: Maybe<Video_ImmediateSwitch_Prepend_Input>;
  _set?: Maybe<Video_ImmediateSwitch_Set_Input>;
  pk_columns: Video_ImmediateSwitch_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_InputTypeArgs = {
  _set?: Maybe<Video_InputType_Set_Input>;
  where: Video_InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_InputType_By_PkArgs = {
  _set?: Maybe<Video_InputType_Set_Input>;
  pk_columns: Video_InputType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_JobStatusArgs = {
  _set?: Maybe<Video_JobStatus_Set_Input>;
  where: Video_JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_JobStatus_By_PkArgs = {
  _set?: Maybe<Video_JobStatus_Set_Input>;
  pk_columns: Video_JobStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_MediaLiveChannelStatusArgs = {
  _inc?: Maybe<Video_MediaLiveChannelStatus_Inc_Input>;
  _set?: Maybe<Video_MediaLiveChannelStatus_Set_Input>;
  where: Video_MediaLiveChannelStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_MediaLiveChannelStatus_By_PkArgs = {
  _inc?: Maybe<Video_MediaLiveChannelStatus_Inc_Input>;
  _set?: Maybe<Video_MediaLiveChannelStatus_Set_Input>;
  pk_columns: Video_MediaLiveChannelStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_RtmpInputArgs = {
  _set?: Maybe<Video_RtmpInput_Set_Input>;
  where: Video_RtmpInput_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_RtmpInput_By_PkArgs = {
  _set?: Maybe<Video_RtmpInput_Set_Input>;
  pk_columns: Video_RtmpInput_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_TranscriptionJobArgs = {
  _set?: Maybe<Video_TranscriptionJob_Set_Input>;
  where: Video_TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_TranscriptionJob_By_PkArgs = {
  _set?: Maybe<Video_TranscriptionJob_Set_Input>;
  pk_columns: Video_TranscriptionJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_VideoRenderJobArgs = {
  _append?: Maybe<Video_VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<Video_VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<Video_VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<Video_VideoRenderJob_Prepend_Input>;
  _set?: Maybe<Video_VideoRenderJob_Set_Input>;
  where: Video_VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_VideoRenderJob_By_PkArgs = {
  _append?: Maybe<Video_VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<Video_VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Video_VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Video_VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<Video_VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<Video_VideoRenderJob_Prepend_Input>;
  _set?: Maybe<Video_VideoRenderJob_Set_Input>;
  pk_columns: Video_VideoRenderJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Video_YouTubeUploadArgs = {
  _set?: Maybe<Video_YouTubeUpload_Set_Input>;
  where: Video_YouTubeUpload_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Video_YouTubeUpload_By_PkArgs = {
  _set?: Maybe<Video_YouTubeUpload_Set_Input>;
  pk_columns: Video_YouTubeUpload_Pk_Columns_Input;
};


/** expression to compare columns of type numeric. All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['numeric']>;
  readonly _gt?: Maybe<Scalars['numeric']>;
  readonly _gte?: Maybe<Scalars['numeric']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['numeric']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['numeric']>;
  readonly _lte?: Maybe<Scalars['numeric']>;
  readonly _neq?: Maybe<Scalars['numeric']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['numeric']>>;
};

/** column ordering options */
export enum Order_By {
  /** in the ascending order, nulls last */
  Asc = 'asc',
  /** in the ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in the ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in the descending order, nulls first */
  Desc = 'desc',
  /** in the descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in the descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** columns and relationships of "permissions.Group" */
export type Permissions_Group = {
  readonly __typename?: 'permissions_Group';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly enabled: Scalars['Boolean'];
  /** An array relationship */
  readonly groupRegistrants: ReadonlyArray<Permissions_GroupRegistrant>;
  /** An aggregated array relationship */
  readonly groupRegistrants_aggregate: Permissions_GroupRegistrant_Aggregate;
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<Permissions_GroupRole>;
  /** An aggregated array relationship */
  readonly groupRoles_aggregate: Permissions_GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly includeUnauthenticated: Scalars['Boolean'];
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** columns and relationships of "permissions.Group" */
export type Permissions_GroupGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};

/** columns and relationships of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant = {
  readonly __typename?: 'permissions_GroupRegistrant';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Permissions_Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate = {
  readonly __typename?: 'permissions_GroupRegistrant_aggregate';
  readonly aggregate?: Maybe<Permissions_GroupRegistrant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_GroupRegistrant>;
};

/** aggregate fields of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate_Fields = {
  readonly __typename?: 'permissions_GroupRegistrant_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permissions_GroupRegistrant_Max_Fields>;
  readonly min?: Maybe<Permissions_GroupRegistrant_Min_Fields>;
};


/** aggregate fields of "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_GroupRegistrant_Max_Order_By>;
  readonly min?: Maybe<Permissions_GroupRegistrant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input>;
  readonly on_conflict?: Maybe<Permissions_GroupRegistrant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.GroupRegistrant". All fields are combined with a logical 'AND'. */
export type Permissions_GroupRegistrant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permissions_GroupRegistrant_Bool_Exp>>>;
  readonly _not?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permissions_GroupRegistrant_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Permissions_Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.GroupRegistrant" */
export enum Permissions_GroupRegistrant_Constraint {
  /** unique or primary key constraint */
  GroupRegistrantGroupIdRegistrantIdKey = 'GroupRegistrant_groupId_registrantId_key',
  /** unique or primary key constraint */
  GroupRegistrantPkey = 'GroupRegistrant_pkey'
}

/** input type for inserting data into table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Permissions_Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_GroupRegistrant_Max_Fields = {
  readonly __typename?: 'permissions_GroupRegistrant_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_GroupRegistrant_Min_Fields = {
  readonly __typename?: 'permissions_GroupRegistrant_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Mutation_Response = {
  readonly __typename?: 'permissions_GroupRegistrant_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permissions_GroupRegistrant>;
};

/** input type for inserting object relation for remote table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Obj_Rel_Insert_Input = {
  readonly data: Permissions_GroupRegistrant_Insert_Input;
  readonly on_conflict?: Maybe<Permissions_GroupRegistrant_On_Conflict>;
};

/** on conflict condition type for table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_On_Conflict = {
  readonly constraint: Permissions_GroupRegistrant_Constraint;
  readonly update_columns: ReadonlyArray<Permissions_GroupRegistrant_Update_Column>;
  readonly where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};

/** ordering options when selecting data from "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Permissions_Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.GroupRegistrant" */
export enum Permissions_GroupRegistrant_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.GroupRegistrant" */
export type Permissions_GroupRegistrant_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.GroupRegistrant" */
export enum Permissions_GroupRegistrant_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "permissions.GroupRole" */
export type Permissions_GroupRole = {
  readonly __typename?: 'permissions_GroupRole';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Permissions_Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly role: Permissions_Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate = {
  readonly __typename?: 'permissions_GroupRole_aggregate';
  readonly aggregate?: Maybe<Permissions_GroupRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_GroupRole>;
};

/** aggregate fields of "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate_Fields = {
  readonly __typename?: 'permissions_GroupRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permissions_GroupRole_Max_Fields>;
  readonly min?: Maybe<Permissions_GroupRole_Min_Fields>;
};


/** aggregate fields of "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.GroupRole" */
export type Permissions_GroupRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_GroupRole_Max_Order_By>;
  readonly min?: Maybe<Permissions_GroupRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.GroupRole" */
export type Permissions_GroupRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_GroupRole_Insert_Input>;
  readonly on_conflict?: Maybe<Permissions_GroupRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.GroupRole". All fields are combined with a logical 'AND'. */
export type Permissions_GroupRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permissions_GroupRole_Bool_Exp>>>;
  readonly _not?: Maybe<Permissions_GroupRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permissions_GroupRole_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Permissions_Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly role?: Maybe<Permissions_Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.GroupRole" */
export enum Permissions_GroupRole_Constraint {
  /** unique or primary key constraint */
  GroupRoleGroupIdRoleIdKey = 'GroupRole_groupId_roleId_key',
  /** unique or primary key constraint */
  GroupRolePkey = 'GroupRole_pkey'
}

/** input type for inserting data into table "permissions.GroupRole" */
export type Permissions_GroupRole_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Permissions_Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly role?: Maybe<Permissions_Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_GroupRole_Max_Fields = {
  readonly __typename?: 'permissions_GroupRole_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.GroupRole" */
export type Permissions_GroupRole_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_GroupRole_Min_Fields = {
  readonly __typename?: 'permissions_GroupRole_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.GroupRole" */
export type Permissions_GroupRole_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.GroupRole" */
export type Permissions_GroupRole_Mutation_Response = {
  readonly __typename?: 'permissions_GroupRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permissions_GroupRole>;
};

/** input type for inserting object relation for remote table "permissions.GroupRole" */
export type Permissions_GroupRole_Obj_Rel_Insert_Input = {
  readonly data: Permissions_GroupRole_Insert_Input;
  readonly on_conflict?: Maybe<Permissions_GroupRole_On_Conflict>;
};

/** on conflict condition type for table "permissions.GroupRole" */
export type Permissions_GroupRole_On_Conflict = {
  readonly constraint: Permissions_GroupRole_Constraint;
  readonly update_columns: ReadonlyArray<Permissions_GroupRole_Update_Column>;
  readonly where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};

/** ordering options when selecting data from "permissions.GroupRole" */
export type Permissions_GroupRole_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Permissions_Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly role?: Maybe<Permissions_Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "permissions.GroupRole" */
export type Permissions_GroupRole_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.GroupRole" */
export enum Permissions_GroupRole_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.GroupRole" */
export type Permissions_GroupRole_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.GroupRole" */
export enum Permissions_GroupRole_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "permissions.Group" */
export type Permissions_Group_Aggregate = {
  readonly __typename?: 'permissions_Group_aggregate';
  readonly aggregate?: Maybe<Permissions_Group_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_Group>;
};

/** aggregate fields of "permissions.Group" */
export type Permissions_Group_Aggregate_Fields = {
  readonly __typename?: 'permissions_Group_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permissions_Group_Max_Fields>;
  readonly min?: Maybe<Permissions_Group_Min_Fields>;
};


/** aggregate fields of "permissions.Group" */
export type Permissions_Group_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.Group" */
export type Permissions_Group_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_Group_Max_Order_By>;
  readonly min?: Maybe<Permissions_Group_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.Group" */
export type Permissions_Group_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_Group_Insert_Input>;
  readonly on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.Group". All fields are combined with a logical 'AND'. */
export type Permissions_Group_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permissions_Group_Bool_Exp>>>;
  readonly _not?: Maybe<Permissions_Group_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permissions_Group_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly enabled?: Maybe<Boolean_Comparison_Exp>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly includeUnauthenticated?: Maybe<Boolean_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.Group" */
export enum Permissions_Group_Constraint {
  /** unique or primary key constraint */
  GroupConferenceIdNameKey = 'Group_conferenceId_name_key',
  /** unique or primary key constraint */
  GroupPkey = 'Group_pkey'
}

/** input type for inserting data into table "permissions.Group" */
export type Permissions_Group_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Arr_Rel_Insert_Input>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_Group_Max_Fields = {
  readonly __typename?: 'permissions_Group_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.Group" */
export type Permissions_Group_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_Group_Min_Fields = {
  readonly __typename?: 'permissions_Group_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.Group" */
export type Permissions_Group_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.Group" */
export type Permissions_Group_Mutation_Response = {
  readonly __typename?: 'permissions_Group_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permissions_Group>;
};

/** input type for inserting object relation for remote table "permissions.Group" */
export type Permissions_Group_Obj_Rel_Insert_Input = {
  readonly data: Permissions_Group_Insert_Input;
  readonly on_conflict?: Maybe<Permissions_Group_On_Conflict>;
};

/** on conflict condition type for table "permissions.Group" */
export type Permissions_Group_On_Conflict = {
  readonly constraint: Permissions_Group_Constraint;
  readonly update_columns: ReadonlyArray<Permissions_Group_Update_Column>;
  readonly where?: Maybe<Permissions_Group_Bool_Exp>;
};

/** ordering options when selecting data from "permissions.Group" */
export type Permissions_Group_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly enabled?: Maybe<Order_By>;
  readonly groupRegistrants_aggregate?: Maybe<Permissions_GroupRegistrant_Aggregate_Order_By>;
  readonly groupRoles_aggregate?: Maybe<Permissions_GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly includeUnauthenticated?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "permissions.Group" */
export type Permissions_Group_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.Group" */
export enum Permissions_Group_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.Group" */
export type Permissions_Group_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.Group" */
export enum Permissions_Group_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "permissions.Permission" */
export type Permissions_Permission = {
  readonly __typename?: 'permissions_Permission';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<Permissions_RolePermission>;
  /** An aggregated array relationship */
  readonly rolePermissions_aggregate: Permissions_RolePermission_Aggregate;
};


/** columns and relationships of "permissions.Permission" */
export type Permissions_PermissionRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** columns and relationships of "permissions.Permission" */
export type Permissions_PermissionRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** aggregated selection of "permissions.Permission" */
export type Permissions_Permission_Aggregate = {
  readonly __typename?: 'permissions_Permission_aggregate';
  readonly aggregate?: Maybe<Permissions_Permission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_Permission>;
};

/** aggregate fields of "permissions.Permission" */
export type Permissions_Permission_Aggregate_Fields = {
  readonly __typename?: 'permissions_Permission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permissions_Permission_Max_Fields>;
  readonly min?: Maybe<Permissions_Permission_Min_Fields>;
};


/** aggregate fields of "permissions.Permission" */
export type Permissions_Permission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.Permission" */
export type Permissions_Permission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_Permission_Max_Order_By>;
  readonly min?: Maybe<Permissions_Permission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.Permission" */
export type Permissions_Permission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_Permission_Insert_Input>;
  readonly on_conflict?: Maybe<Permissions_Permission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.Permission". All fields are combined with a logical 'AND'. */
export type Permissions_Permission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permissions_Permission_Bool_Exp>>>;
  readonly _not?: Maybe<Permissions_Permission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permissions_Permission_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** unique or primary key constraints on table "permissions.Permission" */
export enum Permissions_Permission_Constraint {
  /** unique or primary key constraint */
  PermissionPkey = 'Permission_pkey'
}

export enum Permissions_Permission_Enum {
  /** Manage (create/update/delete) conference attendees. */
  ConferenceManageAttendees = 'CONFERENCE_MANAGE_ATTENDEES',
  /** Manage Content tables. */
  ConferenceManageContent = 'CONFERENCE_MANAGE_CONTENT',
  /** Manage groups of a conference. */
  ConferenceManageGroups = 'CONFERENCE_MANAGE_GROUPS',
  /** Manage (update only) conference name, short name and slug. */
  ConferenceManageName = 'CONFERENCE_MANAGE_NAME',
  /** Manage roles of a conference. */
  ConferenceManageRoles = 'CONFERENCE_MANAGE_ROLES',
  /** Manage Schedule tables. */
  ConferenceManageSchedule = 'CONFERENCE_MANAGE_SCHEDULE',
  /** Manage shuffle periods. */
  ConferenceManageShuffle = 'CONFERENCE_MANAGE_SHUFFLE',
  /** Moderate (update only) conference attendees. */
  ConferenceModerateAttendees = 'CONFERENCE_MODERATE_ATTENDEES',
  /** View the conference. */
  ConferenceView = 'CONFERENCE_VIEW',
  /** View conference attendees. */
  ConferenceViewAttendees = 'CONFERENCE_VIEW_ATTENDEES'
}

/** expression to compare columns of type permissions_Permission_enum. All fields are combined with logical 'AND'. */
export type Permissions_Permission_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Permissions_Permission_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Permissions_Permission_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Permissions_Permission_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Permissions_Permission_Enum>>;
};

/** input type for inserting data into table "permissions.Permission" */
export type Permissions_Permission_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Permissions_Permission_Max_Fields = {
  readonly __typename?: 'permissions_Permission_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "permissions.Permission" */
export type Permissions_Permission_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_Permission_Min_Fields = {
  readonly __typename?: 'permissions_Permission_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "permissions.Permission" */
export type Permissions_Permission_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.Permission" */
export type Permissions_Permission_Mutation_Response = {
  readonly __typename?: 'permissions_Permission_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permissions_Permission>;
};

/** input type for inserting object relation for remote table "permissions.Permission" */
export type Permissions_Permission_Obj_Rel_Insert_Input = {
  readonly data: Permissions_Permission_Insert_Input;
  readonly on_conflict?: Maybe<Permissions_Permission_On_Conflict>;
};

/** on conflict condition type for table "permissions.Permission" */
export type Permissions_Permission_On_Conflict = {
  readonly constraint: Permissions_Permission_Constraint;
  readonly update_columns: ReadonlyArray<Permissions_Permission_Update_Column>;
  readonly where?: Maybe<Permissions_Permission_Bool_Exp>;
};

/** ordering options when selecting data from "permissions.Permission" */
export type Permissions_Permission_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<Permissions_RolePermission_Aggregate_Order_By>;
};

/** primary key columns input for table: "permissions.Permission" */
export type Permissions_Permission_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "permissions.Permission" */
export enum Permissions_Permission_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "permissions.Permission" */
export type Permissions_Permission_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "permissions.Permission" */
export enum Permissions_Permission_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "permissions.Role" */
export type Permissions_Role = {
  readonly __typename?: 'permissions_Role';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<Permissions_GroupRole>;
  /** An aggregated array relationship */
  readonly groupRoles_aggregate: Permissions_GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<Permissions_RolePermission>;
  /** An aggregated array relationship */
  readonly rolePermissions_aggregate: Permissions_RolePermission_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** columns and relationships of "permissions.Role" */
export type Permissions_RoleRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** columns and relationships of "permissions.RolePermission" */
export type Permissions_RolePermission = {
  readonly __typename?: 'permissions_RolePermission';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly permission: Permissions_Permission;
  readonly permissionName: Permissions_Permission_Enum;
  /** An object relationship */
  readonly role: Permissions_Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate = {
  readonly __typename?: 'permissions_RolePermission_aggregate';
  readonly aggregate?: Maybe<Permissions_RolePermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_RolePermission>;
};

/** aggregate fields of "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate_Fields = {
  readonly __typename?: 'permissions_RolePermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permissions_RolePermission_Max_Fields>;
  readonly min?: Maybe<Permissions_RolePermission_Min_Fields>;
};


/** aggregate fields of "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.RolePermission" */
export type Permissions_RolePermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_RolePermission_Max_Order_By>;
  readonly min?: Maybe<Permissions_RolePermission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.RolePermission" */
export type Permissions_RolePermission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_RolePermission_Insert_Input>;
  readonly on_conflict?: Maybe<Permissions_RolePermission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.RolePermission". All fields are combined with a logical 'AND'. */
export type Permissions_RolePermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permissions_RolePermission_Bool_Exp>>>;
  readonly _not?: Maybe<Permissions_RolePermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permissions_RolePermission_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly permission?: Maybe<Permissions_Permission_Bool_Exp>;
  readonly permissionName?: Maybe<Permissions_Permission_Enum_Comparison_Exp>;
  readonly role?: Maybe<Permissions_Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.RolePermission" */
export enum Permissions_RolePermission_Constraint {
  /** unique or primary key constraint */
  RolePermissionPkey = 'RolePermission_pkey',
  /** unique or primary key constraint */
  RolePermissionRoleIdPermissionKey = 'RolePermission_roleId_permission_key'
}

/** input type for inserting data into table "permissions.RolePermission" */
export type Permissions_RolePermission_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permission?: Maybe<Permissions_Permission_Obj_Rel_Insert_Input>;
  readonly permissionName?: Maybe<Permissions_Permission_Enum>;
  readonly role?: Maybe<Permissions_Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_RolePermission_Max_Fields = {
  readonly __typename?: 'permissions_RolePermission_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.RolePermission" */
export type Permissions_RolePermission_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_RolePermission_Min_Fields = {
  readonly __typename?: 'permissions_RolePermission_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.RolePermission" */
export type Permissions_RolePermission_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.RolePermission" */
export type Permissions_RolePermission_Mutation_Response = {
  readonly __typename?: 'permissions_RolePermission_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permissions_RolePermission>;
};

/** input type for inserting object relation for remote table "permissions.RolePermission" */
export type Permissions_RolePermission_Obj_Rel_Insert_Input = {
  readonly data: Permissions_RolePermission_Insert_Input;
  readonly on_conflict?: Maybe<Permissions_RolePermission_On_Conflict>;
};

/** on conflict condition type for table "permissions.RolePermission" */
export type Permissions_RolePermission_On_Conflict = {
  readonly constraint: Permissions_RolePermission_Constraint;
  readonly update_columns: ReadonlyArray<Permissions_RolePermission_Update_Column>;
  readonly where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};

/** ordering options when selecting data from "permissions.RolePermission" */
export type Permissions_RolePermission_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permission?: Maybe<Permissions_Permission_Order_By>;
  readonly permissionName?: Maybe<Order_By>;
  readonly role?: Maybe<Permissions_Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "permissions.RolePermission" */
export type Permissions_RolePermission_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.RolePermission" */
export enum Permissions_RolePermission_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.RolePermission" */
export type Permissions_RolePermission_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionName?: Maybe<Permissions_Permission_Enum>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.RolePermission" */
export enum Permissions_RolePermission_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "permissions.Role" */
export type Permissions_Role_Aggregate = {
  readonly __typename?: 'permissions_Role_aggregate';
  readonly aggregate?: Maybe<Permissions_Role_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permissions_Role>;
};

/** aggregate fields of "permissions.Role" */
export type Permissions_Role_Aggregate_Fields = {
  readonly __typename?: 'permissions_Role_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permissions_Role_Max_Fields>;
  readonly min?: Maybe<Permissions_Role_Min_Fields>;
};


/** aggregate fields of "permissions.Role" */
export type Permissions_Role_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "permissions.Role" */
export type Permissions_Role_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permissions_Role_Max_Order_By>;
  readonly min?: Maybe<Permissions_Role_Min_Order_By>;
};

/** input type for inserting array relation for remote table "permissions.Role" */
export type Permissions_Role_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permissions_Role_Insert_Input>;
  readonly on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};

/** Boolean expression to filter rows from the table "permissions.Role". All fields are combined with a logical 'AND'. */
export type Permissions_Role_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permissions_Role_Bool_Exp>>>;
  readonly _not?: Maybe<Permissions_Role_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permissions_Role_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "permissions.Role" */
export enum Permissions_Role_Constraint {
  /** unique or primary key constraint */
  RoleConferenceNameKey = 'Role_conference_name_key',
  /** unique or primary key constraint */
  RolePkey = 'Role_pkey'
}

/** input type for inserting data into table "permissions.Role" */
export type Permissions_Role_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupRoles?: Maybe<Permissions_GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<Permissions_RolePermission_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Permissions_Role_Max_Fields = {
  readonly __typename?: 'permissions_Role_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "permissions.Role" */
export type Permissions_Role_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permissions_Role_Min_Fields = {
  readonly __typename?: 'permissions_Role_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "permissions.Role" */
export type Permissions_Role_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "permissions.Role" */
export type Permissions_Role_Mutation_Response = {
  readonly __typename?: 'permissions_Role_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permissions_Role>;
};

/** input type for inserting object relation for remote table "permissions.Role" */
export type Permissions_Role_Obj_Rel_Insert_Input = {
  readonly data: Permissions_Role_Insert_Input;
  readonly on_conflict?: Maybe<Permissions_Role_On_Conflict>;
};

/** on conflict condition type for table "permissions.Role" */
export type Permissions_Role_On_Conflict = {
  readonly constraint: Permissions_Role_Constraint;
  readonly update_columns: ReadonlyArray<Permissions_Role_Update_Column>;
  readonly where?: Maybe<Permissions_Role_Bool_Exp>;
};

/** ordering options when selecting data from "permissions.Role" */
export type Permissions_Role_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupRoles_aggregate?: Maybe<Permissions_GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<Permissions_RolePermission_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "permissions.Role" */
export type Permissions_Role_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "permissions.Role" */
export enum Permissions_Role_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "permissions.Role" */
export type Permissions_Role_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "permissions.Role" */
export enum Permissions_Role_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** query root */
export type Query_Root = {
  readonly __typename?: 'query_root';
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription: ReadonlyArray<PushNotificationSubscription>;
  /** fetch aggregated fields from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription_aggregate: PushNotificationSubscription_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" using primary key columns */
  readonly PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "analytics.AppStats" */
  readonly analytics_AppStats: ReadonlyArray<Analytics_AppStats>;
  /** fetch aggregated fields from the table: "analytics.AppStats" */
  readonly analytics_AppStats_aggregate: Analytics_AppStats_Aggregate;
  /** fetch data from the table: "analytics.AppStats" using primary key columns */
  readonly analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** fetch data from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats: ReadonlyArray<Analytics_ContentElementStats>;
  /** fetch aggregated fields from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats_aggregate: Analytics_ContentElementStats_Aggregate;
  /** fetch data from the table: "analytics.ContentElementStats" using primary key columns */
  readonly analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** fetch data from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats: ReadonlyArray<Analytics_ContentItemStats>;
  /** fetch aggregated fields from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats_aggregate: Analytics_ContentItemStats_Aggregate;
  /** fetch data from the table: "analytics.ContentItemStats" using primary key columns */
  readonly analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** fetch data from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats: ReadonlyArray<Analytics_RoomStats>;
  /** fetch aggregated fields from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats_aggregate: Analytics_RoomStats_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" using primary key columns */
  readonly analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** fetch data from the table: "collection.Exhibition" */
  readonly collection_Exhibition: ReadonlyArray<Collection_Exhibition>;
  /** fetch aggregated fields from the table: "collection.Exhibition" */
  readonly collection_Exhibition_aggregate: Collection_Exhibition_Aggregate;
  /** fetch data from the table: "collection.Exhibition" using primary key columns */
  readonly collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** fetch data from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson: ReadonlyArray<Collection_ProgramPerson>;
  /** fetch aggregated fields from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson_aggregate: Collection_ProgramPerson_Aggregate;
  /** fetch data from the table: "collection.ProgramPerson" using primary key columns */
  readonly collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** fetch data from the table: "collection.Tag" */
  readonly collection_Tag: ReadonlyArray<Collection_Tag>;
  /** fetch aggregated fields from the table: "collection.Tag" */
  readonly collection_Tag_aggregate: Collection_Tag_Aggregate;
  /** fetch data from the table: "collection.Tag" using primary key columns */
  readonly collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** fetch data from the table: "conference.Conference" */
  readonly conference_Conference: ReadonlyArray<Conference_Conference>;
  /** fetch aggregated fields from the table: "conference.Conference" */
  readonly conference_Conference_aggregate: Conference_Conference_Aggregate;
  /** fetch data from the table: "conference.Conference" using primary key columns */
  readonly conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** fetch data from the table: "conference.Configuration" */
  readonly conference_Configuration: ReadonlyArray<Conference_Configuration>;
  /** fetch aggregated fields from the table: "conference.Configuration" */
  readonly conference_Configuration_aggregate: Conference_Configuration_Aggregate;
  /** fetch data from the table: "conference.Configuration" using primary key columns */
  readonly conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** fetch data from the table: "conference.DemoCode" */
  readonly conference_DemoCode: ReadonlyArray<Conference_DemoCode>;
  /** fetch aggregated fields from the table: "conference.DemoCode" */
  readonly conference_DemoCode_aggregate: Conference_DemoCode_Aggregate;
  /** fetch data from the table: "conference.DemoCode" using primary key columns */
  readonly conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** fetch data from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData: ReadonlyArray<Conference_OriginatingData>;
  /** fetch aggregated fields from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData_aggregate: Conference_OriginatingData_Aggregate;
  /** fetch data from the table: "conference.OriginatingData" using primary key columns */
  readonly conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** fetch data from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob: ReadonlyArray<Conference_PrepareJob>;
  /** fetch aggregated fields from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob_aggregate: Conference_PrepareJob_Aggregate;
  /** fetch data from the table: "conference.PrepareJob" using primary key columns */
  readonly conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** fetch data from the table: "content.Element" */
  readonly content_Element: ReadonlyArray<Content_Element>;
  /** fetch data from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken: ReadonlyArray<Content_ElementByAccessToken>;
  /** fetch aggregated fields from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken_aggregate: Content_ElementByAccessToken_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant: ReadonlyArray<Content_ElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant_aggregate: Content_ElementPermissionGrant_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" using primary key columns */
  readonly content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** fetch data from the table: "content.ElementType" */
  readonly content_ElementType: ReadonlyArray<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.ElementType" */
  readonly content_ElementType_aggregate: Content_ElementType_Aggregate;
  /** fetch data from the table: "content.ElementType" using primary key columns */
  readonly content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.Element" */
  readonly content_Element_aggregate: Content_Element_Aggregate;
  /** fetch data from the table: "content.Element" using primary key columns */
  readonly content_Element_by_pk?: Maybe<Content_Element>;
  /** fetch data from the table: "content.Item" */
  readonly content_Item: ReadonlyArray<Content_Item>;
  /** fetch data from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition: ReadonlyArray<Content_ItemExhibition>;
  /** fetch aggregated fields from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition_aggregate: Content_ItemExhibition_Aggregate;
  /** fetch data from the table: "content.ItemExhibition" using primary key columns */
  readonly content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** fetch data from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson: ReadonlyArray<Content_ItemProgramPerson>;
  /** fetch aggregated fields from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson_aggregate: Content_ItemProgramPerson_Aggregate;
  /** fetch data from the table: "content.ItemProgramPerson" using primary key columns */
  readonly content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** fetch data from the table: "content.ItemTag" */
  readonly content_ItemTag: ReadonlyArray<Content_ItemTag>;
  /** fetch aggregated fields from the table: "content.ItemTag" */
  readonly content_ItemTag_aggregate: Content_ItemTag_Aggregate;
  /** fetch data from the table: "content.ItemTag" using primary key columns */
  readonly content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** fetch data from the table: "content.ItemType" */
  readonly content_ItemType: ReadonlyArray<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.ItemType" */
  readonly content_ItemType_aggregate: Content_ItemType_Aggregate;
  /** fetch data from the table: "content.ItemType" using primary key columns */
  readonly content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.Item" */
  readonly content_Item_aggregate: Content_Item_Aggregate;
  /** fetch data from the table: "content.Item" using primary key columns */
  readonly content_Item_by_pk?: Maybe<Content_Item>;
  /** fetch data from the table: "content.UploadableElement" */
  readonly content_UploadableElement: ReadonlyArray<Content_UploadableElement>;
  /** fetch data from the table: "content.UploadableElementPermissionGrant" */
  readonly content_UploadableElementPermissionGrant: ReadonlyArray<Content_UploadableElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.UploadableElementPermissionGrant" */
  readonly content_UploadableElementPermissionGrant_aggregate: Content_UploadableElementPermissionGrant_Aggregate;
  /** fetch data from the table: "content.UploadableElementPermissionGrant" using primary key columns */
  readonly content_UploadableElementPermissionGrant_by_pk?: Maybe<Content_UploadableElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.UploadableElement" */
  readonly content_UploadableElement_aggregate: Content_UploadableElement_Aggregate;
  /** fetch data from the table: "content.UploadableElement" using primary key columns */
  readonly content_UploadableElement_by_pk?: Maybe<Content_UploadableElement>;
  /** fetch data from the table: "content.Uploader" */
  readonly content_Uploader: ReadonlyArray<Content_Uploader>;
  /** fetch aggregated fields from the table: "content.Uploader" */
  readonly content_Uploader_aggregate: Content_Uploader_Aggregate;
  /** fetch data from the table: "content.Uploader" using primary key columns */
  readonly content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** perform the action: "getUploadAgreement" */
  readonly getUploadAgreement?: Maybe<GetUploadAgreementOutput>;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" using primary key columns */
  readonly job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob_aggregate: Job_Queues_ChannelStackDeleteJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" using primary key columns */
  readonly job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** fetch data from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob: ReadonlyArray<Job_Queues_CombineVideosJob>;
  /** fetch aggregated fields from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob_aggregate: Job_Queues_CombineVideosJob_Aggregate;
  /** fetch data from the table: "job_queues.CombineVideosJob" using primary key columns */
  readonly job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** fetch data from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob: ReadonlyArray<Job_Queues_CustomEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob_aggregate: Job_Queues_CustomEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.CustomEmailJob" using primary key columns */
  readonly job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob_aggregate: Job_Queues_UploadYouTubeVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" using primary key columns */
  readonly job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch data from the table: "permissions.Group" */
  readonly permissions_Group: ReadonlyArray<Permissions_Group>;
  /** fetch data from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant: ReadonlyArray<Permissions_GroupRegistrant>;
  /** fetch aggregated fields from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant_aggregate: Permissions_GroupRegistrant_Aggregate;
  /** fetch data from the table: "permissions.GroupRegistrant" using primary key columns */
  readonly permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** fetch data from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole: ReadonlyArray<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole_aggregate: Permissions_GroupRole_Aggregate;
  /** fetch data from the table: "permissions.GroupRole" using primary key columns */
  readonly permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.Group" */
  readonly permissions_Group_aggregate: Permissions_Group_Aggregate;
  /** fetch data from the table: "permissions.Group" using primary key columns */
  readonly permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** fetch data from the table: "permissions.Permission" */
  readonly permissions_Permission: ReadonlyArray<Permissions_Permission>;
  /** fetch aggregated fields from the table: "permissions.Permission" */
  readonly permissions_Permission_aggregate: Permissions_Permission_Aggregate;
  /** fetch data from the table: "permissions.Permission" using primary key columns */
  readonly permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** fetch data from the table: "permissions.Role" */
  readonly permissions_Role: ReadonlyArray<Permissions_Role>;
  /** fetch data from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission: ReadonlyArray<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission_aggregate: Permissions_RolePermission_Aggregate;
  /** fetch data from the table: "permissions.RolePermission" using primary key columns */
  readonly permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.Role" */
  readonly permissions_Role_aggregate: Permissions_Role_Aggregate;
  /** fetch data from the table: "permissions.Role" using primary key columns */
  readonly permissions_Role_by_pk?: Maybe<Permissions_Role>;
  /** perform the action: "presence_Summary" */
  readonly presence_Summary?: Maybe<PresenceSummaryOutput>;
  /** fetch data from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount: ReadonlyArray<Registrant_GoogleAccount>;
  /** fetch aggregated fields from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount_aggregate: Registrant_GoogleAccount_Aggregate;
  /** fetch data from the table: "registrant.GoogleAccount" using primary key columns */
  readonly registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** fetch data from the table: "registrant.Invitation" */
  readonly registrant_Invitation: ReadonlyArray<Registrant_Invitation>;
  /** fetch aggregated fields from the table: "registrant.Invitation" */
  readonly registrant_Invitation_aggregate: Registrant_Invitation_Aggregate;
  /** fetch data from the table: "registrant.Invitation" using primary key columns */
  readonly registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** fetch data from the table: "registrant.Profile" */
  readonly registrant_Profile: ReadonlyArray<Registrant_Profile>;
  /** fetch data from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges: ReadonlyArray<Registrant_ProfileBadges>;
  /** fetch aggregated fields from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges_aggregate: Registrant_ProfileBadges_Aggregate;
  /** fetch aggregated fields from the table: "registrant.Profile" */
  readonly registrant_Profile_aggregate: Registrant_Profile_Aggregate;
  /** fetch data from the table: "registrant.Profile" using primary key columns */
  readonly registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** fetch data from the table: "registrant.Registrant" */
  readonly registrant_Registrant: ReadonlyArray<Registrant_Registrant>;
  /** fetch aggregated fields from the table: "registrant.Registrant" */
  readonly registrant_Registrant_aggregate: Registrant_Registrant_Aggregate;
  /** fetch data from the table: "registrant.Registrant" using primary key columns */
  readonly registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** fetch data from the table: "room.Backend" */
  readonly room_Backend: ReadonlyArray<Room_Backend>;
  /** fetch aggregated fields from the table: "room.Backend" */
  readonly room_Backend_aggregate: Room_Backend_Aggregate;
  /** fetch data from the table: "room.Backend" using primary key columns */
  readonly room_Backend_by_pk?: Maybe<Room_Backend>;
  /** fetch data from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting: ReadonlyArray<Room_ChimeMeeting>;
  /** fetch aggregated fields from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting_aggregate: Room_ChimeMeeting_Aggregate;
  /** fetch data from the table: "room.ChimeMeeting" using primary key columns */
  readonly room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** fetch data from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations: ReadonlyArray<Room_LivestreamDurations>;
  /** fetch aggregated fields from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations_aggregate: Room_LivestreamDurations_Aggregate;
  /** fetch data from the table: "room.ManagementMode" */
  readonly room_ManagementMode: ReadonlyArray<Room_ManagementMode>;
  /** fetch aggregated fields from the table: "room.ManagementMode" */
  readonly room_ManagementMode_aggregate: Room_ManagementMode_Aggregate;
  /** fetch data from the table: "room.ManagementMode" using primary key columns */
  readonly room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** fetch data from the table: "room.Mode" */
  readonly room_Mode: ReadonlyArray<Room_Mode>;
  /** fetch aggregated fields from the table: "room.Mode" */
  readonly room_Mode_aggregate: Room_Mode_Aggregate;
  /** fetch data from the table: "room.Mode" using primary key columns */
  readonly room_Mode_by_pk?: Maybe<Room_Mode>;
  /** fetch data from the table: "room.Participant" */
  readonly room_Participant: ReadonlyArray<Room_Participant>;
  /** fetch aggregated fields from the table: "room.Participant" */
  readonly room_Participant_aggregate: Room_Participant_Aggregate;
  /** fetch data from the table: "room.Participant" using primary key columns */
  readonly room_Participant_by_pk?: Maybe<Room_Participant>;
  /** fetch data from the table: "room.PersonRole" */
  readonly room_PersonRole: ReadonlyArray<Room_PersonRole>;
  /** fetch aggregated fields from the table: "room.PersonRole" */
  readonly room_PersonRole_aggregate: Room_PersonRole_Aggregate;
  /** fetch data from the table: "room.PersonRole" using primary key columns */
  readonly room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** fetch data from the table: "room.Room" */
  readonly room_Room: ReadonlyArray<Room_Room>;
  /** fetch data from the table: "room.RoomPerson" */
  readonly room_RoomPerson: ReadonlyArray<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.RoomPerson" */
  readonly room_RoomPerson_aggregate: Room_RoomPerson_Aggregate;
  /** fetch data from the table: "room.RoomPerson" using primary key columns */
  readonly room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.Room" */
  readonly room_Room_aggregate: Room_Room_Aggregate;
  /** fetch data from the table: "room.Room" using primary key columns */
  readonly room_Room_by_pk?: Maybe<Room_Room>;
  /** fetch data from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm: ReadonlyArray<Room_ShuffleAlgorithm>;
  /** fetch aggregated fields from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm_aggregate: Room_ShuffleAlgorithm_Aggregate;
  /** fetch data from the table: "room.ShuffleAlgorithm" using primary key columns */
  readonly room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** fetch data from the table: "schedule.Event" */
  readonly schedule_Event: ReadonlyArray<Schedule_Event>;
  /** fetch data from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson: ReadonlyArray<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole: ReadonlyArray<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole_aggregate: Schedule_EventProgramPersonRole_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPersonRole" using primary key columns */
  readonly schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson_aggregate: Schedule_EventProgramPerson_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPerson" using primary key columns */
  readonly schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventRoomJoinRequest" */
  readonly schedule_EventRoomJoinRequest: ReadonlyArray<Schedule_EventRoomJoinRequest>;
  /** fetch aggregated fields from the table: "schedule.EventRoomJoinRequest" */
  readonly schedule_EventRoomJoinRequest_aggregate: Schedule_EventRoomJoinRequest_Aggregate;
  /** fetch data from the table: "schedule.EventRoomJoinRequest" using primary key columns */
  readonly schedule_EventRoomJoinRequest_by_pk?: Maybe<Schedule_EventRoomJoinRequest>;
  /** fetch data from the table: "schedule.EventTag" */
  readonly schedule_EventTag: ReadonlyArray<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.EventTag" */
  readonly schedule_EventTag_aggregate: Schedule_EventTag_Aggregate;
  /** fetch data from the table: "schedule.EventTag" using primary key columns */
  readonly schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.Event" */
  readonly schedule_Event_aggregate: Schedule_Event_Aggregate;
  /** fetch data from the table: "schedule.Event" using primary key columns */
  readonly schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** fetch data from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents: ReadonlyArray<Schedule_OverlappingEvents>;
  /** fetch aggregated fields from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents_aggregate: Schedule_OverlappingEvents_Aggregate;
  /** fetch data from the table: "system.Configuration" */
  readonly system_Configuration: ReadonlyArray<System_Configuration>;
  /** fetch data from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey: ReadonlyArray<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey_aggregate: System_ConfigurationKey_Aggregate;
  /** fetch data from the table: "system.ConfigurationKey" using primary key columns */
  readonly system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.Configuration" */
  readonly system_Configuration_aggregate: System_Configuration_Aggregate;
  /** fetch data from the table: "system.Configuration" using primary key columns */
  readonly system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** perform the action: "vapidPublicKey" */
  readonly vapidPublicKey: VapidPublicKeyOutput;
  /** fetch data from the table: "video.ChannelStack" */
  readonly video_ChannelStack: ReadonlyArray<Video_ChannelStack>;
  /** fetch aggregated fields from the table: "video.ChannelStack" */
  readonly video_ChannelStack_aggregate: Video_ChannelStack_Aggregate;
  /** fetch data from the table: "video.ChannelStack" using primary key columns */
  readonly video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** fetch data from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream: ReadonlyArray<Video_EventParticipantStream>;
  /** fetch aggregated fields from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream_aggregate: Video_EventParticipantStream_Aggregate;
  /** fetch data from the table: "video.EventParticipantStream" using primary key columns */
  readonly video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** fetch data from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession: ReadonlyArray<Video_EventVonageSession>;
  /** fetch aggregated fields from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession_aggregate: Video_EventVonageSession_Aggregate;
  /** fetch data from the table: "video.EventVonageSession" using primary key columns */
  readonly video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** fetch data from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch: ReadonlyArray<Video_ImmediateSwitch>;
  /** fetch aggregated fields from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch_aggregate: Video_ImmediateSwitch_Aggregate;
  /** fetch data from the table: "video.ImmediateSwitch" using primary key columns */
  readonly video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** fetch data from the table: "video.InputType" */
  readonly video_InputType: ReadonlyArray<Video_InputType>;
  /** fetch aggregated fields from the table: "video.InputType" */
  readonly video_InputType_aggregate: Video_InputType_Aggregate;
  /** fetch data from the table: "video.InputType" using primary key columns */
  readonly video_InputType_by_pk?: Maybe<Video_InputType>;
  /** fetch data from the table: "video.JobStatus" */
  readonly video_JobStatus: ReadonlyArray<Video_JobStatus>;
  /** fetch aggregated fields from the table: "video.JobStatus" */
  readonly video_JobStatus_aggregate: Video_JobStatus_Aggregate;
  /** fetch data from the table: "video.JobStatus" using primary key columns */
  readonly video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** fetch data from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus: ReadonlyArray<Video_MediaLiveChannelStatus>;
  /** fetch aggregated fields from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus_aggregate: Video_MediaLiveChannelStatus_Aggregate;
  /** fetch data from the table: "video.MediaLiveChannelStatus" using primary key columns */
  readonly video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** fetch data from the table: "video.RtmpInput" */
  readonly video_RtmpInput: ReadonlyArray<Video_RtmpInput>;
  /** fetch aggregated fields from the table: "video.RtmpInput" */
  readonly video_RtmpInput_aggregate: Video_RtmpInput_Aggregate;
  /** fetch data from the table: "video.RtmpInput" using primary key columns */
  readonly video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** fetch data from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob: ReadonlyArray<Video_TranscriptionJob>;
  /** fetch aggregated fields from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob_aggregate: Video_TranscriptionJob_Aggregate;
  /** fetch data from the table: "video.TranscriptionJob" using primary key columns */
  readonly video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** fetch data from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob: ReadonlyArray<Video_VideoRenderJob>;
  /** fetch aggregated fields from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob_aggregate: Video_VideoRenderJob_Aggregate;
  /** fetch data from the table: "video.VideoRenderJob" using primary key columns */
  readonly video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** fetch data from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload: ReadonlyArray<Video_YouTubeUpload>;
  /** fetch aggregated fields from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload_aggregate: Video_YouTubeUpload_Aggregate;
  /** fetch data from the table: "video.YouTubeUpload" using primary key columns */
  readonly video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
};


/** query root */
export type Query_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** query root */
export type Query_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** query root */
export type Query_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** query root */
export type Query_RootPushNotificationSubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** query root */
export type Query_RootPushNotificationSubscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** query root */
export type Query_RootPushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


/** query root */
export type Query_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** query root */
export type Query_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** query root */
export type Query_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


/** query root */
export type Query_RootAnalytics_AppStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_AppStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootAnalytics_ContentElementStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentElementStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentElementStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootAnalytics_ContentItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentItemStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootAnalytics_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_RoomStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Pin_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReadUpToIndex_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Subscription_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** query root */
export type Query_RootCollection_ExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** query root */
export type Query_RootCollection_Exhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** query root */
export type Query_RootCollection_Exhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootCollection_ProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** query root */
export type Query_RootCollection_ProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** query root */
export type Query_RootCollection_ProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootCollection_TagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** query root */
export type Query_RootCollection_Tag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** query root */
export type Query_RootCollection_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConference_ConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** query root */
export type Query_RootConference_Conference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** query root */
export type Query_RootConference_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConference_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** query root */
export type Query_RootConference_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** query root */
export type Query_RootConference_Configuration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConference_DemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** query root */
export type Query_RootConference_DemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** query root */
export type Query_RootConference_DemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConference_OriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** query root */
export type Query_RootConference_OriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** query root */
export type Query_RootConference_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConference_PrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


/** query root */
export type Query_RootConference_PrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


/** query root */
export type Query_RootConference_PrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_ElementArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ElementByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ElementByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ElementPermissionGrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ElementPermissionGrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_ElementTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ElementType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ElementType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootContent_Element_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** query root */
export type Query_RootContent_Element_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_ItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemExhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemExhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_ItemProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_ItemTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_ItemTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


/** query root */
export type Query_RootContent_ItemType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootContent_Item_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** query root */
export type Query_RootContent_Item_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_UploadableElementArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};


/** query root */
export type Query_RootContent_UploadableElementPermissionGrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
};


/** query root */
export type Query_RootContent_UploadableElementPermissionGrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
};


/** query root */
export type Query_RootContent_UploadableElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_UploadableElement_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};


/** query root */
export type Query_RootContent_UploadableElement_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContent_UploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


/** query root */
export type Query_RootContent_Uploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


/** query root */
export type Query_RootContent_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootGetUploadAgreementArgs = {
  magicToken: Scalars['String'];
};


/** query root */
export type Query_RootJob_Queues_ChannelStackCreateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_ChannelStackCreateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_ChannelStackDeleteJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_ChannelStackDeleteJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_ChannelStackDeleteJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_CombineVideosJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CombineVideosJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_CustomEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CustomEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_UploadYouTubeVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_UploadYouTubeVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootPermissions_GroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_GroupRegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_GroupRegistrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_GroupRegistrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootPermissions_GroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_GroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootPermissions_Group_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootPermissions_PermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_Permission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_Permission_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootPermissions_RoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_RolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_RolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootPermissions_Role_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** query root */
export type Query_RootPermissions_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRegistrant_GoogleAccountArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_GoogleAccount_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_GoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRegistrant_InvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_Invitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRegistrant_ProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_ProfileBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_ProfileBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_Profile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_Profile_By_PkArgs = {
  registrantId: Scalars['uuid'];
};


/** query root */
export type Query_RootRegistrant_RegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_Registrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** query root */
export type Query_RootRegistrant_Registrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_BackendArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_Backend_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_Backend_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_ChimeMeetingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ChimeMeeting_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_LivestreamDurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_LivestreamDurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ManagementModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ManagementMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ManagementMode_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_ModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_Mode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_Mode_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_ParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_Participant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_PersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_PersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_PersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_RoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_RoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_RoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_Room_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_ShuffleAlgorithmArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleAlgorithm_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** query root */
export type Query_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** query root */
export type Query_RootSchedule_EventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventProgramPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventProgramPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventProgramPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootSchedule_EventProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootSchedule_EventRoomJoinRequestArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Order_By>>;
  where?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventRoomJoinRequest_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Order_By>>;
  where?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootSchedule_EventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootSchedule_Event_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootSchedule_OverlappingEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


/** query root */
export type Query_RootSchedule_OverlappingEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootSystem_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};


/** query root */
export type Query_RootVideo_ChannelStackArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_ChannelStack_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_ChannelStack_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootVideo_EventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_EventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootVideo_EventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_EventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootVideo_ImmediateSwitchArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_ImmediateSwitch_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_ImmediateSwitch_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootVideo_InputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_InputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_InputType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootVideo_JobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_JobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootVideo_MediaLiveChannelStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_MediaLiveChannelStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_MediaLiveChannelStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootVideo_RtmpInputArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_RtmpInput_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_RtmpInput_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootVideo_TranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_TranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootVideo_VideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_VideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootVideo_YouTubeUploadArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_YouTubeUpload_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


/** query root */
export type Query_RootVideo_YouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};

/** columns and relationships of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount = {
  readonly __typename?: 'registrant_GoogleAccount';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly googleAccountEmail: Scalars['String'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly tokenData: Scalars['jsonb'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};


/** columns and relationships of "registrant.GoogleAccount" */
export type Registrant_GoogleAccountTokenDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.GoogleAccount" */
export type Registrant_GoogleAccountYouTubeDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Aggregate = {
  readonly __typename?: 'registrant_GoogleAccount_aggregate';
  readonly aggregate?: Maybe<Registrant_GoogleAccount_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_GoogleAccount>;
};

/** aggregate fields of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Aggregate_Fields = {
  readonly __typename?: 'registrant_GoogleAccount_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Registrant_GoogleAccount_Max_Fields>;
  readonly min?: Maybe<Registrant_GoogleAccount_Min_Fields>;
};


/** aggregate fields of "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_GoogleAccount_Max_Order_By>;
  readonly min?: Maybe<Registrant_GoogleAccount_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Registrant_GoogleAccount_Append_Input = {
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_GoogleAccount_Insert_Input>;
  readonly on_conflict?: Maybe<Registrant_GoogleAccount_On_Conflict>;
};

/** Boolean expression to filter rows from the table "registrant.GoogleAccount". All fields are combined with a logical 'AND'. */
export type Registrant_GoogleAccount_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Registrant_GoogleAccount_Bool_Exp>>>;
  readonly _not?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Registrant_GoogleAccount_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly googleAccountEmail?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly tokenData?: Maybe<Jsonb_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly youTubeData?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "registrant.GoogleAccount" */
export enum Registrant_GoogleAccount_Constraint {
  /** unique or primary key constraint */
  GoogleAccountPkey = 'GoogleAccount_pkey',
  /** unique or primary key constraint */
  GoogleAccountRegistrantIdGoogleAccountEmailKey = 'GoogleAccount_registrantId_googleAccountEmail_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Registrant_GoogleAccount_Delete_At_Path_Input = {
  readonly tokenData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly youTubeData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Registrant_GoogleAccount_Delete_Elem_Input = {
  readonly tokenData?: Maybe<Scalars['Int']>;
  readonly youTubeData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Registrant_GoogleAccount_Delete_Key_Input = {
  readonly tokenData?: Maybe<Scalars['String']>;
  readonly youTubeData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type Registrant_GoogleAccount_Max_Fields = {
  readonly __typename?: 'registrant_GoogleAccount_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly googleAccountEmail?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_GoogleAccount_Min_Fields = {
  readonly __typename?: 'registrant_GoogleAccount_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly googleAccountEmail?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Mutation_Response = {
  readonly __typename?: 'registrant_GoogleAccount_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Registrant_GoogleAccount>;
};

/** input type for inserting object relation for remote table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Obj_Rel_Insert_Input = {
  readonly data: Registrant_GoogleAccount_Insert_Input;
  readonly on_conflict?: Maybe<Registrant_GoogleAccount_On_Conflict>;
};

/** on conflict condition type for table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_On_Conflict = {
  readonly constraint: Registrant_GoogleAccount_Constraint;
  readonly update_columns: ReadonlyArray<Registrant_GoogleAccount_Update_Column>;
  readonly where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};

/** ordering options when selecting data from "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly googleAccountEmail?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly tokenData?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly youTubeData?: Maybe<Order_By>;
};

/** primary key columns input for table: "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Registrant_GoogleAccount_Prepend_Input = {
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "registrant.GoogleAccount" */
export enum Registrant_GoogleAccount_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GoogleAccountEmail = 'googleAccountEmail',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TokenData = 'tokenData',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  YouTubeData = 'youTubeData'
}

/** input type for updating data in table "registrant.GoogleAccount" */
export type Registrant_GoogleAccount_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "registrant.GoogleAccount" */
export enum Registrant_GoogleAccount_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GoogleAccountEmail = 'googleAccountEmail',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TokenData = 'tokenData',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  YouTubeData = 'youTubeData'
}

/** columns and relationships of "registrant.Invitation" */
export type Registrant_Invitation = {
  readonly __typename?: 'registrant_Invitation';
  readonly conferenceId: Scalars['uuid'];
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregated array relationship */
  readonly emails_aggregate: Email_Aggregate;
  /** A computed field, executes function "registrant.invitationHash" */
  readonly hash?: Maybe<Scalars['String']>;
  readonly id: Scalars['uuid'];
  readonly inviteCode: Scalars['uuid'];
  readonly invitedEmailAddress: Scalars['String'];
  readonly linkToUserId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
};


/** columns and relationships of "registrant.Invitation" */
export type Registrant_InvitationEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "registrant.Invitation" */
export type Registrant_InvitationEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};

/** aggregated selection of "registrant.Invitation" */
export type Registrant_Invitation_Aggregate = {
  readonly __typename?: 'registrant_Invitation_aggregate';
  readonly aggregate?: Maybe<Registrant_Invitation_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_Invitation>;
};

/** aggregate fields of "registrant.Invitation" */
export type Registrant_Invitation_Aggregate_Fields = {
  readonly __typename?: 'registrant_Invitation_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Registrant_Invitation_Max_Fields>;
  readonly min?: Maybe<Registrant_Invitation_Min_Fields>;
};


/** aggregate fields of "registrant.Invitation" */
export type Registrant_Invitation_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.Invitation" */
export type Registrant_Invitation_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_Invitation_Max_Order_By>;
  readonly min?: Maybe<Registrant_Invitation_Min_Order_By>;
};

/** input type for inserting array relation for remote table "registrant.Invitation" */
export type Registrant_Invitation_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_Invitation_Insert_Input>;
  readonly on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};

/** Boolean expression to filter rows from the table "registrant.Invitation". All fields are combined with a logical 'AND'. */
export type Registrant_Invitation_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Registrant_Invitation_Bool_Exp>>>;
  readonly _not?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Registrant_Invitation_Bool_Exp>>>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly confirmationCode?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly inviteCode?: Maybe<Uuid_Comparison_Exp>;
  readonly invitedEmailAddress?: Maybe<String_Comparison_Exp>;
  readonly linkToUserId?: Maybe<String_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
};

/** unique or primary key constraints on table "registrant.Invitation" */
export enum Registrant_Invitation_Constraint {
  /** unique or primary key constraint */
  InvitationConfirmationCodeKey = 'Invitation_confirmationCode_key',
  /** unique or primary key constraint */
  InvitationInviteCodeKey = 'Invitation_inviteCode_key',
  /** unique or primary key constraint */
  InvitationInvitedEmailAddressConferenceIdKey = 'Invitation_invitedEmailAddress_conferenceId_key',
  /** unique or primary key constraint */
  InvitationPkey = 'Invitation_pkey',
  /** unique or primary key constraint */
  InvitationRegistrantIdKey = 'Invitation_registrantId_key'
}

/** input type for inserting data into table "registrant.Invitation" */
export type Registrant_Invitation_Insert_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Registrant_Invitation_Max_Fields = {
  readonly __typename?: 'registrant_Invitation_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "registrant.Invitation" */
export type Registrant_Invitation_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_Invitation_Min_Fields = {
  readonly __typename?: 'registrant_Invitation_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "registrant.Invitation" */
export type Registrant_Invitation_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "registrant.Invitation" */
export type Registrant_Invitation_Mutation_Response = {
  readonly __typename?: 'registrant_Invitation_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Registrant_Invitation>;
};

/** input type for inserting object relation for remote table "registrant.Invitation" */
export type Registrant_Invitation_Obj_Rel_Insert_Input = {
  readonly data: Registrant_Invitation_Insert_Input;
  readonly on_conflict?: Maybe<Registrant_Invitation_On_Conflict>;
};

/** on conflict condition type for table "registrant.Invitation" */
export type Registrant_Invitation_On_Conflict = {
  readonly constraint: Registrant_Invitation_Constraint;
  readonly update_columns: ReadonlyArray<Registrant_Invitation_Update_Column>;
  readonly where?: Maybe<Registrant_Invitation_Bool_Exp>;
};

/** ordering options when selecting data from "registrant.Invitation" */
export type Registrant_Invitation_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
};

/** primary key columns input for table: "registrant.Invitation" */
export type Registrant_Invitation_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "registrant.Invitation" */
export enum Registrant_Invitation_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "registrant.Invitation" */
export type Registrant_Invitation_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "registrant.Invitation" */
export enum Registrant_Invitation_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "registrant.Profile" */
export type Registrant_Profile = {
  readonly __typename?: 'registrant_Profile';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at: Scalars['timestamptz'];
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited: Scalars['Boolean'];
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
  readonly website?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.Profile" */
export type Registrant_ProfileBadgesArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.Profile" */
export type Registrant_ProfilePronounsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges = {
  readonly __typename?: 'registrant_ProfileBadges';
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly registrant?: Maybe<Registrant_Registrant>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate = {
  readonly __typename?: 'registrant_ProfileBadges_aggregate';
  readonly aggregate?: Maybe<Registrant_ProfileBadges_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_ProfileBadges>;
};

/** aggregate fields of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate_Fields = {
  readonly __typename?: 'registrant_ProfileBadges_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Registrant_ProfileBadges_Max_Fields>;
  readonly min?: Maybe<Registrant_ProfileBadges_Min_Fields>;
};


/** aggregate fields of "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_ProfileBadges_Max_Order_By>;
  readonly min?: Maybe<Registrant_ProfileBadges_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "registrant.ProfileBadges". All fields are combined with a logical 'AND'. */
export type Registrant_ProfileBadges_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Registrant_ProfileBadges_Bool_Exp>>>;
  readonly _not?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Registrant_ProfileBadges_Bool_Exp>>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
};

/** aggregate max on columns */
export type Registrant_ProfileBadges_Max_Fields = {
  readonly __typename?: 'registrant_ProfileBadges_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_ProfileBadges_Min_Fields = {
  readonly __typename?: 'registrant_ProfileBadges_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** ordering options when selecting data from "registrant.ProfileBadges" */
export type Registrant_ProfileBadges_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
};

/** select columns of table "registrant.ProfileBadges" */
export enum Registrant_ProfileBadges_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  Name = 'name',
  /** column name */
  RegistrantId = 'registrantId'
}

/** aggregated selection of "registrant.Profile" */
export type Registrant_Profile_Aggregate = {
  readonly __typename?: 'registrant_Profile_aggregate';
  readonly aggregate?: Maybe<Registrant_Profile_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_Profile>;
};

/** aggregate fields of "registrant.Profile" */
export type Registrant_Profile_Aggregate_Fields = {
  readonly __typename?: 'registrant_Profile_aggregate_fields';
  readonly avg?: Maybe<Registrant_Profile_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Registrant_Profile_Max_Fields>;
  readonly min?: Maybe<Registrant_Profile_Min_Fields>;
  readonly stddev?: Maybe<Registrant_Profile_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Registrant_Profile_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Registrant_Profile_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Registrant_Profile_Sum_Fields>;
  readonly var_pop?: Maybe<Registrant_Profile_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Registrant_Profile_Var_Samp_Fields>;
  readonly variance?: Maybe<Registrant_Profile_Variance_Fields>;
};


/** aggregate fields of "registrant.Profile" */
export type Registrant_Profile_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.Profile" */
export type Registrant_Profile_Aggregate_Order_By = {
  readonly avg?: Maybe<Registrant_Profile_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_Profile_Max_Order_By>;
  readonly min?: Maybe<Registrant_Profile_Min_Order_By>;
  readonly stddev?: Maybe<Registrant_Profile_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Registrant_Profile_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Registrant_Profile_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Registrant_Profile_Sum_Order_By>;
  readonly var_pop?: Maybe<Registrant_Profile_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Registrant_Profile_Var_Samp_Order_By>;
  readonly variance?: Maybe<Registrant_Profile_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Registrant_Profile_Append_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "registrant.Profile" */
export type Registrant_Profile_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_Profile_Insert_Input>;
  readonly on_conflict?: Maybe<Registrant_Profile_On_Conflict>;
};

/** aggregate avg on columns */
export type Registrant_Profile_Avg_Fields = {
  readonly __typename?: 'registrant_Profile_avg_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "registrant.Profile" */
export type Registrant_Profile_Avg_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "registrant.Profile". All fields are combined with a logical 'AND'. */
export type Registrant_Profile_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Registrant_Profile_Bool_Exp>>>;
  readonly _not?: Maybe<Registrant_Profile_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Registrant_Profile_Bool_Exp>>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly affiliationURL?: Maybe<String_Comparison_Exp>;
  readonly badges?: Maybe<Jsonb_Comparison_Exp>;
  readonly bio?: Maybe<String_Comparison_Exp>;
  readonly country?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly github?: Maybe<String_Comparison_Exp>;
  readonly hasBeenEdited?: Maybe<Boolean_Comparison_Exp>;
  readonly photoS3BucketName?: Maybe<String_Comparison_Exp>;
  readonly photoS3BucketRegion?: Maybe<String_Comparison_Exp>;
  readonly photoS3ObjectName?: Maybe<String_Comparison_Exp>;
  readonly photoURL_350x350?: Maybe<String_Comparison_Exp>;
  readonly photoURL_50x50?: Maybe<String_Comparison_Exp>;
  readonly pronouns?: Maybe<Jsonb_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly timezoneUTCOffset?: Maybe<Float_Comparison_Exp>;
  readonly twitter?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly website?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "registrant.Profile" */
export enum Registrant_Profile_Constraint {
  /** unique or primary key constraint */
  ProfilePkey = 'Profile_pkey',
  /** unique or primary key constraint */
  ProfileRegistrantIdKey = 'Profile_registrantId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Registrant_Profile_Delete_At_Path_Input = {
  readonly badges?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly pronouns?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Registrant_Profile_Delete_Elem_Input = {
  readonly badges?: Maybe<Scalars['Int']>;
  readonly pronouns?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Registrant_Profile_Delete_Key_Input = {
  readonly badges?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "registrant.Profile" */
export type Registrant_Profile_Inc_Input = {
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** input type for inserting data into table "registrant.Profile" */
export type Registrant_Profile_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Registrant_Profile_Max_Fields = {
  readonly __typename?: 'registrant_Profile_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "registrant.Profile" */
export type Registrant_Profile_Max_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_Profile_Min_Fields = {
  readonly __typename?: 'registrant_Profile_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "registrant.Profile" */
export type Registrant_Profile_Min_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** response of any mutation on the table "registrant.Profile" */
export type Registrant_Profile_Mutation_Response = {
  readonly __typename?: 'registrant_Profile_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Registrant_Profile>;
};

/** input type for inserting object relation for remote table "registrant.Profile" */
export type Registrant_Profile_Obj_Rel_Insert_Input = {
  readonly data: Registrant_Profile_Insert_Input;
  readonly on_conflict?: Maybe<Registrant_Profile_On_Conflict>;
};

/** on conflict condition type for table "registrant.Profile" */
export type Registrant_Profile_On_Conflict = {
  readonly constraint: Registrant_Profile_Constraint;
  readonly update_columns: ReadonlyArray<Registrant_Profile_Update_Column>;
  readonly where?: Maybe<Registrant_Profile_Bool_Exp>;
};

/** ordering options when selecting data from "registrant.Profile" */
export type Registrant_Profile_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly badges?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly hasBeenEdited?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly pronouns?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** primary key columns input for table: "registrant.Profile" */
export type Registrant_Profile_Pk_Columns_Input = {
  readonly registrantId: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Registrant_Profile_Prepend_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "registrant.Profile" */
export enum Registrant_Profile_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** input type for updating data in table "registrant.Profile" */
export type Registrant_Profile_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Registrant_Profile_Stddev_Fields = {
  readonly __typename?: 'registrant_Profile_stddev_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "registrant.Profile" */
export type Registrant_Profile_Stddev_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Registrant_Profile_Stddev_Pop_Fields = {
  readonly __typename?: 'registrant_Profile_stddev_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "registrant.Profile" */
export type Registrant_Profile_Stddev_Pop_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Registrant_Profile_Stddev_Samp_Fields = {
  readonly __typename?: 'registrant_Profile_stddev_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "registrant.Profile" */
export type Registrant_Profile_Stddev_Samp_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Registrant_Profile_Sum_Fields = {
  readonly __typename?: 'registrant_Profile_sum_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by sum() on columns of table "registrant.Profile" */
export type Registrant_Profile_Sum_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** update columns of table "registrant.Profile" */
export enum Registrant_Profile_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** aggregate var_pop on columns */
export type Registrant_Profile_Var_Pop_Fields = {
  readonly __typename?: 'registrant_Profile_var_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "registrant.Profile" */
export type Registrant_Profile_Var_Pop_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Registrant_Profile_Var_Samp_Fields = {
  readonly __typename?: 'registrant_Profile_var_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "registrant.Profile" */
export type Registrant_Profile_Var_Samp_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Registrant_Profile_Variance_Fields = {
  readonly __typename?: 'registrant_Profile_variance_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "registrant.Profile" */
export type Registrant_Profile_Variance_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** columns and relationships of "registrant.Registrant" */
export type Registrant_Registrant = {
  readonly __typename?: 'registrant_Registrant';
  /** An array relationship */
  readonly badges: ReadonlyArray<Registrant_ProfileBadges>;
  /** An aggregated array relationship */
  readonly badges_aggregate: Registrant_ProfileBadges_Aggregate;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly displayName: Scalars['String'];
  /** An array relationship */
  readonly groupRegistrants: ReadonlyArray<Permissions_GroupRegistrant>;
  /** An aggregated array relationship */
  readonly groupRegistrants_aggregate: Permissions_GroupRegistrant_Aggregate;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Registrant_Invitation>;
  /** A computed field, executes function "registrant.HasBeenInvited" */
  readonly inviteSent?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly profile?: Maybe<Registrant_Profile>;
  /** An array relationship */
  readonly programPeople: ReadonlyArray<Collection_ProgramPerson>;
  /** An aggregated array relationship */
  readonly programPeople_aggregate: Collection_ProgramPerson_Aggregate;
  /** An array relationship */
  readonly roomParticipants: ReadonlyArray<Room_Participant>;
  /** An aggregated array relationship */
  readonly roomParticipants_aggregate: Room_Participant_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantGroupRegistrantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantGroupRegistrants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantProgramPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantProgramPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantRoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** columns and relationships of "registrant.Registrant" */
export type Registrant_RegistrantRoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};

/** aggregated selection of "registrant.Registrant" */
export type Registrant_Registrant_Aggregate = {
  readonly __typename?: 'registrant_Registrant_aggregate';
  readonly aggregate?: Maybe<Registrant_Registrant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Registrant_Registrant>;
};

/** aggregate fields of "registrant.Registrant" */
export type Registrant_Registrant_Aggregate_Fields = {
  readonly __typename?: 'registrant_Registrant_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Registrant_Registrant_Max_Fields>;
  readonly min?: Maybe<Registrant_Registrant_Min_Fields>;
};


/** aggregate fields of "registrant.Registrant" */
export type Registrant_Registrant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "registrant.Registrant" */
export type Registrant_Registrant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Registrant_Registrant_Max_Order_By>;
  readonly min?: Maybe<Registrant_Registrant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "registrant.Registrant" */
export type Registrant_Registrant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Registrant_Registrant_Insert_Input>;
  readonly on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "registrant.Registrant". All fields are combined with a logical 'AND'. */
export type Registrant_Registrant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Registrant_Registrant_Bool_Exp>>>;
  readonly _not?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Registrant_Registrant_Bool_Exp>>>;
  readonly badges?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly displayName?: Maybe<String_Comparison_Exp>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Registrant_Invitation_Bool_Exp>;
  readonly profile?: Maybe<Registrant_Profile_Bool_Exp>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly roomParticipants?: Maybe<Room_Participant_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "registrant.Registrant" */
export enum Registrant_Registrant_Constraint {
  /** unique or primary key constraint */
  RegistrantConferenceIdUserIdKey = 'Registrant_conferenceId_userId_key',
  /** unique or primary key constraint */
  RegistrantPkey = 'Registrant_pkey'
}

/** input type for inserting data into table "registrant.Registrant" */
export type Registrant_Registrant_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly groupRegistrants?: Maybe<Permissions_GroupRegistrant_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Registrant_Invitation_Obj_Rel_Insert_Input>;
  readonly profile?: Maybe<Registrant_Profile_Obj_Rel_Insert_Input>;
  readonly programPeople?: Maybe<Collection_ProgramPerson_Arr_Rel_Insert_Input>;
  readonly roomParticipants?: Maybe<Room_Participant_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Registrant_Registrant_Max_Fields = {
  readonly __typename?: 'registrant_Registrant_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "registrant.Registrant" */
export type Registrant_Registrant_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Registrant_Registrant_Min_Fields = {
  readonly __typename?: 'registrant_Registrant_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "registrant.Registrant" */
export type Registrant_Registrant_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "registrant.Registrant" */
export type Registrant_Registrant_Mutation_Response = {
  readonly __typename?: 'registrant_Registrant_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Registrant_Registrant>;
};

/** input type for inserting object relation for remote table "registrant.Registrant" */
export type Registrant_Registrant_Obj_Rel_Insert_Input = {
  readonly data: Registrant_Registrant_Insert_Input;
  readonly on_conflict?: Maybe<Registrant_Registrant_On_Conflict>;
};

/** on conflict condition type for table "registrant.Registrant" */
export type Registrant_Registrant_On_Conflict = {
  readonly constraint: Registrant_Registrant_Constraint;
  readonly update_columns: ReadonlyArray<Registrant_Registrant_Update_Column>;
  readonly where?: Maybe<Registrant_Registrant_Bool_Exp>;
};

/** ordering options when selecting data from "registrant.Registrant" */
export type Registrant_Registrant_Order_By = {
  readonly badges_aggregate?: Maybe<Registrant_ProfileBadges_Aggregate_Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly groupRegistrants_aggregate?: Maybe<Permissions_GroupRegistrant_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Registrant_Invitation_Order_By>;
  readonly profile?: Maybe<Registrant_Profile_Order_By>;
  readonly programPeople_aggregate?: Maybe<Collection_ProgramPerson_Aggregate_Order_By>;
  readonly roomParticipants_aggregate?: Maybe<Room_Participant_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "registrant.Registrant" */
export type Registrant_Registrant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "registrant.Registrant" */
export enum Registrant_Registrant_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "registrant.Registrant" */
export type Registrant_Registrant_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "registrant.Registrant" */
export enum Registrant_Registrant_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** columns and relationships of "room.Backend" */
export type Room_Backend = {
  readonly __typename?: 'room_Backend';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.Backend" */
export type Room_Backend_Aggregate = {
  readonly __typename?: 'room_Backend_aggregate';
  readonly aggregate?: Maybe<Room_Backend_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Backend>;
};

/** aggregate fields of "room.Backend" */
export type Room_Backend_Aggregate_Fields = {
  readonly __typename?: 'room_Backend_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_Backend_Max_Fields>;
  readonly min?: Maybe<Room_Backend_Min_Fields>;
};


/** aggregate fields of "room.Backend" */
export type Room_Backend_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.Backend" */
export type Room_Backend_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Backend_Max_Order_By>;
  readonly min?: Maybe<Room_Backend_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.Backend" */
export type Room_Backend_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Backend_Insert_Input>;
  readonly on_conflict?: Maybe<Room_Backend_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.Backend". All fields are combined with a logical 'AND'. */
export type Room_Backend_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_Backend_Bool_Exp>>>;
  readonly _not?: Maybe<Room_Backend_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_Backend_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.Backend" */
export enum Room_Backend_Constraint {
  /** unique or primary key constraint */
  VideoRoomBackendPkey = 'VideoRoomBackend_pkey'
}

export enum Room_Backend_Enum {
  /** AWS Chime SDK */
  Chime = 'CHIME',
  /** Vonage Video API */
  Vonage = 'VONAGE'
}

/** expression to compare columns of type room_Backend_enum. All fields are combined with logical 'AND'. */
export type Room_Backend_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_Backend_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_Backend_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_Backend_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_Backend_Enum>>;
};

/** input type for inserting data into table "room.Backend" */
export type Room_Backend_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_Backend_Max_Fields = {
  readonly __typename?: 'room_Backend_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.Backend" */
export type Room_Backend_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Backend_Min_Fields = {
  readonly __typename?: 'room_Backend_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.Backend" */
export type Room_Backend_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.Backend" */
export type Room_Backend_Mutation_Response = {
  readonly __typename?: 'room_Backend_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_Backend>;
};

/** input type for inserting object relation for remote table "room.Backend" */
export type Room_Backend_Obj_Rel_Insert_Input = {
  readonly data: Room_Backend_Insert_Input;
  readonly on_conflict?: Maybe<Room_Backend_On_Conflict>;
};

/** on conflict condition type for table "room.Backend" */
export type Room_Backend_On_Conflict = {
  readonly constraint: Room_Backend_Constraint;
  readonly update_columns: ReadonlyArray<Room_Backend_Update_Column>;
  readonly where?: Maybe<Room_Backend_Bool_Exp>;
};

/** ordering options when selecting data from "room.Backend" */
export type Room_Backend_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.Backend" */
export type Room_Backend_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.Backend" */
export enum Room_Backend_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.Backend" */
export type Room_Backend_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.Backend" */
export enum Room_Backend_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.ChimeMeeting" */
export type Room_ChimeMeeting = {
  readonly __typename?: 'room_ChimeMeeting';
  readonly chimeMeetingData: Scalars['jsonb'];
  readonly chimeMeetingId: Scalars['String'];
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "room.ChimeMeeting" */
export type Room_ChimeMeetingChimeMeetingDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "room.ChimeMeeting" */
export type Room_ChimeMeeting_Aggregate = {
  readonly __typename?: 'room_ChimeMeeting_aggregate';
  readonly aggregate?: Maybe<Room_ChimeMeeting_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ChimeMeeting>;
};

/** aggregate fields of "room.ChimeMeeting" */
export type Room_ChimeMeeting_Aggregate_Fields = {
  readonly __typename?: 'room_ChimeMeeting_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ChimeMeeting_Max_Fields>;
  readonly min?: Maybe<Room_ChimeMeeting_Min_Fields>;
};


/** aggregate fields of "room.ChimeMeeting" */
export type Room_ChimeMeeting_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ChimeMeeting_Max_Order_By>;
  readonly min?: Maybe<Room_ChimeMeeting_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Room_ChimeMeeting_Append_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ChimeMeeting_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ChimeMeeting_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.ChimeMeeting". All fields are combined with a logical 'AND'. */
export type Room_ChimeMeeting_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ChimeMeeting_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ChimeMeeting_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ChimeMeeting_Bool_Exp>>>;
  readonly chimeMeetingData?: Maybe<Jsonb_Comparison_Exp>;
  readonly chimeMeetingId?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ChimeMeeting" */
export enum Room_ChimeMeeting_Constraint {
  /** unique or primary key constraint */
  ChimeMeetingPkey = 'ChimeMeeting_pkey',
  /** unique or primary key constraint */
  ChimeMeetingRoomIdKey = 'ChimeMeeting_roomId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Room_ChimeMeeting_Delete_At_Path_Input = {
  readonly chimeMeetingData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Room_ChimeMeeting_Delete_Elem_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Room_ChimeMeeting_Delete_Key_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Insert_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ChimeMeeting_Max_Fields = {
  readonly __typename?: 'room_ChimeMeeting_max_fields';
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Max_Order_By = {
  readonly chimeMeetingId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ChimeMeeting_Min_Fields = {
  readonly __typename?: 'room_ChimeMeeting_min_fields';
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Min_Order_By = {
  readonly chimeMeetingId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Mutation_Response = {
  readonly __typename?: 'room_ChimeMeeting_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ChimeMeeting>;
};

/** input type for inserting object relation for remote table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Obj_Rel_Insert_Input = {
  readonly data: Room_ChimeMeeting_Insert_Input;
  readonly on_conflict?: Maybe<Room_ChimeMeeting_On_Conflict>;
};

/** on conflict condition type for table "room.ChimeMeeting" */
export type Room_ChimeMeeting_On_Conflict = {
  readonly constraint: Room_ChimeMeeting_Constraint;
  readonly update_columns: ReadonlyArray<Room_ChimeMeeting_Update_Column>;
  readonly where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};

/** ordering options when selecting data from "room.ChimeMeeting" */
export type Room_ChimeMeeting_Order_By = {
  readonly chimeMeetingData?: Maybe<Order_By>;
  readonly chimeMeetingId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ChimeMeeting" */
export type Room_ChimeMeeting_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Room_ChimeMeeting_Prepend_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "room.ChimeMeeting" */
export enum Room_ChimeMeeting_Select_Column {
  /** column name */
  ChimeMeetingData = 'chimeMeetingData',
  /** column name */
  ChimeMeetingId = 'chimeMeetingId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "room.ChimeMeeting" */
export type Room_ChimeMeeting_Set_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "room.ChimeMeeting" */
export enum Room_ChimeMeeting_Update_Column {
  /** column name */
  ChimeMeetingData = 'chimeMeetingData',
  /** column name */
  ChimeMeetingId = 'chimeMeetingId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "room.LivestreamDurations" */
export type Room_LivestreamDurations = {
  readonly __typename?: 'room_LivestreamDurations';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "room.LivestreamDurations" */
export type Room_LivestreamDurations_Aggregate = {
  readonly __typename?: 'room_LivestreamDurations_aggregate';
  readonly aggregate?: Maybe<Room_LivestreamDurations_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_LivestreamDurations>;
};

/** aggregate fields of "room.LivestreamDurations" */
export type Room_LivestreamDurations_Aggregate_Fields = {
  readonly __typename?: 'room_LivestreamDurations_aggregate_fields';
  readonly avg?: Maybe<Room_LivestreamDurations_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_LivestreamDurations_Max_Fields>;
  readonly min?: Maybe<Room_LivestreamDurations_Min_Fields>;
  readonly stddev?: Maybe<Room_LivestreamDurations_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_LivestreamDurations_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_LivestreamDurations_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_LivestreamDurations_Sum_Fields>;
  readonly var_pop?: Maybe<Room_LivestreamDurations_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_LivestreamDurations_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_LivestreamDurations_Variance_Fields>;
};


/** aggregate fields of "room.LivestreamDurations" */
export type Room_LivestreamDurations_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_LivestreamDurations_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_LivestreamDurations_Max_Order_By>;
  readonly min?: Maybe<Room_LivestreamDurations_Min_Order_By>;
  readonly stddev?: Maybe<Room_LivestreamDurations_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_LivestreamDurations_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_LivestreamDurations_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_LivestreamDurations_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_LivestreamDurations_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_LivestreamDurations_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_LivestreamDurations_Variance_Order_By>;
};

/** aggregate avg on columns */
export type Room_LivestreamDurations_Avg_Fields = {
  readonly __typename?: 'room_LivestreamDurations_avg_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Avg_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.LivestreamDurations". All fields are combined with a logical 'AND'. */
export type Room_LivestreamDurations_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_LivestreamDurations_Bool_Exp>>>;
  readonly _not?: Maybe<Room_LivestreamDurations_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_LivestreamDurations_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly sum?: Maybe<Bigint_Comparison_Exp>;
};

/** aggregate max on columns */
export type Room_LivestreamDurations_Max_Fields = {
  readonly __typename?: 'room_LivestreamDurations_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly sum?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_LivestreamDurations_Min_Fields = {
  readonly __typename?: 'room_LivestreamDurations_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly sum?: Maybe<Order_By>;
};

/** ordering options when selecting data from "room.LivestreamDurations" */
export type Room_LivestreamDurations_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly sum?: Maybe<Order_By>;
};

/** select columns of table "room.LivestreamDurations" */
export enum Room_LivestreamDurations_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Sum = 'sum'
}

/** aggregate stddev on columns */
export type Room_LivestreamDurations_Stddev_Fields = {
  readonly __typename?: 'room_LivestreamDurations_stddev_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Stddev_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_LivestreamDurations_Stddev_Pop_Fields = {
  readonly __typename?: 'room_LivestreamDurations_stddev_pop_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Stddev_Pop_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_LivestreamDurations_Stddev_Samp_Fields = {
  readonly __typename?: 'room_LivestreamDurations_stddev_samp_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Stddev_Samp_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_LivestreamDurations_Sum_Fields = {
  readonly __typename?: 'room_LivestreamDurations_sum_fields';
  readonly sum?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Sum_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** aggregate var_pop on columns */
export type Room_LivestreamDurations_Var_Pop_Fields = {
  readonly __typename?: 'room_LivestreamDurations_var_pop_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Var_Pop_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_LivestreamDurations_Var_Samp_Fields = {
  readonly __typename?: 'room_LivestreamDurations_var_samp_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Var_Samp_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_LivestreamDurations_Variance_Fields = {
  readonly __typename?: 'room_LivestreamDurations_variance_fields';
  readonly sum?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.LivestreamDurations" */
export type Room_LivestreamDurations_Variance_Order_By = {
  readonly sum?: Maybe<Order_By>;
};

/** columns and relationships of "room.ManagementMode" */
export type Room_ManagementMode = {
  readonly __typename?: 'room_ManagementMode';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.ManagementMode" */
export type Room_ManagementMode_Aggregate = {
  readonly __typename?: 'room_ManagementMode_aggregate';
  readonly aggregate?: Maybe<Room_ManagementMode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ManagementMode>;
};

/** aggregate fields of "room.ManagementMode" */
export type Room_ManagementMode_Aggregate_Fields = {
  readonly __typename?: 'room_ManagementMode_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ManagementMode_Max_Fields>;
  readonly min?: Maybe<Room_ManagementMode_Min_Fields>;
};


/** aggregate fields of "room.ManagementMode" */
export type Room_ManagementMode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ManagementMode" */
export type Room_ManagementMode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ManagementMode_Max_Order_By>;
  readonly min?: Maybe<Room_ManagementMode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.ManagementMode" */
export type Room_ManagementMode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ManagementMode_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ManagementMode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.ManagementMode". All fields are combined with a logical 'AND'. */
export type Room_ManagementMode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ManagementMode_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ManagementMode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ManagementMode_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ManagementMode" */
export enum Room_ManagementMode_Constraint {
  /** unique or primary key constraint */
  ManagementModePkey = 'ManagementMode_pkey'
}

export enum Room_ManagementMode_Enum {
  /** Room is a direct message between two attendees. No new attendees can be added. */
  Dm = 'DM',
  /** Room access is automatically controlled by the system. */
  Managed = 'MANAGED',
  /** Room is only visible to attendees who have been given access. New attendees can be added. */
  Private = 'PRIVATE',
  /** Room is visible to all attendees at the conference. */
  Public = 'PUBLIC'
}

/** expression to compare columns of type room_ManagementMode_enum. All fields are combined with logical 'AND'. */
export type Room_ManagementMode_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_ManagementMode_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_ManagementMode_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_ManagementMode_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_ManagementMode_Enum>>;
};

/** input type for inserting data into table "room.ManagementMode" */
export type Room_ManagementMode_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_ManagementMode_Max_Fields = {
  readonly __typename?: 'room_ManagementMode_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.ManagementMode" */
export type Room_ManagementMode_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ManagementMode_Min_Fields = {
  readonly __typename?: 'room_ManagementMode_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.ManagementMode" */
export type Room_ManagementMode_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ManagementMode" */
export type Room_ManagementMode_Mutation_Response = {
  readonly __typename?: 'room_ManagementMode_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ManagementMode>;
};

/** input type for inserting object relation for remote table "room.ManagementMode" */
export type Room_ManagementMode_Obj_Rel_Insert_Input = {
  readonly data: Room_ManagementMode_Insert_Input;
  readonly on_conflict?: Maybe<Room_ManagementMode_On_Conflict>;
};

/** on conflict condition type for table "room.ManagementMode" */
export type Room_ManagementMode_On_Conflict = {
  readonly constraint: Room_ManagementMode_Constraint;
  readonly update_columns: ReadonlyArray<Room_ManagementMode_Update_Column>;
  readonly where?: Maybe<Room_ManagementMode_Bool_Exp>;
};

/** ordering options when selecting data from "room.ManagementMode" */
export type Room_ManagementMode_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ManagementMode" */
export type Room_ManagementMode_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.ManagementMode" */
export enum Room_ManagementMode_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.ManagementMode" */
export type Room_ManagementMode_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.ManagementMode" */
export enum Room_ManagementMode_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.Mode" */
export type Room_Mode = {
  readonly __typename?: 'room_Mode';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room_Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Room_Aggregate;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** columns and relationships of "room.Mode" */
export type Room_ModeRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};

/** aggregated selection of "room.Mode" */
export type Room_Mode_Aggregate = {
  readonly __typename?: 'room_Mode_aggregate';
  readonly aggregate?: Maybe<Room_Mode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Mode>;
};

/** aggregate fields of "room.Mode" */
export type Room_Mode_Aggregate_Fields = {
  readonly __typename?: 'room_Mode_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_Mode_Max_Fields>;
  readonly min?: Maybe<Room_Mode_Min_Fields>;
};


/** aggregate fields of "room.Mode" */
export type Room_Mode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.Mode" */
export type Room_Mode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Mode_Max_Order_By>;
  readonly min?: Maybe<Room_Mode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.Mode" */
export type Room_Mode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Mode_Insert_Input>;
  readonly on_conflict?: Maybe<Room_Mode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.Mode". All fields are combined with a logical 'AND'. */
export type Room_Mode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_Mode_Bool_Exp>>>;
  readonly _not?: Maybe<Room_Mode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_Mode_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rooms?: Maybe<Room_Room_Bool_Exp>;
};

/** unique or primary key constraints on table "room.Mode" */
export enum Room_Mode_Constraint {
  /** unique or primary key constraint */
  ModePkey = 'Mode_pkey'
}

export enum Room_Mode_Enum {
  /** Users may participate in the general video chat. */
  Breakout = 'BREAKOUT',
  /** An exhibition hall. */
  Exhibition = 'EXHIBITION',
  /** An empty room. */
  None = 'NONE',
  /** Pre-recorded content should be played out to attendees. The breakout and Q&A video chats may also be available to relevant users. */
  Prerecorded = 'PRERECORDED',
  /** A live presentation should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  Presentation = 'PRESENTATION',
  /** A live Q&A/discussion should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  QAndA = 'Q_AND_A',
  /** A shuffle queue. */
  Shuffle = 'SHUFFLE',
  /** An ordinary video from either a VIDEO_URL content element or a video uploaded to Clowdr. */
  VideoPlayer = 'VIDEO_PLAYER',
  /** Event is taking place in a Zoom room. */
  Zoom = 'ZOOM'
}

/** expression to compare columns of type room_Mode_enum. All fields are combined with logical 'AND'. */
export type Room_Mode_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_Mode_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_Mode_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_Mode_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_Mode_Enum>>;
};

/** input type for inserting data into table "room.Mode" */
export type Room_Mode_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rooms?: Maybe<Room_Room_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Room_Mode_Max_Fields = {
  readonly __typename?: 'room_Mode_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.Mode" */
export type Room_Mode_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Mode_Min_Fields = {
  readonly __typename?: 'room_Mode_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.Mode" */
export type Room_Mode_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.Mode" */
export type Room_Mode_Mutation_Response = {
  readonly __typename?: 'room_Mode_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_Mode>;
};

/** input type for inserting object relation for remote table "room.Mode" */
export type Room_Mode_Obj_Rel_Insert_Input = {
  readonly data: Room_Mode_Insert_Input;
  readonly on_conflict?: Maybe<Room_Mode_On_Conflict>;
};

/** on conflict condition type for table "room.Mode" */
export type Room_Mode_On_Conflict = {
  readonly constraint: Room_Mode_Constraint;
  readonly update_columns: ReadonlyArray<Room_Mode_Update_Column>;
  readonly where?: Maybe<Room_Mode_Bool_Exp>;
};

/** ordering options when selecting data from "room.Mode" */
export type Room_Mode_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Room_Aggregate_Order_By>;
};

/** primary key columns input for table: "room.Mode" */
export type Room_Mode_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.Mode" */
export enum Room_Mode_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.Mode" */
export type Room_Mode_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.Mode" */
export enum Room_Mode_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.Participant" */
export type Room_Participant = {
  readonly __typename?: 'room_Participant';
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** aggregated selection of "room.Participant" */
export type Room_Participant_Aggregate = {
  readonly __typename?: 'room_Participant_aggregate';
  readonly aggregate?: Maybe<Room_Participant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Participant>;
};

/** aggregate fields of "room.Participant" */
export type Room_Participant_Aggregate_Fields = {
  readonly __typename?: 'room_Participant_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_Participant_Max_Fields>;
  readonly min?: Maybe<Room_Participant_Min_Fields>;
};


/** aggregate fields of "room.Participant" */
export type Room_Participant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.Participant" */
export type Room_Participant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Participant_Max_Order_By>;
  readonly min?: Maybe<Room_Participant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.Participant" */
export type Room_Participant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Participant_Insert_Input>;
  readonly on_conflict?: Maybe<Room_Participant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.Participant". All fields are combined with a logical 'AND'. */
export type Room_Participant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_Participant_Bool_Exp>>>;
  readonly _not?: Maybe<Room_Participant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_Participant_Bool_Exp>>>;
  readonly chimeRegistrantId?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.Participant" */
export enum Room_Participant_Constraint {
  /** unique or primary key constraint */
  ParticipantPkey = 'Participant_pkey',
  /** unique or primary key constraint */
  ParticipantRoomIdRegistrantIdKey = 'Participant_roomId_registrantId_key'
}

/** input type for inserting data into table "room.Participant" */
export type Room_Participant_Insert_Input = {
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_Participant_Max_Fields = {
  readonly __typename?: 'room_Participant_max_fields';
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.Participant" */
export type Room_Participant_Max_Order_By = {
  readonly chimeRegistrantId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Participant_Min_Fields = {
  readonly __typename?: 'room_Participant_min_fields';
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.Participant" */
export type Room_Participant_Min_Order_By = {
  readonly chimeRegistrantId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.Participant" */
export type Room_Participant_Mutation_Response = {
  readonly __typename?: 'room_Participant_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_Participant>;
};

/** input type for inserting object relation for remote table "room.Participant" */
export type Room_Participant_Obj_Rel_Insert_Input = {
  readonly data: Room_Participant_Insert_Input;
  readonly on_conflict?: Maybe<Room_Participant_On_Conflict>;
};

/** on conflict condition type for table "room.Participant" */
export type Room_Participant_On_Conflict = {
  readonly constraint: Room_Participant_Constraint;
  readonly update_columns: ReadonlyArray<Room_Participant_Update_Column>;
  readonly where?: Maybe<Room_Participant_Bool_Exp>;
};

/** ordering options when selecting data from "room.Participant" */
export type Room_Participant_Order_By = {
  readonly chimeRegistrantId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.Participant" */
export type Room_Participant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.Participant" */
export enum Room_Participant_Select_Column {
  /** column name */
  ChimeRegistrantId = 'chimeRegistrantId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** input type for updating data in table "room.Participant" */
export type Room_Participant_Set_Input = {
  readonly chimeRegistrantId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** update columns of table "room.Participant" */
export enum Room_Participant_Update_Column {
  /** column name */
  ChimeRegistrantId = 'chimeRegistrantId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** columns and relationships of "room.PersonRole" */
export type Room_PersonRole = {
  readonly __typename?: 'room_PersonRole';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.PersonRole" */
export type Room_PersonRole_Aggregate = {
  readonly __typename?: 'room_PersonRole_aggregate';
  readonly aggregate?: Maybe<Room_PersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_PersonRole>;
};

/** aggregate fields of "room.PersonRole" */
export type Room_PersonRole_Aggregate_Fields = {
  readonly __typename?: 'room_PersonRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_PersonRole_Max_Fields>;
  readonly min?: Maybe<Room_PersonRole_Min_Fields>;
};


/** aggregate fields of "room.PersonRole" */
export type Room_PersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.PersonRole" */
export type Room_PersonRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_PersonRole_Max_Order_By>;
  readonly min?: Maybe<Room_PersonRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.PersonRole" */
export type Room_PersonRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_PersonRole_Insert_Input>;
  readonly on_conflict?: Maybe<Room_PersonRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.PersonRole". All fields are combined with a logical 'AND'. */
export type Room_PersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_PersonRole_Bool_Exp>>>;
  readonly _not?: Maybe<Room_PersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_PersonRole_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.PersonRole" */
export enum Room_PersonRole_Constraint {
  /** unique or primary key constraint */
  PersonRolePkey = 'PersonRole_pkey'
}

export enum Room_PersonRole_Enum {
  /** User has control over the room. */
  Admin = 'ADMIN',
  /** User can participate in the room. */
  Participant = 'PARTICIPANT'
}

/** expression to compare columns of type room_PersonRole_enum. All fields are combined with logical 'AND'. */
export type Room_PersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_PersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_PersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_PersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_PersonRole_Enum>>;
};

/** input type for inserting data into table "room.PersonRole" */
export type Room_PersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_PersonRole_Max_Fields = {
  readonly __typename?: 'room_PersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.PersonRole" */
export type Room_PersonRole_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_PersonRole_Min_Fields = {
  readonly __typename?: 'room_PersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.PersonRole" */
export type Room_PersonRole_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.PersonRole" */
export type Room_PersonRole_Mutation_Response = {
  readonly __typename?: 'room_PersonRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_PersonRole>;
};

/** input type for inserting object relation for remote table "room.PersonRole" */
export type Room_PersonRole_Obj_Rel_Insert_Input = {
  readonly data: Room_PersonRole_Insert_Input;
  readonly on_conflict?: Maybe<Room_PersonRole_On_Conflict>;
};

/** on conflict condition type for table "room.PersonRole" */
export type Room_PersonRole_On_Conflict = {
  readonly constraint: Room_PersonRole_Constraint;
  readonly update_columns: ReadonlyArray<Room_PersonRole_Update_Column>;
  readonly where?: Maybe<Room_PersonRole_Bool_Exp>;
};

/** ordering options when selecting data from "room.PersonRole" */
export type Room_PersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.PersonRole" */
export type Room_PersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.PersonRole" */
export enum Room_PersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.PersonRole" */
export type Room_PersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.PersonRole" */
export enum Room_PersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.Room" */
export type Room_Room = {
  readonly __typename?: 'room_Room';
  readonly backendName?: Maybe<Room_Backend_Enum>;
  readonly capacity?: Maybe<Scalars['Int']>;
  /** An object relationship */
  readonly channelStack?: Maybe<Video_ChannelStack>;
  /** An array relationship */
  readonly channelStackCreateJobs: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** An aggregated array relationship */
  readonly channelStackCreateJobs_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting>;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly currentMode: Room_Mode;
  readonly currentModeName: Room_Mode_Enum;
  /** An array relationship */
  readonly events: ReadonlyArray<Schedule_Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Schedule_Event_Aggregate;
  readonly id: Scalars['uuid'];
  /** A computed field, executes function "room.IsProgramRoom" */
  readonly isProgramRoom?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly livestreamDuration?: Maybe<Room_LivestreamDurations>;
  /** An object relationship */
  readonly managementMode: Room_ManagementMode;
  readonly managementModeName: Room_ManagementMode_Enum;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingEvent?: Maybe<Schedule_Event>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingItem?: Maybe<Content_Item>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly participants: ReadonlyArray<Room_Participant>;
  /** An aggregated array relationship */
  readonly participants_aggregate: Room_Participant_Aggregate;
  readonly priority: Scalars['Int'];
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly roomPeople: ReadonlyArray<Room_RoomPerson>;
  /** An aggregated array relationship */
  readonly roomPeople_aggregate: Room_RoomPerson_Aggregate;
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregated array relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  /** An array relationship */
  readonly stats: ReadonlyArray<Analytics_RoomStats>;
  /** An aggregated array relationship */
  readonly stats_aggregate: Analytics_RoomStats_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "room.Room" */
export type Room_RoomChannelStackCreateJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomChannelStackCreateJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomRoomPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomRoomPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** columns and relationships of "room.Room" */
export type Room_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};

/** columns and relationships of "room.RoomPerson" */
export type Room_RoomPerson = {
  readonly __typename?: 'room_RoomPerson';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly personRole: Room_PersonRole;
  readonly personRoleName: Room_PersonRole_Enum;
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "room.RoomPerson" */
export type Room_RoomPerson_Aggregate = {
  readonly __typename?: 'room_RoomPerson_aggregate';
  readonly aggregate?: Maybe<Room_RoomPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_RoomPerson>;
};

/** aggregate fields of "room.RoomPerson" */
export type Room_RoomPerson_Aggregate_Fields = {
  readonly __typename?: 'room_RoomPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_RoomPerson_Max_Fields>;
  readonly min?: Maybe<Room_RoomPerson_Min_Fields>;
};


/** aggregate fields of "room.RoomPerson" */
export type Room_RoomPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.RoomPerson" */
export type Room_RoomPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_RoomPerson_Max_Order_By>;
  readonly min?: Maybe<Room_RoomPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.RoomPerson" */
export type Room_RoomPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_RoomPerson_Insert_Input>;
  readonly on_conflict?: Maybe<Room_RoomPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.RoomPerson". All fields are combined with a logical 'AND'. */
export type Room_RoomPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_RoomPerson_Bool_Exp>>>;
  readonly _not?: Maybe<Room_RoomPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_RoomPerson_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly personRole?: Maybe<Room_PersonRole_Bool_Exp>;
  readonly personRoleName?: Maybe<Room_PersonRole_Enum_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.RoomPerson" */
export enum Room_RoomPerson_Constraint {
  /** unique or primary key constraint */
  RoomPersonPkey = 'RoomPerson_pkey',
  /** unique or primary key constraint */
  RoomPersonRegistrantIdRoomIdKey = 'RoomPerson_registrantId_roomId_key'
}

/** input type for inserting data into table "room.RoomPerson" */
export type Room_RoomPerson_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personRole?: Maybe<Room_PersonRole_Obj_Rel_Insert_Input>;
  readonly personRoleName?: Maybe<Room_PersonRole_Enum>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_RoomPerson_Max_Fields = {
  readonly __typename?: 'room_RoomPerson_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.RoomPerson" */
export type Room_RoomPerson_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_RoomPerson_Min_Fields = {
  readonly __typename?: 'room_RoomPerson_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.RoomPerson" */
export type Room_RoomPerson_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.RoomPerson" */
export type Room_RoomPerson_Mutation_Response = {
  readonly __typename?: 'room_RoomPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_RoomPerson>;
};

/** input type for inserting object relation for remote table "room.RoomPerson" */
export type Room_RoomPerson_Obj_Rel_Insert_Input = {
  readonly data: Room_RoomPerson_Insert_Input;
  readonly on_conflict?: Maybe<Room_RoomPerson_On_Conflict>;
};

/** on conflict condition type for table "room.RoomPerson" */
export type Room_RoomPerson_On_Conflict = {
  readonly constraint: Room_RoomPerson_Constraint;
  readonly update_columns: ReadonlyArray<Room_RoomPerson_Update_Column>;
  readonly where?: Maybe<Room_RoomPerson_Bool_Exp>;
};

/** ordering options when selecting data from "room.RoomPerson" */
export type Room_RoomPerson_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personRole?: Maybe<Room_PersonRole_Order_By>;
  readonly personRoleName?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.RoomPerson" */
export type Room_RoomPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.RoomPerson" */
export enum Room_RoomPerson_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PersonRoleName = 'personRoleName',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "room.RoomPerson" */
export type Room_RoomPerson_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personRoleName?: Maybe<Room_PersonRole_Enum>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "room.RoomPerson" */
export enum Room_RoomPerson_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PersonRoleName = 'personRoleName',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "room.Room" */
export type Room_Room_Aggregate = {
  readonly __typename?: 'room_Room_aggregate';
  readonly aggregate?: Maybe<Room_Room_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_Room>;
};

/** aggregate fields of "room.Room" */
export type Room_Room_Aggregate_Fields = {
  readonly __typename?: 'room_Room_aggregate_fields';
  readonly avg?: Maybe<Room_Room_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_Room_Max_Fields>;
  readonly min?: Maybe<Room_Room_Min_Fields>;
  readonly stddev?: Maybe<Room_Room_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_Room_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_Room_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_Room_Sum_Fields>;
  readonly var_pop?: Maybe<Room_Room_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_Room_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_Room_Variance_Fields>;
};


/** aggregate fields of "room.Room" */
export type Room_Room_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.Room" */
export type Room_Room_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_Room_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Room_Max_Order_By>;
  readonly min?: Maybe<Room_Room_Min_Order_By>;
  readonly stddev?: Maybe<Room_Room_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_Room_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_Room_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_Room_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_Room_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_Room_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_Room_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.Room" */
export type Room_Room_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Room_Insert_Input>;
  readonly on_conflict?: Maybe<Room_Room_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_Room_Avg_Fields = {
  readonly __typename?: 'room_Room_avg_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.Room" */
export type Room_Room_Avg_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.Room". All fields are combined with a logical 'AND'. */
export type Room_Room_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_Room_Bool_Exp>>>;
  readonly _not?: Maybe<Room_Room_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_Room_Bool_Exp>>>;
  readonly backendName?: Maybe<Room_Backend_Enum_Comparison_Exp>;
  readonly capacity?: Maybe<Int_Comparison_Exp>;
  readonly channelStack?: Maybe<Video_ChannelStack_Bool_Exp>;
  readonly channelStackCreateJobs?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting_Bool_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly currentMode?: Maybe<Room_Mode_Bool_Exp>;
  readonly currentModeName?: Maybe<Room_Mode_Enum_Comparison_Exp>;
  readonly events?: Maybe<Schedule_Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly livestreamDuration?: Maybe<Room_LivestreamDurations_Bool_Exp>;
  readonly managementMode?: Maybe<Room_ManagementMode_Bool_Exp>;
  readonly managementModeName?: Maybe<Room_ManagementMode_Enum_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingEvent?: Maybe<Schedule_Event_Bool_Exp>;
  readonly originatingEventId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingItem?: Maybe<Content_Item_Bool_Exp>;
  readonly originatingItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly participants?: Maybe<Room_Participant_Bool_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly publicVonageSessionId?: Maybe<String_Comparison_Exp>;
  readonly roomPeople?: Maybe<Room_RoomPerson_Bool_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly stats?: Maybe<Analytics_RoomStats_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.Room" */
export enum Room_Room_Constraint {
  /** unique or primary key constraint */
  RoomOriginatingEventIdKey = 'Room_originatingEventId_key',
  /** unique or primary key constraint */
  RoomPkey = 'Room_pkey'
}

/** input type for incrementing integer column in table "room.Room" */
export type Room_Room_Inc_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "room.Room" */
export type Room_Room_Insert_Input = {
  readonly backendName?: Maybe<Room_Backend_Enum>;
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly channelStack?: Maybe<Video_ChannelStack_Obj_Rel_Insert_Input>;
  readonly channelStackCreateJobs?: Maybe<Job_Queues_ChannelStackCreateJob_Arr_Rel_Insert_Input>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentMode?: Maybe<Room_Mode_Obj_Rel_Insert_Input>;
  readonly currentModeName?: Maybe<Room_Mode_Enum>;
  readonly events?: Maybe<Schedule_Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly managementMode?: Maybe<Room_ManagementMode_Obj_Rel_Insert_Input>;
  readonly managementModeName?: Maybe<Room_ManagementMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEvent?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItem?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly participants?: Maybe<Room_Participant_Arr_Rel_Insert_Input>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly roomPeople?: Maybe<Room_RoomPerson_Arr_Rel_Insert_Input>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly stats?: Maybe<Analytics_RoomStats_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_Room_Max_Fields = {
  readonly __typename?: 'room_Room_max_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.Room" */
export type Room_Room_Max_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly originatingItemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Room_Min_Fields = {
  readonly __typename?: 'room_Room_min_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.Room" */
export type Room_Room_Min_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly originatingItemId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.Room" */
export type Room_Room_Mutation_Response = {
  readonly __typename?: 'room_Room_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_Room>;
};

/** input type for inserting object relation for remote table "room.Room" */
export type Room_Room_Obj_Rel_Insert_Input = {
  readonly data: Room_Room_Insert_Input;
  readonly on_conflict?: Maybe<Room_Room_On_Conflict>;
};

/** on conflict condition type for table "room.Room" */
export type Room_Room_On_Conflict = {
  readonly constraint: Room_Room_Constraint;
  readonly update_columns: ReadonlyArray<Room_Room_Update_Column>;
  readonly where?: Maybe<Room_Room_Bool_Exp>;
};

/** ordering options when selecting data from "room.Room" */
export type Room_Room_Order_By = {
  readonly backendName?: Maybe<Order_By>;
  readonly capacity?: Maybe<Order_By>;
  readonly channelStack?: Maybe<Video_ChannelStack_Order_By>;
  readonly channelStackCreateJobs_aggregate?: Maybe<Job_Queues_ChannelStackCreateJob_Aggregate_Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly chimeMeeting?: Maybe<Room_ChimeMeeting_Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly currentMode?: Maybe<Room_Mode_Order_By>;
  readonly currentModeName?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Schedule_Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly livestreamDuration?: Maybe<Room_LivestreamDurations_Order_By>;
  readonly managementMode?: Maybe<Room_ManagementMode_Order_By>;
  readonly managementModeName?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEvent?: Maybe<Schedule_Event_Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly originatingItem?: Maybe<Content_Item_Order_By>;
  readonly originatingItemId?: Maybe<Order_By>;
  readonly participants_aggregate?: Maybe<Room_Participant_Aggregate_Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly roomPeople_aggregate?: Maybe<Room_RoomPerson_Aggregate_Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly stats_aggregate?: Maybe<Analytics_RoomStats_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.Room" */
export type Room_Room_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.Room" */
export enum Room_Room_Select_Column {
  /** column name */
  BackendName = 'backendName',
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  ManagementModeName = 'managementModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  OriginatingItemId = 'originatingItemId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.Room" */
export type Room_Room_Set_Input = {
  readonly backendName?: Maybe<Room_Backend_Enum>;
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentModeName?: Maybe<Room_Mode_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly managementModeName?: Maybe<Room_ManagementMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly originatingItemId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_Room_Stddev_Fields = {
  readonly __typename?: 'room_Room_stddev_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.Room" */
export type Room_Room_Stddev_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_Room_Stddev_Pop_Fields = {
  readonly __typename?: 'room_Room_stddev_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.Room" */
export type Room_Room_Stddev_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_Room_Stddev_Samp_Fields = {
  readonly __typename?: 'room_Room_stddev_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.Room" */
export type Room_Room_Stddev_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_Room_Sum_Fields = {
  readonly __typename?: 'room_Room_sum_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "room.Room" */
export type Room_Room_Sum_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "room.Room" */
export enum Room_Room_Update_Column {
  /** column name */
  BackendName = 'backendName',
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  ManagementModeName = 'managementModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  OriginatingItemId = 'originatingItemId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_Room_Var_Pop_Fields = {
  readonly __typename?: 'room_Room_var_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.Room" */
export type Room_Room_Var_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_Room_Var_Samp_Fields = {
  readonly __typename?: 'room_Room_var_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.Room" */
export type Room_Room_Var_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_Room_Variance_Fields = {
  readonly __typename?: 'room_Room_variance_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.Room" */
export type Room_Room_Variance_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm = {
  readonly __typename?: 'room_ShuffleAlgorithm';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate = {
  readonly __typename?: 'room_ShuffleAlgorithm_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleAlgorithm_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleAlgorithm>;
};

/** aggregate fields of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleAlgorithm_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleAlgorithm_Min_Fields>;
};


/** aggregate fields of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleAlgorithm_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleAlgorithm_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleAlgorithm_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.ShuffleAlgorithm". All fields are combined with a logical 'AND'. */
export type Room_ShuffleAlgorithm_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleAlgorithm_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleAlgorithm_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Constraint {
  /** unique or primary key constraint */
  ShuffleAlgorithmPkey = 'ShuffleAlgorithm_pkey'
}

export enum Room_ShuffleAlgorithm_Enum {
  /** First-come, first-served with auto-created rooms. */
  Fcfs = 'fcfs',
  /** First-come, first-served with a fixed set of (manually created) rooms. Limits max participants. */
  FcfsFixedRooms = 'fcfs_fixed_rooms',
  /** No automation. Rooms and allocations controlled manually. */
  None = 'none'
}

/** expression to compare columns of type room_ShuffleAlgorithm_enum. All fields are combined with logical 'AND'. */
export type Room_ShuffleAlgorithm_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Enum>>;
};

/** input type for inserting data into table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_ShuffleAlgorithm_Max_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleAlgorithm_Min_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Mutation_Response = {
  readonly __typename?: 'room_ShuffleAlgorithm_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleAlgorithm>;
};

/** input type for inserting object relation for remote table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleAlgorithm_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_On_Conflict = {
  readonly constraint: Room_ShuffleAlgorithm_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleAlgorithm_Update_Column>;
  readonly where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriod = {
  readonly __typename?: 'room_ShufflePeriod';
  readonly algorithm: Room_ShuffleAlgorithm_Enum;
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly endAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly maxRegistrantsPerRoom: Scalars['Int'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly organiser: Registrant_Registrant;
  readonly organiserId: Scalars['uuid'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregated array relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly roomDurationMinutes: Scalars['Int'];
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregated array relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  readonly startAt: Scalars['timestamptz'];
  readonly targetRegistrantsPerRoom: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
  readonly waitRoomMaxDurationSeconds: Scalars['Int'];
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** aggregated selection of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate = {
  readonly __typename?: 'room_ShufflePeriod_aggregate';
  readonly aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShufflePeriod>;
};

/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Fields = {
  readonly __typename?: 'room_ShufflePeriod_aggregate_fields';
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShufflePeriod_Max_Fields>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Fields>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Fields>;
};


/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShufflePeriod_Max_Order_By>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShufflePeriod_Avg_Fields = {
  readonly __typename?: 'room_ShufflePeriod_avg_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Avg_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShufflePeriod". All fields are combined with a logical 'AND'. */
export type Room_ShufflePeriod_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShufflePeriod_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShufflePeriod_Bool_Exp>>>;
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly maxRegistrantsPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly organiser?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly organiserId?: Maybe<Uuid_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly roomDurationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly startAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly targetRegistrantsPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Constraint {
  /** unique or primary key constraint */
  ShufflePeriodPkey = 'ShufflePeriod_pkey'
}

/** input type for incrementing integer column in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Inc_Input = {
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Insert_Input = {
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiser?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Room_ShufflePeriod_Max_Fields = {
  readonly __typename?: 'room_ShufflePeriod_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShufflePeriod_Min_Fields = {
  readonly __typename?: 'room_ShufflePeriod_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Mutation_Response = {
  readonly __typename?: 'room_ShufflePeriod_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShufflePeriod>;
};

/** input type for inserting object relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Obj_Rel_Insert_Input = {
  readonly data: Room_ShufflePeriod_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** on conflict condition type for table "room.ShufflePeriod" */
export type Room_ShufflePeriod_On_Conflict = {
  readonly constraint: Room_ShufflePeriod_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShufflePeriod_Update_Column>;
  readonly where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShufflePeriod" */
export type Room_ShufflePeriod_Order_By = {
  readonly algorithm?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiser?: Maybe<Registrant_Registrant_Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShufflePeriod" */
export type Room_ShufflePeriod_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Select_Column {
  /** column name */
  Algorithm = 'algorithm',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxRegistrantsPerRoom = 'maxRegistrantsPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetRegistrantsPerRoom = 'targetRegistrantsPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** input type for updating data in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Set_Input = {
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Room_ShufflePeriod_Stddev_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShufflePeriod_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_pop_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Pop_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShufflePeriod_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_samp_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Samp_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShufflePeriod_Sum_Fields = {
  readonly __typename?: 'room_ShufflePeriod_sum_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Sum_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** update columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Update_Column {
  /** column name */
  Algorithm = 'algorithm',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxRegistrantsPerRoom = 'maxRegistrantsPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetRegistrantsPerRoom = 'targetRegistrantsPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** aggregate var_pop on columns */
export type Room_ShufflePeriod_Var_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_pop_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Pop_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShufflePeriod_Var_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_samp_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Samp_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShufflePeriod_Variance_Fields = {
  readonly __typename?: 'room_ShufflePeriod_variance_fields';
  readonly maxRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetRegistrantsPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Variance_Order_By = {
  readonly maxRegistrantsPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetRegistrantsPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry = {
  readonly __typename?: 'room_ShuffleQueueEntry';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['bigint'];
  readonly isExpired: Scalars['Boolean'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  /** An object relationship */
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleQueueEntry_Avg_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_avg_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Avg_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleQueueEntry". All fields are combined with a logical 'AND'. */
export type Room_ShuffleQueueEntry_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleQueueEntry_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleQueueEntry_Bool_Exp>>>;
  readonly allocatedShuffleRoomId?: Maybe<Int_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly isExpired?: Maybe<Boolean_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Constraint {
  /** unique or primary key constraint */
  ShuffleQueueEntryPkey = 'ShuffleQueueEntry_pkey',
  /** unique or primary key constraint */
  RoomShuffleQueueEntryIsWaiting = 'room_ShuffleQueueEntry_isWaiting'
}

/** input type for incrementing integer column in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Inc_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Insert_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isExpired?: Maybe<Scalars['Boolean']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Obj_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleQueueEntry_Max_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_max_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Max_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleQueueEntry_Min_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_min_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Min_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Mutation_Response = {
  readonly __typename?: 'room_ShuffleQueueEntry_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** input type for inserting object relation for remote table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleQueueEntry_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_On_Conflict = {
  readonly constraint: Room_ShuffleQueueEntry_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleQueueEntry_Update_Column>;
  readonly where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isExpired?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Select_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsExpired = 'isExpired',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Set_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isExpired?: Maybe<Scalars['Boolean']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleQueueEntry_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleQueueEntry_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleQueueEntry_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleQueueEntry_Sum_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_sum_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Sum_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Update_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsExpired = 'isExpired',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleQueueEntry_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleQueueEntry_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleQueueEntry_Variance_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_variance_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Variance_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoom = {
  readonly __typename?: 'room_ShuffleRoom';
  readonly created_at: Scalars['timestamptz'];
  readonly durationMinutes: Scalars['Int'];
  readonly id: Scalars['bigint'];
  readonly isEnded: Scalars['Boolean'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregated array relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly reshuffleUponEnd: Scalars['Boolean'];
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  readonly startedAt: Scalars['timestamptz'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** aggregated selection of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate = {
  readonly __typename?: 'room_ShuffleRoom_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleRoom>;
};

/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleRoom_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleRoom_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleRoom_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleRoom_Avg_Fields = {
  readonly __typename?: 'room_ShuffleRoom_avg_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Avg_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleRoom". All fields are combined with a logical 'AND'. */
export type Room_ShuffleRoom_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleRoom_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleRoom_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly isEnded?: Maybe<Boolean_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly reshuffleUponEnd?: Maybe<Boolean_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly startedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Constraint {
  /** unique or primary key constraint */
  ShuffleRoomPkey = 'ShuffleRoom_pkey'
}

/** input type for incrementing integer column in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Inc_Input = {
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleRoom_Max_Fields = {
  readonly __typename?: 'room_ShuffleRoom_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleRoom_Min_Fields = {
  readonly __typename?: 'room_ShuffleRoom_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Mutation_Response = {
  readonly __typename?: 'room_ShuffleRoom_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleRoom>;
};

/** input type for inserting object relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleRoom_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleRoom" */
export type Room_ShuffleRoom_On_Conflict = {
  readonly constraint: Room_ShuffleRoom_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleRoom_Update_Column>;
  readonly where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleRoom" */
export type Room_ShuffleRoom_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isEnded?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly reshuffleUponEnd?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleRoom" */
export type Room_ShuffleRoom_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleRoom_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleRoom_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleRoom_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleRoom_Sum_Fields = {
  readonly __typename?: 'room_ShuffleRoom_sum_fields';
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Sum_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleRoom_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleRoom_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleRoom_Variance_Fields = {
  readonly __typename?: 'room_ShuffleRoom_variance_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Variance_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** columns and relationships of "schedule.Event" */
export type Schedule_Event = {
  readonly __typename?: 'schedule_Event';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly durationSeconds: Scalars['Int'];
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<Schedule_EventProgramPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: Schedule_EventProgramPerson_Aggregate;
  /** An array relationship */
  readonly eventTags: ReadonlyArray<Schedule_EventTag>;
  /** An aggregated array relationship */
  readonly eventTags_aggregate: Schedule_EventTag_Aggregate;
  /** An object relationship */
  readonly eventVonageSession?: Maybe<Video_EventVonageSession>;
  /** An object relationship */
  readonly exhibition?: Maybe<Collection_Exhibition>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  readonly intendedRoomModeName: Room_Mode_Enum;
  /** An object relationship */
  readonly item?: Maybe<Content_Item>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly joinRequests: ReadonlyArray<Schedule_EventRoomJoinRequest>;
  /** An aggregated array relationship */
  readonly joinRequests_aggregate: Schedule_EventRoomJoinRequest_Aggregate;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<Conference_OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly participantStreams: ReadonlyArray<Video_EventParticipantStream>;
  /** An aggregated array relationship */
  readonly participantStreams_aggregate: Video_EventParticipantStream_Aggregate;
  /** An object relationship */
  readonly room: Room_Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly roomMode: Room_Mode;
  /** An object relationship */
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventJoinRequestsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Order_By>>;
  where?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventJoinRequests_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Order_By>>;
  where?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventParticipantStreamsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


/** columns and relationships of "schedule.Event" */
export type Schedule_EventParticipantStreams_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};

/** columns and relationships of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson = {
  readonly __typename?: 'schedule_EventProgramPerson';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  /** An object relationship */
  readonly eventPersonRole: Schedule_EventProgramPersonRole;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly person: Collection_ProgramPerson;
  readonly personId: Scalars['uuid'];
  readonly roleName: Schedule_EventProgramPersonRole_Enum;
  readonly updatedAt: Scalars['timestamptz'];
};

/** columns and relationships of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole = {
  readonly __typename?: 'schedule_EventProgramPersonRole';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<Schedule_EventProgramPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: Schedule_EventProgramPerson_Aggregate;
  readonly name: Scalars['String'];
};


/** columns and relationships of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRoleEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** columns and relationships of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRoleEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};

/** aggregated selection of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Aggregate = {
  readonly __typename?: 'schedule_EventProgramPersonRole_aggregate';
  readonly aggregate?: Maybe<Schedule_EventProgramPersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_EventProgramPersonRole>;
};

/** aggregate fields of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Aggregate_Fields = {
  readonly __typename?: 'schedule_EventProgramPersonRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Schedule_EventProgramPersonRole_Max_Fields>;
  readonly min?: Maybe<Schedule_EventProgramPersonRole_Min_Fields>;
};


/** aggregate fields of "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_EventProgramPersonRole_Max_Order_By>;
  readonly min?: Maybe<Schedule_EventProgramPersonRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_EventProgramPersonRole_Insert_Input>;
  readonly on_conflict?: Maybe<Schedule_EventProgramPersonRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "schedule.EventProgramPersonRole". All fields are combined with a logical 'AND'. */
export type Schedule_EventProgramPersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Schedule_EventProgramPersonRole_Bool_Exp>>>;
  readonly _not?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Schedule_EventProgramPersonRole_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.EventProgramPersonRole" */
export enum Schedule_EventProgramPersonRole_Constraint {
  /** unique or primary key constraint */
  EventProgramPersonRolePkey = 'EventProgramPersonRole_pkey'
}

export enum Schedule_EventProgramPersonRole_Enum {
  /** Chair/moderator of the event */
  Chair = 'CHAIR',
  /** Viewer who has been given access to the event (e.g. to ask a question). */
  Participant = 'PARTICIPANT',
  /** A presenter. */
  Presenter = 'PRESENTER'
}

/** expression to compare columns of type schedule_EventProgramPersonRole_enum. All fields are combined with logical 'AND'. */
export type Schedule_EventProgramPersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Enum>>;
};

/** input type for inserting data into table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Schedule_EventProgramPersonRole_Max_Fields = {
  readonly __typename?: 'schedule_EventProgramPersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_EventProgramPersonRole_Min_Fields = {
  readonly __typename?: 'schedule_EventProgramPersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Mutation_Response = {
  readonly __typename?: 'schedule_EventProgramPersonRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Schedule_EventProgramPersonRole>;
};

/** input type for inserting object relation for remote table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Obj_Rel_Insert_Input = {
  readonly data: Schedule_EventProgramPersonRole_Insert_Input;
  readonly on_conflict?: Maybe<Schedule_EventProgramPersonRole_On_Conflict>;
};

/** on conflict condition type for table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_On_Conflict = {
  readonly constraint: Schedule_EventProgramPersonRole_Constraint;
  readonly update_columns: ReadonlyArray<Schedule_EventProgramPersonRole_Update_Column>;
  readonly where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};

/** ordering options when selecting data from "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "schedule.EventProgramPersonRole" */
export enum Schedule_EventProgramPersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "schedule.EventProgramPersonRole" */
export type Schedule_EventProgramPersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "schedule.EventProgramPersonRole" */
export enum Schedule_EventProgramPersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate = {
  readonly __typename?: 'schedule_EventProgramPerson_aggregate';
  readonly aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_EventProgramPerson>;
};

/** aggregate fields of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate_Fields = {
  readonly __typename?: 'schedule_EventProgramPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Schedule_EventProgramPerson_Max_Fields>;
  readonly min?: Maybe<Schedule_EventProgramPerson_Min_Fields>;
};


/** aggregate fields of "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_EventProgramPerson_Max_Order_By>;
  readonly min?: Maybe<Schedule_EventProgramPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_EventProgramPerson_Insert_Input>;
  readonly on_conflict?: Maybe<Schedule_EventProgramPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "schedule.EventProgramPerson". All fields are combined with a logical 'AND'. */
export type Schedule_EventProgramPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Schedule_EventProgramPerson_Bool_Exp>>>;
  readonly _not?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Schedule_EventProgramPerson_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<Collection_ProgramPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly roleName?: Maybe<Schedule_EventProgramPersonRole_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.EventProgramPerson" */
export enum Schedule_EventProgramPerson_Constraint {
  /** unique or primary key constraint */
  EventProgramPersonEventIdPersonIdRoleNameKey = 'EventProgramPerson_eventId_personId_roleName_key',
  /** unique or primary key constraint */
  EventProgramPersonPkey = 'EventProgramPerson_pkey'
}

/** input type for inserting data into table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Obj_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<Collection_ProgramPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Schedule_EventProgramPerson_Max_Fields = {
  readonly __typename?: 'schedule_EventProgramPerson_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_EventProgramPerson_Min_Fields = {
  readonly __typename?: 'schedule_EventProgramPerson_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Mutation_Response = {
  readonly __typename?: 'schedule_EventProgramPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Schedule_EventProgramPerson>;
};

/** input type for inserting object relation for remote table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Obj_Rel_Insert_Input = {
  readonly data: Schedule_EventProgramPerson_Insert_Input;
  readonly on_conflict?: Maybe<Schedule_EventProgramPerson_On_Conflict>;
};

/** on conflict condition type for table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_On_Conflict = {
  readonly constraint: Schedule_EventProgramPerson_Constraint;
  readonly update_columns: ReadonlyArray<Schedule_EventProgramPerson_Update_Column>;
  readonly where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};

/** ordering options when selecting data from "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly person?: Maybe<Collection_ProgramPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.EventProgramPerson" */
export enum Schedule_EventProgramPerson_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "schedule.EventProgramPerson" */
export type Schedule_EventProgramPerson_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "schedule.EventProgramPerson" */
export enum Schedule_EventProgramPerson_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest = {
  readonly __typename?: 'schedule_EventRoomJoinRequest';
  readonly approved: Scalars['Boolean'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  /** An object relationship */
  readonly eventPersonRole: Schedule_EventProgramPersonRole;
  readonly eventPersonRoleName: Schedule_EventProgramPersonRole_Enum;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Aggregate = {
  readonly __typename?: 'schedule_EventRoomJoinRequest_aggregate';
  readonly aggregate?: Maybe<Schedule_EventRoomJoinRequest_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_EventRoomJoinRequest>;
};

/** aggregate fields of "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Aggregate_Fields = {
  readonly __typename?: 'schedule_EventRoomJoinRequest_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Schedule_EventRoomJoinRequest_Max_Fields>;
  readonly min?: Maybe<Schedule_EventRoomJoinRequest_Min_Fields>;
};


/** aggregate fields of "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_EventRoomJoinRequest_Max_Order_By>;
  readonly min?: Maybe<Schedule_EventRoomJoinRequest_Min_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_EventRoomJoinRequest_Insert_Input>;
  readonly on_conflict?: Maybe<Schedule_EventRoomJoinRequest_On_Conflict>;
};

/** Boolean expression to filter rows from the table "schedule.EventRoomJoinRequest". All fields are combined with a logical 'AND'. */
export type Schedule_EventRoomJoinRequest_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>>>;
  readonly _not?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>>>;
  readonly approved?: Maybe<Boolean_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
  readonly eventPersonRoleName?: Maybe<Schedule_EventProgramPersonRole_Enum_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.EventRoomJoinRequest" */
export enum Schedule_EventRoomJoinRequest_Constraint {
  /** unique or primary key constraint */
  EventRoomJoinRequestEventIdRegistrantIdKey = 'EventRoomJoinRequest_eventId_registrantId_key',
  /** unique or primary key constraint */
  EventRoomJoinRequestPkey = 'EventRoomJoinRequest_pkey'
}

/** input type for inserting data into table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Insert_Input = {
  readonly approved?: Maybe<Scalars['Boolean']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Obj_Rel_Insert_Input>;
  readonly eventPersonRoleName?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Schedule_EventRoomJoinRequest_Max_Fields = {
  readonly __typename?: 'schedule_EventRoomJoinRequest_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_EventRoomJoinRequest_Min_Fields = {
  readonly __typename?: 'schedule_EventRoomJoinRequest_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Mutation_Response = {
  readonly __typename?: 'schedule_EventRoomJoinRequest_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Schedule_EventRoomJoinRequest>;
};

/** input type for inserting object relation for remote table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Obj_Rel_Insert_Input = {
  readonly data: Schedule_EventRoomJoinRequest_Insert_Input;
  readonly on_conflict?: Maybe<Schedule_EventRoomJoinRequest_On_Conflict>;
};

/** on conflict condition type for table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_On_Conflict = {
  readonly constraint: Schedule_EventRoomJoinRequest_Constraint;
  readonly update_columns: ReadonlyArray<Schedule_EventRoomJoinRequest_Update_Column>;
  readonly where?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
};

/** ordering options when selecting data from "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Order_By = {
  readonly approved?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly eventPersonRole?: Maybe<Schedule_EventProgramPersonRole_Order_By>;
  readonly eventPersonRoleName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.EventRoomJoinRequest" */
export enum Schedule_EventRoomJoinRequest_Select_Column {
  /** column name */
  Approved = 'approved',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  EventPersonRoleName = 'eventPersonRoleName',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "schedule.EventRoomJoinRequest" */
export type Schedule_EventRoomJoinRequest_Set_Input = {
  readonly approved?: Maybe<Scalars['Boolean']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRoleName?: Maybe<Schedule_EventProgramPersonRole_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "schedule.EventRoomJoinRequest" */
export enum Schedule_EventRoomJoinRequest_Update_Column {
  /** column name */
  Approved = 'approved',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  EventPersonRoleName = 'eventPersonRoleName',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "schedule.EventTag" */
export type Schedule_EventTag = {
  readonly __typename?: 'schedule_EventTag';
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Collection_Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "schedule.EventTag" */
export type Schedule_EventTag_Aggregate = {
  readonly __typename?: 'schedule_EventTag_aggregate';
  readonly aggregate?: Maybe<Schedule_EventTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_EventTag>;
};

/** aggregate fields of "schedule.EventTag" */
export type Schedule_EventTag_Aggregate_Fields = {
  readonly __typename?: 'schedule_EventTag_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Schedule_EventTag_Max_Fields>;
  readonly min?: Maybe<Schedule_EventTag_Min_Fields>;
};


/** aggregate fields of "schedule.EventTag" */
export type Schedule_EventTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.EventTag" */
export type Schedule_EventTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_EventTag_Max_Order_By>;
  readonly min?: Maybe<Schedule_EventTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.EventTag" */
export type Schedule_EventTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_EventTag_Insert_Input>;
  readonly on_conflict?: Maybe<Schedule_EventTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "schedule.EventTag". All fields are combined with a logical 'AND'. */
export type Schedule_EventTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Schedule_EventTag_Bool_Exp>>>;
  readonly _not?: Maybe<Schedule_EventTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Schedule_EventTag_Bool_Exp>>>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Collection_Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.EventTag" */
export enum Schedule_EventTag_Constraint {
  /** unique or primary key constraint */
  EventTagPkey = 'EventTag_pkey',
  /** unique or primary key constraint */
  EventTagTagIdEventIdKey = 'EventTag_tagId_eventId_key'
}

/** input type for inserting data into table "schedule.EventTag" */
export type Schedule_EventTag_Insert_Input = {
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Collection_Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Schedule_EventTag_Max_Fields = {
  readonly __typename?: 'schedule_EventTag_max_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "schedule.EventTag" */
export type Schedule_EventTag_Max_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_EventTag_Min_Fields = {
  readonly __typename?: 'schedule_EventTag_min_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "schedule.EventTag" */
export type Schedule_EventTag_Min_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.EventTag" */
export type Schedule_EventTag_Mutation_Response = {
  readonly __typename?: 'schedule_EventTag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Schedule_EventTag>;
};

/** input type for inserting object relation for remote table "schedule.EventTag" */
export type Schedule_EventTag_Obj_Rel_Insert_Input = {
  readonly data: Schedule_EventTag_Insert_Input;
  readonly on_conflict?: Maybe<Schedule_EventTag_On_Conflict>;
};

/** on conflict condition type for table "schedule.EventTag" */
export type Schedule_EventTag_On_Conflict = {
  readonly constraint: Schedule_EventTag_Constraint;
  readonly update_columns: ReadonlyArray<Schedule_EventTag_Update_Column>;
  readonly where?: Maybe<Schedule_EventTag_Bool_Exp>;
};

/** ordering options when selecting data from "schedule.EventTag" */
export type Schedule_EventTag_Order_By = {
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tag?: Maybe<Collection_Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: "schedule.EventTag" */
export type Schedule_EventTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.EventTag" */
export enum Schedule_EventTag_Select_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "schedule.EventTag" */
export type Schedule_EventTag_Set_Input = {
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "schedule.EventTag" */
export enum Schedule_EventTag_Update_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** aggregated selection of "schedule.Event" */
export type Schedule_Event_Aggregate = {
  readonly __typename?: 'schedule_Event_aggregate';
  readonly aggregate?: Maybe<Schedule_Event_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_Event>;
};

/** aggregate fields of "schedule.Event" */
export type Schedule_Event_Aggregate_Fields = {
  readonly __typename?: 'schedule_Event_aggregate_fields';
  readonly avg?: Maybe<Schedule_Event_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Schedule_Event_Max_Fields>;
  readonly min?: Maybe<Schedule_Event_Min_Fields>;
  readonly stddev?: Maybe<Schedule_Event_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Schedule_Event_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Schedule_Event_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Schedule_Event_Sum_Fields>;
  readonly var_pop?: Maybe<Schedule_Event_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Schedule_Event_Var_Samp_Fields>;
  readonly variance?: Maybe<Schedule_Event_Variance_Fields>;
};


/** aggregate fields of "schedule.Event" */
export type Schedule_Event_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.Event" */
export type Schedule_Event_Aggregate_Order_By = {
  readonly avg?: Maybe<Schedule_Event_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_Event_Max_Order_By>;
  readonly min?: Maybe<Schedule_Event_Min_Order_By>;
  readonly stddev?: Maybe<Schedule_Event_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Schedule_Event_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Schedule_Event_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Schedule_Event_Sum_Order_By>;
  readonly var_pop?: Maybe<Schedule_Event_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Schedule_Event_Var_Samp_Order_By>;
  readonly variance?: Maybe<Schedule_Event_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "schedule.Event" */
export type Schedule_Event_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Schedule_Event_Insert_Input>;
  readonly on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};

/** aggregate avg on columns */
export type Schedule_Event_Avg_Fields = {
  readonly __typename?: 'schedule_Event_avg_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "schedule.Event" */
export type Schedule_Event_Avg_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "schedule.Event". All fields are combined with a logical 'AND'. */
export type Schedule_Event_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Schedule_Event_Bool_Exp>>>;
  readonly _not?: Maybe<Schedule_Event_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Schedule_Event_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationSeconds?: Maybe<Int_Comparison_Exp>;
  readonly endTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
  readonly eventTags?: Maybe<Schedule_EventTag_Bool_Exp>;
  readonly eventVonageSession?: Maybe<Video_EventVonageSession_Bool_Exp>;
  readonly exhibition?: Maybe<Collection_Exhibition_Bool_Exp>;
  readonly exhibitionId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly intendedRoomModeName?: Maybe<Room_Mode_Enum_Comparison_Exp>;
  readonly item?: Maybe<Content_Item_Bool_Exp>;
  readonly itemId?: Maybe<Uuid_Comparison_Exp>;
  readonly joinRequests?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly participantStreams?: Maybe<Video_EventParticipantStream_Bool_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly roomMode?: Maybe<Room_Mode_Bool_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly startTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "schedule.Event" */
export enum Schedule_Event_Constraint {
  /** unique or primary key constraint */
  EventPkey = 'Event_pkey'
}

/** input type for incrementing integer column in table "schedule.Event" */
export type Schedule_Event_Inc_Input = {
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "schedule.Event" */
export type Schedule_Event_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly eventPeople?: Maybe<Schedule_EventProgramPerson_Arr_Rel_Insert_Input>;
  readonly eventTags?: Maybe<Schedule_EventTag_Arr_Rel_Insert_Input>;
  readonly eventVonageSession?: Maybe<Video_EventVonageSession_Obj_Rel_Insert_Input>;
  readonly exhibition?: Maybe<Collection_Exhibition_Obj_Rel_Insert_Input>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<Room_Mode_Enum>;
  readonly item?: Maybe<Content_Item_Obj_Rel_Insert_Input>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly joinRequests?: Maybe<Schedule_EventRoomJoinRequest_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly participantStreams?: Maybe<Video_EventParticipantStream_Arr_Rel_Insert_Input>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomMode?: Maybe<Room_Mode_Obj_Rel_Insert_Input>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Schedule_Event_Max_Fields = {
  readonly __typename?: 'schedule_Event_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "schedule.Event" */
export type Schedule_Event_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_Event_Min_Fields = {
  readonly __typename?: 'schedule_Event_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "schedule.Event" */
export type Schedule_Event_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "schedule.Event" */
export type Schedule_Event_Mutation_Response = {
  readonly __typename?: 'schedule_Event_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Schedule_Event>;
};

/** input type for inserting object relation for remote table "schedule.Event" */
export type Schedule_Event_Obj_Rel_Insert_Input = {
  readonly data: Schedule_Event_Insert_Input;
  readonly on_conflict?: Maybe<Schedule_Event_On_Conflict>;
};

/** on conflict condition type for table "schedule.Event" */
export type Schedule_Event_On_Conflict = {
  readonly constraint: Schedule_Event_Constraint;
  readonly update_columns: ReadonlyArray<Schedule_Event_Update_Column>;
  readonly where?: Maybe<Schedule_Event_Bool_Exp>;
};

/** ordering options when selecting data from "schedule.Event" */
export type Schedule_Event_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<Schedule_EventProgramPerson_Aggregate_Order_By>;
  readonly eventTags_aggregate?: Maybe<Schedule_EventTag_Aggregate_Order_By>;
  readonly eventVonageSession?: Maybe<Video_EventVonageSession_Order_By>;
  readonly exhibition?: Maybe<Collection_Exhibition_Order_By>;
  readonly exhibitionId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly intendedRoomModeName?: Maybe<Order_By>;
  readonly item?: Maybe<Content_Item_Order_By>;
  readonly itemId?: Maybe<Order_By>;
  readonly joinRequests_aggregate?: Maybe<Schedule_EventRoomJoinRequest_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<Conference_OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly participantStreams_aggregate?: Maybe<Video_EventParticipantStream_Aggregate_Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly roomMode?: Maybe<Room_Mode_Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "schedule.Event" */
export type Schedule_Event_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "schedule.Event" */
export enum Schedule_Event_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "schedule.Event" */
export type Schedule_Event_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly exhibitionId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<Room_Mode_Enum>;
  readonly itemId?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Schedule_Event_Stddev_Fields = {
  readonly __typename?: 'schedule_Event_stddev_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "schedule.Event" */
export type Schedule_Event_Stddev_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Schedule_Event_Stddev_Pop_Fields = {
  readonly __typename?: 'schedule_Event_stddev_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "schedule.Event" */
export type Schedule_Event_Stddev_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Schedule_Event_Stddev_Samp_Fields = {
  readonly __typename?: 'schedule_Event_stddev_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "schedule.Event" */
export type Schedule_Event_Stddev_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Schedule_Event_Sum_Fields = {
  readonly __typename?: 'schedule_Event_sum_fields';
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "schedule.Event" */
export type Schedule_Event_Sum_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** update columns of table "schedule.Event" */
export enum Schedule_Event_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  ExhibitionId = 'exhibitionId',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  ItemId = 'itemId',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Schedule_Event_Var_Pop_Fields = {
  readonly __typename?: 'schedule_Event_var_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "schedule.Event" */
export type Schedule_Event_Var_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Schedule_Event_Var_Samp_Fields = {
  readonly __typename?: 'schedule_Event_var_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "schedule.Event" */
export type Schedule_Event_Var_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Schedule_Event_Variance_Fields = {
  readonly __typename?: 'schedule_Event_variance_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "schedule.Event" */
export type Schedule_Event_Variance_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents = {
  readonly __typename?: 'schedule_OverlappingEvents';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly eventX?: Maybe<Schedule_Event>;
  /** An object relationship */
  readonly eventY?: Maybe<Schedule_Event>;
  readonly xId?: Maybe<Scalars['uuid']>;
  readonly yId?: Maybe<Scalars['uuid']>;
};

/** aggregated selection of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Aggregate = {
  readonly __typename?: 'schedule_OverlappingEvents_aggregate';
  readonly aggregate?: Maybe<Schedule_OverlappingEvents_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Schedule_OverlappingEvents>;
};

/** aggregate fields of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Aggregate_Fields = {
  readonly __typename?: 'schedule_OverlappingEvents_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Schedule_OverlappingEvents_Max_Fields>;
  readonly min?: Maybe<Schedule_OverlappingEvents_Min_Fields>;
};


/** aggregate fields of "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Schedule_OverlappingEvents_Max_Order_By>;
  readonly min?: Maybe<Schedule_OverlappingEvents_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "schedule.OverlappingEvents". All fields are combined with a logical 'AND'. */
export type Schedule_OverlappingEvents_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Schedule_OverlappingEvents_Bool_Exp>>>;
  readonly _not?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Schedule_OverlappingEvents_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventX?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventY?: Maybe<Schedule_Event_Bool_Exp>;
  readonly xId?: Maybe<Uuid_Comparison_Exp>;
  readonly yId?: Maybe<Uuid_Comparison_Exp>;
};

/** aggregate max on columns */
export type Schedule_OverlappingEvents_Max_Fields = {
  readonly __typename?: 'schedule_OverlappingEvents_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly xId?: Maybe<Scalars['uuid']>;
  readonly yId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly xId?: Maybe<Order_By>;
  readonly yId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Schedule_OverlappingEvents_Min_Fields = {
  readonly __typename?: 'schedule_OverlappingEvents_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly xId?: Maybe<Scalars['uuid']>;
  readonly yId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly xId?: Maybe<Order_By>;
  readonly yId?: Maybe<Order_By>;
};

/** ordering options when selecting data from "schedule.OverlappingEvents" */
export type Schedule_OverlappingEvents_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly eventX?: Maybe<Schedule_Event_Order_By>;
  readonly eventY?: Maybe<Schedule_Event_Order_By>;
  readonly xId?: Maybe<Order_By>;
  readonly yId?: Maybe<Order_By>;
};

/** select columns of table "schedule.OverlappingEvents" */
export enum Schedule_OverlappingEvents_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  XId = 'xId',
  /** column name */
  YId = 'yId'
}

/** subscription root */
export type Subscription_Root = {
  readonly __typename?: 'subscription_root';
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription: ReadonlyArray<PushNotificationSubscription>;
  /** fetch aggregated fields from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription_aggregate: PushNotificationSubscription_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" using primary key columns */
  readonly PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "analytics.AppStats" */
  readonly analytics_AppStats: ReadonlyArray<Analytics_AppStats>;
  /** fetch aggregated fields from the table: "analytics.AppStats" */
  readonly analytics_AppStats_aggregate: Analytics_AppStats_Aggregate;
  /** fetch data from the table: "analytics.AppStats" using primary key columns */
  readonly analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** fetch data from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats: ReadonlyArray<Analytics_ContentElementStats>;
  /** fetch aggregated fields from the table: "analytics.ContentElementStats" */
  readonly analytics_ContentElementStats_aggregate: Analytics_ContentElementStats_Aggregate;
  /** fetch data from the table: "analytics.ContentElementStats" using primary key columns */
  readonly analytics_ContentElementStats_by_pk?: Maybe<Analytics_ContentElementStats>;
  /** fetch data from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats: ReadonlyArray<Analytics_ContentItemStats>;
  /** fetch aggregated fields from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats_aggregate: Analytics_ContentItemStats_Aggregate;
  /** fetch data from the table: "analytics.ContentItemStats" using primary key columns */
  readonly analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** fetch data from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats: ReadonlyArray<Analytics_RoomStats>;
  /** fetch aggregated fields from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats_aggregate: Analytics_RoomStats_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" using primary key columns */
  readonly analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** fetch data from the table: "collection.Exhibition" */
  readonly collection_Exhibition: ReadonlyArray<Collection_Exhibition>;
  /** fetch aggregated fields from the table: "collection.Exhibition" */
  readonly collection_Exhibition_aggregate: Collection_Exhibition_Aggregate;
  /** fetch data from the table: "collection.Exhibition" using primary key columns */
  readonly collection_Exhibition_by_pk?: Maybe<Collection_Exhibition>;
  /** fetch data from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson: ReadonlyArray<Collection_ProgramPerson>;
  /** fetch aggregated fields from the table: "collection.ProgramPerson" */
  readonly collection_ProgramPerson_aggregate: Collection_ProgramPerson_Aggregate;
  /** fetch data from the table: "collection.ProgramPerson" using primary key columns */
  readonly collection_ProgramPerson_by_pk?: Maybe<Collection_ProgramPerson>;
  /** fetch data from the table: "collection.Tag" */
  readonly collection_Tag: ReadonlyArray<Collection_Tag>;
  /** fetch aggregated fields from the table: "collection.Tag" */
  readonly collection_Tag_aggregate: Collection_Tag_Aggregate;
  /** fetch data from the table: "collection.Tag" using primary key columns */
  readonly collection_Tag_by_pk?: Maybe<Collection_Tag>;
  /** fetch data from the table: "conference.Conference" */
  readonly conference_Conference: ReadonlyArray<Conference_Conference>;
  /** fetch aggregated fields from the table: "conference.Conference" */
  readonly conference_Conference_aggregate: Conference_Conference_Aggregate;
  /** fetch data from the table: "conference.Conference" using primary key columns */
  readonly conference_Conference_by_pk?: Maybe<Conference_Conference>;
  /** fetch data from the table: "conference.Configuration" */
  readonly conference_Configuration: ReadonlyArray<Conference_Configuration>;
  /** fetch aggregated fields from the table: "conference.Configuration" */
  readonly conference_Configuration_aggregate: Conference_Configuration_Aggregate;
  /** fetch data from the table: "conference.Configuration" using primary key columns */
  readonly conference_Configuration_by_pk?: Maybe<Conference_Configuration>;
  /** fetch data from the table: "conference.DemoCode" */
  readonly conference_DemoCode: ReadonlyArray<Conference_DemoCode>;
  /** fetch aggregated fields from the table: "conference.DemoCode" */
  readonly conference_DemoCode_aggregate: Conference_DemoCode_Aggregate;
  /** fetch data from the table: "conference.DemoCode" using primary key columns */
  readonly conference_DemoCode_by_pk?: Maybe<Conference_DemoCode>;
  /** fetch data from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData: ReadonlyArray<Conference_OriginatingData>;
  /** fetch aggregated fields from the table: "conference.OriginatingData" */
  readonly conference_OriginatingData_aggregate: Conference_OriginatingData_Aggregate;
  /** fetch data from the table: "conference.OriginatingData" using primary key columns */
  readonly conference_OriginatingData_by_pk?: Maybe<Conference_OriginatingData>;
  /** fetch data from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob: ReadonlyArray<Conference_PrepareJob>;
  /** fetch aggregated fields from the table: "conference.PrepareJob" */
  readonly conference_PrepareJob_aggregate: Conference_PrepareJob_Aggregate;
  /** fetch data from the table: "conference.PrepareJob" using primary key columns */
  readonly conference_PrepareJob_by_pk?: Maybe<Conference_PrepareJob>;
  /** fetch data from the table: "content.Element" */
  readonly content_Element: ReadonlyArray<Content_Element>;
  /** fetch data from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken: ReadonlyArray<Content_ElementByAccessToken>;
  /** fetch aggregated fields from the table: "content.ElementByAccessToken" */
  readonly content_ElementByAccessToken_aggregate: Content_ElementByAccessToken_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant: ReadonlyArray<Content_ElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.ElementPermissionGrant" */
  readonly content_ElementPermissionGrant_aggregate: Content_ElementPermissionGrant_Aggregate;
  /** fetch data from the table: "content.ElementPermissionGrant" using primary key columns */
  readonly content_ElementPermissionGrant_by_pk?: Maybe<Content_ElementPermissionGrant>;
  /** fetch data from the table: "content.ElementType" */
  readonly content_ElementType: ReadonlyArray<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.ElementType" */
  readonly content_ElementType_aggregate: Content_ElementType_Aggregate;
  /** fetch data from the table: "content.ElementType" using primary key columns */
  readonly content_ElementType_by_pk?: Maybe<Content_ElementType>;
  /** fetch aggregated fields from the table: "content.Element" */
  readonly content_Element_aggregate: Content_Element_Aggregate;
  /** fetch data from the table: "content.Element" using primary key columns */
  readonly content_Element_by_pk?: Maybe<Content_Element>;
  /** fetch data from the table: "content.Item" */
  readonly content_Item: ReadonlyArray<Content_Item>;
  /** fetch data from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition: ReadonlyArray<Content_ItemExhibition>;
  /** fetch aggregated fields from the table: "content.ItemExhibition" */
  readonly content_ItemExhibition_aggregate: Content_ItemExhibition_Aggregate;
  /** fetch data from the table: "content.ItemExhibition" using primary key columns */
  readonly content_ItemExhibition_by_pk?: Maybe<Content_ItemExhibition>;
  /** fetch data from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson: ReadonlyArray<Content_ItemProgramPerson>;
  /** fetch aggregated fields from the table: "content.ItemProgramPerson" */
  readonly content_ItemProgramPerson_aggregate: Content_ItemProgramPerson_Aggregate;
  /** fetch data from the table: "content.ItemProgramPerson" using primary key columns */
  readonly content_ItemProgramPerson_by_pk?: Maybe<Content_ItemProgramPerson>;
  /** fetch data from the table: "content.ItemTag" */
  readonly content_ItemTag: ReadonlyArray<Content_ItemTag>;
  /** fetch aggregated fields from the table: "content.ItemTag" */
  readonly content_ItemTag_aggregate: Content_ItemTag_Aggregate;
  /** fetch data from the table: "content.ItemTag" using primary key columns */
  readonly content_ItemTag_by_pk?: Maybe<Content_ItemTag>;
  /** fetch data from the table: "content.ItemType" */
  readonly content_ItemType: ReadonlyArray<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.ItemType" */
  readonly content_ItemType_aggregate: Content_ItemType_Aggregate;
  /** fetch data from the table: "content.ItemType" using primary key columns */
  readonly content_ItemType_by_pk?: Maybe<Content_ItemType>;
  /** fetch aggregated fields from the table: "content.Item" */
  readonly content_Item_aggregate: Content_Item_Aggregate;
  /** fetch data from the table: "content.Item" using primary key columns */
  readonly content_Item_by_pk?: Maybe<Content_Item>;
  /** fetch data from the table: "content.UploadableElement" */
  readonly content_UploadableElement: ReadonlyArray<Content_UploadableElement>;
  /** fetch data from the table: "content.UploadableElementPermissionGrant" */
  readonly content_UploadableElementPermissionGrant: ReadonlyArray<Content_UploadableElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.UploadableElementPermissionGrant" */
  readonly content_UploadableElementPermissionGrant_aggregate: Content_UploadableElementPermissionGrant_Aggregate;
  /** fetch data from the table: "content.UploadableElementPermissionGrant" using primary key columns */
  readonly content_UploadableElementPermissionGrant_by_pk?: Maybe<Content_UploadableElementPermissionGrant>;
  /** fetch aggregated fields from the table: "content.UploadableElement" */
  readonly content_UploadableElement_aggregate: Content_UploadableElement_Aggregate;
  /** fetch data from the table: "content.UploadableElement" using primary key columns */
  readonly content_UploadableElement_by_pk?: Maybe<Content_UploadableElement>;
  /** fetch data from the table: "content.Uploader" */
  readonly content_Uploader: ReadonlyArray<Content_Uploader>;
  /** fetch aggregated fields from the table: "content.Uploader" */
  readonly content_Uploader_aggregate: Content_Uploader_Aggregate;
  /** fetch data from the table: "content.Uploader" using primary key columns */
  readonly content_Uploader_by_pk?: Maybe<Content_Uploader>;
  /** perform the action: "getUploadAgreement" */
  readonly getUploadAgreement?: Maybe<GetUploadAgreementOutput>;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" using primary key columns */
  readonly job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob: ReadonlyArray<Job_Queues_ChannelStackDeleteJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackDeleteJob" */
  readonly job_queues_ChannelStackDeleteJob_aggregate: Job_Queues_ChannelStackDeleteJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackDeleteJob" using primary key columns */
  readonly job_queues_ChannelStackDeleteJob_by_pk?: Maybe<Job_Queues_ChannelStackDeleteJob>;
  /** fetch data from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob: ReadonlyArray<Job_Queues_CombineVideosJob>;
  /** fetch aggregated fields from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob_aggregate: Job_Queues_CombineVideosJob_Aggregate;
  /** fetch data from the table: "job_queues.CombineVideosJob" using primary key columns */
  readonly job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** fetch data from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob: ReadonlyArray<Job_Queues_CustomEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob_aggregate: Job_Queues_CustomEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.CustomEmailJob" using primary key columns */
  readonly job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob_aggregate: Job_Queues_UploadYouTubeVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" using primary key columns */
  readonly job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch data from the table: "permissions.Group" */
  readonly permissions_Group: ReadonlyArray<Permissions_Group>;
  /** fetch data from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant: ReadonlyArray<Permissions_GroupRegistrant>;
  /** fetch aggregated fields from the table: "permissions.GroupRegistrant" */
  readonly permissions_GroupRegistrant_aggregate: Permissions_GroupRegistrant_Aggregate;
  /** fetch data from the table: "permissions.GroupRegistrant" using primary key columns */
  readonly permissions_GroupRegistrant_by_pk?: Maybe<Permissions_GroupRegistrant>;
  /** fetch data from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole: ReadonlyArray<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.GroupRole" */
  readonly permissions_GroupRole_aggregate: Permissions_GroupRole_Aggregate;
  /** fetch data from the table: "permissions.GroupRole" using primary key columns */
  readonly permissions_GroupRole_by_pk?: Maybe<Permissions_GroupRole>;
  /** fetch aggregated fields from the table: "permissions.Group" */
  readonly permissions_Group_aggregate: Permissions_Group_Aggregate;
  /** fetch data from the table: "permissions.Group" using primary key columns */
  readonly permissions_Group_by_pk?: Maybe<Permissions_Group>;
  /** fetch data from the table: "permissions.Permission" */
  readonly permissions_Permission: ReadonlyArray<Permissions_Permission>;
  /** fetch aggregated fields from the table: "permissions.Permission" */
  readonly permissions_Permission_aggregate: Permissions_Permission_Aggregate;
  /** fetch data from the table: "permissions.Permission" using primary key columns */
  readonly permissions_Permission_by_pk?: Maybe<Permissions_Permission>;
  /** fetch data from the table: "permissions.Role" */
  readonly permissions_Role: ReadonlyArray<Permissions_Role>;
  /** fetch data from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission: ReadonlyArray<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.RolePermission" */
  readonly permissions_RolePermission_aggregate: Permissions_RolePermission_Aggregate;
  /** fetch data from the table: "permissions.RolePermission" using primary key columns */
  readonly permissions_RolePermission_by_pk?: Maybe<Permissions_RolePermission>;
  /** fetch aggregated fields from the table: "permissions.Role" */
  readonly permissions_Role_aggregate: Permissions_Role_Aggregate;
  /** fetch data from the table: "permissions.Role" using primary key columns */
  readonly permissions_Role_by_pk?: Maybe<Permissions_Role>;
  /** perform the action: "presence_Summary" */
  readonly presence_Summary?: Maybe<PresenceSummaryOutput>;
  /** fetch data from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount: ReadonlyArray<Registrant_GoogleAccount>;
  /** fetch aggregated fields from the table: "registrant.GoogleAccount" */
  readonly registrant_GoogleAccount_aggregate: Registrant_GoogleAccount_Aggregate;
  /** fetch data from the table: "registrant.GoogleAccount" using primary key columns */
  readonly registrant_GoogleAccount_by_pk?: Maybe<Registrant_GoogleAccount>;
  /** fetch data from the table: "registrant.Invitation" */
  readonly registrant_Invitation: ReadonlyArray<Registrant_Invitation>;
  /** fetch aggregated fields from the table: "registrant.Invitation" */
  readonly registrant_Invitation_aggregate: Registrant_Invitation_Aggregate;
  /** fetch data from the table: "registrant.Invitation" using primary key columns */
  readonly registrant_Invitation_by_pk?: Maybe<Registrant_Invitation>;
  /** fetch data from the table: "registrant.Profile" */
  readonly registrant_Profile: ReadonlyArray<Registrant_Profile>;
  /** fetch data from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges: ReadonlyArray<Registrant_ProfileBadges>;
  /** fetch aggregated fields from the table: "registrant.ProfileBadges" */
  readonly registrant_ProfileBadges_aggregate: Registrant_ProfileBadges_Aggregate;
  /** fetch aggregated fields from the table: "registrant.Profile" */
  readonly registrant_Profile_aggregate: Registrant_Profile_Aggregate;
  /** fetch data from the table: "registrant.Profile" using primary key columns */
  readonly registrant_Profile_by_pk?: Maybe<Registrant_Profile>;
  /** fetch data from the table: "registrant.Registrant" */
  readonly registrant_Registrant: ReadonlyArray<Registrant_Registrant>;
  /** fetch aggregated fields from the table: "registrant.Registrant" */
  readonly registrant_Registrant_aggregate: Registrant_Registrant_Aggregate;
  /** fetch data from the table: "registrant.Registrant" using primary key columns */
  readonly registrant_Registrant_by_pk?: Maybe<Registrant_Registrant>;
  /** fetch data from the table: "room.Backend" */
  readonly room_Backend: ReadonlyArray<Room_Backend>;
  /** fetch aggregated fields from the table: "room.Backend" */
  readonly room_Backend_aggregate: Room_Backend_Aggregate;
  /** fetch data from the table: "room.Backend" using primary key columns */
  readonly room_Backend_by_pk?: Maybe<Room_Backend>;
  /** fetch data from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting: ReadonlyArray<Room_ChimeMeeting>;
  /** fetch aggregated fields from the table: "room.ChimeMeeting" */
  readonly room_ChimeMeeting_aggregate: Room_ChimeMeeting_Aggregate;
  /** fetch data from the table: "room.ChimeMeeting" using primary key columns */
  readonly room_ChimeMeeting_by_pk?: Maybe<Room_ChimeMeeting>;
  /** fetch data from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations: ReadonlyArray<Room_LivestreamDurations>;
  /** fetch aggregated fields from the table: "room.LivestreamDurations" */
  readonly room_LivestreamDurations_aggregate: Room_LivestreamDurations_Aggregate;
  /** fetch data from the table: "room.ManagementMode" */
  readonly room_ManagementMode: ReadonlyArray<Room_ManagementMode>;
  /** fetch aggregated fields from the table: "room.ManagementMode" */
  readonly room_ManagementMode_aggregate: Room_ManagementMode_Aggregate;
  /** fetch data from the table: "room.ManagementMode" using primary key columns */
  readonly room_ManagementMode_by_pk?: Maybe<Room_ManagementMode>;
  /** fetch data from the table: "room.Mode" */
  readonly room_Mode: ReadonlyArray<Room_Mode>;
  /** fetch aggregated fields from the table: "room.Mode" */
  readonly room_Mode_aggregate: Room_Mode_Aggregate;
  /** fetch data from the table: "room.Mode" using primary key columns */
  readonly room_Mode_by_pk?: Maybe<Room_Mode>;
  /** fetch data from the table: "room.Participant" */
  readonly room_Participant: ReadonlyArray<Room_Participant>;
  /** fetch aggregated fields from the table: "room.Participant" */
  readonly room_Participant_aggregate: Room_Participant_Aggregate;
  /** fetch data from the table: "room.Participant" using primary key columns */
  readonly room_Participant_by_pk?: Maybe<Room_Participant>;
  /** fetch data from the table: "room.PersonRole" */
  readonly room_PersonRole: ReadonlyArray<Room_PersonRole>;
  /** fetch aggregated fields from the table: "room.PersonRole" */
  readonly room_PersonRole_aggregate: Room_PersonRole_Aggregate;
  /** fetch data from the table: "room.PersonRole" using primary key columns */
  readonly room_PersonRole_by_pk?: Maybe<Room_PersonRole>;
  /** fetch data from the table: "room.Room" */
  readonly room_Room: ReadonlyArray<Room_Room>;
  /** fetch data from the table: "room.RoomPerson" */
  readonly room_RoomPerson: ReadonlyArray<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.RoomPerson" */
  readonly room_RoomPerson_aggregate: Room_RoomPerson_Aggregate;
  /** fetch data from the table: "room.RoomPerson" using primary key columns */
  readonly room_RoomPerson_by_pk?: Maybe<Room_RoomPerson>;
  /** fetch aggregated fields from the table: "room.Room" */
  readonly room_Room_aggregate: Room_Room_Aggregate;
  /** fetch data from the table: "room.Room" using primary key columns */
  readonly room_Room_by_pk?: Maybe<Room_Room>;
  /** fetch data from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm: ReadonlyArray<Room_ShuffleAlgorithm>;
  /** fetch aggregated fields from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm_aggregate: Room_ShuffleAlgorithm_Aggregate;
  /** fetch data from the table: "room.ShuffleAlgorithm" using primary key columns */
  readonly room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** fetch data from the table: "schedule.Event" */
  readonly schedule_Event: ReadonlyArray<Schedule_Event>;
  /** fetch data from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson: ReadonlyArray<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole: ReadonlyArray<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPersonRole" */
  readonly schedule_EventProgramPersonRole_aggregate: Schedule_EventProgramPersonRole_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPersonRole" using primary key columns */
  readonly schedule_EventProgramPersonRole_by_pk?: Maybe<Schedule_EventProgramPersonRole>;
  /** fetch aggregated fields from the table: "schedule.EventProgramPerson" */
  readonly schedule_EventProgramPerson_aggregate: Schedule_EventProgramPerson_Aggregate;
  /** fetch data from the table: "schedule.EventProgramPerson" using primary key columns */
  readonly schedule_EventProgramPerson_by_pk?: Maybe<Schedule_EventProgramPerson>;
  /** fetch data from the table: "schedule.EventRoomJoinRequest" */
  readonly schedule_EventRoomJoinRequest: ReadonlyArray<Schedule_EventRoomJoinRequest>;
  /** fetch aggregated fields from the table: "schedule.EventRoomJoinRequest" */
  readonly schedule_EventRoomJoinRequest_aggregate: Schedule_EventRoomJoinRequest_Aggregate;
  /** fetch data from the table: "schedule.EventRoomJoinRequest" using primary key columns */
  readonly schedule_EventRoomJoinRequest_by_pk?: Maybe<Schedule_EventRoomJoinRequest>;
  /** fetch data from the table: "schedule.EventTag" */
  readonly schedule_EventTag: ReadonlyArray<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.EventTag" */
  readonly schedule_EventTag_aggregate: Schedule_EventTag_Aggregate;
  /** fetch data from the table: "schedule.EventTag" using primary key columns */
  readonly schedule_EventTag_by_pk?: Maybe<Schedule_EventTag>;
  /** fetch aggregated fields from the table: "schedule.Event" */
  readonly schedule_Event_aggregate: Schedule_Event_Aggregate;
  /** fetch data from the table: "schedule.Event" using primary key columns */
  readonly schedule_Event_by_pk?: Maybe<Schedule_Event>;
  /** fetch data from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents: ReadonlyArray<Schedule_OverlappingEvents>;
  /** fetch aggregated fields from the table: "schedule.OverlappingEvents" */
  readonly schedule_OverlappingEvents_aggregate: Schedule_OverlappingEvents_Aggregate;
  /** fetch data from the table: "system.Configuration" */
  readonly system_Configuration: ReadonlyArray<System_Configuration>;
  /** fetch data from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey: ReadonlyArray<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey_aggregate: System_ConfigurationKey_Aggregate;
  /** fetch data from the table: "system.ConfigurationKey" using primary key columns */
  readonly system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.Configuration" */
  readonly system_Configuration_aggregate: System_Configuration_Aggregate;
  /** fetch data from the table: "system.Configuration" using primary key columns */
  readonly system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** perform the action: "vapidPublicKey" */
  readonly vapidPublicKey: VapidPublicKeyOutput;
  /** fetch data from the table: "video.ChannelStack" */
  readonly video_ChannelStack: ReadonlyArray<Video_ChannelStack>;
  /** fetch aggregated fields from the table: "video.ChannelStack" */
  readonly video_ChannelStack_aggregate: Video_ChannelStack_Aggregate;
  /** fetch data from the table: "video.ChannelStack" using primary key columns */
  readonly video_ChannelStack_by_pk?: Maybe<Video_ChannelStack>;
  /** fetch data from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream: ReadonlyArray<Video_EventParticipantStream>;
  /** fetch aggregated fields from the table: "video.EventParticipantStream" */
  readonly video_EventParticipantStream_aggregate: Video_EventParticipantStream_Aggregate;
  /** fetch data from the table: "video.EventParticipantStream" using primary key columns */
  readonly video_EventParticipantStream_by_pk?: Maybe<Video_EventParticipantStream>;
  /** fetch data from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession: ReadonlyArray<Video_EventVonageSession>;
  /** fetch aggregated fields from the table: "video.EventVonageSession" */
  readonly video_EventVonageSession_aggregate: Video_EventVonageSession_Aggregate;
  /** fetch data from the table: "video.EventVonageSession" using primary key columns */
  readonly video_EventVonageSession_by_pk?: Maybe<Video_EventVonageSession>;
  /** fetch data from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch: ReadonlyArray<Video_ImmediateSwitch>;
  /** fetch aggregated fields from the table: "video.ImmediateSwitch" */
  readonly video_ImmediateSwitch_aggregate: Video_ImmediateSwitch_Aggregate;
  /** fetch data from the table: "video.ImmediateSwitch" using primary key columns */
  readonly video_ImmediateSwitch_by_pk?: Maybe<Video_ImmediateSwitch>;
  /** fetch data from the table: "video.InputType" */
  readonly video_InputType: ReadonlyArray<Video_InputType>;
  /** fetch aggregated fields from the table: "video.InputType" */
  readonly video_InputType_aggregate: Video_InputType_Aggregate;
  /** fetch data from the table: "video.InputType" using primary key columns */
  readonly video_InputType_by_pk?: Maybe<Video_InputType>;
  /** fetch data from the table: "video.JobStatus" */
  readonly video_JobStatus: ReadonlyArray<Video_JobStatus>;
  /** fetch aggregated fields from the table: "video.JobStatus" */
  readonly video_JobStatus_aggregate: Video_JobStatus_Aggregate;
  /** fetch data from the table: "video.JobStatus" using primary key columns */
  readonly video_JobStatus_by_pk?: Maybe<Video_JobStatus>;
  /** fetch data from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus: ReadonlyArray<Video_MediaLiveChannelStatus>;
  /** fetch aggregated fields from the table: "video.MediaLiveChannelStatus" */
  readonly video_MediaLiveChannelStatus_aggregate: Video_MediaLiveChannelStatus_Aggregate;
  /** fetch data from the table: "video.MediaLiveChannelStatus" using primary key columns */
  readonly video_MediaLiveChannelStatus_by_pk?: Maybe<Video_MediaLiveChannelStatus>;
  /** fetch data from the table: "video.RtmpInput" */
  readonly video_RtmpInput: ReadonlyArray<Video_RtmpInput>;
  /** fetch aggregated fields from the table: "video.RtmpInput" */
  readonly video_RtmpInput_aggregate: Video_RtmpInput_Aggregate;
  /** fetch data from the table: "video.RtmpInput" using primary key columns */
  readonly video_RtmpInput_by_pk?: Maybe<Video_RtmpInput>;
  /** fetch data from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob: ReadonlyArray<Video_TranscriptionJob>;
  /** fetch aggregated fields from the table: "video.TranscriptionJob" */
  readonly video_TranscriptionJob_aggregate: Video_TranscriptionJob_Aggregate;
  /** fetch data from the table: "video.TranscriptionJob" using primary key columns */
  readonly video_TranscriptionJob_by_pk?: Maybe<Video_TranscriptionJob>;
  /** fetch data from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob: ReadonlyArray<Video_VideoRenderJob>;
  /** fetch aggregated fields from the table: "video.VideoRenderJob" */
  readonly video_VideoRenderJob_aggregate: Video_VideoRenderJob_Aggregate;
  /** fetch data from the table: "video.VideoRenderJob" using primary key columns */
  readonly video_VideoRenderJob_by_pk?: Maybe<Video_VideoRenderJob>;
  /** fetch data from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload: ReadonlyArray<Video_YouTubeUpload>;
  /** fetch aggregated fields from the table: "video.YouTubeUpload" */
  readonly video_YouTubeUpload_aggregate: Video_YouTubeUpload_Aggregate;
  /** fetch data from the table: "video.YouTubeUpload" using primary key columns */
  readonly video_YouTubeUpload_by_pk?: Maybe<Video_YouTubeUpload>;
};


/** subscription root */
export type Subscription_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPushNotificationSubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPushNotificationSubscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


/** subscription root */
export type Subscription_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


/** subscription root */
export type Subscription_RootAnalytics_AppStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_AppStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootAnalytics_ContentElementStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentElementStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentElementStats_Order_By>>;
  where?: Maybe<Analytics_ContentElementStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentElementStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAnalytics_ContentItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentItemStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAnalytics_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_RoomStats_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Pin_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndex_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Subscription_By_PkArgs = {
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootCollection_ExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootCollection_Exhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Exhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Exhibition_Order_By>>;
  where?: Maybe<Collection_Exhibition_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootCollection_Exhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootCollection_ProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootCollection_ProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_ProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_ProgramPerson_Order_By>>;
  where?: Maybe<Collection_ProgramPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootCollection_ProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootCollection_TagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootCollection_Tag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Collection_Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Collection_Tag_Order_By>>;
  where?: Maybe<Collection_Tag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootCollection_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConference_ConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_Conference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Conference_Order_By>>;
  where?: Maybe<Conference_Conference_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConference_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Configuration_Order_By>>;
  where?: Maybe<Conference_Configuration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_Configuration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConference_DemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_DemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_DemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_DemoCode_Order_By>>;
  where?: Maybe<Conference_DemoCode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_DemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConference_OriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_OriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_OriginatingData_Order_By>>;
  where?: Maybe<Conference_OriginatingData_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConference_PrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_PrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_PrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_PrepareJob_Order_By>>;
  where?: Maybe<Conference_PrepareJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_PrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_ElementArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ElementByAccessTokenArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ElementByAccessToken_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementByAccessToken_Order_By>>;
  where?: Maybe<Content_ElementByAccessToken_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ElementPermissionGrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ElementPermissionGrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_ElementPermissionGrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_ElementTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ElementType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ElementType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ElementType_Order_By>>;
  where?: Maybe<Content_ElementType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ElementType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootContent_Element_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Element_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Element_Order_By>>;
  where?: Maybe<Content_Element_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_Element_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_ItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemExhibitionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemExhibition_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemExhibition_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemExhibition_Order_By>>;
  where?: Maybe<Content_ItemExhibition_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemExhibition_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_ItemProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemProgramPerson_Order_By>>;
  where?: Maybe<Content_ItemProgramPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_ItemTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemTag_Order_By>>;
  where?: Maybe<Content_ItemTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_ItemTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_ItemType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_ItemType_Order_By>>;
  where?: Maybe<Content_ItemType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_ItemType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootContent_Item_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Item_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Item_Order_By>>;
  where?: Maybe<Content_Item_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_Item_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_UploadableElementArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_UploadableElementPermissionGrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_UploadableElementPermissionGrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElementPermissionGrant_Order_By>>;
  where?: Maybe<Content_UploadableElementPermissionGrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_UploadableElementPermissionGrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_UploadableElement_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_UploadableElement_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_UploadableElement_Order_By>>;
  where?: Maybe<Content_UploadableElement_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_UploadableElement_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContent_UploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_Uploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Content_Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Content_Uploader_Order_By>>;
  where?: Maybe<Content_Uploader_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContent_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootGetUploadAgreementArgs = {
  magicToken: Scalars['String'];
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackCreateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackCreateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackDeleteJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackDeleteJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackDeleteJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackDeleteJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackDeleteJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_CombineVideosJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CombineVideosJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_CustomEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CustomEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_UploadYouTubeVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_UploadYouTubeVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootPermissions_GroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_GroupRegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_GroupRegistrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRegistrant_Order_By>>;
  where?: Maybe<Permissions_GroupRegistrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_GroupRegistrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootPermissions_GroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_GroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_GroupRole_Order_By>>;
  where?: Maybe<Permissions_GroupRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootPermissions_Group_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Group_Order_By>>;
  where?: Maybe<Permissions_Group_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootPermissions_PermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_Permission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Permission_Order_By>>;
  where?: Maybe<Permissions_Permission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_Permission_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootPermissions_RoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_RolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_RolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_RolePermission_Order_By>>;
  where?: Maybe<Permissions_RolePermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootPermissions_Role_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permissions_Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permissions_Role_Order_By>>;
  where?: Maybe<Permissions_Role_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermissions_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRegistrant_GoogleAccountArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_GoogleAccount_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_GoogleAccount_Order_By>>;
  where?: Maybe<Registrant_GoogleAccount_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_GoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRegistrant_InvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_Invitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Invitation_Order_By>>;
  where?: Maybe<Registrant_Invitation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRegistrant_ProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_ProfileBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_ProfileBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_ProfileBadges_Order_By>>;
  where?: Maybe<Registrant_ProfileBadges_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_Profile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Profile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Profile_Order_By>>;
  where?: Maybe<Registrant_Profile_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_Profile_By_PkArgs = {
  registrantId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRegistrant_RegistrantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_Registrant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Registrant_Registrant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Registrant_Registrant_Order_By>>;
  where?: Maybe<Registrant_Registrant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRegistrant_Registrant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_BackendArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_Backend_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Backend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Backend_Order_By>>;
  where?: Maybe<Room_Backend_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_Backend_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_ChimeMeetingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ChimeMeeting_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ChimeMeeting_Order_By>>;
  where?: Maybe<Room_ChimeMeeting_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_LivestreamDurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_LivestreamDurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_LivestreamDurations_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_LivestreamDurations_Order_By>>;
  where?: Maybe<Room_LivestreamDurations_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ManagementModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ManagementMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ManagementMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ManagementMode_Order_By>>;
  where?: Maybe<Room_ManagementMode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ManagementMode_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_ModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_Mode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Mode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Mode_Order_By>>;
  where?: Maybe<Room_Mode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_Mode_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_ParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_Participant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Participant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Participant_Order_By>>;
  where?: Maybe<Room_Participant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_Participant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_PersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_PersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_PersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_PersonRole_Order_By>>;
  where?: Maybe<Room_PersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_PersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_RoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_RoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_RoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomPerson_Order_By>>;
  where?: Maybe<Room_RoomPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_Room_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Room_Order_By>>;
  where?: Maybe<Room_Room_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleAlgorithmArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleAlgorithm_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** subscription root */
export type Subscription_RootSchedule_EventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventProgramPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventProgramPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventProgramPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPersonRole_Order_By>>;
  where?: Maybe<Schedule_EventProgramPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventProgramPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootSchedule_EventProgramPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventProgramPerson_Order_By>>;
  where?: Maybe<Schedule_EventProgramPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventProgramPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootSchedule_EventRoomJoinRequestArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Order_By>>;
  where?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventRoomJoinRequest_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventRoomJoinRequest_Order_By>>;
  where?: Maybe<Schedule_EventRoomJoinRequest_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootSchedule_EventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_EventTag_Order_By>>;
  where?: Maybe<Schedule_EventTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootSchedule_Event_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_Event_Order_By>>;
  where?: Maybe<Schedule_Event_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootSchedule_OverlappingEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSchedule_OverlappingEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Schedule_OverlappingEvents_Order_By>>;
  where?: Maybe<Schedule_OverlappingEvents_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootSystem_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};


/** subscription root */
export type Subscription_RootVideo_ChannelStackArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_ChannelStack_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ChannelStack_Order_By>>;
  where?: Maybe<Video_ChannelStack_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_ChannelStack_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootVideo_EventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_EventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventParticipantStream_Order_By>>;
  where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootVideo_EventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_EventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_EventVonageSession_Order_By>>;
  where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootVideo_ImmediateSwitchArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_ImmediateSwitch_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Order_By>>;
  where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_ImmediateSwitch_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootVideo_InputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_InputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_InputType_Order_By>>;
  where?: Maybe<Video_InputType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_InputType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootVideo_JobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_JobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_JobStatus_Order_By>>;
  where?: Maybe<Video_JobStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootVideo_MediaLiveChannelStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_MediaLiveChannelStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Order_By>>;
  where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_MediaLiveChannelStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootVideo_RtmpInputArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_RtmpInput_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_RtmpInput_Order_By>>;
  where?: Maybe<Video_RtmpInput_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_RtmpInput_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootVideo_TranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_TranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_TranscriptionJob_Order_By>>;
  where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootVideo_VideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_VideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_VideoRenderJob_Order_By>>;
  where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootVideo_YouTubeUploadArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_YouTubeUpload_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Video_YouTubeUpload_Order_By>>;
  where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideo_YouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};

/** columns and relationships of "system.Configuration" */
export type System_Configuration = {
  readonly __typename?: 'system_Configuration';
  readonly created_at: Scalars['timestamptz'];
  readonly key: System_ConfigurationKey_Enum;
  readonly updated_at: Scalars['timestamptz'];
  readonly value: Scalars['jsonb'];
};


/** columns and relationships of "system.Configuration" */
export type System_ConfigurationValueArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "system.ConfigurationKey" */
export type System_ConfigurationKey = {
  readonly __typename?: 'system_ConfigurationKey';
  readonly description?: Maybe<Scalars['String']>;
  readonly name: Scalars['String'];
};

/** aggregated selection of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate = {
  readonly __typename?: 'system_ConfigurationKey_aggregate';
  readonly aggregate?: Maybe<System_ConfigurationKey_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<System_ConfigurationKey>;
};

/** aggregate fields of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_Fields = {
  readonly __typename?: 'system_ConfigurationKey_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<System_ConfigurationKey_Max_Fields>;
  readonly min?: Maybe<System_ConfigurationKey_Min_Fields>;
};


/** aggregate fields of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<System_ConfigurationKey_Max_Order_By>;
  readonly min?: Maybe<System_ConfigurationKey_Min_Order_By>;
};

/** input type for inserting array relation for remote table "system.ConfigurationKey" */
export type System_ConfigurationKey_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<System_ConfigurationKey_Insert_Input>;
  readonly on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};

/** Boolean expression to filter rows from the table "system.ConfigurationKey". All fields are combined with a logical 'AND'. */
export type System_ConfigurationKey_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<System_ConfigurationKey_Bool_Exp>>>;
  readonly _not?: Maybe<System_ConfigurationKey_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<System_ConfigurationKey_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Constraint {
  /** unique or primary key constraint */
  ConfigurationKeyPkey = 'ConfigurationKey_pkey'
}

export enum System_ConfigurationKey_Enum {
  /** The time of the latest revision of the host cookie policy. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  CookiePolicyLatestRevisionTimestamp = 'COOKIE_POLICY_LATEST_REVISION_TIMESTAMP',
  /** The URL to the host cookie policy. Note: If self hosting Clowdr, this must be your organisation's cookie policy - you cannot legally reuse, rely on or copy Clowdr's cookie policy. */
  CookiePolicyUrl = 'COOKIE_POLICY_URL',
  /** Default backend platform for video rooms */
  DefaultVideoRoomBackend = 'DEFAULT_VIDEO_ROOM_BACKEND',
  /** The name of the organisation legally responsible for hosting this instance of the Clowdr software. */
  HostOrganisationName = 'HOST_ORGANISATION_NAME',
  /** The time of the latest revision of the host Privacy Policy. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  PrivacyPolicyLatestRevisionTimestamp = 'PRIVACY_POLICY_LATEST_REVISION_TIMESTAMP',
  /** URL to the host Privacy Policy. Note: If self hosting Clowdr, this must be your organisation's privacy policy - you cannot legally reuse, rely on or copy Clowdr's privacy policy. */
  PrivacyPolicyUrl = 'PRIVACY_POLICY_URL',
  /** The time of the latest revision of the host T&Cs. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  TermsLatestRevisionTimestamp = 'TERMS_LATEST_REVISION_TIMESTAMP',
  /** URL to the host T&Cs. Note: If self hosting Clowdr, this must be your organisation's terms - you cannot legally reuse, rely on or copy Clowdr's terms. */
  TermsUrl = 'TERMS_URL',
  /** VAPID keys are used for push notifications and are generated automatically by the realtime service on first use. */
  VapidPrivateKey = 'VAPID_PRIVATE_KEY',
  /** VAPID keys are used for push notifications and are generated automatically by the realtime service on first use. */
  VapidPublicKey = 'VAPID_PUBLIC_KEY'
}

/** expression to compare columns of type system_ConfigurationKey_enum. All fields are combined with logical 'AND'. */
export type System_ConfigurationKey_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<System_ConfigurationKey_Enum>;
  readonly _in?: Maybe<ReadonlyArray<System_ConfigurationKey_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<System_ConfigurationKey_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<System_ConfigurationKey_Enum>>;
};

/** input type for inserting data into table "system.ConfigurationKey" */
export type System_ConfigurationKey_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type System_ConfigurationKey_Max_Fields = {
  readonly __typename?: 'system_ConfigurationKey_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "system.ConfigurationKey" */
export type System_ConfigurationKey_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type System_ConfigurationKey_Min_Fields = {
  readonly __typename?: 'system_ConfigurationKey_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "system.ConfigurationKey" */
export type System_ConfigurationKey_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "system.ConfigurationKey" */
export type System_ConfigurationKey_Mutation_Response = {
  readonly __typename?: 'system_ConfigurationKey_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<System_ConfigurationKey>;
};

/** input type for inserting object relation for remote table "system.ConfigurationKey" */
export type System_ConfigurationKey_Obj_Rel_Insert_Input = {
  readonly data: System_ConfigurationKey_Insert_Input;
  readonly on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};

/** on conflict condition type for table "system.ConfigurationKey" */
export type System_ConfigurationKey_On_Conflict = {
  readonly constraint: System_ConfigurationKey_Constraint;
  readonly update_columns: ReadonlyArray<System_ConfigurationKey_Update_Column>;
  readonly where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};

/** ordering options when selecting data from "system.ConfigurationKey" */
export type System_ConfigurationKey_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "system.ConfigurationKey" */
export type System_ConfigurationKey_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "system.ConfigurationKey" */
export type System_ConfigurationKey_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "system.Configuration" */
export type System_Configuration_Aggregate = {
  readonly __typename?: 'system_Configuration_aggregate';
  readonly aggregate?: Maybe<System_Configuration_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<System_Configuration>;
};

/** aggregate fields of "system.Configuration" */
export type System_Configuration_Aggregate_Fields = {
  readonly __typename?: 'system_Configuration_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<System_Configuration_Max_Fields>;
  readonly min?: Maybe<System_Configuration_Min_Fields>;
};


/** aggregate fields of "system.Configuration" */
export type System_Configuration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "system.Configuration" */
export type System_Configuration_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<System_Configuration_Max_Order_By>;
  readonly min?: Maybe<System_Configuration_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type System_Configuration_Append_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "system.Configuration" */
export type System_Configuration_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<System_Configuration_Insert_Input>;
  readonly on_conflict?: Maybe<System_Configuration_On_Conflict>;
};

/** Boolean expression to filter rows from the table "system.Configuration". All fields are combined with a logical 'AND'. */
export type System_Configuration_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<System_Configuration_Bool_Exp>>>;
  readonly _not?: Maybe<System_Configuration_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<System_Configuration_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly key?: Maybe<System_ConfigurationKey_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly value?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "system.Configuration" */
export enum System_Configuration_Constraint {
  /** unique or primary key constraint */
  ConfigurationPkey = 'Configuration_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type System_Configuration_Delete_At_Path_Input = {
  readonly value?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type System_Configuration_Delete_Elem_Input = {
  readonly value?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type System_Configuration_Delete_Key_Input = {
  readonly value?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "system.Configuration" */
export type System_Configuration_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<System_ConfigurationKey_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type System_Configuration_Max_Fields = {
  readonly __typename?: 'system_Configuration_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "system.Configuration" */
export type System_Configuration_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type System_Configuration_Min_Fields = {
  readonly __typename?: 'system_Configuration_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "system.Configuration" */
export type System_Configuration_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "system.Configuration" */
export type System_Configuration_Mutation_Response = {
  readonly __typename?: 'system_Configuration_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<System_Configuration>;
};

/** input type for inserting object relation for remote table "system.Configuration" */
export type System_Configuration_Obj_Rel_Insert_Input = {
  readonly data: System_Configuration_Insert_Input;
  readonly on_conflict?: Maybe<System_Configuration_On_Conflict>;
};

/** on conflict condition type for table "system.Configuration" */
export type System_Configuration_On_Conflict = {
  readonly constraint: System_Configuration_Constraint;
  readonly update_columns: ReadonlyArray<System_Configuration_Update_Column>;
  readonly where?: Maybe<System_Configuration_Bool_Exp>;
};

/** ordering options when selecting data from "system.Configuration" */
export type System_Configuration_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly value?: Maybe<Order_By>;
};

/** primary key columns input for table: "system.Configuration" */
export type System_Configuration_Pk_Columns_Input = {
  readonly key: System_ConfigurationKey_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type System_Configuration_Prepend_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "system.Configuration" */
export enum System_Configuration_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "system.Configuration" */
export type System_Configuration_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<System_ConfigurationKey_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "system.Configuration" */
export enum System_Configuration_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}


/** expression to compare columns of type timestamptz. All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['timestamptz']>;
  readonly _gt?: Maybe<Scalars['timestamptz']>;
  readonly _gte?: Maybe<Scalars['timestamptz']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['timestamptz']>;
  readonly _lte?: Maybe<Scalars['timestamptz']>;
  readonly _neq?: Maybe<Scalars['timestamptz']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
};


/** expression to compare columns of type uuid. All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['uuid']>;
  readonly _gt?: Maybe<Scalars['uuid']>;
  readonly _gte?: Maybe<Scalars['uuid']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['uuid']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['uuid']>;
  readonly _lte?: Maybe<Scalars['uuid']>;
  readonly _neq?: Maybe<Scalars['uuid']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['uuid']>>;
};

/** columns and relationships of "video.ChannelStack" */
export type Video_ChannelStack = {
  readonly __typename?: 'video_ChannelStack';
  /** An object relationship */
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob>;
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId: Scalars['String'];
  readonly cloudFrontDomain: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly endpointUri: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly loopingMp4InputAttachmentName: Scalars['String'];
  readonly mediaLiveChannelId: Scalars['String'];
  /** An object relationship */
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus>;
  readonly mediaPackageChannelId: Scalars['String'];
  readonly mp4InputAttachmentName: Scalars['String'];
  readonly mp4InputId: Scalars['String'];
  /** An object relationship */
  readonly room?: Maybe<Room_Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName: Scalars['String'];
  readonly rtmpAInputId: Scalars['String'];
  readonly rtmpAInputUri: Scalars['String'];
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "video.ChannelStack" */
export type Video_ChannelStack_Aggregate = {
  readonly __typename?: 'video_ChannelStack_aggregate';
  readonly aggregate?: Maybe<Video_ChannelStack_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_ChannelStack>;
};

/** aggregate fields of "video.ChannelStack" */
export type Video_ChannelStack_Aggregate_Fields = {
  readonly __typename?: 'video_ChannelStack_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_ChannelStack_Max_Fields>;
  readonly min?: Maybe<Video_ChannelStack_Min_Fields>;
};


/** aggregate fields of "video.ChannelStack" */
export type Video_ChannelStack_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_ChannelStack_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.ChannelStack" */
export type Video_ChannelStack_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_ChannelStack_Max_Order_By>;
  readonly min?: Maybe<Video_ChannelStack_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.ChannelStack" */
export type Video_ChannelStack_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_ChannelStack_Insert_Input>;
  readonly on_conflict?: Maybe<Video_ChannelStack_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.ChannelStack". All fields are combined with a logical 'AND'. */
export type Video_ChannelStack_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_ChannelStack_Bool_Exp>>>;
  readonly _not?: Maybe<Video_ChannelStack_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_ChannelStack_Bool_Exp>>>;
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly channelStackCreateJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly cloudFormationStackArn?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDistributionId?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDomain?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpointUri?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly loopingMp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
  readonly mediaPackageChannelId?: Maybe<String_Comparison_Exp>;
  readonly mp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mp4InputId?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly rtmpAInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly rtmpAInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpAInputUri?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpBInputUri?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.ChannelStack" */
export enum Video_ChannelStack_Constraint {
  /** unique or primary key constraint */
  MediaLiveChannelPkey = 'MediaLiveChannel_pkey',
  /** unique or primary key constraint */
  MediaLiveChannelRoomIdKey = 'MediaLiveChannel_roomId_key'
}

/** input type for inserting data into table "video.ChannelStack" */
export type Video_ChannelStack_Insert_Input = {
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Obj_Rel_Insert_Input>;
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Obj_Rel_Insert_Input>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_ChannelStack_Max_Fields = {
  readonly __typename?: 'video_ChannelStack_max_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "video.ChannelStack" */
export type Video_ChannelStack_Max_Order_By = {
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpAInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpAInputId?: Maybe<Order_By>;
  readonly rtmpAInputUri?: Maybe<Order_By>;
  readonly rtmpBInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpBInputId?: Maybe<Order_By>;
  readonly rtmpBInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_ChannelStack_Min_Fields = {
  readonly __typename?: 'video_ChannelStack_min_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "video.ChannelStack" */
export type Video_ChannelStack_Min_Order_By = {
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpAInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpAInputId?: Maybe<Order_By>;
  readonly rtmpAInputUri?: Maybe<Order_By>;
  readonly rtmpBInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpBInputId?: Maybe<Order_By>;
  readonly rtmpBInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.ChannelStack" */
export type Video_ChannelStack_Mutation_Response = {
  readonly __typename?: 'video_ChannelStack_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_ChannelStack>;
};

/** input type for inserting object relation for remote table "video.ChannelStack" */
export type Video_ChannelStack_Obj_Rel_Insert_Input = {
  readonly data: Video_ChannelStack_Insert_Input;
  readonly on_conflict?: Maybe<Video_ChannelStack_On_Conflict>;
};

/** on conflict condition type for table "video.ChannelStack" */
export type Video_ChannelStack_On_Conflict = {
  readonly constraint: Video_ChannelStack_Constraint;
  readonly update_columns: ReadonlyArray<Video_ChannelStack_Update_Column>;
  readonly where?: Maybe<Video_ChannelStack_Bool_Exp>;
};

/** ordering options when selecting data from "video.ChannelStack" */
export type Video_ChannelStack_Order_By = {
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Order_By>;
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaLiveChannelStatus?: Maybe<Video_MediaLiveChannelStatus_Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpAInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpAInputId?: Maybe<Order_By>;
  readonly rtmpAInputUri?: Maybe<Order_By>;
  readonly rtmpBInputAttachmentName?: Maybe<Order_By>;
  readonly rtmpBInputId?: Maybe<Order_By>;
  readonly rtmpBInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.ChannelStack" */
export type Video_ChannelStack_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.ChannelStack" */
export enum Video_ChannelStack_Select_Column {
  /** column name */
  ChannelStackCreateJobId = 'channelStackCreateJobId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RtmpAInputAttachmentName = 'rtmpAInputAttachmentName',
  /** column name */
  RtmpAInputId = 'rtmpAInputId',
  /** column name */
  RtmpAInputUri = 'rtmpAInputUri',
  /** column name */
  RtmpBInputAttachmentName = 'rtmpBInputAttachmentName',
  /** column name */
  RtmpBInputId = 'rtmpBInputId',
  /** column name */
  RtmpBInputUri = 'rtmpBInputUri',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.ChannelStack" */
export type Video_ChannelStack_Set_Input = {
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpAInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpAInputId?: Maybe<Scalars['String']>;
  readonly rtmpAInputUri?: Maybe<Scalars['String']>;
  readonly rtmpBInputAttachmentName?: Maybe<Scalars['String']>;
  readonly rtmpBInputId?: Maybe<Scalars['String']>;
  readonly rtmpBInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "video.ChannelStack" */
export enum Video_ChannelStack_Update_Column {
  /** column name */
  ChannelStackCreateJobId = 'channelStackCreateJobId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RtmpAInputAttachmentName = 'rtmpAInputAttachmentName',
  /** column name */
  RtmpAInputId = 'rtmpAInputId',
  /** column name */
  RtmpAInputUri = 'rtmpAInputUri',
  /** column name */
  RtmpBInputAttachmentName = 'rtmpBInputAttachmentName',
  /** column name */
  RtmpBInputId = 'rtmpBInputId',
  /** column name */
  RtmpBInputUri = 'rtmpBInputUri',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/**
 * Current streams in event Vonage sessions.
 *
 *
 * columns and relationships of "video.EventParticipantStream"
 */
export type Video_EventParticipantStream = {
  readonly __typename?: 'video_EventParticipantStream';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly registrant: Registrant_Registrant;
  readonly registrantId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId: Scalars['String'];
  readonly vonageStreamId: Scalars['String'];
  readonly vonageStreamType: Scalars['String'];
};

/** aggregated selection of "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate = {
  readonly __typename?: 'video_EventParticipantStream_aggregate';
  readonly aggregate?: Maybe<Video_EventParticipantStream_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_EventParticipantStream>;
};

/** aggregate fields of "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate_Fields = {
  readonly __typename?: 'video_EventParticipantStream_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_EventParticipantStream_Max_Fields>;
  readonly min?: Maybe<Video_EventParticipantStream_Min_Fields>;
};


/** aggregate fields of "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_EventParticipantStream_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_EventParticipantStream_Max_Order_By>;
  readonly min?: Maybe<Video_EventParticipantStream_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_EventParticipantStream_Insert_Input>;
  readonly on_conflict?: Maybe<Video_EventParticipantStream_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.EventParticipantStream". All fields are combined with a logical 'AND'. */
export type Video_EventParticipantStream_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_EventParticipantStream_Bool_Exp>>>;
  readonly _not?: Maybe<Video_EventParticipantStream_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_EventParticipantStream_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly registrant?: Maybe<Registrant_Registrant_Bool_Exp>;
  readonly registrantId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamType?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.EventParticipantStream" */
export enum Video_EventParticipantStream_Constraint {
  /** unique or primary key constraint */
  EventParticipantStreamEventIdRegistrantIdVonageStreamIdKey = 'EventParticipantStream_eventId_registrantId_vonageStreamId_key',
  /** unique or primary key constraint */
  EventParticipantStreamPkey = 'EventParticipantStream_pkey'
}

/** input type for inserting data into table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrant?: Maybe<Registrant_Registrant_Obj_Rel_Insert_Input>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_EventParticipantStream_Max_Fields = {
  readonly __typename?: 'video_EventParticipantStream_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_EventParticipantStream_Min_Fields = {
  readonly __typename?: 'video_EventParticipantStream_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Mutation_Response = {
  readonly __typename?: 'video_EventParticipantStream_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_EventParticipantStream>;
};

/** input type for inserting object relation for remote table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Obj_Rel_Insert_Input = {
  readonly data: Video_EventParticipantStream_Insert_Input;
  readonly on_conflict?: Maybe<Video_EventParticipantStream_On_Conflict>;
};

/** on conflict condition type for table "video.EventParticipantStream" */
export type Video_EventParticipantStream_On_Conflict = {
  readonly constraint: Video_EventParticipantStream_Constraint;
  readonly update_columns: ReadonlyArray<Video_EventParticipantStream_Update_Column>;
  readonly where?: Maybe<Video_EventParticipantStream_Bool_Exp>;
};

/** ordering options when selecting data from "video.EventParticipantStream" */
export type Video_EventParticipantStream_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly registrant?: Maybe<Registrant_Registrant_Order_By>;
  readonly registrantId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.EventParticipantStream" */
export type Video_EventParticipantStream_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.EventParticipantStream" */
export enum Video_EventParticipantStream_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** input type for updating data in table "video.EventParticipantStream" */
export type Video_EventParticipantStream_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly registrantId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** update columns of table "video.EventParticipantStream" */
export enum Video_EventParticipantStream_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RegistrantId = 'registrantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** columns and relationships of "video.EventVonageSession" */
export type Video_EventVonageSession = {
  readonly __typename?: 'video_EventVonageSession';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Schedule_Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly rtmpInputName: Video_RtmpInput_Enum;
  readonly sessionId: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "video.EventVonageSession" */
export type Video_EventVonageSessionLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "video.EventVonageSession" */
export type Video_EventVonageSession_Aggregate = {
  readonly __typename?: 'video_EventVonageSession_aggregate';
  readonly aggregate?: Maybe<Video_EventVonageSession_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_EventVonageSession>;
};

/** aggregate fields of "video.EventVonageSession" */
export type Video_EventVonageSession_Aggregate_Fields = {
  readonly __typename?: 'video_EventVonageSession_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_EventVonageSession_Max_Fields>;
  readonly min?: Maybe<Video_EventVonageSession_Min_Fields>;
};


/** aggregate fields of "video.EventVonageSession" */
export type Video_EventVonageSession_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_EventVonageSession_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.EventVonageSession" */
export type Video_EventVonageSession_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_EventVonageSession_Max_Order_By>;
  readonly min?: Maybe<Video_EventVonageSession_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Video_EventVonageSession_Append_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "video.EventVonageSession" */
export type Video_EventVonageSession_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_EventVonageSession_Insert_Input>;
  readonly on_conflict?: Maybe<Video_EventVonageSession_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.EventVonageSession". All fields are combined with a logical 'AND'. */
export type Video_EventVonageSession_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_EventVonageSession_Bool_Exp>>>;
  readonly _not?: Maybe<Video_EventVonageSession_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_EventVonageSession_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly rtmpInputName?: Maybe<Video_RtmpInput_Enum_Comparison_Exp>;
  readonly sessionId?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.EventVonageSession" */
export enum Video_EventVonageSession_Constraint {
  /** unique or primary key constraint */
  EventVonageSessionEventIdKey = 'EventVonageSession_eventId_key',
  /** unique or primary key constraint */
  EventVonageSessionPkey = 'EventVonageSession_pkey',
  /** unique or primary key constraint */
  EventVonageSessionSessionIdKey = 'EventVonageSession_sessionId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Video_EventVonageSession_Delete_At_Path_Input = {
  readonly layoutData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Video_EventVonageSession_Delete_Elem_Input = {
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Video_EventVonageSession_Delete_Key_Input = {
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "video.EventVonageSession" */
export type Video_EventVonageSession_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly rtmpInputName?: Maybe<Video_RtmpInput_Enum>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_EventVonageSession_Max_Fields = {
  readonly __typename?: 'video_EventVonageSession_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "video.EventVonageSession" */
export type Video_EventVonageSession_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_EventVonageSession_Min_Fields = {
  readonly __typename?: 'video_EventVonageSession_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "video.EventVonageSession" */
export type Video_EventVonageSession_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.EventVonageSession" */
export type Video_EventVonageSession_Mutation_Response = {
  readonly __typename?: 'video_EventVonageSession_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_EventVonageSession>;
};

/** input type for inserting object relation for remote table "video.EventVonageSession" */
export type Video_EventVonageSession_Obj_Rel_Insert_Input = {
  readonly data: Video_EventVonageSession_Insert_Input;
  readonly on_conflict?: Maybe<Video_EventVonageSession_On_Conflict>;
};

/** on conflict condition type for table "video.EventVonageSession" */
export type Video_EventVonageSession_On_Conflict = {
  readonly constraint: Video_EventVonageSession_Constraint;
  readonly update_columns: ReadonlyArray<Video_EventVonageSession_Update_Column>;
  readonly where?: Maybe<Video_EventVonageSession_Bool_Exp>;
};

/** ordering options when selecting data from "video.EventVonageSession" */
export type Video_EventVonageSession_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly rtmpInputName?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.EventVonageSession" */
export type Video_EventVonageSession_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Video_EventVonageSession_Prepend_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "video.EventVonageSession" */
export enum Video_EventVonageSession_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  RtmpInputName = 'rtmpInputName',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.EventVonageSession" */
export type Video_EventVonageSession_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly rtmpInputName?: Maybe<Video_RtmpInput_Enum>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "video.EventVonageSession" */
export enum Video_EventVonageSession_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  RtmpInputName = 'rtmpInputName',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch = {
  readonly __typename?: 'video_ImmediateSwitch';
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly errorMessage?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly event?: Maybe<Schedule_Event>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "video.ImmediateSwitch" */
export type Video_ImmediateSwitchDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Aggregate = {
  readonly __typename?: 'video_ImmediateSwitch_aggregate';
  readonly aggregate?: Maybe<Video_ImmediateSwitch_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_ImmediateSwitch>;
};

/** aggregate fields of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Aggregate_Fields = {
  readonly __typename?: 'video_ImmediateSwitch_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_ImmediateSwitch_Max_Fields>;
  readonly min?: Maybe<Video_ImmediateSwitch_Min_Fields>;
};


/** aggregate fields of "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_ImmediateSwitch_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_ImmediateSwitch_Max_Order_By>;
  readonly min?: Maybe<Video_ImmediateSwitch_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Video_ImmediateSwitch_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_ImmediateSwitch_Insert_Input>;
  readonly on_conflict?: Maybe<Video_ImmediateSwitch_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.ImmediateSwitch". All fields are combined with a logical 'AND'. */
export type Video_ImmediateSwitch_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_ImmediateSwitch_Bool_Exp>>>;
  readonly _not?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_ImmediateSwitch_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly errorMessage?: Maybe<String_Comparison_Exp>;
  readonly event?: Maybe<Schedule_Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly executedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.ImmediateSwitch" */
export enum Video_ImmediateSwitch_Constraint {
  /** unique or primary key constraint */
  ImmediateSwitchPkey = 'ImmediateSwitch_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Video_ImmediateSwitch_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Video_ImmediateSwitch_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Video_ImmediateSwitch_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly event?: Maybe<Schedule_Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_ImmediateSwitch_Max_Fields = {
  readonly __typename?: 'video_ImmediateSwitch_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly errorMessage?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly executedAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_ImmediateSwitch_Min_Fields = {
  readonly __typename?: 'video_ImmediateSwitch_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly errorMessage?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly executedAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Mutation_Response = {
  readonly __typename?: 'video_ImmediateSwitch_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_ImmediateSwitch>;
};

/** input type for inserting object relation for remote table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Obj_Rel_Insert_Input = {
  readonly data: Video_ImmediateSwitch_Insert_Input;
  readonly on_conflict?: Maybe<Video_ImmediateSwitch_On_Conflict>;
};

/** on conflict condition type for table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_On_Conflict = {
  readonly constraint: Video_ImmediateSwitch_Constraint;
  readonly update_columns: ReadonlyArray<Video_ImmediateSwitch_Update_Column>;
  readonly where?: Maybe<Video_ImmediateSwitch_Bool_Exp>;
};

/** ordering options when selecting data from "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly errorMessage?: Maybe<Order_By>;
  readonly event?: Maybe<Schedule_Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly executedAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Video_ImmediateSwitch_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "video.ImmediateSwitch" */
export enum Video_ImmediateSwitch_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  ErrorMessage = 'errorMessage',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExecutedAt = 'executedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.ImmediateSwitch" */
export type Video_ImmediateSwitch_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly errorMessage?: Maybe<Scalars['String']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "video.ImmediateSwitch" */
export enum Video_ImmediateSwitch_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  ErrorMessage = 'errorMessage',
  /** column name */
  EventId = 'eventId',
  /** column name */
  ExecutedAt = 'executedAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "video.InputType" */
export type Video_InputType = {
  readonly __typename?: 'video_InputType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "video.InputType" */
export type Video_InputType_Aggregate = {
  readonly __typename?: 'video_InputType_aggregate';
  readonly aggregate?: Maybe<Video_InputType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_InputType>;
};

/** aggregate fields of "video.InputType" */
export type Video_InputType_Aggregate_Fields = {
  readonly __typename?: 'video_InputType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_InputType_Max_Fields>;
  readonly min?: Maybe<Video_InputType_Min_Fields>;
};


/** aggregate fields of "video.InputType" */
export type Video_InputType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_InputType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.InputType" */
export type Video_InputType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_InputType_Max_Order_By>;
  readonly min?: Maybe<Video_InputType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.InputType" */
export type Video_InputType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_InputType_Insert_Input>;
  readonly on_conflict?: Maybe<Video_InputType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.InputType". All fields are combined with a logical 'AND'. */
export type Video_InputType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_InputType_Bool_Exp>>>;
  readonly _not?: Maybe<Video_InputType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_InputType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.InputType" */
export enum Video_InputType_Constraint {
  /** unique or primary key constraint */
  InputTypeNamePkey = 'InputTypeName_pkey'
}

/** input type for inserting data into table "video.InputType" */
export type Video_InputType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_InputType_Max_Fields = {
  readonly __typename?: 'video_InputType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.InputType" */
export type Video_InputType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_InputType_Min_Fields = {
  readonly __typename?: 'video_InputType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.InputType" */
export type Video_InputType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.InputType" */
export type Video_InputType_Mutation_Response = {
  readonly __typename?: 'video_InputType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_InputType>;
};

/** input type for inserting object relation for remote table "video.InputType" */
export type Video_InputType_Obj_Rel_Insert_Input = {
  readonly data: Video_InputType_Insert_Input;
  readonly on_conflict?: Maybe<Video_InputType_On_Conflict>;
};

/** on conflict condition type for table "video.InputType" */
export type Video_InputType_On_Conflict = {
  readonly constraint: Video_InputType_Constraint;
  readonly update_columns: ReadonlyArray<Video_InputType_Update_Column>;
  readonly where?: Maybe<Video_InputType_Bool_Exp>;
};

/** ordering options when selecting data from "video.InputType" */
export type Video_InputType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.InputType" */
export type Video_InputType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "video.InputType" */
export enum Video_InputType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "video.InputType" */
export type Video_InputType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "video.InputType" */
export enum Video_InputType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "video.JobStatus" */
export type Video_JobStatus = {
  readonly __typename?: 'video_JobStatus';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "video.JobStatus" */
export type Video_JobStatus_Aggregate = {
  readonly __typename?: 'video_JobStatus_aggregate';
  readonly aggregate?: Maybe<Video_JobStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_JobStatus>;
};

/** aggregate fields of "video.JobStatus" */
export type Video_JobStatus_Aggregate_Fields = {
  readonly __typename?: 'video_JobStatus_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_JobStatus_Max_Fields>;
  readonly min?: Maybe<Video_JobStatus_Min_Fields>;
};


/** aggregate fields of "video.JobStatus" */
export type Video_JobStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_JobStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.JobStatus" */
export type Video_JobStatus_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_JobStatus_Max_Order_By>;
  readonly min?: Maybe<Video_JobStatus_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.JobStatus" */
export type Video_JobStatus_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_JobStatus_Insert_Input>;
  readonly on_conflict?: Maybe<Video_JobStatus_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.JobStatus". All fields are combined with a logical 'AND'. */
export type Video_JobStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_JobStatus_Bool_Exp>>>;
  readonly _not?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_JobStatus_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.JobStatus" */
export enum Video_JobStatus_Constraint {
  /** unique or primary key constraint */
  JobStatusPkey = 'JobStatus_pkey'
}

export enum Video_JobStatus_Enum {
  /** Job completed successfully. */
  Completed = 'COMPLETED',
  /** Job is no longer valid. */
  Expired = 'EXPIRED',
  /** Job failed during execution. */
  Failed = 'FAILED',
  /** Job is currently in progress. */
  InProgress = 'IN_PROGRESS',
  /** Job has not yet started execution. */
  New = 'NEW'
}

/** expression to compare columns of type video_JobStatus_enum. All fields are combined with logical 'AND'. */
export type Video_JobStatus_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Video_JobStatus_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Video_JobStatus_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Video_JobStatus_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Video_JobStatus_Enum>>;
};

/** input type for inserting data into table "video.JobStatus" */
export type Video_JobStatus_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_JobStatus_Max_Fields = {
  readonly __typename?: 'video_JobStatus_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.JobStatus" */
export type Video_JobStatus_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_JobStatus_Min_Fields = {
  readonly __typename?: 'video_JobStatus_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.JobStatus" */
export type Video_JobStatus_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.JobStatus" */
export type Video_JobStatus_Mutation_Response = {
  readonly __typename?: 'video_JobStatus_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_JobStatus>;
};

/** input type for inserting object relation for remote table "video.JobStatus" */
export type Video_JobStatus_Obj_Rel_Insert_Input = {
  readonly data: Video_JobStatus_Insert_Input;
  readonly on_conflict?: Maybe<Video_JobStatus_On_Conflict>;
};

/** on conflict condition type for table "video.JobStatus" */
export type Video_JobStatus_On_Conflict = {
  readonly constraint: Video_JobStatus_Constraint;
  readonly update_columns: ReadonlyArray<Video_JobStatus_Update_Column>;
  readonly where?: Maybe<Video_JobStatus_Bool_Exp>;
};

/** ordering options when selecting data from "video.JobStatus" */
export type Video_JobStatus_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.JobStatus" */
export type Video_JobStatus_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "video.JobStatus" */
export enum Video_JobStatus_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "video.JobStatus" */
export type Video_JobStatus_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "video.JobStatus" */
export enum Video_JobStatus_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus = {
  readonly __typename?: 'video_MediaLiveChannelStatus';
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly channelStack: Video_ChannelStack;
  readonly channelStackId: Scalars['uuid'];
  /** An object relationship */
  readonly conference?: Maybe<Conference_Conference>;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Aggregate = {
  readonly __typename?: 'video_MediaLiveChannelStatus_aggregate';
  readonly aggregate?: Maybe<Video_MediaLiveChannelStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_MediaLiveChannelStatus>;
};

/** aggregate fields of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Aggregate_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_aggregate_fields';
  readonly avg?: Maybe<Video_MediaLiveChannelStatus_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_MediaLiveChannelStatus_Max_Fields>;
  readonly min?: Maybe<Video_MediaLiveChannelStatus_Min_Fields>;
  readonly stddev?: Maybe<Video_MediaLiveChannelStatus_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Video_MediaLiveChannelStatus_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Video_MediaLiveChannelStatus_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Video_MediaLiveChannelStatus_Sum_Fields>;
  readonly var_pop?: Maybe<Video_MediaLiveChannelStatus_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Video_MediaLiveChannelStatus_Var_Samp_Fields>;
  readonly variance?: Maybe<Video_MediaLiveChannelStatus_Variance_Fields>;
};


/** aggregate fields of "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_MediaLiveChannelStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Aggregate_Order_By = {
  readonly avg?: Maybe<Video_MediaLiveChannelStatus_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_MediaLiveChannelStatus_Max_Order_By>;
  readonly min?: Maybe<Video_MediaLiveChannelStatus_Min_Order_By>;
  readonly stddev?: Maybe<Video_MediaLiveChannelStatus_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Video_MediaLiveChannelStatus_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Video_MediaLiveChannelStatus_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Video_MediaLiveChannelStatus_Sum_Order_By>;
  readonly var_pop?: Maybe<Video_MediaLiveChannelStatus_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Video_MediaLiveChannelStatus_Var_Samp_Order_By>;
  readonly variance?: Maybe<Video_MediaLiveChannelStatus_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_MediaLiveChannelStatus_Insert_Input>;
  readonly on_conflict?: Maybe<Video_MediaLiveChannelStatus_On_Conflict>;
};

/** aggregate avg on columns */
export type Video_MediaLiveChannelStatus_Avg_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_avg_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Avg_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "video.MediaLiveChannelStatus". All fields are combined with a logical 'AND'. */
export type Video_MediaLiveChannelStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_MediaLiveChannelStatus_Bool_Exp>>>;
  readonly _not?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_MediaLiveChannelStatus_Bool_Exp>>>;
  readonly activeInputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly activeInputSwitchActionName?: Maybe<String_Comparison_Exp>;
  readonly channelStack?: Maybe<Video_ChannelStack_Bool_Exp>;
  readonly channelStackId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly pipelinesRunningCount?: Maybe<Numeric_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.MediaLiveChannelStatus" */
export enum Video_MediaLiveChannelStatus_Constraint {
  /** unique or primary key constraint */
  MediaLiveChannelStatusChannelStackIdKey = 'MediaLiveChannelStatus_channelStackId_key',
  /** unique or primary key constraint */
  MediaLiveChannelStatusPkey = 'MediaLiveChannelStatus_pkey'
}

/** input type for incrementing integer column in table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Inc_Input = {
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
};

/** input type for inserting data into table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Insert_Input = {
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStack?: Maybe<Video_ChannelStack_Obj_Rel_Insert_Input>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_MediaLiveChannelStatus_Max_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_max_fields';
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Max_Order_By = {
  readonly activeInputAttachmentName?: Maybe<Order_By>;
  readonly activeInputSwitchActionName?: Maybe<Order_By>;
  readonly channelStackId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly pipelinesRunningCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_MediaLiveChannelStatus_Min_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_min_fields';
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Min_Order_By = {
  readonly activeInputAttachmentName?: Maybe<Order_By>;
  readonly activeInputSwitchActionName?: Maybe<Order_By>;
  readonly channelStackId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly pipelinesRunningCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Mutation_Response = {
  readonly __typename?: 'video_MediaLiveChannelStatus_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_MediaLiveChannelStatus>;
};

/** input type for inserting object relation for remote table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Obj_Rel_Insert_Input = {
  readonly data: Video_MediaLiveChannelStatus_Insert_Input;
  readonly on_conflict?: Maybe<Video_MediaLiveChannelStatus_On_Conflict>;
};

/** on conflict condition type for table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_On_Conflict = {
  readonly constraint: Video_MediaLiveChannelStatus_Constraint;
  readonly update_columns: ReadonlyArray<Video_MediaLiveChannelStatus_Update_Column>;
  readonly where?: Maybe<Video_MediaLiveChannelStatus_Bool_Exp>;
};

/** ordering options when selecting data from "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Order_By = {
  readonly activeInputAttachmentName?: Maybe<Order_By>;
  readonly activeInputSwitchActionName?: Maybe<Order_By>;
  readonly channelStack?: Maybe<Video_ChannelStack_Order_By>;
  readonly channelStackId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly pipelinesRunningCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.MediaLiveChannelStatus" */
export enum Video_MediaLiveChannelStatus_Select_Column {
  /** column name */
  ActiveInputAttachmentName = 'activeInputAttachmentName',
  /** column name */
  ActiveInputSwitchActionName = 'activeInputSwitchActionName',
  /** column name */
  ChannelStackId = 'channelStackId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PipelinesRunningCount = 'pipelinesRunningCount',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Set_Input = {
  readonly activeInputAttachmentName?: Maybe<Scalars['String']>;
  readonly activeInputSwitchActionName?: Maybe<Scalars['String']>;
  readonly channelStackId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Video_MediaLiveChannelStatus_Stddev_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_stddev_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Stddev_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Video_MediaLiveChannelStatus_Stddev_Pop_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_stddev_pop_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Stddev_Pop_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Video_MediaLiveChannelStatus_Stddev_Samp_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_stddev_samp_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Stddev_Samp_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Video_MediaLiveChannelStatus_Sum_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_sum_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['numeric']>;
};

/** order by sum() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Sum_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** update columns of table "video.MediaLiveChannelStatus" */
export enum Video_MediaLiveChannelStatus_Update_Column {
  /** column name */
  ActiveInputAttachmentName = 'activeInputAttachmentName',
  /** column name */
  ActiveInputSwitchActionName = 'activeInputSwitchActionName',
  /** column name */
  ChannelStackId = 'channelStackId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PipelinesRunningCount = 'pipelinesRunningCount',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Video_MediaLiveChannelStatus_Var_Pop_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_var_pop_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Var_Pop_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Video_MediaLiveChannelStatus_Var_Samp_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_var_samp_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Var_Samp_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Video_MediaLiveChannelStatus_Variance_Fields = {
  readonly __typename?: 'video_MediaLiveChannelStatus_variance_fields';
  readonly pipelinesRunningCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "video.MediaLiveChannelStatus" */
export type Video_MediaLiveChannelStatus_Variance_Order_By = {
  readonly pipelinesRunningCount?: Maybe<Order_By>;
};

/** columns and relationships of "video.RtmpInput" */
export type Video_RtmpInput = {
  readonly __typename?: 'video_RtmpInput';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "video.RtmpInput" */
export type Video_RtmpInput_Aggregate = {
  readonly __typename?: 'video_RtmpInput_aggregate';
  readonly aggregate?: Maybe<Video_RtmpInput_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_RtmpInput>;
};

/** aggregate fields of "video.RtmpInput" */
export type Video_RtmpInput_Aggregate_Fields = {
  readonly __typename?: 'video_RtmpInput_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_RtmpInput_Max_Fields>;
  readonly min?: Maybe<Video_RtmpInput_Min_Fields>;
};


/** aggregate fields of "video.RtmpInput" */
export type Video_RtmpInput_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_RtmpInput_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.RtmpInput" */
export type Video_RtmpInput_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_RtmpInput_Max_Order_By>;
  readonly min?: Maybe<Video_RtmpInput_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.RtmpInput" */
export type Video_RtmpInput_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_RtmpInput_Insert_Input>;
  readonly on_conflict?: Maybe<Video_RtmpInput_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.RtmpInput". All fields are combined with a logical 'AND'. */
export type Video_RtmpInput_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_RtmpInput_Bool_Exp>>>;
  readonly _not?: Maybe<Video_RtmpInput_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_RtmpInput_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.RtmpInput" */
export enum Video_RtmpInput_Constraint {
  /** unique or primary key constraint */
  RtmpInputPkey = 'RtmpInput_pkey'
}

export enum Video_RtmpInput_Enum {
  /** The A RTMP input. */
  RtmpA = 'RTMP_A',
  /** The B RTMP input. */
  RtmpB = 'RTMP_B'
}

/** expression to compare columns of type video_RtmpInput_enum. All fields are combined with logical 'AND'. */
export type Video_RtmpInput_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Video_RtmpInput_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Video_RtmpInput_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Video_RtmpInput_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Video_RtmpInput_Enum>>;
};

/** input type for inserting data into table "video.RtmpInput" */
export type Video_RtmpInput_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_RtmpInput_Max_Fields = {
  readonly __typename?: 'video_RtmpInput_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.RtmpInput" */
export type Video_RtmpInput_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_RtmpInput_Min_Fields = {
  readonly __typename?: 'video_RtmpInput_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.RtmpInput" */
export type Video_RtmpInput_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.RtmpInput" */
export type Video_RtmpInput_Mutation_Response = {
  readonly __typename?: 'video_RtmpInput_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_RtmpInput>;
};

/** input type for inserting object relation for remote table "video.RtmpInput" */
export type Video_RtmpInput_Obj_Rel_Insert_Input = {
  readonly data: Video_RtmpInput_Insert_Input;
  readonly on_conflict?: Maybe<Video_RtmpInput_On_Conflict>;
};

/** on conflict condition type for table "video.RtmpInput" */
export type Video_RtmpInput_On_Conflict = {
  readonly constraint: Video_RtmpInput_Constraint;
  readonly update_columns: ReadonlyArray<Video_RtmpInput_Update_Column>;
  readonly where?: Maybe<Video_RtmpInput_Bool_Exp>;
};

/** ordering options when selecting data from "video.RtmpInput" */
export type Video_RtmpInput_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.RtmpInput" */
export type Video_RtmpInput_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "video.RtmpInput" */
export enum Video_RtmpInput_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "video.RtmpInput" */
export type Video_RtmpInput_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "video.RtmpInput" */
export enum Video_RtmpInput_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "video.TranscriptionJob" */
export type Video_TranscriptionJob = {
  readonly __typename?: 'video_TranscriptionJob';
  readonly awsTranscribeJobName: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly languageCode: Scalars['String'];
  readonly transcriptionS3Url: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
  readonly videoS3Url: Scalars['String'];
};

/** aggregated selection of "video.TranscriptionJob" */
export type Video_TranscriptionJob_Aggregate = {
  readonly __typename?: 'video_TranscriptionJob_aggregate';
  readonly aggregate?: Maybe<Video_TranscriptionJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_TranscriptionJob>;
};

/** aggregate fields of "video.TranscriptionJob" */
export type Video_TranscriptionJob_Aggregate_Fields = {
  readonly __typename?: 'video_TranscriptionJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_TranscriptionJob_Max_Fields>;
  readonly min?: Maybe<Video_TranscriptionJob_Min_Fields>;
};


/** aggregate fields of "video.TranscriptionJob" */
export type Video_TranscriptionJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_TranscriptionJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_TranscriptionJob_Max_Order_By>;
  readonly min?: Maybe<Video_TranscriptionJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_TranscriptionJob_Insert_Input>;
  readonly on_conflict?: Maybe<Video_TranscriptionJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.TranscriptionJob". All fields are combined with a logical 'AND'. */
export type Video_TranscriptionJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_TranscriptionJob_Bool_Exp>>>;
  readonly _not?: Maybe<Video_TranscriptionJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_TranscriptionJob_Bool_Exp>>>;
  readonly awsTranscribeJobName?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly languageCode?: Maybe<String_Comparison_Exp>;
  readonly transcriptionS3Url?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoS3Url?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.TranscriptionJob" */
export enum Video_TranscriptionJob_Constraint {
  /** unique or primary key constraint */
  TranscriptionJobAwsTranscribeJobNameKey = 'TranscriptionJob_awsTranscribeJobName_key',
  /** unique or primary key constraint */
  TranscriptionJobPkey = 'TranscriptionJob_pkey'
}

/** input type for inserting data into table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Insert_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_TranscriptionJob_Max_Fields = {
  readonly __typename?: 'video_TranscriptionJob_max_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Max_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_TranscriptionJob_Min_Fields = {
  readonly __typename?: 'video_TranscriptionJob_min_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Min_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Mutation_Response = {
  readonly __typename?: 'video_TranscriptionJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_TranscriptionJob>;
};

/** input type for inserting object relation for remote table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Obj_Rel_Insert_Input = {
  readonly data: Video_TranscriptionJob_Insert_Input;
  readonly on_conflict?: Maybe<Video_TranscriptionJob_On_Conflict>;
};

/** on conflict condition type for table "video.TranscriptionJob" */
export type Video_TranscriptionJob_On_Conflict = {
  readonly constraint: Video_TranscriptionJob_Constraint;
  readonly update_columns: ReadonlyArray<Video_TranscriptionJob_Update_Column>;
  readonly where?: Maybe<Video_TranscriptionJob_Bool_Exp>;
};

/** ordering options when selecting data from "video.TranscriptionJob" */
export type Video_TranscriptionJob_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.TranscriptionJob" */
export type Video_TranscriptionJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.TranscriptionJob" */
export enum Video_TranscriptionJob_Select_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** input type for updating data in table "video.TranscriptionJob" */
export type Video_TranscriptionJob_Set_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** update columns of table "video.TranscriptionJob" */
export enum Video_TranscriptionJob_Update_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** columns and relationships of "video.VideoRenderJob" */
export type Video_VideoRenderJob = {
  readonly __typename?: 'video_VideoRenderJob';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly conferencePrepareJob: Conference_PrepareJob;
  readonly conferencePrepareJobId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly element?: Maybe<Content_Element>;
  readonly elementId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: Video_JobStatus;
  readonly jobStatusName: Video_JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "video.VideoRenderJob" */
export type Video_VideoRenderJobDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate = {
  readonly __typename?: 'video_VideoRenderJob_aggregate';
  readonly aggregate?: Maybe<Video_VideoRenderJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_VideoRenderJob>;
};

/** aggregate fields of "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate_Fields = {
  readonly __typename?: 'video_VideoRenderJob_aggregate_fields';
  readonly avg?: Maybe<Video_VideoRenderJob_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_VideoRenderJob_Max_Fields>;
  readonly min?: Maybe<Video_VideoRenderJob_Min_Fields>;
  readonly stddev?: Maybe<Video_VideoRenderJob_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Video_VideoRenderJob_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Video_VideoRenderJob_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Video_VideoRenderJob_Sum_Fields>;
  readonly var_pop?: Maybe<Video_VideoRenderJob_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Video_VideoRenderJob_Var_Samp_Fields>;
  readonly variance?: Maybe<Video_VideoRenderJob_Variance_Fields>;
};


/** aggregate fields of "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_VideoRenderJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Aggregate_Order_By = {
  readonly avg?: Maybe<Video_VideoRenderJob_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_VideoRenderJob_Max_Order_By>;
  readonly min?: Maybe<Video_VideoRenderJob_Min_Order_By>;
  readonly stddev?: Maybe<Video_VideoRenderJob_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Video_VideoRenderJob_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Video_VideoRenderJob_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Video_VideoRenderJob_Sum_Order_By>;
  readonly var_pop?: Maybe<Video_VideoRenderJob_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Video_VideoRenderJob_Var_Samp_Order_By>;
  readonly variance?: Maybe<Video_VideoRenderJob_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Video_VideoRenderJob_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_VideoRenderJob_Insert_Input>;
  readonly on_conflict?: Maybe<Video_VideoRenderJob_On_Conflict>;
};

/** aggregate avg on columns */
export type Video_VideoRenderJob_Avg_Fields = {
  readonly __typename?: 'video_VideoRenderJob_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "video.VideoRenderJob". All fields are combined with a logical 'AND'. */
export type Video_VideoRenderJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_VideoRenderJob_Bool_Exp>>>;
  readonly _not?: Maybe<Video_VideoRenderJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_VideoRenderJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly conferencePrepareJob?: Maybe<Conference_PrepareJob_Bool_Exp>;
  readonly conferencePrepareJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<Video_JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.VideoRenderJob" */
export enum Video_VideoRenderJob_Constraint {
  /** unique or primary key constraint */
  VideoRenderJobPkey = 'VideoRenderJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Video_VideoRenderJob_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Video_VideoRenderJob_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Video_VideoRenderJob_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJob?: Maybe<Conference_PrepareJob_Obj_Rel_Insert_Input>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<Video_JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Video_VideoRenderJob_Max_Fields = {
  readonly __typename?: 'video_VideoRenderJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_VideoRenderJob_Min_Fields = {
  readonly __typename?: 'video_VideoRenderJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Mutation_Response = {
  readonly __typename?: 'video_VideoRenderJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_VideoRenderJob>;
};

/** input type for inserting object relation for remote table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Obj_Rel_Insert_Input = {
  readonly data: Video_VideoRenderJob_Insert_Input;
  readonly on_conflict?: Maybe<Video_VideoRenderJob_On_Conflict>;
};

/** on conflict condition type for table "video.VideoRenderJob" */
export type Video_VideoRenderJob_On_Conflict = {
  readonly constraint: Video_VideoRenderJob_Constraint;
  readonly update_columns: ReadonlyArray<Video_VideoRenderJob_Update_Column>;
  readonly where?: Maybe<Video_VideoRenderJob_Bool_Exp>;
};

/** ordering options when selecting data from "video.VideoRenderJob" */
export type Video_VideoRenderJob_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJob?: Maybe<Conference_PrepareJob_Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<Video_JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.VideoRenderJob" */
export type Video_VideoRenderJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Video_VideoRenderJob_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "video.VideoRenderJob" */
export enum Video_VideoRenderJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Video_JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Video_VideoRenderJob_Stddev_Fields = {
  readonly __typename?: 'video_VideoRenderJob_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Video_VideoRenderJob_Stddev_Pop_Fields = {
  readonly __typename?: 'video_VideoRenderJob_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Video_VideoRenderJob_Stddev_Samp_Fields = {
  readonly __typename?: 'video_VideoRenderJob_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Video_VideoRenderJob_Sum_Fields = {
  readonly __typename?: 'video_VideoRenderJob_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "video.VideoRenderJob" */
export enum Video_VideoRenderJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Video_VideoRenderJob_Var_Pop_Fields = {
  readonly __typename?: 'video_VideoRenderJob_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Video_VideoRenderJob_Var_Samp_Fields = {
  readonly __typename?: 'video_VideoRenderJob_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Video_VideoRenderJob_Variance_Fields = {
  readonly __typename?: 'video_VideoRenderJob_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "video.VideoRenderJob" */
export type Video_VideoRenderJob_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** columns and relationships of "video.YouTubeUpload" */
export type Video_YouTubeUpload = {
  readonly __typename?: 'video_YouTubeUpload';
  /** An object relationship */
  readonly conference: Conference_Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly element?: Maybe<Content_Element>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId: Scalars['String'];
  readonly videoPrivacyStatus: Scalars['String'];
  readonly videoStatus: Scalars['String'];
  readonly videoTitle: Scalars['String'];
};

/** aggregated selection of "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate = {
  readonly __typename?: 'video_YouTubeUpload_aggregate';
  readonly aggregate?: Maybe<Video_YouTubeUpload_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Video_YouTubeUpload>;
};

/** aggregate fields of "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate_Fields = {
  readonly __typename?: 'video_YouTubeUpload_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Video_YouTubeUpload_Max_Fields>;
  readonly min?: Maybe<Video_YouTubeUpload_Min_Fields>;
};


/** aggregate fields of "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Video_YouTubeUpload_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Video_YouTubeUpload_Max_Order_By>;
  readonly min?: Maybe<Video_YouTubeUpload_Min_Order_By>;
};

/** input type for inserting array relation for remote table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Video_YouTubeUpload_Insert_Input>;
  readonly on_conflict?: Maybe<Video_YouTubeUpload_On_Conflict>;
};

/** Boolean expression to filter rows from the table "video.YouTubeUpload". All fields are combined with a logical 'AND'. */
export type Video_YouTubeUpload_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Video_YouTubeUpload_Bool_Exp>>>;
  readonly _not?: Maybe<Video_YouTubeUpload_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Video_YouTubeUpload_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly element?: Maybe<Content_Element_Bool_Exp>;
  readonly elementId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadYouTubeVideoJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly videoId?: Maybe<String_Comparison_Exp>;
  readonly videoPrivacyStatus?: Maybe<String_Comparison_Exp>;
  readonly videoStatus?: Maybe<String_Comparison_Exp>;
  readonly videoTitle?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "video.YouTubeUpload" */
export enum Video_YouTubeUpload_Constraint {
  /** unique or primary key constraint */
  YouTubeUploadPkey = 'YouTubeUpload_pkey',
  /** unique or primary key constraint */
  YouTubeUploadVideoIdKey = 'YouTubeUpload_videoId_key'
}

/** input type for inserting data into table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Insert_Input = {
  readonly conference?: Maybe<Conference_Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly element?: Maybe<Content_Element_Obj_Rel_Insert_Input>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Video_YouTubeUpload_Max_Fields = {
  readonly __typename?: 'video_YouTubeUpload_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Video_YouTubeUpload_Min_Fields = {
  readonly __typename?: 'video_YouTubeUpload_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** response of any mutation on the table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Mutation_Response = {
  readonly __typename?: 'video_YouTubeUpload_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Video_YouTubeUpload>;
};

/** input type for inserting object relation for remote table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Obj_Rel_Insert_Input = {
  readonly data: Video_YouTubeUpload_Insert_Input;
  readonly on_conflict?: Maybe<Video_YouTubeUpload_On_Conflict>;
};

/** on conflict condition type for table "video.YouTubeUpload" */
export type Video_YouTubeUpload_On_Conflict = {
  readonly constraint: Video_YouTubeUpload_Constraint;
  readonly update_columns: ReadonlyArray<Video_YouTubeUpload_Update_Column>;
  readonly where?: Maybe<Video_YouTubeUpload_Bool_Exp>;
};

/** ordering options when selecting data from "video.YouTubeUpload" */
export type Video_YouTubeUpload_Order_By = {
  readonly conference?: Maybe<Conference_Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly element?: Maybe<Content_Element_Order_By>;
  readonly elementId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** primary key columns input for table: "video.YouTubeUpload" */
export type Video_YouTubeUpload_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "video.YouTubeUpload" */
export enum Video_YouTubeUpload_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadYouTubeVideoJobId = 'uploadYouTubeVideoJobId',
  /** column name */
  VideoId = 'videoId',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoStatus = 'videoStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** input type for updating data in table "video.YouTubeUpload" */
export type Video_YouTubeUpload_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly elementId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** update columns of table "video.YouTubeUpload" */
export enum Video_YouTubeUpload_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  ElementId = 'elementId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadYouTubeVideoJobId = 'uploadYouTubeVideoJobId',
  /** column name */
  VideoId = 'videoId',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoStatus = 'videoStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

export type ChatState_SubdMessageFragment = { readonly __typename?: 'chat_Message', readonly id: number, readonly chatId: any, readonly message: string, readonly type: Chat_MessageType_Enum, readonly senderId?: Maybe<any> };

export type InitialChatState_ChatFragment = { readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string> }>, readonly nonDMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum }>, readonly DMRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } }> }>, readonly pins: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly registrantId: any, readonly chatId: any, readonly wasManuallyPinned: boolean }>, readonly subscriptions: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly registrantId: any, readonly chatId: any, readonly wasManuallySubscribed: boolean }> };

export type InitialChatStateQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type InitialChatStateQuery = { readonly __typename?: 'query_root', readonly chat_Pin: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly chatId: any, readonly registrantId: any, readonly chat: (
      { readonly __typename?: 'chat_Chat' }
      & InitialChatState_ChatFragment
    ) }> };

export type SelectInitialChatStateQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type SelectInitialChatStateQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<(
    { readonly __typename?: 'chat_Chat' }
    & InitialChatState_ChatFragment
  )> };

export type SelectInitialChatStatesQueryVariables = Exact<{
  chatIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type SelectInitialChatStatesQuery = { readonly __typename?: 'query_root', readonly chat_Chat: ReadonlyArray<(
    { readonly __typename?: 'chat_Chat' }
    & InitialChatState_ChatFragment
  )> };

export type SubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type SubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Subscription?: Maybe<{ readonly __typename?: 'chat_Subscription_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly chatId: any, readonly registrantId: any }> }> };

export type UnsubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type UnsubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Subscription_by_pk?: Maybe<{ readonly __typename?: 'chat_Subscription', readonly registrantId: any, readonly chatId: any }> };

export type PinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type PinChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Pin?: Maybe<{ readonly __typename?: 'chat_Pin_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly chatId: any, readonly registrantId: any }> }> };

export type UnpinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type UnpinChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Pin_by_pk?: Maybe<{ readonly __typename?: 'chat_Pin', readonly registrantId: any, readonly chatId: any }> };

export type ChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly sId: any, readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly duplicateSId?: Maybe<any>, readonly created_at: any, readonly updated_at: any, readonly chatId: any };

export type ChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly id: number, readonly sId: any, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly reactions: ReadonlyArray<(
    { readonly __typename?: 'chat_Reaction' }
    & ChatReactionDataFragment
  )> };

export type SelectMessagesPageQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  startAtIndex: Scalars['Int'];
  maxCount: Scalars['Int'];
}>;


export type SelectMessagesPageQuery = { readonly __typename?: 'query_root', readonly chat_Message: ReadonlyArray<(
    { readonly __typename?: 'chat_Message' }
    & ChatMessageDataFragment
  )> };

export type ShortChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly sId: any };

export type ShortChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly sId: any, readonly duplicateSId?: Maybe<any> };

export type GetChatPathQueryVariables = Exact<{
  chatId: Scalars['uuid'];
}>;


export type GetChatPathQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }>, readonly items: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any }> }> };

export type ConferenceLandingPageItemQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferenceLandingPageItemQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & ItemDataFragment
  )> };

export type ProgramPersonDataFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } };

export type ElementDataFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly typeName: Content_ElementType_Enum };

export type ItemElements_GetItemQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type ItemElements_GetItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & ItemElements_ItemDataFragment
  )> };

export type ItemElements_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string }> }>, readonly elements: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & ElementDataFragment
  )>, readonly itemPeople: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ProgramPersonDataFragment
  )> };

export type ItemRoomEventFragment = { readonly __typename?: 'schedule_Event', readonly startTime: any, readonly exhibitionId?: Maybe<any>, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type ItemList_ProgramPersonDataFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly affiliation?: Maybe<string>, readonly name: string } };

export type ItemList_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeople: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ItemList_ProgramPersonDataFragment
  )> };

export type ItemList_ItemTagDataFragment = { readonly __typename?: 'content_ItemTag', readonly item: (
    { readonly __typename?: 'content_Item' }
    & ItemList_ItemDataFragment
  ) };

export type ItemList_TagInfoFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly colour: string, readonly name: string, readonly priority: number };

export type ContentOfTagQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type ContentOfTagQuery = { readonly __typename?: 'query_root', readonly content_ItemTag: ReadonlyArray<(
    { readonly __typename?: 'content_ItemTag' }
    & ItemList_ItemTagDataFragment
  )> };

export type TagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type TagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<(
    { readonly __typename?: 'collection_Tag' }
    & ItemList_TagInfoFragment
  )> };

export type GetItemQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type GetItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & ItemDataFragment
    & ItemPage_ItemRoomsFragment
  )>, readonly schedule_Event: ReadonlyArray<(
    { readonly __typename?: 'schedule_Event' }
    & ItemEventFragment
  )> };

export type ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly elements: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & ElementDataFragment
  )>, readonly itemPeople: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ProgramPersonDataFragment
  )> };

export type ItemPage_ItemRoomsFragment = { readonly __typename?: 'content_Item', readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type ItemEventFragment = { readonly __typename?: 'schedule_Event', readonly startTime: any, readonly roomId: any, readonly exhibitionId?: Maybe<any>, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly room: { readonly __typename?: 'room_Room', readonly name: string, readonly id: any } };

export type ExhibitionItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly elements: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & ElementDataFragment
  )>, readonly events: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly roomId: any }>, readonly discussionRoom: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type ExhibitionWithContentFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly conferenceId: any, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly layout?: Maybe<any>, readonly priority?: Maybe<number>, readonly item: (
      { readonly __typename?: 'content_Item' }
      & ExhibitionItemFragment
    ) }> };

export type SelectExhibitionQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type SelectExhibitionQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition_by_pk?: Maybe<(
    { readonly __typename?: 'collection_Exhibition' }
    & ExhibitionWithContentFragment
  )> };

export type ExhibitionSummaryFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number };

export type SelectAllExhibitionsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllExhibitionsQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition: ReadonlyArray<(
    { readonly __typename?: 'collection_Exhibition' }
    & ExhibitionSummaryFragment
  )> };

export type RegistrantByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type RegistrantByIdQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantDataFragment
  )> };

export type UpdateProfileMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  profile?: Maybe<Registrant_Profile_Set_Input>;
}>;


export type UpdateProfileMutation = { readonly __typename?: 'mutation_root', readonly update_registrant_Profile_by_pk?: Maybe<(
    { readonly __typename?: 'registrant_Profile' }
    & ProfileDataFragment
  )> };

export type UpdateRegistrantDisplayNameMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type UpdateRegistrantDisplayNameMutation = { readonly __typename?: 'mutation_root', readonly update_registrant_Registrant_by_pk?: Maybe<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantDataFragment
  )> };

export type SubmitProfilePhotoMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  s3URL: Scalars['String'];
}>;


export type SubmitProfilePhotoMutation = { readonly __typename?: 'mutation_root', readonly updateProfilePhoto?: Maybe<{ readonly __typename?: 'UpdateProfilePhotoResponse', readonly ok: boolean, readonly photoURL_350x350?: Maybe<string>, readonly photoURL_50x50?: Maybe<string> }> };

export type MyBackstages_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } };

export type RegistrantEventsWithBackstagesQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type RegistrantEventsWithBackstagesQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<(
    { readonly __typename?: 'schedule_Event' }
    & MyBackstages_EventFragment
  )> };

export type SelectRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantDataFragment
  )> };

export type SearchRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type SearchRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantDataFragment
  )> };

export type GetRoomChimeDataMutationVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomChimeDataMutation = { readonly __typename?: 'mutation_root', readonly joinRoomChimeSession?: Maybe<{ readonly __typename?: 'JoinRoomChimeSessionOutput', readonly registrant?: Maybe<any>, readonly meeting?: Maybe<any>, readonly message?: Maybe<string> }> };

export type GetRoomVonageTokenMutationVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinRoomVonageSession?: Maybe<{ readonly __typename?: 'JoinRoomVonageSessionOutput', readonly accessToken?: Maybe<string>, readonly sessionId?: Maybe<string> }> };

export type Registrant_RegistrantCreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  name: Scalars['String'];
  managementModeName: Room_ManagementMode_Enum;
}>;


export type Registrant_RegistrantCreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_room_Room_one?: Maybe<(
    { readonly __typename?: 'room_Room' }
    & RoomListRoomDetailsFragment
  )> };

export type UpdateEventVonageSessionLayoutMutationVariables = Exact<{
  eventVonageSessionId: Scalars['uuid'];
  layoutData: Scalars['jsonb'];
}>;


export type UpdateEventVonageSessionLayoutMutation = { readonly __typename?: 'mutation_root', readonly update_video_EventVonageSession_by_pk?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly id: any }> };

export type DeleteEventProgramPersonMutationVariables = Exact<{
  eventProgramPersonId: Scalars['uuid'];
}>;


export type DeleteEventProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_EventProgramPerson_by_pk?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any }> };

export type GetEventParticipantStreamsSubscriptionVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventParticipantStreamsSubscription = { readonly __typename?: 'subscription_root', readonly video_EventParticipantStream: ReadonlyArray<(
    { readonly __typename?: 'video_EventParticipantStream' }
    & EventParticipantStreamDetailsFragment
  )> };

export type EventParticipantStreamDetailsFragment = { readonly __typename?: 'video_EventParticipantStream', readonly id: any, readonly conferenceId: any, readonly eventId: any, readonly vonageStreamType: string, readonly vonageStreamId: string, readonly registrantId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } };

export type UnapprovedEventRoomJoinRequestsSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type UnapprovedEventRoomJoinRequestsSubscription = { readonly __typename?: 'subscription_root', readonly schedule_EventRoomJoinRequest: ReadonlyArray<(
    { readonly __typename?: 'schedule_EventRoomJoinRequest' }
    & EventRoomJoinRequestDetailsFragment
  )> };

export type EventRoomJoinRequestDetailsFragment = { readonly __typename?: 'schedule_EventRoomJoinRequest', readonly id: any, readonly registrantId: any };

export type GetEventVonageTokenMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinEventVonageSession?: Maybe<{ readonly __typename?: 'JoinEventVonageSessionOutput', readonly accessToken?: Maybe<string> }> };

export type GetEventDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventDetailsQuery = { readonly __typename?: 'query_root', readonly schedule_Event_by_pk?: Maybe<(
    { readonly __typename?: 'schedule_Event' }
    & RoomEventDetailsFragment
  )> };

export type RoomEventDetailsFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly id: any, readonly sessionId: string }> };

export type ImmediateSwitch_GetElementsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type ImmediateSwitch_GetElementsQuery = { readonly __typename?: 'query_root', readonly schedule_Event_by_pk?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string }> }> }> };

export type ImmediateSwitch_CreateMutationVariables = Exact<{
  data: Scalars['jsonb'];
  eventId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
}>;


export type ImmediateSwitch_CreateMutation = { readonly __typename?: 'mutation_root', readonly insert_video_ImmediateSwitch_one?: Maybe<{ readonly __typename?: 'video_ImmediateSwitch', readonly id: any }> };

export type ApproveEventRoomJoinRequestMutationVariables = Exact<{
  eventRoomJoinRequestId: Scalars['uuid'];
}>;


export type ApproveEventRoomJoinRequestMutation = { readonly __typename?: 'mutation_root', readonly update_schedule_EventRoomJoinRequest_by_pk?: Maybe<{ readonly __typename?: 'schedule_EventRoomJoinRequest', readonly id: any }> };

export type LiveIndicator_GetLatestQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type LiveIndicator_GetLatestQuery = { readonly __typename?: 'query_root', readonly video_ImmediateSwitch: ReadonlyArray<{ readonly __typename?: 'video_ImmediateSwitch', readonly id: any, readonly data: any, readonly executedAt?: Maybe<any> }> };

export type LiveIndicator_GetElementQueryVariables = Exact<{
  elementId: Scalars['uuid'];
}>;


export type LiveIndicator_GetElementQuery = { readonly __typename?: 'query_root', readonly content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }> };

export type GetBreakoutRoomFromEventQueryVariables = Exact<{
  originatingEventId: Scalars['uuid'];
}>;


export type GetBreakoutRoomFromEventQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type MakeEventRoomJoinRequestMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type MakeEventRoomJoinRequestMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_EventRoomJoinRequest_one?: Maybe<{ readonly __typename?: 'schedule_EventRoomJoinRequest', readonly id: any }> };

export type MyEventRoomJoinRequestSubscriptionVariables = Exact<{
  registrantId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type MyEventRoomJoinRequestSubscription = { readonly __typename?: 'subscription_root', readonly schedule_EventRoomJoinRequest: ReadonlyArray<{ readonly __typename?: 'schedule_EventRoomJoinRequest', readonly id: any, readonly approved: boolean }> };

export type Room_GetEventsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
  now: Scalars['timestamptz'];
  cutoff: Scalars['timestamptz'];
}>;


export type Room_GetEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<(
    { readonly __typename?: 'schedule_Event' }
    & Room_EventSummaryFragment
  )> };

export type Room_EventSummaryFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: Room_Mode_Enum, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly typeName: Content_ItemType_Enum, readonly chatId?: Maybe<any>, readonly zoomItems: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any, readonly name: string }>, readonly videoItems: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }> }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> } }> };

export type Room_GetEventBreakoutRoomQueryVariables = Exact<{
  originatingItemId: Scalars['uuid'];
}>;


export type Room_GetEventBreakoutRoomQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type Room_GetDefaultVideoRoomBackendQueryVariables = Exact<{ [key: string]: never; }>;


export type Room_GetDefaultVideoRoomBackendQuery = { readonly __typename?: 'query_root', readonly system_Configuration_by_pk?: Maybe<{ readonly __typename?: 'system_Configuration', readonly value: any }> };

export type AddParticipantToRoomMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  roomId: Scalars['uuid'];
}>;


export type AddParticipantToRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_room_RoomPerson_one?: Maybe<{ readonly __typename?: 'room_RoomPerson', readonly id: any }> };

export type GetAllRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetAllRoomsQuery = { readonly __typename?: 'query_root', readonly socialRooms: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & RoomListRoomDetailsFragment
  )>, readonly programRooms: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & RoomListRoomDetailsFragment
  )> };

export type GetAllTodaysRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  todayStart: Scalars['timestamptz'];
  todayEnd: Scalars['timestamptz'];
}>;


export type GetAllTodaysRoomsQuery = { readonly __typename?: 'query_root', readonly socialOrDiscussionRooms: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & RoomListRoomDetailsFragment
  )>, readonly programRooms: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & RoomListRoomDetailsFragment
  )> };

export type RoomListRoomDetailsFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingEventId?: Maybe<any>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> }> };

export type RoomPage_GetRoomDetailsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type RoomPage_GetRoomDetailsQuery = { readonly __typename?: 'query_root', readonly room_Room_by_pk?: Maybe<(
    { readonly __typename?: 'room_Room' }
    & RoomPage_RoomDetailsFragment
  )> };

export type RoomPage_RoomDetailsFragment = (
  { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly publicVonageSessionId?: Maybe<string>, readonly chatId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly backendName?: Maybe<Room_Backend_Enum>, readonly channelStack?: Maybe<{ readonly __typename?: 'video_ChannelStack', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }>, readonly originatingItem?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }> }>, readonly shuffleRooms: ReadonlyArray<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly durationMinutes: number, readonly reshuffleUponEnd: boolean }> }
  & RoomPage_RoomPeopleFragment
);

export type RoomPage_RoomPeopleFragment = { readonly __typename?: 'room_Room', readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'room_RoomPerson', readonly id: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrantId: any }> };

export type GetEventVonageDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageDetailsQuery = { readonly __typename?: 'query_root', readonly schedule_Event_by_pk?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'video_EventVonageSession', readonly sessionId: string, readonly id: any }> }> };

export type RoomSponsorContent_GetElementsQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type RoomSponsorContent_GetElementsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & RoomSponsorContent_ItemDataFragment
  )> };

export type RoomSponsorContent_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly elements: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & RoomSponsorContent_ElementDataFragment
  )> };

export type RoomSponsorContent_ElementDataFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any> };

export type Schedule_TagFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number };

export type Schedule_EventTagFragment = { readonly __typename?: 'schedule_EventTag', readonly id: any, readonly tag: (
    { readonly __typename?: 'collection_Tag' }
    & Schedule_TagFragment
  ) };

export type Schedule_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any };

export type Schedule_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any> };

export type Schedule_ItemPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: (
    { readonly __typename?: 'collection_ProgramPerson' }
    & Schedule_ProgramPersonFragment
  ) };

export type Schedule_ItemElementsFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum };

export type Schedule_ItemFragment = (
  { readonly __typename?: 'content_Item', readonly abstractElements: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & Schedule_ElementFragment
  )>, readonly itemPeople: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & Schedule_ItemPersonFragment
  )> }
  & Schedule_ItemElementsFragment
);

export type Schedule_SelectItemQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type Schedule_SelectItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & Schedule_ItemFragment
  )> };

export type Schedule_EventSummaryFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly shufflePeriodId?: Maybe<any> };

export type Schedule_RoomSummaryFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly priority: number, readonly managementModeName: Room_ManagementMode_Enum };

export type Schedule_SelectSummariesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type Schedule_SelectSummariesQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & Schedule_RoomSummaryFragment
  )>, readonly schedule_Event: ReadonlyArray<(
    { readonly __typename?: 'schedule_Event' }
    & Schedule_EventSummaryFragment
  )>, readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & Schedule_ItemElementsFragment
  )> };

export type GetChannelStacksQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetChannelStacksQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly name: string, readonly id: any, readonly channelStack?: Maybe<{ readonly __typename?: 'video_ChannelStack', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }> }> };

export type ConferenceConfiguration_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferenceConfiguration_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<(
    { readonly __typename?: 'conference_Configuration' }
    & ConferenceConfiguration_ConferenceConfigurationsFragment
  )> };

export type ConferenceConfiguration_ConferenceConfigurationsFragment = { readonly __typename?: 'conference_Configuration', readonly id: any, readonly key: string, readonly value: any };

export type Conference_Configuration_UpdateConferenceConfigurationsMutationVariables = Exact<{
  conferenceConfigurationId: Scalars['uuid'];
  value: Scalars['jsonb'];
}>;


export type Conference_Configuration_UpdateConferenceConfigurationsMutation = { readonly __typename?: 'mutation_root', readonly update_conference_Configuration_by_pk?: Maybe<{ readonly __typename?: 'conference_Configuration', readonly id: any }> };

export type EventVonageControls_GetEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type EventVonageControls_GetEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }> };

export type EventVonageControls_StopEventBroadcastMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type EventVonageControls_StopEventBroadcastMutation = { readonly __typename?: 'mutation_root', readonly stopEventBroadcast?: Maybe<{ readonly __typename?: 'StopEventBroadcastOutput', readonly broadcastsStopped: number }> };

export type CreateConferencePrepareJobMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateConferencePrepareJobMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_PrepareJob_one?: Maybe<{ readonly __typename?: 'conference_PrepareJob', readonly id: any, readonly conferenceId: any }> };

export type ConferencePrepareJobSubscriptionSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferencePrepareJobSubscriptionSubscription = { readonly __typename?: 'subscription_root', readonly conference_PrepareJob: ReadonlyArray<{ readonly __typename?: 'conference_PrepareJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly message?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly videoRenderJobs: ReadonlyArray<{ readonly __typename?: 'video_VideoRenderJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly updated_at: any, readonly created_at: any }> }> };

export type PreshowChecklistQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type PreshowChecklistQuery = { readonly __typename?: 'query_root', readonly requiredProgramPeopleNotLinkedToRegistrant: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string> }>, readonly requiredProgramPeopleNotRegistered: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string> }>, readonly submissionsNotReceived: ReadonlyArray<{ readonly __typename?: 'content_UploadableElement', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }>, readonly livestreamEventsWithoutRegisteredPresenter: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly livestreamEventsWithoutRegisteredChair: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly prerecordedEventsWithoutVideo: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly prerecordedEventsWithVideo: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly data: any }> }> }>, readonly allLiveEventsWithPeople: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly intendedRoomModeName: Room_Mode_Enum, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly itemPeopleWithRegistrant: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly personId: any }>, readonly itemPeopleWithoutRegistrant: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly personId: any }> }>, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly personId: any }> }>, readonly emptyExhibitions: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string }>, readonly emptyTags: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string }>, readonly exhibitionEventsWithoutExhibition: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }>, readonly exhibitionEventsWithoutDiscussionRooms: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition', readonly id: any, readonly name: string, readonly items: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> }> }>, readonly liveEventsWithoutContent: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }>, readonly overlappingEvents: ReadonlyArray<{ readonly __typename?: 'schedule_OverlappingEvents', readonly eventX?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string } }>, readonly eventY?: Maybe<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any> }> }>, readonly shortEvents: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly endTime?: Maybe<any>, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }>, readonly roomsWithStreams: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly name: string, readonly livestreamDuration?: Maybe<{ readonly __typename?: 'room_LivestreamDurations', readonly sum?: Maybe<any> }> }>, readonly eventsWithNegativeDuration: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> }> };

export type CombineVideosModal_CreateCombineVideosJobMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  createdByRegistrantId: Scalars['uuid'];
  outputName: Scalars['String'];
  data: Scalars['jsonb'];
}>;


export type CombineVideosModal_CreateCombineVideosJobMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_CombineVideosJob_one?: Maybe<{ readonly __typename?: 'job_queues_CombineVideosJob', readonly id: any }> };

export type CombineVideosModal_GetCombineVideosJobQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type CombineVideosModal_GetCombineVideosJobQuery = { readonly __typename?: 'query_root', readonly job_queues_CombineVideosJob_by_pk?: Maybe<{ readonly __typename?: 'job_queues_CombineVideosJob', readonly id: any, readonly message?: Maybe<string>, readonly jobStatusName: Video_JobStatus_Enum }> };

export type Item_CreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  itemId: Scalars['uuid'];
}>;


export type Item_CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly createItemRoom?: Maybe<{ readonly __typename?: 'CreateItemRoomOutput', readonly roomId?: Maybe<string>, readonly message?: Maybe<string> }> };

export type SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SubmissionRequestsModal_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<(
    { readonly __typename?: 'conference_Configuration' }
    & ConfigureEmailTemplates_ConferenceConfigurationFragment
  )> };

export type SubmissionRequestsModal_ConferenceConfigurationFragment = { readonly __typename?: 'conference_Configuration', readonly id: any, readonly conferenceId: any, readonly key: string, readonly value: any };

export type InsertSubmissionRequestEmailJobsMutationVariables = Exact<{
  objs: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input> | Job_Queues_SubmissionRequestEmailJob_Insert_Input;
}>;


export type InsertSubmissionRequestEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<{ readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response', readonly affected_rows: number }> };

export type UploaderInfoFragment = { readonly __typename?: 'content_Uploader', readonly id: any, readonly conferenceId: any, readonly email: string, readonly emailsSentCount: number, readonly name: string, readonly uploadableElementId: any };

export type UploadableElementInfoFragment = { readonly __typename?: 'content_UploadableElement', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly typeName: Content_ElementType_Enum, readonly conferenceId: any, readonly itemId: any, readonly uploadsRemaining?: Maybe<number>, readonly originatingDataId?: Maybe<any>, readonly uploaders: ReadonlyArray<(
    { readonly __typename?: 'content_Uploader' }
    & UploaderInfoFragment
  )> };

export type ElementInfoFragment = { readonly __typename?: 'content_Element', readonly conferenceId: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly uploadableId?: Maybe<any>, readonly originatingDataId?: Maybe<any> };

export type OriginatingDataInfoFragment = { readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> };

export type ProgramPersonInfoFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly conferenceId: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any> };

export type ItemTagInfoFragment = { readonly __typename?: 'content_ItemTag', readonly id: any, readonly tagId: any, readonly itemId: any };

export type ItemExhibitionInfoFragment = { readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly itemId: any, readonly exhibitionId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> };

export type ItemPersonInfoFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly conferenceId: any, readonly itemId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string };

export type ItemFullNestedInfoFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly typeName: Content_ItemType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly uploadableElements: ReadonlyArray<(
    { readonly __typename?: 'content_UploadableElement' }
    & UploadableElementInfoFragment
  )>, readonly elements: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & ElementInfoFragment
  )>, readonly itemTags: ReadonlyArray<(
    { readonly __typename?: 'content_ItemTag' }
    & ItemTagInfoFragment
  )>, readonly itemExhibitions: ReadonlyArray<(
    { readonly __typename?: 'content_ItemExhibition' }
    & ItemExhibitionInfoFragment
  )>, readonly itemPeople: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ItemPersonInfoFragment
  )>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type TagInfoFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly priority: number };

export type ExhibitionInfoFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number };

export type SelectAllContentQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllContentQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & ItemFullNestedInfoFragment
  )>, readonly collection_ProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & ProgramPersonInfoFragment
  )>, readonly conference_OriginatingData: ReadonlyArray<(
    { readonly __typename?: 'conference_OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly collection_Tag: ReadonlyArray<(
    { readonly __typename?: 'collection_Tag' }
    & TagInfoFragment
  )>, readonly collection_Exhibition: ReadonlyArray<(
    { readonly __typename?: 'collection_Exhibition' }
    & ExhibitionInfoFragment
  )> };

export type InsertDeleteItemsMutationVariables = Exact<{
  newGroups: ReadonlyArray<Content_Item_Insert_Input> | Content_Item_Insert_Input;
  deleteGroupIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type InsertDeleteItemsMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_Item' }
      & ItemFullNestedInfoFragment
    )> }>, readonly delete_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any }> }> };

export type InsertOriginatingDatasMutationVariables = Exact<{
  newDatas: ReadonlyArray<Conference_OriginatingData_Insert_Input> | Conference_OriginatingData_Insert_Input;
}>;


export type InsertOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_OriginatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'conference_OriginatingData' }
      & OriginatingDataInfoFragment
    )> }> };

export type DeleteOriginatingDatasMutationVariables = Exact<{
  deleteDataIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly delete_conference_OriginatingData?: Maybe<{ readonly __typename?: 'conference_OriginatingData_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'conference_OriginatingData', readonly id: any }> }> };

export type InsertTagsMutationVariables = Exact<{
  newTags: ReadonlyArray<Collection_Tag_Insert_Input> | Collection_Tag_Insert_Input;
}>;


export type InsertTagsMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Tag?: Maybe<{ readonly __typename?: 'collection_Tag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'collection_Tag' }
      & TagInfoFragment
    )> }> };

export type InsertExhibitionsMutationVariables = Exact<{
  newExhibitions: ReadonlyArray<Collection_Exhibition_Insert_Input> | Collection_Exhibition_Insert_Input;
}>;


export type InsertExhibitionsMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'collection_Exhibition' }
      & ExhibitionInfoFragment
    )> }> };

export type DeleteTagsMutationVariables = Exact<{
  deleteTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteTagsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Tag?: Maybe<{ readonly __typename?: 'collection_Tag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any }> }> };

export type DeleteExhibitionsMutationVariables = Exact<{
  deleteExhibitionIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteExhibitionsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any }> }> };

export type InsertProgramPeopleMutationVariables = Exact<{
  newPeople: ReadonlyArray<Collection_ProgramPerson_Insert_Input> | Collection_ProgramPerson_Insert_Input;
}>;


export type InsertProgramPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_ProgramPerson?: Maybe<{ readonly __typename?: 'collection_ProgramPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'collection_ProgramPerson' }
      & ProgramPersonInfoFragment
    )> }> };

export type DeleteProgramPeopleMutationVariables = Exact<{
  deletePersonIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteProgramPeopleMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_ProgramPerson?: Maybe<{ readonly __typename?: 'collection_ProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any }> }> };

export type UpdateItemMutationVariables = Exact<{
  newItems: ReadonlyArray<Content_Element_Insert_Input> | Content_Element_Insert_Input;
  newUploadableItems: ReadonlyArray<Content_UploadableElement_Insert_Input> | Content_UploadableElement_Insert_Input;
  newGroupTags: ReadonlyArray<Content_ItemTag_Insert_Input> | Content_ItemTag_Insert_Input;
  newGroupExhibitions: ReadonlyArray<Content_ItemExhibition_Insert_Input> | Content_ItemExhibition_Insert_Input;
  groupId: Scalars['uuid'];
  typeName: Content_ItemType_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  shortTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  deleteItemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteUploadableItemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteGroupTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteGroupExhibitionIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  newUploaders: ReadonlyArray<Content_Uploader_Insert_Input> | Content_Uploader_Insert_Input;
  deleteUploaderIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  newGroupPeople: ReadonlyArray<Content_ItemProgramPerson_Insert_Input> | Content_ItemProgramPerson_Insert_Input;
  deleteGroupPeopleIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UpdateItemMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_Element' }
      & ElementInfoFragment
    )> }>, readonly insert_content_UploadableElement?: Maybe<{ readonly __typename?: 'content_UploadableElement_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_UploadableElement' }
      & UploadableElementInfoFragment
    )> }>, readonly insert_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_ItemTag' }
      & ItemTagInfoFragment
    )> }>, readonly insert_content_ItemExhibition?: Maybe<{ readonly __typename?: 'content_ItemExhibition_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_ItemExhibition' }
      & ItemExhibitionInfoFragment
    )> }>, readonly insert_content_Uploader?: Maybe<{ readonly __typename?: 'content_Uploader_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_Uploader' }
      & UploaderInfoFragment
    )> }>, readonly insert_content_ItemProgramPerson?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_ItemProgramPerson' }
      & ItemPersonInfoFragment
    )> }>, readonly update_content_Item_by_pk?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & ItemFullNestedInfoFragment
  )>, readonly delete_content_Element?: Maybe<{ readonly __typename?: 'content_Element_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any }> }>, readonly delete_content_UploadableElement?: Maybe<{ readonly __typename?: 'content_UploadableElement_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_UploadableElement', readonly id: any }> }>, readonly delete_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any }> }>, readonly delete_content_ItemExhibition?: Maybe<{ readonly __typename?: 'content_ItemExhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemExhibition', readonly id: any }> }>, readonly delete_content_Uploader?: Maybe<{ readonly __typename?: 'content_Uploader_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Uploader', readonly id: any }> }>, readonly delete_content_ItemProgramPerson?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any }> }> };

export type UpdateElementMutationVariables = Exact<{
  id: Scalars['uuid'];
  typeName: Content_ElementType_Enum;
  layoutData?: Maybe<Scalars['jsonb']>;
  name: Scalars['String'];
  data: Scalars['jsonb'];
  isHidden: Scalars['Boolean'];
  originatingDataId?: Maybe<Scalars['uuid']>;
  uploadableId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateElementMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element_by_pk?: Maybe<(
    { readonly __typename?: 'content_Element' }
    & ElementInfoFragment
  )> };

export type UpdateUploadableElementMutationVariables = Exact<{
  id: Scalars['uuid'];
  typeName: Content_ElementType_Enum;
  name: Scalars['String'];
  isHidden: Scalars['Boolean'];
  uploadsRemaining?: Maybe<Scalars['Int']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateUploadableElementMutation = { readonly __typename?: 'mutation_root', readonly update_content_UploadableElement_by_pk?: Maybe<(
    { readonly __typename?: 'content_UploadableElement' }
    & UploadableElementInfoFragment
  )> };

export type UpdateUploaderMutationVariables = Exact<{
  id: Scalars['uuid'];
  email: Scalars['String'];
  name: Scalars['String'];
}>;


export type UpdateUploaderMutation = { readonly __typename?: 'mutation_root', readonly update_content_Uploader_by_pk?: Maybe<(
    { readonly __typename?: 'content_Uploader' }
    & UploaderInfoFragment
  )> };

export type UpdateGroupPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  roleName: Scalars['String'];
  priority?: Maybe<Scalars['Int']>;
}>;


export type UpdateGroupPersonMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemProgramPerson_by_pk?: Maybe<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ItemPersonInfoFragment
  )> };

export type UpdateGroupExhibitionMutationVariables = Exact<{
  id: Scalars['uuid'];
  priority?: Maybe<Scalars['Int']>;
  layout?: Maybe<Scalars['jsonb']>;
}>;


export type UpdateGroupExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemExhibition_by_pk?: Maybe<(
    { readonly __typename?: 'content_ItemExhibition' }
    & ItemExhibitionInfoFragment
  )> };

export type UpdatePersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
  registrantId?: Maybe<Scalars['uuid']>;
}>;


export type UpdatePersonMutation = { readonly __typename?: 'mutation_root', readonly update_collection_ProgramPerson_by_pk?: Maybe<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & ProgramPersonInfoFragment
  )> };

export type UpdateTagMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  originatingDataId?: Maybe<Scalars['uuid']>;
  priority?: Scalars['Int'];
}>;


export type UpdateTagMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Tag_by_pk?: Maybe<(
    { readonly __typename?: 'collection_Tag' }
    & TagInfoFragment
  )> };

export type UpdateExhibitionMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  priority: Scalars['Int'];
}>;


export type UpdateExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Exhibition_by_pk?: Maybe<(
    { readonly __typename?: 'collection_Exhibition' }
    & ExhibitionInfoFragment
  )> };

export type SEoUm_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly itemId: any, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } };

export type SEoUm_UploadableFragment = { readonly __typename?: 'content_UploadableElement', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly hasBeenUploaded?: Maybe<boolean>, readonly itemId: any, readonly itemTitle?: Maybe<string>, readonly uploaders: ReadonlyArray<{ readonly __typename?: 'content_Uploader', readonly id: any }>, readonly element?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any }> };

export type SEoUm_InfosQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type SEoUm_InfosQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & SEoUm_ElementFragment
  )>, readonly content_UploadableElement: ReadonlyArray<(
    { readonly __typename?: 'content_UploadableElement' }
    & SEoUm_UploadableFragment
  )> };

export type ManageContent_DeleteElementMutationVariables = Exact<{
  elementId: Scalars['uuid'];
}>;


export type ManageContent_DeleteElementMutation = { readonly __typename?: 'mutation_root', readonly delete_content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any }> };

export type ManageContent_UpdateElementMutationVariables = Exact<{
  elementId: Scalars['uuid'];
  element: Content_Element_Set_Input;
}>;


export type ManageContent_UpdateElementMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element_by_pk?: Maybe<(
    { readonly __typename?: 'content_Element' }
    & ManageContent_ElementFragment
  )> };

export type ManageContent_DeleteUploadableElementMutationVariables = Exact<{
  uploadableElementId: Scalars['uuid'];
}>;


export type ManageContent_DeleteUploadableElementMutation = { readonly __typename?: 'mutation_root', readonly delete_content_UploadableElement_by_pk?: Maybe<{ readonly __typename?: 'content_UploadableElement', readonly id: any }> };

export type ManageContent_UpdateUploadableElementMutationVariables = Exact<{
  uploadableElementId: Scalars['uuid'];
  uploadableElement: Content_UploadableElement_Set_Input;
}>;


export type ManageContent_UpdateUploadableElementMutation = { readonly __typename?: 'mutation_root', readonly update_content_UploadableElement_by_pk?: Maybe<(
    { readonly __typename?: 'content_UploadableElement' }
    & ManageContent_UploadableElementFragment
  )> };

export type ManageContent_UploaderFragment = { readonly __typename?: 'content_Uploader', readonly id: any, readonly uploadableElementId: any, readonly email: string, readonly name: string, readonly emailsSentCount: number, readonly conferenceId: any };

export type ManageContent_SelectUploadersQueryVariables = Exact<{
  uploadableElementId: Scalars['uuid'];
}>;


export type ManageContent_SelectUploadersQuery = { readonly __typename?: 'query_root', readonly content_Uploader: ReadonlyArray<(
    { readonly __typename?: 'content_Uploader' }
    & ManageContent_UploaderFragment
  )> };

export type ManageContent_InsertUploadersMutationVariables = Exact<{
  objects: ReadonlyArray<Content_Uploader_Insert_Input> | Content_Uploader_Insert_Input;
}>;


export type ManageContent_InsertUploadersMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Uploader?: Maybe<{ readonly __typename?: 'content_Uploader_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_Uploader' }
      & ManageContent_UploaderFragment
    )> }> };

export type ManageContent_UpdateUploaderMutationVariables = Exact<{
  id: Scalars['uuid'];
  update: Content_Uploader_Set_Input;
}>;


export type ManageContent_UpdateUploaderMutation = { readonly __typename?: 'mutation_root', readonly update_content_Uploader_by_pk?: Maybe<(
    { readonly __typename?: 'content_Uploader' }
    & ManageContent_UploaderFragment
  )> };

export type ManageContent_DeleteUploadersMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_DeleteUploadersMutation = { readonly __typename?: 'mutation_root', readonly delete_content_Uploader?: Maybe<{ readonly __typename?: 'content_Uploader_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Uploader', readonly id: any }> }> };

export type ManageContent_SelectItemExhibitionsQueryVariables = Exact<{
  exhibitionId: Scalars['uuid'];
}>;


export type ManageContent_SelectItemExhibitionsQuery = { readonly __typename?: 'query_root', readonly content_ItemExhibition: ReadonlyArray<(
    { readonly __typename?: 'content_ItemExhibition' }
    & ManageContent_ItemExhibitionFragment
  )> };

export type ManageContent_InsertItemExhibitionMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  exhibitionId: Scalars['uuid'];
  itemId: Scalars['uuid'];
  priority: Scalars['Int'];
}>;


export type ManageContent_InsertItemExhibitionMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ItemExhibition_one?: Maybe<(
    { readonly __typename?: 'content_ItemExhibition' }
    & ManageContent_ItemExhibitionFragment
  )> };

export type ManageContent_UpdateItemExhibitionMutationVariables = Exact<{
  itemExhibitionId: Scalars['uuid'];
  priority: Scalars['Int'];
}>;


export type ManageContent_UpdateItemExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemExhibition_by_pk?: Maybe<(
    { readonly __typename?: 'content_ItemExhibition' }
    & ManageContent_ItemExhibitionFragment
  )> };

export type ManageContent_DeleteItemExhibitionMutationVariables = Exact<{
  itemExhibitionId: Scalars['uuid'];
}>;


export type ManageContent_DeleteItemExhibitionMutation = { readonly __typename?: 'mutation_root', readonly delete_content_ItemExhibition_by_pk?: Maybe<{ readonly __typename?: 'content_ItemExhibition', readonly id: any }> };

export type ManageContent_InsertExhibitionMutationVariables = Exact<{
  exhibition: Collection_Exhibition_Insert_Input;
}>;


export type ManageContent_InsertExhibitionMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Exhibition_one?: Maybe<(
    { readonly __typename?: 'collection_Exhibition' }
    & ManageContent_ExhibitionFragment
  )> };

export type ManageContent_UpdateExhibitionMutationVariables = Exact<{
  id: Scalars['uuid'];
  update: Collection_Exhibition_Set_Input;
}>;


export type ManageContent_UpdateExhibitionMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Exhibition_by_pk?: Maybe<(
    { readonly __typename?: 'collection_Exhibition' }
    & ManageContent_ExhibitionFragment
  )> };

export type ManageContent_DeleteExhibitionsMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_DeleteExhibitionsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Exhibition?: Maybe<{ readonly __typename?: 'collection_Exhibition_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Exhibition', readonly id: any }> }> };

export type AddContentMenu_CreateElementMutationVariables = Exact<{
  object: Content_Element_Insert_Input;
}>;


export type AddContentMenu_CreateElementMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Element_one?: Maybe<(
    { readonly __typename?: 'content_Element' }
    & ManageContent_ElementFragment
  )> };

export type AddContentMenu_CreateUploadableElementMutationVariables = Exact<{
  object: Content_UploadableElement_Insert_Input;
}>;


export type AddContentMenu_CreateUploadableElementMutation = { readonly __typename?: 'mutation_root', readonly insert_content_UploadableElement_one?: Maybe<(
    { readonly __typename?: 'content_UploadableElement' }
    & ManageContent_UploadableElementFragment
  )> };

export type ManageContent_SelectProgramPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectProgramPeopleQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & ManageContent_ProgramPersonFragment
  )> };

export type ManageContent_InsertItemProgramPersonMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  personId: Scalars['uuid'];
  roleName: Scalars['String'];
  priority: Scalars['Int'];
  itemId: Scalars['uuid'];
}>;


export type ManageContent_InsertItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ItemProgramPerson_one?: Maybe<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ManageContent_ItemProgramPersonFragment
  )> };

export type ManageContent_UpdateItemProgramPersonMutationVariables = Exact<{
  itemPersonId: Scalars['uuid'];
  priority: Scalars['Int'];
  roleName: Scalars['String'];
}>;


export type ManageContent_UpdateItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly update_content_ItemProgramPerson_by_pk?: Maybe<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ManageContent_ItemProgramPersonFragment
  )> };

export type ManageContent_DeleteItemProgramPersonMutationVariables = Exact<{
  itemPersonId: Scalars['uuid'];
}>;


export type ManageContent_DeleteItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly delete_content_ItemProgramPerson_by_pk?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any }> };

export type ManageContent_InsertTagMutationVariables = Exact<{
  tag: Collection_Tag_Insert_Input;
}>;


export type ManageContent_InsertTagMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_Tag_one?: Maybe<(
    { readonly __typename?: 'collection_Tag' }
    & ManageContent_TagFragment
  )> };

export type ManageContent_UpdateTagMutationVariables = Exact<{
  id: Scalars['uuid'];
  update: Collection_Tag_Set_Input;
}>;


export type ManageContent_UpdateTagMutation = { readonly __typename?: 'mutation_root', readonly update_collection_Tag_by_pk?: Maybe<(
    { readonly __typename?: 'collection_Tag' }
    & ManageContent_TagFragment
  )> };

export type ManageContent_DeleteTagsMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_DeleteTagsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_Tag?: Maybe<{ readonly __typename?: 'collection_Tag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any }> }> };

export type ElementSecurity_ElementPgFragment = { readonly __typename?: 'content_ElementPermissionGrant', readonly id: any, readonly permissionSetId: any, readonly conferenceSlug: string, readonly groupId?: Maybe<any>, readonly entityId?: Maybe<any> };

export type ElementSecurity_UploadablePgFragment = { readonly __typename?: 'content_UploadableElementPermissionGrant', readonly id: any, readonly permissionSetId: any, readonly conferenceSlug: string, readonly groupId?: Maybe<any>, readonly entityId?: Maybe<any>, readonly entity?: Maybe<{ readonly __typename?: 'content_UploadableElement', readonly id: any, readonly element?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly permissionGrants: ReadonlyArray<(
        { readonly __typename?: 'content_ElementPermissionGrant' }
        & ElementSecurity_ElementPgFragment
      )> }> }> };

export type ElementSecurity_PermissionSetFragment = { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string };

export type ElementSecurity_GroupFragment = { readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string, readonly enabled: boolean, readonly includeUnauthenticated: boolean };

export type ElementSecurity_SelectGrantsQueryVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  uploadableIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  conferenceId: Scalars['uuid'];
}>;


export type ElementSecurity_SelectGrantsQuery = { readonly __typename?: 'query_root', readonly content_ElementPermissionGrant: ReadonlyArray<(
    { readonly __typename?: 'content_ElementPermissionGrant' }
    & ElementSecurity_ElementPgFragment
  )>, readonly content_UploadableElementPermissionGrant: ReadonlyArray<(
    { readonly __typename?: 'content_UploadableElementPermissionGrant' }
    & ElementSecurity_UploadablePgFragment
  )>, readonly permissions_Role: ReadonlyArray<(
    { readonly __typename?: 'permissions_Role' }
    & ElementSecurity_PermissionSetFragment
  )>, readonly permissions_Group: ReadonlyArray<(
    { readonly __typename?: 'permissions_Group' }
    & ElementSecurity_GroupFragment
  )> };

export type ElementSecurity_InsertGrantsMutationVariables = Exact<{
  elementGrants: ReadonlyArray<Content_ElementPermissionGrant_Insert_Input> | Content_ElementPermissionGrant_Insert_Input;
  uploadableGrants: ReadonlyArray<Content_UploadableElementPermissionGrant_Insert_Input> | Content_UploadableElementPermissionGrant_Insert_Input;
}>;


export type ElementSecurity_InsertGrantsMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ElementPermissionGrant?: Maybe<{ readonly __typename?: 'content_ElementPermissionGrant_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_ElementPermissionGrant' }
      & ElementSecurity_ElementPgFragment
    )> }>, readonly insert_content_UploadableElementPermissionGrant?: Maybe<{ readonly __typename?: 'content_UploadableElementPermissionGrant_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_UploadableElementPermissionGrant' }
      & ElementSecurity_UploadablePgFragment
    )> }> };

export type ElementSecurity_DeleteGrantsMutationVariables = Exact<{
  elementGrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  uploadableGrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ElementSecurity_DeleteGrantsMutation = { readonly __typename?: 'mutation_root', readonly delete_content_ElementPermissionGrant?: Maybe<{ readonly __typename?: 'content_ElementPermissionGrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ElementPermissionGrant', readonly id: any }> }>, readonly delete_content_UploadableElementPermissionGrant?: Maybe<{ readonly __typename?: 'content_UploadableElementPermissionGrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_UploadableElementPermissionGrant', readonly id: any }> }> };

export type SubmissionRequestsModalDataQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type SubmissionRequestsModalDataQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<(
    { readonly __typename?: 'conference_Configuration' }
    & ConfigureEmailTemplates_ConferenceConfigurationFragment
  )>, readonly content_UploadableElement: ReadonlyArray<(
    { readonly __typename?: 'content_UploadableElement' }
    & SubmissionRequestsModal_UploadableElementFragment
  )> };

export type SubmissionRequestsModal_UploadableElementFragment = { readonly __typename?: 'content_UploadableElement', readonly id: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly uploadsRemaining?: Maybe<number>, readonly itemTitle?: Maybe<string>, readonly hasBeenUploaded?: Maybe<boolean>, readonly uploaders: ReadonlyArray<{ readonly __typename?: 'content_Uploader', readonly id: any, readonly email: string, readonly name: string }> };

export type SubmissionsReviewModalDataQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type SubmissionsReviewModalDataQuery = { readonly __typename?: 'query_root', readonly content_UploadableElement: ReadonlyArray<(
    { readonly __typename?: 'content_UploadableElement' }
    & SubmissionsReviewModal_UploadableElementFragment
  )> };

export type SubmissionsReviewModal_UploadableElementFragment = { readonly __typename?: 'content_UploadableElement', readonly id: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly uploadsRemaining?: Maybe<number>, readonly itemTitle?: Maybe<string>, readonly hasBeenUploaded?: Maybe<boolean>, readonly uploaders: ReadonlyArray<{ readonly __typename?: 'content_Uploader', readonly id: any, readonly email: string, readonly name: string, readonly emailsSentCount: number }>, readonly element?: Maybe<(
    { readonly __typename?: 'content_Element' }
    & ElementDataFragment
  )> };

export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConfigureEmailTemplates_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<(
    { readonly __typename?: 'conference_Configuration' }
    & ConfigureEmailTemplates_ConferenceConfigurationFragment
  )> };

export type ConfigureEmailTemplates_ConferenceConfigurationFragment = { readonly __typename?: 'conference_Configuration', readonly id: any, readonly conferenceId: any, readonly key: string, readonly value: any };

export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables = Exact<{
  value: Scalars['jsonb'];
  conferenceId: Scalars['uuid'];
  key: Scalars['String'];
}>;


export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_Configuration_one?: Maybe<{ readonly __typename?: 'conference_Configuration', readonly id: any }> };

export type ChooseElementByTagModal_GetTagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ChooseElementByTagModal_GetTagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<{ readonly __typename?: 'collection_Tag', readonly id: any, readonly name: string }> };

export type ChooseElementByTagModal_GetVideoElementsQueryVariables = Exact<{
  tagId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type ChooseElementByTagModal_GetVideoElementsQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type ChooseElementModal_GetItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ChooseElementModal_GetItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type ChooseElementModal_GetVideoElementsQueryVariables = Exact<{
  itemId?: Maybe<Scalars['uuid']>;
}>;


export type ChooseElementModal_GetVideoElementsQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string }> };

export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  scopes: ReadonlyArray<Scalars['String']> | Scalars['String'];
}>;


export type ManageConferenceExportPage_GetGoogleOAuthUrlMutation = { readonly __typename?: 'mutation_root', readonly getGoogleOAuthUrl?: Maybe<{ readonly __typename?: 'GetGoogleOAuthUrlOutput', readonly url: string }> };

export type ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type ManageConferenceExportPage_GetRegistrantGoogleAccountsQuery = { readonly __typename?: 'query_root', readonly registrant_GoogleAccount: ReadonlyArray<(
    { readonly __typename?: 'registrant_GoogleAccount' }
    & ManageConferenceExportPage_RegistrantGoogleAccountFragment
  )> };

export type ManageConferenceExportPage_RegistrantGoogleAccountFragment = { readonly __typename?: 'registrant_GoogleAccount', readonly id: any, readonly googleAccountEmail: string };

export type ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationVariables = Exact<{
  registrantGoogleAccountId: Scalars['uuid'];
}>;


export type ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation = { readonly __typename?: 'mutation_root', readonly delete_registrant_GoogleAccount_by_pk?: Maybe<{ readonly __typename?: 'registrant_GoogleAccount', readonly id: any }> };

export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery = { readonly __typename?: 'query_root', readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<(
    { readonly __typename?: 'job_queues_UploadYouTubeVideoJob' }
    & UploadYouTubeVideos_UploadYouTubeVideoJobFragment
  )> };

export type UploadYouTubeVideos_UploadYouTubeVideoJobFragment = { readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any, readonly jobStatusName: Video_JobStatus_Enum, readonly element: { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } } };

export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables = Exact<{
  registrantId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery = { readonly __typename?: 'query_root', readonly registrant_GoogleAccount: ReadonlyArray<{ readonly __typename?: 'registrant_GoogleAccount', readonly id: any, readonly googleAccountEmail: string, readonly youTubeData?: Maybe<any> }> };

export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables = Exact<{
  objects: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input> | Job_Queues_UploadYouTubeVideoJob_Insert_Input;
}>;


export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_UploadYouTubeVideoJob?: Maybe<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any }> }> };

export type UploadYouTubeVideos_GetElementsQueryVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetElementsQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type UploadYouTubeVideos_GetTemplateDataQueryVariables = Exact<{
  elementIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetTemplateDataQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly shortTitle?: Maybe<string>, readonly title: string, readonly elements: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly youTubeUploads: ReadonlyArray<{ readonly __typename?: 'video_YouTubeUpload', readonly id: any, readonly videoTitle: string, readonly videoId: string }> }>, readonly abstractElements: ReadonlyArray<(
        { readonly __typename?: 'content_Element' }
        & UploadYouTubeVideos_ElementFragment
      )>, readonly paperLinkElements: ReadonlyArray<(
        { readonly __typename?: 'content_Element' }
        & UploadYouTubeVideos_ElementFragment
      )>, readonly paperUrlElements: ReadonlyArray<(
        { readonly __typename?: 'content_Element' }
        & UploadYouTubeVideos_ElementFragment
      )>, readonly authors: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string> } }> } }> };

export type UploadYouTubeVideos_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly data: any };

export type UploadYouTubeVideos_RefreshYouTubeDataMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  registrantGoogleAccountId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_RefreshYouTubeDataMutation = { readonly __typename?: 'mutation_root', readonly refreshYouTubeData?: Maybe<{ readonly __typename?: 'RefreshYouTubeDataOutput', readonly message?: Maybe<string>, readonly success: boolean }> };

export type UploadYouTubeVideos_GetYouTubeUploadsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetYouTubeUploadsQuery = { readonly __typename?: 'query_root', readonly video_YouTubeUpload: ReadonlyArray<(
    { readonly __typename?: 'video_YouTubeUpload' }
    & UploadYouTubeVideos_YouTubeUploadFragment
  )> };

export type UploadYouTubeVideos_YouTubeUploadFragment = { readonly __typename?: 'video_YouTubeUpload', readonly id: any, readonly videoId: string, readonly videoPrivacyStatus: string, readonly videoStatus: string, readonly videoTitle: string, readonly element?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } }> };

export type ImportRegistrantsMutationVariables = Exact<{
  insertRegistrants: ReadonlyArray<Registrant_Registrant_Insert_Input> | Registrant_Registrant_Insert_Input;
  insertInvitations: ReadonlyArray<Registrant_Invitation_Insert_Input> | Registrant_Invitation_Insert_Input;
  insertGroupRegistrants: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input> | Permissions_GroupRegistrant_Insert_Input;
}>;


export type ImportRegistrantsMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant_mutation_response', readonly affected_rows: number }>, readonly insert_registrant_Invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation_mutation_response', readonly affected_rows: number }>, readonly insert_permissions_GroupRegistrant?: Maybe<{ readonly __typename?: 'permissions_GroupRegistrant_mutation_response', readonly affected_rows: number }> };

export type ManageContent_ItemTagFragment = { readonly __typename?: 'content_ItemTag', readonly id: any, readonly itemId: any, readonly tagId: any };

export type ManageContent_ItemExhibitionFragment = { readonly __typename?: 'content_ItemExhibition', readonly id: any, readonly conferenceId: any, readonly exhibitionId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any>, readonly item: { readonly __typename?: 'content_Item', readonly id: any, readonly title: string } };

export type ManageContent_ItemFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly conferenceId: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly typeName: Content_ItemType_Enum, readonly itemTags: ReadonlyArray<(
    { readonly __typename?: 'content_ItemTag' }
    & ManageContent_ItemTagFragment
  )> };

export type ManageContent_OriginatingDataFragment = { readonly __typename?: 'conference_OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> };

export type ManageContent_RoomFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly name: string };

export type ManageContent_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly isHidden: boolean, readonly updatedAt: any };

export type ManageContent_UploadableElementFragment = { readonly __typename?: 'content_UploadableElement', readonly id: any, readonly itemId: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly conferenceId: any, readonly uploadsRemaining?: Maybe<number>, readonly isHidden: boolean, readonly hasBeenUploaded?: Maybe<boolean>, readonly element?: Maybe<(
    { readonly __typename?: 'content_Element' }
    & ManageContent_ElementFragment
  )> };

export type ManageContent_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> };

export type ManageContent_ItemProgramPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: (
    { readonly __typename?: 'collection_ProgramPerson' }
    & ManageContent_ProgramPersonFragment
  ) };

export type ManageContent_ItemSecondaryFragment = { readonly __typename?: 'content_Item', readonly chatId?: Maybe<any>, readonly rooms: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & ManageContent_RoomFragment
  )>, readonly originatingData?: Maybe<(
    { readonly __typename?: 'conference_OriginatingData' }
    & ManageContent_OriginatingDataFragment
  )> };

export type ManageContent_SelectAllItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectAllItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & ManageContent_ItemFragment
  )> };

export type ManageContent_SelectItemQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type ManageContent_SelectItemQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & ManageContent_ItemSecondaryFragment
  )>, readonly content_Element: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & ManageContent_ElementFragment
  )>, readonly content_UploadableElement: ReadonlyArray<(
    { readonly __typename?: 'content_UploadableElement' }
    & ManageContent_UploadableElementFragment
  )> };

export type ManageContent_SelectItemPeopleQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type ManageContent_SelectItemPeopleQuery = { readonly __typename?: 'query_root', readonly content_ItemProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & ManageContent_ItemProgramPersonFragment
  )> };

export type ManageContent_InsertItemMutationVariables = Exact<{
  item: Content_Item_Insert_Input;
  itemTags: ReadonlyArray<Content_ItemTag_Insert_Input> | Content_ItemTag_Insert_Input;
}>;


export type ManageContent_InsertItemMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Item_one?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & ManageContent_ItemFragment
  )>, readonly insert_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any }> }> };

export type ManageContent_UpdateItemMutationVariables = Exact<{
  id: Scalars['uuid'];
  item: Content_Item_Set_Input;
  tags: ReadonlyArray<Content_ItemTag_Insert_Input> | Content_ItemTag_Insert_Input;
  tagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_UpdateItemMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_ItemTag' }
      & ManageContent_ItemTagFragment
    )> }>, readonly delete_content_ItemTag?: Maybe<{ readonly __typename?: 'content_ItemTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_ItemTag', readonly id: any }> }>, readonly update_content_Item_by_pk?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & ManageContent_ItemFragment
  )> };

export type ManageContent_DeleteItemsMutationVariables = Exact<{
  ids: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type ManageContent_DeleteItemsMutation = { readonly __typename?: 'mutation_root', readonly delete_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any }> }> };

export type ManageContent_TagFragment = { readonly __typename?: 'collection_Tag', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number };

export type ManageContent_SelectAllTagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectAllTagsQuery = { readonly __typename?: 'query_root', readonly collection_Tag: ReadonlyArray<(
    { readonly __typename?: 'collection_Tag' }
    & ManageContent_TagFragment
  )> };

export type ManageContent_ExhibitionFragment = { readonly __typename?: 'collection_Exhibition', readonly id: any, readonly conferenceId: any, readonly name: string, readonly colour: string, readonly priority: number };

export type ManageContent_SelectAllExhibitionsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContent_SelectAllExhibitionsQuery = { readonly __typename?: 'query_root', readonly collection_Exhibition: ReadonlyArray<(
    { readonly __typename?: 'collection_Exhibition' }
    & ManageContent_ExhibitionFragment
  )> };

export type ManageGroups_GroupFragment = { readonly __typename?: 'permissions_Group', readonly conferenceId: any, readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any }> };

export type SelectAllGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<(
    { readonly __typename?: 'permissions_Group' }
    & ManageGroups_GroupFragment
  )> };

export type CreateDeleteGroupsMutationVariables = Exact<{
  deleteGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
  insertGroups: ReadonlyArray<Permissions_Group_Insert_Input> | Permissions_Group_Insert_Input;
}>;


export type CreateDeleteGroupsMutation = { readonly __typename?: 'mutation_root', readonly delete_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any }> }>, readonly insert_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly includeUnauthenticated: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }> };

export type UpdateGroupMutationVariables = Exact<{
  groupId: Scalars['uuid'];
  groupName: Scalars['String'];
  enabled: Scalars['Boolean'];
  includeUnauthenticated: Scalars['Boolean'];
  insertRoles: ReadonlyArray<Permissions_GroupRole_Insert_Input> | Permissions_GroupRole_Insert_Input;
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type UpdateGroupMutation = { readonly __typename?: 'mutation_root', readonly update_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }>, readonly insert_permissions_GroupRole?: Maybe<{ readonly __typename?: 'permissions_GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }>, readonly delete_permissions_GroupRole?: Maybe<{ readonly __typename?: 'permissions_GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any }> }> };

export type UpdateConferenceMutationVariables = Exact<{
  id: Scalars['uuid'];
  name?: Maybe<Scalars['String']>;
  shortName?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
}>;


export type UpdateConferenceMutation = { readonly __typename?: 'mutation_root', readonly update_conference_Conference?: Maybe<{ readonly __typename?: 'conference_Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> }> };

export type ManageProgramPeople_RegistrantFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }>, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }> };

export type ManageProgramPeople_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly conferenceId: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly registrantId?: Maybe<any> };

export type ManageProgramPeople_SelectAllPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageProgramPeople_SelectAllPeopleQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & ManageProgramPeople_ProgramPersonFragment
  )> };

export type ManageProgramPeople_SelectAllRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageProgramPeople_SelectAllRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & ManageProgramPeople_RegistrantFragment
  )> };

export type ManageProgramPeople_InsertProgramPersonMutationVariables = Exact<{
  person: Collection_ProgramPerson_Insert_Input;
}>;


export type ManageProgramPeople_InsertProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_ProgramPerson_one?: Maybe<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & ManageProgramPeople_ProgramPersonFragment
  )> };

export type ManageProgramPeople_DeleteProgramPersonsMutationVariables = Exact<{
  ids?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type ManageProgramPeople_DeleteProgramPersonsMutation = { readonly __typename?: 'mutation_root', readonly delete_collection_ProgramPerson?: Maybe<{ readonly __typename?: 'collection_ProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'collection_ProgramPerson', readonly id: any }> }> };

export type ManageProgramPeople_UpdateProgramPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  registrantId?: Maybe<Scalars['uuid']>;
}>;


export type ManageProgramPeople_UpdateProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly update_collection_ProgramPerson_by_pk?: Maybe<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & ManageProgramPeople_ProgramPersonFragment
  )> };

export type InvitationPartsFragment = { readonly __typename?: 'registrant_Invitation', readonly registrantId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> };

export type RegistrantPartsFragment = { readonly __typename?: 'registrant_Registrant', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly registrantId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<(
    { readonly __typename?: 'registrant_Invitation' }
    & InvitationPartsFragment
  )> };

export type SelectAllRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantPartsFragment
  )> };

export type InsertRegistrantMutationVariables = Exact<{
  registrant: Registrant_Registrant_Insert_Input;
  invitation: Registrant_Invitation_Insert_Input;
}>;


export type InsertRegistrantMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant_one?: Maybe<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantPartsFragment
  )>, readonly insert_registrant_Invitation_one?: Maybe<(
    { readonly __typename?: 'registrant_Invitation' }
    & InvitationPartsFragment
  )> };

export type InsertRegistrantWithoutInviteMutationVariables = Exact<{
  registrant: Registrant_Registrant_Insert_Input;
}>;


export type InsertRegistrantWithoutInviteMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant_one?: Maybe<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantPartsFragment
  )> };

export type DeleteRegistrantsMutationVariables = Exact<{
  deleteRegistrantIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type DeleteRegistrantsMutation = { readonly __typename?: 'mutation_root', readonly delete_registrant_Registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'registrant_Registrant', readonly id: any }> }> };

export type UpdateRegistrantMutationVariables = Exact<{
  registrantId: Scalars['uuid'];
  registrantName: Scalars['String'];
  upsertGroups: ReadonlyArray<Permissions_GroupRegistrant_Insert_Input> | Permissions_GroupRegistrant_Insert_Input;
  remainingGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type UpdateRegistrantMutation = { readonly __typename?: 'mutation_root', readonly update_registrant_Registrant_by_pk?: Maybe<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantPartsFragment
  )>, readonly insert_permissions_GroupRegistrant?: Maybe<{ readonly __typename?: 'permissions_GroupRegistrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly registrantId: any, readonly groupId: any }> }>, readonly delete_permissions_GroupRegistrant?: Maybe<{ readonly __typename?: 'permissions_GroupRegistrant_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any }> }> };

export type InsertInvitationEmailJobsMutationVariables = Exact<{
  registrantIds: Scalars['jsonb'];
  conferenceId: Scalars['uuid'];
  sendRepeat: Scalars['Boolean'];
}>;


export type InsertInvitationEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_InvitationEmailJob?: Maybe<{ readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response', readonly affected_rows: number }> };

export type ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables = Exact<{
  htmlBody: Scalars['String'];
  subject: Scalars['String'];
  conferenceId: Scalars['uuid'];
  registrantIds: Scalars['jsonb'];
}>;


export type ManageConferencePeoplePage_InsertCustomEmailJobMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_CustomEmailJob?: Maybe<{ readonly __typename?: 'job_queues_CustomEmailJob_mutation_response', readonly affected_rows: number }> };

export type SelectAllPermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type SelectAllPermissionsQuery = { readonly __typename?: 'query_root', readonly permissions_Permission: ReadonlyArray<{ readonly __typename?: 'permissions_Permission', readonly name: string, readonly description: string }> };

export type SelectAllRolesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRolesQuery = { readonly __typename?: 'query_root', readonly permissions_Role: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly conferenceId: any, readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }> };

export type CreateDeleteRolesMutationVariables = Exact<{
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
  insertRoles: ReadonlyArray<Permissions_Role_Insert_Input> | Permissions_Role_Insert_Input;
}>;


export type CreateDeleteRolesMutation = { readonly __typename?: 'mutation_root', readonly delete_permissions_Role?: Maybe<{ readonly __typename?: 'permissions_Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly id: any }> }>, readonly insert_permissions_Role?: Maybe<{ readonly __typename?: 'permissions_Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly id: any, readonly conferenceId: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }> }> };

export type UpdateRoleMutationVariables = Exact<{
  roleId: Scalars['uuid'];
  roleName: Scalars['String'];
  insertPermissions: ReadonlyArray<Permissions_RolePermission_Insert_Input> | Permissions_RolePermission_Insert_Input;
  deletePermissionNames?: Maybe<ReadonlyArray<Permissions_Permission_Enum> | Permissions_Permission_Enum>;
}>;


export type UpdateRoleMutation = { readonly __typename?: 'mutation_root', readonly update_permissions_Role?: Maybe<{ readonly __typename?: 'permissions_Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }> }>, readonly insert_permissions_RolePermission?: Maybe<{ readonly __typename?: 'permissions_RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum, readonly roleId: any }> }>, readonly delete_permissions_RolePermission?: Maybe<{ readonly __typename?: 'permissions_RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any }> }> };

export type RoomParticipantWithRegistrantInfoFragment = { readonly __typename?: 'room_Participant', readonly id: any, readonly conferenceId: any, readonly registrantId: any, readonly roomId: any, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } };

export type RoomWithParticipantInfoFragment = { readonly __typename?: 'room_Room', readonly id: any, readonly conferenceId: any, readonly name: string, readonly currentModeName: Room_Mode_Enum, readonly capacity?: Maybe<number>, readonly priority: number, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly participants: ReadonlyArray<(
    { readonly __typename?: 'room_Participant' }
    & RoomParticipantWithRegistrantInfoFragment
  )>, readonly originatingData?: Maybe<(
    { readonly __typename?: 'conference_OriginatingData' }
    & OriginatingDataInfoFragment
  )> };

export type SelectAllRoomsWithParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRoomsWithParticipantsQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type ManageRooms_SelectGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageRooms_SelectGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string }> };

export type ManageRooms_SelectItemsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageRooms_SelectItemsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type ManageRooms_SelectGroupRegistrantsQueryVariables = Exact<{
  groupId: Scalars['uuid'];
}>;


export type ManageRooms_SelectGroupRegistrantsQuery = { readonly __typename?: 'query_root', readonly permissions_GroupRegistrant: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly groupId: any, readonly registrantId: any }> };

export type RoomPersonInfoFragment = { readonly __typename?: 'room_RoomPerson', readonly id: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrant: { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string } };

export type ManageRooms_SelectRoomPeopleQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type ManageRooms_SelectRoomPeopleQuery = { readonly __typename?: 'query_root', readonly room_RoomPerson: ReadonlyArray<(
    { readonly __typename?: 'room_RoomPerson' }
    & RoomPersonInfoFragment
  )> };

export type CreateRoomMutationVariables = Exact<{
  room: Room_Room_Insert_Input;
}>;


export type CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_room_Room_one?: Maybe<(
    { readonly __typename?: 'room_Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type UpdateRoomsWithParticipantsMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity?: Maybe<Scalars['Int']>;
  priority: Scalars['Int'];
  managementModeName: Room_ManagementMode_Enum;
  originatingItemId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateRoomsWithParticipantsMutation = { readonly __typename?: 'mutation_root', readonly update_room_Room_by_pk?: Maybe<(
    { readonly __typename?: 'room_Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type InsertRoomPeopleMutationVariables = Exact<{
  people: ReadonlyArray<Room_RoomPerson_Insert_Input> | Room_RoomPerson_Insert_Input;
}>;


export type InsertRoomPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_room_RoomPerson?: Maybe<{ readonly __typename?: 'room_RoomPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'room_RoomPerson' }
      & RoomPersonInfoFragment
    )> }> };

export type InsertEventInfoMutationVariables = Exact<{
  id: Scalars['uuid'];
  roomId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  intendedRoomModeName: Room_Mode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  itemId?: Maybe<Scalars['uuid']>;
  exhibitionId?: Maybe<Scalars['uuid']>;
}>;


export type InsertEventInfoMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_Event_one?: Maybe<(
    { readonly __typename?: 'schedule_Event' }
    & EventInfoFragment
  )> };

export type UpdateEventInfoMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  roomId: Scalars['uuid'];
  intendedRoomModeName: Room_Mode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  itemId?: Maybe<Scalars['uuid']>;
  exhibitionId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateEventInfoMutation = { readonly __typename?: 'mutation_root', readonly update_schedule_Event_by_pk?: Maybe<(
    { readonly __typename?: 'schedule_Event' }
    & EventInfoFragment
  )> };

export type DeleteEventInfosMutationVariables = Exact<{
  eventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventInfosMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_Event?: Maybe<{ readonly __typename?: 'schedule_Event_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any }> }> };

export type ManageShufflePeriods_ShufflePeriodFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetRegistrantsPerRoom: number, readonly maxRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum, readonly completedEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count?: Maybe<number> }> }, readonly ongoingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count?: Maybe<number> }> }, readonly waitingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count?: Maybe<number> }> } };

export type ManageShufflePeriods_SelectAllQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageShufflePeriods_SelectAllQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<(
    { readonly __typename?: 'room_ShufflePeriod' }
    & ManageShufflePeriods_ShufflePeriodFragment
  )> };

export type SendEmail_GetAllGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SendEmail_GetAllGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly enabled: boolean, readonly name: string }> };

export type AddEventPeople_ItemPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly personId: any, readonly roleName: string };

export type AddEventPeople_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly registrantId?: Maybe<any> };

export type AddEventPeople_RegistrantFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }>, readonly invitation?: Maybe<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }> };

export type AddEventPeople_GroupFragment = { readonly __typename?: 'permissions_Group', readonly id: any, readonly name: string };

export type AddEventPeople_SelectItemPeopleQueryVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type AddEventPeople_SelectItemPeopleQuery = { readonly __typename?: 'query_root', readonly content_ItemProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & AddEventPeople_ItemPersonFragment
  )> };

export type AddEventPeople_SelectProgramPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectProgramPeopleQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & AddEventPeople_ProgramPersonFragment
  )> };

export type AddEventPeople_SelectRegistrantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectRegistrantsQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & AddEventPeople_RegistrantFragment
  )> };

export type AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables = Exact<{
  registrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type AddEventPeople_SelectProgramPeople_ByRegistrantQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & AddEventPeople_ProgramPersonFragment
  )> };

export type AddEventPeople_SelectGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectGroupsQuery = { readonly __typename?: 'query_root', readonly permissions_Group: ReadonlyArray<(
    { readonly __typename?: 'permissions_Group' }
    & AddEventPeople_GroupFragment
  )> };

export type AddEventPeople_SelectRegistrants_ByGroupQueryVariables = Exact<{
  groupId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectRegistrants_ByGroupQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & AddEventPeople_RegistrantFragment
  )> };

export type AddEventPeople_InsertProgramPeopleMutationVariables = Exact<{
  objects: ReadonlyArray<Collection_ProgramPerson_Insert_Input> | Collection_ProgramPerson_Insert_Input;
}>;


export type AddEventPeople_InsertProgramPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_collection_ProgramPerson?: Maybe<{ readonly __typename?: 'collection_ProgramPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'collection_ProgramPerson' }
      & AddEventPeople_ProgramPersonFragment
    )> }> };

export type AddEventPeople_InsertEventPeopleMutationVariables = Exact<{
  objects: ReadonlyArray<Schedule_EventProgramPerson_Insert_Input> | Schedule_EventProgramPerson_Insert_Input;
}>;


export type AddEventPeople_InsertEventPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_EventProgramPerson?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'schedule_EventProgramPerson' }
      & EventProgramPersonInfoFragment
    )> }> };

export type InsertEventProgramPersonMutationVariables = Exact<{
  newEventProgramPerson: Schedule_EventProgramPerson_Insert_Input;
}>;


export type InsertEventProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_EventProgramPerson_one?: Maybe<(
    { readonly __typename?: 'schedule_EventProgramPerson' }
    & EventProgramPersonInfoFragment
  )> };

export type DeleteEventProgramPersonsMutationVariables = Exact<{
  deleteEventPeopleIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventProgramPersonsMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_EventProgramPerson?: Maybe<{ readonly __typename?: 'schedule_EventProgramPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_EventProgramPerson', readonly id: any }> }> };

export type UpdateEventProgramPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  personId: Scalars['uuid'];
  roleName: Schedule_EventProgramPersonRole_Enum;
}>;


export type UpdateEventProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly update_schedule_EventProgramPerson_by_pk?: Maybe<(
    { readonly __typename?: 'schedule_EventProgramPerson' }
    & EventProgramPersonInfoFragment
  )> };

export type RoomInfoFragment = { readonly __typename?: 'room_Room', readonly capacity?: Maybe<number>, readonly conferenceId: any, readonly currentModeName: Room_Mode_Enum, readonly id: any, readonly name: string, readonly priority: number, readonly originatingDataId?: Maybe<any>, readonly originatingEventId?: Maybe<any>, readonly originatingItemId?: Maybe<any>, readonly managementModeName: Room_ManagementMode_Enum, readonly originatingData?: Maybe<(
    { readonly __typename?: 'conference_OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly participants: ReadonlyArray<(
    { readonly __typename?: 'room_Participant' }
    & RoomParticipantInfoFragment
  )> };

export type RoomParticipantInfoFragment = { readonly __typename?: 'room_Participant', readonly registrantId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any };

export type EventInfoFragment = { readonly __typename?: 'schedule_Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: Room_Mode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly itemId?: Maybe<any>, readonly exhibitionId?: Maybe<any>, readonly eventPeople: ReadonlyArray<(
    { readonly __typename?: 'schedule_EventProgramPerson' }
    & EventProgramPersonInfoFragment
  )>, readonly eventTags: ReadonlyArray<(
    { readonly __typename?: 'schedule_EventTag' }
    & EventTagInfoFragment
  )> };

export type EventProgramPersonInfoFragment = { readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly eventId: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly personId: any };

export type EventTagInfoFragment = { readonly __typename?: 'schedule_EventTag', readonly eventId: any, readonly id: any, readonly tagId: any };

export type SelectWholeScheduleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectWholeScheduleQuery = { readonly __typename?: 'query_root', readonly room_Room: ReadonlyArray<(
    { readonly __typename?: 'room_Room' }
    & RoomInfoFragment
  )>, readonly schedule_Event: ReadonlyArray<(
    { readonly __typename?: 'schedule_Event' }
    & EventInfoFragment
  )>, readonly conference_OriginatingData: ReadonlyArray<(
    { readonly __typename?: 'conference_OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly collection_Tag: ReadonlyArray<(
    { readonly __typename?: 'collection_Tag' }
    & TagInfoFragment
  )>, readonly collection_Exhibition: ReadonlyArray<(
    { readonly __typename?: 'collection_Exhibition' }
    & ExhibitionInfoFragment
  )>, readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & ItemFullNestedInfoFragment
  )>, readonly collection_ProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & ProgramPersonInfoFragment
  )> };

export type InsertRoomsMutationVariables = Exact<{
  newRooms: ReadonlyArray<Room_Room_Insert_Input> | Room_Room_Insert_Input;
}>;


export type InsertRoomsMutation = { readonly __typename?: 'mutation_root', readonly insert_room_Room?: Maybe<{ readonly __typename?: 'room_Room_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'room_Room' }
      & RoomInfoFragment
    )> }> };

export type DeleteRoomsMutationVariables = Exact<{
  deleteRoomIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteRoomsMutation = { readonly __typename?: 'mutation_root', readonly delete_room_Room?: Maybe<{ readonly __typename?: 'room_Room_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any }> }> };

export type UpdateRoomMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity?: Maybe<Scalars['Int']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
  priority: Scalars['Int'];
}>;


export type UpdateRoomMutation = { readonly __typename?: 'mutation_root', readonly update_room_Room_by_pk?: Maybe<(
    { readonly __typename?: 'room_Room' }
    & RoomInfoFragment
  )> };

export type DeleteEventsMutationVariables = Exact<{
  deleteEventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventsMutation = { readonly __typename?: 'mutation_root', readonly delete_schedule_Event?: Maybe<{ readonly __typename?: 'schedule_Event_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_Event', readonly id: any }> }> };

export type InsertEventMutationVariables = Exact<{
  newEvent: Schedule_Event_Insert_Input;
}>;


export type InsertEventMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_Event_one?: Maybe<(
    { readonly __typename?: 'schedule_Event' }
    & EventInfoFragment
  )> };

export type UpdateEventMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  roomId: Scalars['uuid'];
  intendedRoomModeName: Room_Mode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  itemId?: Maybe<Scalars['uuid']>;
  exhibitionId?: Maybe<Scalars['uuid']>;
  newEventTags: ReadonlyArray<Schedule_EventTag_Insert_Input> | Schedule_EventTag_Insert_Input;
  deleteEventTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UpdateEventMutation = { readonly __typename?: 'mutation_root', readonly insert_schedule_EventTag?: Maybe<{ readonly __typename?: 'schedule_EventTag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'schedule_EventTag' }
      & EventTagInfoFragment
    )> }>, readonly update_schedule_Event_by_pk?: Maybe<(
    { readonly __typename?: 'schedule_Event' }
    & EventInfoFragment
  )>, readonly delete_schedule_EventTag?: Maybe<{ readonly __typename?: 'schedule_EventTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly id: any }> }> };

export type UpdateShufflePeriodMutationVariables = Exact<{
  id: Scalars['uuid'];
  object: Room_ShufflePeriod_Set_Input;
}>;


export type UpdateShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly update_room_ShufflePeriod_by_pk?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetRegistrantsPerRoom: number, readonly maxRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum }> };

export type InsertShufflePeriodMutationVariables = Exact<{
  object: Room_ShufflePeriod_Insert_Input;
}>;


export type InsertShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly insert_room_ShufflePeriod_one?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetRegistrantsPerRoom: number, readonly maxRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum }> };

export type DeleteShufflePeriodMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly delete_room_ShufflePeriod_by_pk?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any }> };

export type AddSponsorContentMenu_CreateElementMutationVariables = Exact<{
  object: Content_Element_Insert_Input;
}>;


export type AddSponsorContentMenu_CreateElementMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Element_one?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any }> };

export type EditableSponsorsTable_GetAllSponsorsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type EditableSponsorsTable_GetAllSponsorsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & EditableSponsorsTable_ItemInfoFragment
  )> };

export type EditableSponsorsTable_InsertSponsorMutationVariables = Exact<{
  item: Content_Item_Insert_Input;
}>;


export type EditableSponsorsTable_InsertSponsorMutation = { readonly __typename?: 'mutation_root', readonly insert_content_Item_one?: Maybe<(
    { readonly __typename?: 'content_Item' }
    & EditableSponsorsTable_ItemInfoFragment
  )> };

export type EditableSponsorsTable_UpdateSponsorMutationVariables = Exact<{
  itemId: Scalars['uuid'];
  object: Content_Item_Set_Input;
}>;


export type EditableSponsorsTable_UpdateSponsorMutation = { readonly __typename?: 'mutation_root', readonly update_content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any }> };

export type EditableSponsorsTable_DeleteSponsorMutationVariables = Exact<{
  itemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type EditableSponsorsTable_DeleteSponsorMutation = { readonly __typename?: 'mutation_root', readonly delete_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'content_Item', readonly id: any }> }> };

export type EditableSponsorsTable_ItemInfoFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly room?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any }> };

export type SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type SponsorSecondaryEditor_GetSponsorSecondaryInfoQuery = { readonly __typename?: 'query_root', readonly content_Element: ReadonlyArray<(
    { readonly __typename?: 'content_Element' }
    & SponsorSecondaryEditor_ElementFragment
  )>, readonly content_ItemProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & SponsorSecondaryEditor_ItemProgramPersonFragment
  )> };

export type SponsorSecondaryEditor_ElementFragment = { readonly __typename?: 'content_Element', readonly id: any, readonly name: string, readonly typeName: Content_ElementType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly isHidden: boolean, readonly updatedAt: any };

export type SponsorSecondaryEditor_ItemProgramPersonFragment = { readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly itemId: any, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string> } };

export type SponsorSecondaryEditor_SelectProgramPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SponsorSecondaryEditor_SelectProgramPeopleQuery = { readonly __typename?: 'query_root', readonly collection_ProgramPerson: ReadonlyArray<(
    { readonly __typename?: 'collection_ProgramPerson' }
    & SponsorSecondaryEditor_ProgramPersonFragment
  )> };

export type SponsorSecondaryEditor_ProgramPersonFragment = { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string> };

export type SponsorSecondaryEditor_InsertItemProgramPersonMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  personId: Scalars['uuid'];
  itemId: Scalars['uuid'];
}>;


export type SponsorSecondaryEditor_InsertItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_content_ItemProgramPerson_one?: Maybe<(
    { readonly __typename?: 'content_ItemProgramPerson' }
    & SponsorSecondaryEditor_ItemProgramPersonFragment
  )> };

export type SponsorSecondaryEditor_DeleteItemProgramPersonMutationVariables = Exact<{
  itemPersonId: Scalars['uuid'];
}>;


export type SponsorSecondaryEditor_DeleteItemProgramPersonMutation = { readonly __typename?: 'mutation_root', readonly delete_content_ItemProgramPerson_by_pk?: Maybe<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any }> };

export type SponsorElement_DeleteElementMutationVariables = Exact<{
  elementId: Scalars['uuid'];
}>;


export type SponsorElement_DeleteElementMutation = { readonly __typename?: 'mutation_root', readonly delete_content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any }> };

export type SponsorElement_SetElementIsHiddenMutationVariables = Exact<{
  elementId: Scalars['uuid'];
  isHidden: Scalars['Boolean'];
}>;


export type SponsorElement_SetElementIsHiddenMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any }> };

export type SponsorElementInner_UpdateElementMutationVariables = Exact<{
  elementId: Scalars['uuid'];
  element: Content_Element_Set_Input;
}>;


export type SponsorElementInner_UpdateElementMutation = { readonly __typename?: 'mutation_root', readonly update_content_Element_by_pk?: Maybe<{ readonly __typename?: 'content_Element', readonly id: any }> };

export type ConferenceTakenQueryVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
}>;


export type ConferenceTakenQuery = { readonly __typename?: 'query_root', readonly conference_Conference: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> };

export type CreateConferenceMutationVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
  demoCode: Scalars['uuid'];
}>;


export type CreateConferenceMutation = { readonly __typename?: 'mutation_root', readonly insert_conference_Conference?: Maybe<{ readonly __typename?: 'conference_Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'conference_Conference', readonly id: any, readonly slug: string }> }>, readonly update_conference_DemoCode?: Maybe<{ readonly __typename?: 'conference_DemoCode_mutation_response', readonly affected_rows: number }> };

export type CreateNewConferenceMetaStructureMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantDisplayName: Scalars['String'];
  userId: Scalars['String'];
  abstractData: Scalars['jsonb'];
  itemListData: Scalars['jsonb'];
}>;


export type CreateNewConferenceMetaStructureMutation = { readonly __typename?: 'mutation_root', readonly insert_registrant_Registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant_mutation_response', readonly affected_rows: number }>, readonly insert_permissions_Group?: Maybe<{ readonly __typename?: 'permissions_Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'permissions_Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly roleId: any, readonly permissionName: Permissions_Permission_Enum }> } }> }> }>, readonly insert_content_Item?: Maybe<{ readonly __typename?: 'content_Item_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'content_Item' }
      & ItemDataFragment
    )> }> };

export type RegistrantsByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  registrantIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type RegistrantsByIdQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantDataFragment
  )> };

export type RegistrantsByUserIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  userIds: ReadonlyArray<Scalars['String']> | Scalars['String'];
}>;


export type RegistrantsByUserIdQuery = { readonly __typename?: 'query_root', readonly registrant_Registrant: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantDataFragment
  )> };

export type ConferenceBySlug_WithUserQueryVariables = Exact<{
  slug: Scalars['String'];
  userId: Scalars['String'];
}>;


export type ConferenceBySlug_WithUserQuery = { readonly __typename?: 'query_root', readonly conference_Conference: ReadonlyArray<(
    { readonly __typename?: 'conference_Conference' }
    & PublicConferenceInfoFragment
    & AuthdConferenceInfoFragment
  )> };

export type ConferenceBySlug_WithoutUserQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type ConferenceBySlug_WithoutUserQuery = { readonly __typename?: 'query_root', readonly conference_Conference: ReadonlyArray<(
    { readonly __typename?: 'conference_Conference' }
    & PublicConferenceInfoFragment
  )> };

export type AuthdConferenceInfoFragment = { readonly __typename?: 'conference_Conference', readonly registrants: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant', readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly groupId: any, readonly registrantId: any, readonly group: (
        { readonly __typename?: 'permissions_Group' }
        & GroupDataFragment
      ) }> }
    & RegistrantDataFragment
  )> };

export type PublicConferenceInfoFragment = { readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string, readonly createdBy: string, readonly publicGroups: ReadonlyArray<(
    { readonly __typename?: 'permissions_Group' }
    & GroupDataFragment
  )> };

export type GroupDataFragment = { readonly __typename?: 'permissions_Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly permissionName: Permissions_Permission_Enum, readonly id: any, readonly roleId: any }> } }> };

export type ProfileDataFragment = { readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean };

export type RegistrantDataFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<(
    { readonly __typename?: 'registrant_Profile' }
    & ProfileDataFragment
  )> };

export type UpdateSubtitlesMutationVariables = Exact<{
  elementId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
}>;


export type UpdateSubtitlesMutation = { readonly __typename?: 'mutation_root', readonly updateSubtitles?: Maybe<{ readonly __typename?: 'SubmitUpdatedSubtitlesOutput', readonly message: string, readonly success: boolean }> };

export type GetElementQueryVariables = Exact<{
  magicToken: Scalars['String'];
}>;


export type GetElementQuery = { readonly __typename?: 'query_root', readonly content_ElementByAccessToken: ReadonlyArray<{ readonly __typename?: 'content_ElementByAccessToken', readonly typeName?: Maybe<string>, readonly data?: Maybe<any>, readonly layoutData?: Maybe<any>, readonly name?: Maybe<string>, readonly id?: Maybe<any>, readonly itemTitle?: Maybe<string> }> };

export type SelectUploadableItemQueryVariables = Exact<{
  uploadableId: Scalars['uuid'];
}>;


export type SelectUploadableItemQuery = { readonly __typename?: 'query_root', readonly content_UploadableElement: ReadonlyArray<(
    { readonly __typename?: 'content_UploadableElement' }
    & UploadableItemFieldsFragment
  )> };

export type UploadableItemFieldsFragment = { readonly __typename?: 'content_UploadableElement', readonly id: any, readonly typeName: Content_ElementType_Enum, readonly name: string, readonly uploadsRemaining?: Maybe<number>, readonly itemTitle?: Maybe<string>, readonly conference: { readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string } };

export type SubmitUploadableElementMutationVariables = Exact<{
  elementData: Scalars['jsonb'];
  magicToken: Scalars['String'];
}>;


export type SubmitUploadableElementMutation = { readonly __typename?: 'mutation_root', readonly submitUploadableElement?: Maybe<{ readonly __typename?: 'SubmitUploadableElementOutput', readonly message: string, readonly success: boolean }> };

export type GetUploadAgreementQueryVariables = Exact<{
  magicToken: Scalars['String'];
}>;


export type GetUploadAgreementQuery = { readonly __typename?: 'query_root', readonly getUploadAgreement?: Maybe<{ readonly __typename?: 'GetUploadAgreementOutput', readonly agreementText?: Maybe<string> }> };

export type EventProgramPersonDetailsFragment = { readonly __typename?: 'schedule_EventProgramPerson', readonly id: any, readonly roleName: Schedule_EventProgramPersonRole_Enum, readonly eventId: any, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly registrantId?: Maybe<any>, readonly registrant?: Maybe<{ readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly affiliation?: Maybe<string> }> }> } };

export type GetForceUserRefreshConfigQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetForceUserRefreshConfigQuery = { readonly __typename?: 'query_root', readonly conference_Configuration: ReadonlyArray<{ readonly __typename?: 'conference_Configuration', readonly id: any, readonly conferenceId: any, readonly key: string, readonly value: any }> };

export type GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables = Exact<{
  code: Scalars['String'];
  state: Scalars['String'];
}>;


export type GoogleOAuth_SubmitGoogleOAuthCodeMutation = { readonly __typename?: 'mutation_root', readonly submitGoogleOAuthCode?: Maybe<{ readonly __typename?: 'SubmitGoogleOAuthCodeOutput', readonly message?: Maybe<string>, readonly success: boolean }> };

export type SelectInvitationForAcceptQueryVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SelectInvitationForAcceptQuery = { readonly __typename?: 'query_root', readonly registrant_Invitation: ReadonlyArray<{ readonly __typename?: 'registrant_Invitation', readonly id: any, readonly invitedEmailAddress: string }> };

export type Invitation_ConfirmCurrentMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type Invitation_ConfirmCurrentMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmCurrent?: Maybe<{ readonly __typename?: 'ConfirmInvitationOutput', readonly confSlug?: Maybe<string>, readonly ok: string }> };

export type Invitation_ConfirmWithCodeMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
  confirmationCode: Scalars['String'];
}>;


export type Invitation_ConfirmWithCodeMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmWithCode?: Maybe<{ readonly __typename?: 'ConfirmInvitationOutput', readonly confSlug?: Maybe<string>, readonly ok: string }> };

export type SendInitialConfirmationEmailMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SendInitialConfirmationEmailMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmSendInitialEmail?: Maybe<{ readonly __typename?: 'InvitationConfirmationEmailOutput', readonly sent: boolean }> };

export type SendRepeatConfirmationEmailMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SendRepeatConfirmationEmailMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmSendRepeatEmail?: Maybe<{ readonly __typename?: 'InvitationConfirmationEmailOutput', readonly sent: boolean }> };

export type MenuScheduleQueryVariables = Exact<{
  now: Scalars['timestamptz'];
  inOneHour: Scalars['timestamptz'];
  conferenceId: Scalars['uuid'];
}>;


export type MenuScheduleQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<(
    { readonly __typename?: 'schedule_Event' }
    & MenuSchedule_EventFragment
  )> };

export type MenuSchedule_SearchEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type MenuSchedule_SearchEventsQuery = { readonly __typename?: 'query_root', readonly schedule_Event: ReadonlyArray<(
    { readonly __typename?: 'schedule_Event' }
    & MenuSchedule_EventFragment
  )> };

export type MenuSchedule_EventFragment = { readonly __typename?: 'schedule_Event', readonly id: any, readonly name: string, readonly startTime: any, readonly room: { readonly __typename?: 'room_Room', readonly id: any, readonly name: string }, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'schedule_EventTag', readonly tag: { readonly __typename?: 'collection_Tag', readonly id: any, readonly colour: string, readonly name: string } }>, readonly item?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string }> };

export type MainMenuSponsors_GetSponsorsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type MainMenuSponsors_GetSponsorsQuery = { readonly __typename?: 'query_root', readonly content_Item: ReadonlyArray<(
    { readonly __typename?: 'content_Item' }
    & MainMenuSponsors_ItemDataFragment
  )> };

export type MainMenuSponsors_ItemDataFragment = { readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'room_Room', readonly id: any, readonly priority: number }>, readonly logo: ReadonlyArray<{ readonly __typename?: 'content_Element', readonly id: any, readonly data: any }>, readonly itemPeople: ReadonlyArray<{ readonly __typename?: 'content_ItemProgramPerson', readonly id: any, readonly roleName: string, readonly person: { readonly __typename?: 'collection_ProgramPerson', readonly id: any, readonly registrantId?: Maybe<any> } }> };

export type CreateDmMutationVariables = Exact<{
  registrantIds: ReadonlyArray<Maybe<Scalars['uuid']>> | Maybe<Scalars['uuid']>;
  conferenceId: Scalars['uuid'];
}>;


export type CreateDmMutation = { readonly __typename?: 'mutation_root', readonly createRoomDm?: Maybe<{ readonly __typename?: 'CreateRoomDmOutput', readonly message?: Maybe<string>, readonly roomId?: Maybe<any>, readonly chatId?: Maybe<any> }> };

export type GetRoomChatIdQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomChatIdQuery = { readonly __typename?: 'query_root', readonly room_Room_by_pk?: Maybe<{ readonly __typename?: 'room_Room', readonly id: any, readonly chatId?: Maybe<any>, readonly name: string }> };

export type GetItemChatIdQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type GetItemChatIdQuery = { readonly __typename?: 'query_root', readonly content_Item_by_pk?: Maybe<{ readonly __typename?: 'content_Item', readonly id: any, readonly title: string, readonly chatId?: Maybe<any> }> };

export type GetVapidPublicKeyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetVapidPublicKeyQuery = { readonly __typename?: 'query_root', readonly vapidPublicKey: { readonly __typename?: 'VAPIDPublicKeyOutput', readonly key: string } };

export type UpsertPushNotificationSubscriptionMutationVariables = Exact<{
  object: PushNotificationSubscription_Insert_Input;
}>;


export type UpsertPushNotificationSubscriptionMutation = { readonly __typename?: 'mutation_root', readonly insert_PushNotificationSubscription_one?: Maybe<{ readonly __typename?: 'PushNotificationSubscription', readonly endpoint: string }> };

export type DeletePushNotificationSubscriptionMutationVariables = Exact<{
  endpoint: Scalars['String'];
}>;


export type DeletePushNotificationSubscriptionMutation = { readonly __typename?: 'mutation_root', readonly delete_PushNotificationSubscription?: Maybe<{ readonly __typename?: 'PushNotificationSubscription_mutation_response', readonly affected_rows: number }> };

export type GetRoomMembersQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomMembersQuery = { readonly __typename?: 'query_root', readonly room_RoomPerson: ReadonlyArray<(
    { readonly __typename?: 'room_RoomPerson' }
    & RoomMemberFragment
  )> };

export type RoomMemberFragment = { readonly __typename?: 'room_RoomPerson', readonly id: any, readonly roomId: any, readonly personRoleName: Room_PersonRole_Enum, readonly registrantId: any };

export type GetRoomParticipantsSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
  roomId: Scalars['uuid'];
}>;


export type GetRoomParticipantsSubscription = { readonly __typename?: 'subscription_root', readonly room_Participant: ReadonlyArray<(
    { readonly __typename?: 'room_Participant' }
    & RoomParticipantDetailsFragment
  )> };

export type GetAllRoomParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetAllRoomParticipantsQuery = { readonly __typename?: 'query_root', readonly room_Participant: ReadonlyArray<(
    { readonly __typename?: 'room_Participant' }
    & RoomParticipantDetailsFragment
  )> };

export type RoomParticipantDetailsFragment = { readonly __typename?: 'room_Participant', readonly conferenceId: any, readonly id: any, readonly roomId: any, readonly registrantId: any };

export type ShufflePeriodDataFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly conferenceId: any, readonly endAt: any, readonly maxRegistrantsPerRoom: number, readonly name: string, readonly roomDurationMinutes: number, readonly startAt: any, readonly targetRegistrantsPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly queueEntries: ReadonlyArray<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & PrefetchShuffleQueueEntryDataFragment
  )> };

export type PrefetchShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly registrantId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> };

export type SubdShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly allocatedShuffleRoomId?: Maybe<number> };

export type MyShuffleQueueEntrySubscriptionVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type MyShuffleQueueEntrySubscription = { readonly __typename?: 'subscription_root', readonly room_ShuffleQueueEntry_by_pk?: Maybe<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & SubdShuffleQueueEntryDataFragment
  )> };

export type GetShuffleRoomQueryVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type GetShuffleRoomQuery = { readonly __typename?: 'query_root', readonly room_ShuffleRoom_by_pk?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly roomId: any }> };

export type ShufflePeriodsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  end: Scalars['timestamptz'];
}>;


export type ShufflePeriodsQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<(
    { readonly __typename?: 'room_ShufflePeriod' }
    & ShufflePeriodDataFragment
  )> };

export type JoinShuffleQueueMutationVariables = Exact<{
  shufflePeriodId: Scalars['uuid'];
  registrantId: Scalars['uuid'];
}>;


export type JoinShuffleQueueMutation = { readonly __typename?: 'mutation_root', readonly insert_room_ShuffleQueueEntry_one?: Maybe<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & PrefetchShuffleQueueEntryDataFragment
  )> };

export type GetShuffleRoomsParticipantsCountQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetShuffleRoomsParticipantsCountQuery = { readonly __typename?: 'query_root', readonly room_Participant_aggregate: { readonly __typename?: 'room_Participant_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_Participant_aggregate_fields', readonly count?: Maybe<number> }> } };

export type RegistrantFieldsFragment = { readonly __typename?: 'registrant_Registrant', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly createdAt: any, readonly updatedAt: any, readonly profile?: Maybe<{ readonly __typename?: 'registrant_Profile', readonly registrantId: any, readonly photoURL_50x50?: Maybe<string> }>, readonly conference: { readonly __typename?: 'conference_Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }, readonly groupRegistrants: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRegistrant', readonly id: any, readonly group: { readonly __typename?: 'permissions_Group', readonly id: any, readonly enabled: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'permissions_GroupRole', readonly id: any, readonly role: { readonly __typename?: 'permissions_Role', readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'permissions_RolePermission', readonly id: any, readonly permissionName: Permissions_Permission_Enum }> } }> } }> };

export type UserInfoFragment = { readonly __typename?: 'User', readonly id: string, readonly email?: Maybe<string>, readonly acceptedTermsAt?: Maybe<any>, readonly acceptedPrivacyPolicyAt?: Maybe<any>, readonly registrants: ReadonlyArray<(
    { readonly __typename?: 'registrant_Registrant' }
    & RegistrantFieldsFragment
  )> };

export type SelectCurrentUserQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type SelectCurrentUserQuery = { readonly __typename?: 'query_root', readonly User_by_pk?: Maybe<(
    { readonly __typename?: 'User' }
    & UserInfoFragment
  )> };

export type TermsConfigsQueryVariables = Exact<{ [key: string]: never; }>;


export type TermsConfigsQuery = { readonly __typename?: 'query_root', readonly hostOrganisationName?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly termsTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly termsURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly ppTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly ppURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly cookiesTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly cookiesURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }> };

export type AgreeToTermsMutationVariables = Exact<{
  userId: Scalars['String'];
  at: Scalars['timestamptz'];
}>;


export type AgreeToTermsMutation = { readonly __typename?: 'mutation_root', readonly update_User_by_pk?: Maybe<{ readonly __typename?: 'User', readonly id: string, readonly acceptedTermsAt?: Maybe<any>, readonly acceptedPrivacyPolicyAt?: Maybe<any> }> };

export const ChatState_SubdMessageFragmentDoc = gql`
    fragment ChatState_SubdMessage on chat_Message {
  id
  chatId
  message
  type
  senderId
}
    `;
export const InitialChatState_ChatFragmentDoc = gql`
    fragment InitialChatState_Chat on chat_Chat {
  id
  items {
    id
    title
    shortTitle
  }
  nonDMRoom: rooms(where: {managementModeName: {_neq: DM}}) {
    id
    name
    priority
    managementModeName
  }
  DMRoom: rooms(where: {managementModeName: {_eq: DM}}) {
    id
    name
    roomPeople {
      id
      registrant {
        id
        displayName
      }
    }
  }
  enableAutoPin
  enableAutoSubscribe
  enableMandatoryPin
  enableMandatorySubscribe
  pins(where: {registrantId: {_eq: $registrantId}}) {
    registrantId
    chatId
    wasManuallyPinned
  }
  subscriptions(where: {registrantId: {_eq: $registrantId}}) {
    registrantId
    chatId
    wasManuallySubscribed
  }
}
    `;
export const ChatReactionDataFragmentDoc = gql`
    fragment ChatReactionData on chat_Reaction {
  sId
  data
  senderId
  symbol
  type
  messageSId
  duplicateSId
  created_at
  updated_at
  chatId
}
    `;
export const ChatMessageDataFragmentDoc = gql`
    fragment ChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageSId
  id
  sId
  message
  reactions {
    ...ChatReactionData
  }
  senderId
  type
  chatId
}
    ${ChatReactionDataFragmentDoc}`;
export const ShortChatMessageDataFragmentDoc = gql`
    fragment ShortChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageSId
  message
  senderId
  type
  chatId
  sId
}
    `;
export const ShortChatReactionDataFragmentDoc = gql`
    fragment ShortChatReactionData on chat_Reaction {
  data
  senderId
  symbol
  type
  messageSId
  sId
  duplicateSId
}
    `;
export const ElementDataFragmentDoc = gql`
    fragment ElementData on content_Element {
  id
  data
  layoutData
  name
  typeName
}
    `;
export const ProgramPersonDataFragmentDoc = gql`
    fragment ProgramPersonData on content_ItemProgramPerson {
  id
  person {
    id
    name
    affiliation
    registrantId
  }
  roleName
  priority
}
    `;
export const ItemElements_ItemDataFragmentDoc = gql`
    fragment ItemElements_ItemData on content_Item {
  id
  title
  typeName
  chatId
  chat {
    rooms {
      id
      name
    }
  }
  elements(where: {isHidden: {_eq: false}}) {
    ...ElementData
  }
  itemPeople(order_by: {priority: asc}) {
    ...ProgramPersonData
  }
}
    ${ElementDataFragmentDoc}
${ProgramPersonDataFragmentDoc}`;
export const ItemRoomEventFragmentDoc = gql`
    fragment ItemRoomEvent on schedule_Event {
  startTime
  item {
    id
    title
  }
  exhibitionId
  id
  durationSeconds
  endTime
  name
  intendedRoomModeName
}
    `;
export const ItemList_ProgramPersonDataFragmentDoc = gql`
    fragment ItemList_ProgramPersonData on content_ItemProgramPerson {
  id
  person {
    id
    affiliation
    name
  }
  priority
}
    `;
export const ItemList_ItemDataFragmentDoc = gql`
    fragment ItemList_ItemData on content_Item {
  id
  title
  itemPeople(where: {roleName: {_nilike: "chair"}}) {
    ...ItemList_ProgramPersonData
  }
}
    ${ItemList_ProgramPersonDataFragmentDoc}`;
export const ItemList_ItemTagDataFragmentDoc = gql`
    fragment ItemList_ItemTagData on content_ItemTag {
  item {
    ...ItemList_ItemData
  }
}
    ${ItemList_ItemDataFragmentDoc}`;
export const ItemList_TagInfoFragmentDoc = gql`
    fragment ItemList_TagInfo on collection_Tag {
  id
  colour
  name
  priority
}
    `;
export const ItemDataFragmentDoc = gql`
    fragment ItemData on content_Item {
  id
  title
  typeName
  elements(where: {isHidden: {_eq: false}}) {
    ...ElementData
  }
  itemPeople(order_by: {priority: asc}) {
    ...ProgramPersonData
  }
}
    ${ElementDataFragmentDoc}
${ProgramPersonDataFragmentDoc}`;
export const ItemPage_ItemRoomsFragmentDoc = gql`
    fragment ItemPage_ItemRooms on content_Item {
  rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    `;
export const ItemEventFragmentDoc = gql`
    fragment ItemEvent on schedule_Event {
  startTime
  roomId
  room {
    name
    id
  }
  exhibitionId
  id
  durationSeconds
  endTime
  name
  intendedRoomModeName
}
    `;
export const ExhibitionItemFragmentDoc = gql`
    fragment ExhibitionItem on content_Item {
  id
  title
  typeName
  elements(
    where: {isHidden: {_eq: false}, typeName: {_in: [ABSTRACT, IMAGE_FILE, IMAGE_URL, POSTER_FILE, POSTER_URL, TEXT, VIDEO_BROADCAST, VIDEO_FILE, VIDEO_PREPUBLISH, VIDEO_URL]}}
  ) {
    ...ElementData
  }
  events {
    id
    startTime
    endTime
    roomId
  }
  discussionRoom: rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    ${ElementDataFragmentDoc}`;
export const ExhibitionWithContentFragmentDoc = gql`
    fragment ExhibitionWithContent on collection_Exhibition {
  id
  name
  colour
  priority
  conferenceId
  items {
    id
    itemId
    exhibitionId
    layout
    priority
    item {
      ...ExhibitionItem
    }
  }
}
    ${ExhibitionItemFragmentDoc}`;
export const ExhibitionSummaryFragmentDoc = gql`
    fragment ExhibitionSummary on collection_Exhibition {
  id
  name
  colour
  priority
}
    `;
export const MyBackstages_EventFragmentDoc = gql`
    fragment MyBackstages_Event on schedule_Event {
  id
  conferenceId
  item {
    id
    title
  }
  endTime
  intendedRoomModeName
  name
  room {
    id
    name
  }
  startTime
}
    `;
export const EventParticipantStreamDetailsFragmentDoc = gql`
    fragment EventParticipantStreamDetails on video_EventParticipantStream {
  id
  registrant {
    id
    displayName
  }
  conferenceId
  eventId
  vonageStreamType
  vonageStreamId
  registrantId
}
    `;
export const EventRoomJoinRequestDetailsFragmentDoc = gql`
    fragment EventRoomJoinRequestDetails on schedule_EventRoomJoinRequest {
  id
  registrantId
}
    `;
export const RoomEventDetailsFragmentDoc = gql`
    fragment RoomEventDetails on schedule_Event {
  id
  conferenceId
  startTime
  name
  durationSeconds
  endTime
  intendedRoomModeName
  eventVonageSession {
    id
    sessionId
  }
}
    `;
export const Room_EventSummaryFragmentDoc = gql`
    fragment Room_EventSummary on schedule_Event {
  id
  conferenceId
  startTime
  name
  endTime
  intendedRoomModeName
  itemId
  exhibitionId
  item {
    id
    title
    typeName
    zoomItems: elements(where: {typeName: {_eq: ZOOM}}, limit: 1) {
      id
      data
      name
    }
    videoItems: elements(
      where: {typeName: {_in: [VIDEO_BROADCAST, VIDEO_FILE]}, isHidden: {_eq: false}}
      limit: 1
      order_by: {createdAt: desc_nulls_last}
    ) {
      id
      data
    }
    chatId
  }
  eventPeople {
    id
    person {
      id
      name
      affiliation
      registrantId
    }
    roleName
  }
}
    `;
export const RoomListRoomDetailsFragmentDoc = gql`
    fragment RoomListRoomDetails on room_Room {
  id
  name
  priority
  managementModeName
  originatingItem {
    id
    itemPeople {
      id
      roleName
      person {
        id
        registrantId
      }
    }
  }
  originatingEventId
}
    `;
export const RoomPage_RoomPeopleFragmentDoc = gql`
    fragment RoomPage_RoomPeople on room_Room {
  roomPeople {
    id
    personRoleName
    registrantId
  }
}
    `;
export const RoomPage_RoomDetailsFragmentDoc = gql`
    fragment RoomPage_RoomDetails on room_Room {
  id
  name
  currentModeName
  isProgramRoom
  channelStack {
    cloudFrontDomain
    endpointUri
    id
  }
  publicVonageSessionId
  chatId
  originatingItem {
    id
    typeName
    elements(
      where: {typeName: {_in: [IMAGE_URL, IMAGE_FILE]}, layoutData: {_contains: {isLogo: true}}}
      limit: 1
      order_by: {updatedAt: desc}
    ) {
      id
      data
    }
    title
  }
  managementModeName
  ...RoomPage_RoomPeople
  shuffleRooms(limit: 1, order_by: {id: desc}) {
    id
    startedAt
    durationMinutes
    reshuffleUponEnd
  }
  backendName
}
    ${RoomPage_RoomPeopleFragmentDoc}`;
export const RoomSponsorContent_ElementDataFragmentDoc = gql`
    fragment RoomSponsorContent_ElementData on content_Element {
  id
  name
  isHidden
  typeName
  data
  layoutData
}
    `;
export const RoomSponsorContent_ItemDataFragmentDoc = gql`
    fragment RoomSponsorContent_ItemData on content_Item {
  id
  elements {
    ...RoomSponsorContent_ElementData
  }
}
    ${RoomSponsorContent_ElementDataFragmentDoc}`;
export const Schedule_TagFragmentDoc = gql`
    fragment Schedule_Tag on collection_Tag {
  id
  name
  colour
  priority
}
    `;
export const Schedule_EventTagFragmentDoc = gql`
    fragment Schedule_EventTag on schedule_EventTag {
  id
  tag {
    ...Schedule_Tag
  }
}
    ${Schedule_TagFragmentDoc}`;
export const Schedule_ItemElementsFragmentDoc = gql`
    fragment Schedule_ItemElements on content_Item {
  id
  title
  shortTitle
  typeName
}
    `;
export const Schedule_ElementFragmentDoc = gql`
    fragment Schedule_Element on content_Element {
  id
  typeName
  name
  layoutData
  data
}
    `;
export const Schedule_ProgramPersonFragmentDoc = gql`
    fragment Schedule_ProgramPerson on collection_ProgramPerson {
  id
  name
  affiliation
  registrantId
}
    `;
export const Schedule_ItemPersonFragmentDoc = gql`
    fragment Schedule_ItemPerson on content_ItemProgramPerson {
  id
  priority
  roleName
  person {
    ...Schedule_ProgramPerson
  }
}
    ${Schedule_ProgramPersonFragmentDoc}`;
export const Schedule_ItemFragmentDoc = gql`
    fragment Schedule_Item on content_Item {
  ...Schedule_ItemElements
  abstractElements: elements(
    where: {typeName: {_eq: ABSTRACT}, isHidden: {_eq: false}}
  ) {
    ...Schedule_Element
  }
  itemPeople {
    ...Schedule_ItemPerson
  }
}
    ${Schedule_ItemElementsFragmentDoc}
${Schedule_ElementFragmentDoc}
${Schedule_ItemPersonFragmentDoc}`;
export const Schedule_EventSummaryFragmentDoc = gql`
    fragment Schedule_EventSummary on schedule_Event {
  id
  roomId
  intendedRoomModeName
  name
  startTime
  durationSeconds
  itemId
  exhibitionId
  shufflePeriodId
}
    `;
export const Schedule_RoomSummaryFragmentDoc = gql`
    fragment Schedule_RoomSummary on room_Room {
  id
  name
  currentModeName
  priority
  managementModeName
}
    `;
export const ConferenceConfiguration_ConferenceConfigurationsFragmentDoc = gql`
    fragment ConferenceConfiguration_ConferenceConfigurations on conference_Configuration {
  id
  key
  value
}
    `;
export const SubmissionRequestsModal_ConferenceConfigurationFragmentDoc = gql`
    fragment SubmissionRequestsModal_ConferenceConfiguration on conference_Configuration {
  id
  conferenceId
  key
  value
}
    `;
export const ProgramPersonInfoFragmentDoc = gql`
    fragment ProgramPersonInfo on collection_ProgramPerson {
  id
  conferenceId
  name
  affiliation
  email
  originatingDataId
  registrantId
}
    `;
export const UploaderInfoFragmentDoc = gql`
    fragment UploaderInfo on content_Uploader {
  id
  conferenceId
  email
  emailsSentCount
  name
  uploadableElementId
}
    `;
export const UploadableElementInfoFragmentDoc = gql`
    fragment UploadableElementInfo on content_UploadableElement {
  id
  name
  isHidden
  typeName
  conferenceId
  itemId
  uploadsRemaining
  uploaders {
    ...UploaderInfo
  }
  originatingDataId
}
    ${UploaderInfoFragmentDoc}`;
export const ElementInfoFragmentDoc = gql`
    fragment ElementInfo on content_Element {
  conferenceId
  itemId
  typeName
  data
  id
  isHidden
  layoutData
  name
  uploadableId
  originatingDataId
}
    `;
export const ItemTagInfoFragmentDoc = gql`
    fragment ItemTagInfo on content_ItemTag {
  id
  tagId
  itemId
}
    `;
export const ItemExhibitionInfoFragmentDoc = gql`
    fragment ItemExhibitionInfo on content_ItemExhibition {
  id
  itemId
  exhibitionId
  conferenceId
  priority
  layout
}
    `;
export const ItemPersonInfoFragmentDoc = gql`
    fragment ItemPersonInfo on content_ItemProgramPerson {
  id
  conferenceId
  itemId
  personId
  priority
  roleName
}
    `;
export const ItemFullNestedInfoFragmentDoc = gql`
    fragment ItemFullNestedInfo on content_Item {
  id
  conferenceId
  typeName
  title
  shortTitle
  uploadableElements {
    ...UploadableElementInfo
  }
  elements {
    ...ElementInfo
  }
  itemTags {
    ...ItemTagInfo
  }
  itemExhibitions {
    ...ItemExhibitionInfo
  }
  itemPeople {
    ...ItemPersonInfo
  }
  originatingDataId
  rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    ${UploadableElementInfoFragmentDoc}
${ElementInfoFragmentDoc}
${ItemTagInfoFragmentDoc}
${ItemExhibitionInfoFragmentDoc}
${ItemPersonInfoFragmentDoc}`;
export const TagInfoFragmentDoc = gql`
    fragment TagInfo on collection_Tag {
  id
  conferenceId
  colour
  name
  originatingDataId
  priority
}
    `;
export const ExhibitionInfoFragmentDoc = gql`
    fragment ExhibitionInfo on collection_Exhibition {
  id
  conferenceId
  colour
  name
  priority
}
    `;
export const SEoUm_ElementFragmentDoc = gql`
    fragment SEoUM_Element on content_Element {
  id
  name
  typeName
  itemId
  item {
    id
    title
  }
}
    `;
export const SEoUm_UploadableFragmentDoc = gql`
    fragment SEoUM_Uploadable on content_UploadableElement {
  id
  name
  typeName
  hasBeenUploaded
  uploaders {
    id
  }
  element {
    id
  }
  itemId
  itemTitle
}
    `;
export const ManageContent_UploaderFragmentDoc = gql`
    fragment ManageContent_Uploader on content_Uploader {
  id
  uploadableElementId
  email
  name
  emailsSentCount
  conferenceId
}
    `;
export const ElementSecurity_ElementPgFragmentDoc = gql`
    fragment ElementSecurity_ElementPG on content_ElementPermissionGrant {
  id
  permissionSetId
  conferenceSlug
  groupId
  entityId
}
    `;
export const ElementSecurity_UploadablePgFragmentDoc = gql`
    fragment ElementSecurity_UploadablePG on content_UploadableElementPermissionGrant {
  id
  permissionSetId
  conferenceSlug
  groupId
  entityId
  entity {
    id
    element {
      id
      permissionGrants {
        ...ElementSecurity_ElementPG
      }
    }
  }
}
    ${ElementSecurity_ElementPgFragmentDoc}`;
export const ElementSecurity_PermissionSetFragmentDoc = gql`
    fragment ElementSecurity_PermissionSet on permissions_Role {
  id
  name
}
    `;
export const ElementSecurity_GroupFragmentDoc = gql`
    fragment ElementSecurity_Group on permissions_Group {
  id
  name
  enabled
  includeUnauthenticated
}
    `;
export const SubmissionRequestsModal_UploadableElementFragmentDoc = gql`
    fragment SubmissionRequestsModal_UploadableElement on content_UploadableElement {
  id
  itemId
  typeName
  name
  uploadsRemaining
  itemTitle
  hasBeenUploaded
  uploaders {
    id
    email
    name
  }
}
    `;
export const SubmissionsReviewModal_UploadableElementFragmentDoc = gql`
    fragment SubmissionsReviewModal_UploadableElement on content_UploadableElement {
  id
  itemId
  typeName
  name
  uploadsRemaining
  itemTitle
  hasBeenUploaded
  uploaders {
    id
    email
    name
    emailsSentCount
  }
  element {
    ...ElementData
  }
}
    ${ElementDataFragmentDoc}`;
export const ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc = gql`
    fragment ConfigureEmailTemplates_ConferenceConfiguration on conference_Configuration {
  id
  conferenceId
  key
  value
}
    `;
export const ManageConferenceExportPage_RegistrantGoogleAccountFragmentDoc = gql`
    fragment ManageConferenceExportPage_RegistrantGoogleAccount on registrant_GoogleAccount {
  id
  googleAccountEmail
}
    `;
export const UploadYouTubeVideos_UploadYouTubeVideoJobFragmentDoc = gql`
    fragment UploadYouTubeVideos_UploadYouTubeVideoJob on job_queues_UploadYouTubeVideoJob {
  id
  jobStatusName
  element {
    id
    item {
      id
      title
    }
    name
  }
}
    `;
export const UploadYouTubeVideos_ElementFragmentDoc = gql`
    fragment UploadYouTubeVideos_Element on content_Element {
  id
  data
}
    `;
export const UploadYouTubeVideos_YouTubeUploadFragmentDoc = gql`
    fragment UploadYouTubeVideos_YouTubeUpload on video_YouTubeUpload {
  id
  videoId
  videoPrivacyStatus
  videoStatus
  videoTitle
  element {
    id
    name
    item {
      id
      title
    }
  }
}
    `;
export const ManageContent_ItemExhibitionFragmentDoc = gql`
    fragment ManageContent_ItemExhibition on content_ItemExhibition {
  id
  conferenceId
  item {
    id
    title
  }
  exhibitionId
  priority
  layout
}
    `;
export const ManageContent_ItemTagFragmentDoc = gql`
    fragment ManageContent_ItemTag on content_ItemTag {
  id
  itemId
  tagId
}
    `;
export const ManageContent_ItemFragmentDoc = gql`
    fragment ManageContent_Item on content_Item {
  id
  conferenceId
  title
  shortTitle
  typeName
  itemTags {
    ...ManageContent_ItemTag
  }
}
    ${ManageContent_ItemTagFragmentDoc}`;
export const ManageContent_ElementFragmentDoc = gql`
    fragment ManageContent_Element on content_Element {
  id
  name
  typeName
  data
  layoutData
  isHidden
  updatedAt
}
    `;
export const ManageContent_UploadableElementFragmentDoc = gql`
    fragment ManageContent_UploadableElement on content_UploadableElement {
  id
  itemId
  typeName
  name
  conferenceId
  uploadsRemaining
  isHidden
  hasBeenUploaded
  element {
    ...ManageContent_Element
  }
}
    ${ManageContent_ElementFragmentDoc}`;
export const ManageContent_ProgramPersonFragmentDoc = gql`
    fragment ManageContent_ProgramPerson on collection_ProgramPerson {
  id
  name
  affiliation
  email
  registrantId
}
    `;
export const ManageContent_ItemProgramPersonFragmentDoc = gql`
    fragment ManageContent_ItemProgramPerson on content_ItemProgramPerson {
  id
  itemId
  priority
  roleName
  person {
    ...ManageContent_ProgramPerson
  }
}
    ${ManageContent_ProgramPersonFragmentDoc}`;
export const ManageContent_RoomFragmentDoc = gql`
    fragment ManageContent_Room on room_Room {
  id
  name
}
    `;
export const ManageContent_OriginatingDataFragmentDoc = gql`
    fragment ManageContent_OriginatingData on conference_OriginatingData {
  id
  conferenceId
  sourceId
  data
}
    `;
export const ManageContent_ItemSecondaryFragmentDoc = gql`
    fragment ManageContent_ItemSecondary on content_Item {
  rooms {
    ...ManageContent_Room
  }
  chatId
  originatingData {
    ...ManageContent_OriginatingData
  }
}
    ${ManageContent_RoomFragmentDoc}
${ManageContent_OriginatingDataFragmentDoc}`;
export const ManageContent_TagFragmentDoc = gql`
    fragment ManageContent_Tag on collection_Tag {
  id
  conferenceId
  name
  colour
  priority
}
    `;
export const ManageContent_ExhibitionFragmentDoc = gql`
    fragment ManageContent_Exhibition on collection_Exhibition {
  id
  conferenceId
  name
  colour
  priority
}
    `;
export const ManageGroups_GroupFragmentDoc = gql`
    fragment ManageGroups_Group on permissions_Group {
  conferenceId
  enabled
  id
  includeUnauthenticated
  name
  groupRoles {
    id
    roleId
    groupId
  }
}
    `;
export const ManageProgramPeople_RegistrantFragmentDoc = gql`
    fragment ManageProgramPeople_Registrant on registrant_Registrant {
  id
  displayName
  invitation {
    id
    invitedEmailAddress
  }
  profile {
    registrantId
    affiliation
  }
}
    `;
export const ManageProgramPeople_ProgramPersonFragmentDoc = gql`
    fragment ManageProgramPeople_ProgramPerson on collection_ProgramPerson {
  id
  conferenceId
  name
  affiliation
  email
  originatingDataId
  registrantId
}
    `;
export const InvitationPartsFragmentDoc = gql`
    fragment InvitationParts on registrant_Invitation {
  registrantId
  id
  inviteCode
  invitedEmailAddress
  linkToUserId
  createdAt
  updatedAt
  hash
}
    `;
export const RegistrantPartsFragmentDoc = gql`
    fragment RegistrantParts on registrant_Registrant {
  conferenceId
  id
  groupRegistrants {
    registrantId
    id
    groupId
  }
  invitation {
    ...InvitationParts
  }
  userId
  updatedAt
  createdAt
  displayName
  inviteSent
}
    ${InvitationPartsFragmentDoc}`;
export const RoomParticipantWithRegistrantInfoFragmentDoc = gql`
    fragment RoomParticipantWithRegistrantInfo on room_Participant {
  id
  conferenceId
  registrantId
  roomId
  registrant {
    id
    displayName
  }
}
    `;
export const OriginatingDataInfoFragmentDoc = gql`
    fragment OriginatingDataInfo on conference_OriginatingData {
  id
  conferenceId
  sourceId
  data
}
    `;
export const RoomWithParticipantInfoFragmentDoc = gql`
    fragment RoomWithParticipantInfo on room_Room {
  id
  conferenceId
  name
  currentModeName
  capacity
  priority
  originatingEventId
  originatingItemId
  managementModeName
  isProgramRoom
  participants {
    ...RoomParticipantWithRegistrantInfo
  }
  originatingData {
    ...OriginatingDataInfo
  }
}
    ${RoomParticipantWithRegistrantInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}`;
export const RoomPersonInfoFragmentDoc = gql`
    fragment RoomPersonInfo on room_RoomPerson {
  id
  registrant {
    id
    displayName
  }
  personRoleName
}
    `;
export const ManageShufflePeriods_ShufflePeriodFragmentDoc = gql`
    fragment ManageShufflePeriods_ShufflePeriod on room_ShufflePeriod {
  id
  created_at
  updated_at
  conferenceId
  startAt
  endAt
  roomDurationMinutes
  targetRegistrantsPerRoom
  maxRegistrantsPerRoom
  waitRoomMaxDurationSeconds
  name
  organiserId
  algorithm
  completedEntries: queueEntries_aggregate(
    where: {shuffleRoom: {isEnded: {_eq: true}}}
  ) {
    aggregate {
      count
    }
  }
  ongoingEntries: queueEntries_aggregate(
    where: {shuffleRoom: {isEnded: {_eq: false}}}
  ) {
    aggregate {
      count
    }
  }
  waitingEntries: queueEntries_aggregate(
    where: {allocatedShuffleRoomId: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const AddEventPeople_ItemPersonFragmentDoc = gql`
    fragment AddEventPeople_ItemPerson on content_ItemProgramPerson {
  id
  itemId
  personId
  roleName
}
    `;
export const AddEventPeople_ProgramPersonFragmentDoc = gql`
    fragment AddEventPeople_ProgramPerson on collection_ProgramPerson {
  id
  name
  affiliation
  email
  registrantId
}
    `;
export const AddEventPeople_RegistrantFragmentDoc = gql`
    fragment AddEventPeople_Registrant on registrant_Registrant {
  id
  displayName
  profile {
    registrantId
    affiliation
  }
  invitation {
    id
    invitedEmailAddress
  }
}
    `;
export const AddEventPeople_GroupFragmentDoc = gql`
    fragment AddEventPeople_Group on permissions_Group {
  id
  name
}
    `;
export const RoomParticipantInfoFragmentDoc = gql`
    fragment RoomParticipantInfo on room_Participant {
  registrantId
  conferenceId
  id
  roomId
}
    `;
export const RoomInfoFragmentDoc = gql`
    fragment RoomInfo on room_Room {
  capacity
  conferenceId
  currentModeName
  id
  name
  priority
  originatingDataId
  originatingEventId
  originatingItemId
  managementModeName
  originatingData {
    ...OriginatingDataInfo
  }
  participants {
    ...RoomParticipantInfo
  }
}
    ${OriginatingDataInfoFragmentDoc}
${RoomParticipantInfoFragmentDoc}`;
export const EventProgramPersonInfoFragmentDoc = gql`
    fragment EventProgramPersonInfo on schedule_EventProgramPerson {
  id
  eventId
  roleName
  personId
}
    `;
export const EventTagInfoFragmentDoc = gql`
    fragment EventTagInfo on schedule_EventTag {
  eventId
  id
  tagId
}
    `;
export const EventInfoFragmentDoc = gql`
    fragment EventInfo on schedule_Event {
  conferenceId
  id
  durationSeconds
  eventPeople {
    ...EventProgramPersonInfo
  }
  eventTags {
    ...EventTagInfo
  }
  id
  intendedRoomModeName
  name
  originatingDataId
  roomId
  startTime
  endTime
  itemId
  exhibitionId
}
    ${EventProgramPersonInfoFragmentDoc}
${EventTagInfoFragmentDoc}`;
export const EditableSponsorsTable_ItemInfoFragmentDoc = gql`
    fragment EditableSponsorsTable_ItemInfo on content_Item {
  id
  title
  shortTitle
  room {
    id
  }
}
    `;
export const SponsorSecondaryEditor_ElementFragmentDoc = gql`
    fragment SponsorSecondaryEditor_Element on content_Element {
  id
  name
  typeName
  data
  layoutData
  isHidden
  updatedAt
}
    `;
export const SponsorSecondaryEditor_ItemProgramPersonFragmentDoc = gql`
    fragment SponsorSecondaryEditor_ItemProgramPerson on content_ItemProgramPerson {
  id
  itemId
  person {
    id
    name
    affiliation
    email
  }
}
    `;
export const SponsorSecondaryEditor_ProgramPersonFragmentDoc = gql`
    fragment SponsorSecondaryEditor_ProgramPerson on collection_ProgramPerson {
  id
  name
  affiliation
  email
}
    `;
export const ProfileDataFragmentDoc = gql`
    fragment ProfileData on registrant_Profile {
  registrantId
  badges
  affiliation
  affiliationURL
  country
  timezoneUTCOffset
  bio
  website
  github
  twitter
  pronouns
  photoURL_50x50
  photoURL_350x350
  hasBeenEdited
}
    `;
export const RegistrantDataFragmentDoc = gql`
    fragment RegistrantData on registrant_Registrant {
  id
  userId
  conferenceId
  displayName
  profile {
    ...ProfileData
  }
}
    ${ProfileDataFragmentDoc}`;
export const GroupDataFragmentDoc = gql`
    fragment GroupData on permissions_Group {
  groupRoles {
    role {
      rolePermissions {
        permissionName
        id
        roleId
      }
      id
      name
      conferenceId
    }
    id
    roleId
    groupId
  }
  enabled
  id
  includeUnauthenticated
  name
  conferenceId
}
    `;
export const AuthdConferenceInfoFragmentDoc = gql`
    fragment AuthdConferenceInfo on conference_Conference {
  registrants(where: {userId: {_eq: $userId}}) {
    ...RegistrantData
    groupRegistrants {
      group {
        ...GroupData
      }
      id
      groupId
      registrantId
    }
  }
}
    ${RegistrantDataFragmentDoc}
${GroupDataFragmentDoc}`;
export const PublicConferenceInfoFragmentDoc = gql`
    fragment PublicConferenceInfo on conference_Conference {
  id
  name
  shortName
  slug
  createdBy
  publicGroups: groups(
    where: {enabled: {_eq: true}, includeUnauthenticated: {_eq: true}}
  ) {
    ...GroupData
  }
}
    ${GroupDataFragmentDoc}`;
export const UploadableItemFieldsFragmentDoc = gql`
    fragment UploadableItemFields on content_UploadableElement {
  id
  typeName
  name
  uploadsRemaining
  conference {
    id
    name
  }
  itemTitle
}
    `;
export const EventProgramPersonDetailsFragmentDoc = gql`
    fragment EventProgramPersonDetails on schedule_EventProgramPerson {
  id
  roleName
  eventId
  person {
    id
    name
    affiliation
    registrantId
    registrant {
      id
      userId
      displayName
      profile {
        registrantId
        affiliation
      }
    }
  }
}
    `;
export const MenuSchedule_EventFragmentDoc = gql`
    fragment MenuSchedule_Event on schedule_Event {
  id
  name
  startTime
  room {
    id
    name
  }
  eventTags {
    tag {
      id
      colour
      name
    }
  }
  item {
    id
    title
  }
}
    `;
export const MainMenuSponsors_ItemDataFragmentDoc = gql`
    fragment MainMenuSponsors_ItemData on content_Item {
  id
  rooms(
    limit: 1
    order_by: {created_at: asc}
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    id
    priority
  }
  logo: elements(
    where: {typeName: {_in: [IMAGE_URL, IMAGE_FILE]}, layoutData: {_contains: {isLogo: true}}}
    order_by: {updatedAt: desc}
    limit: 1
  ) {
    id
    data
  }
  title
  shortTitle
  itemPeople {
    id
    person {
      id
      registrantId
    }
    roleName
  }
}
    `;
export const RoomMemberFragmentDoc = gql`
    fragment RoomMember on room_RoomPerson {
  id
  roomId
  personRoleName
  registrantId
}
    `;
export const RoomParticipantDetailsFragmentDoc = gql`
    fragment RoomParticipantDetails on room_Participant {
  conferenceId
  id
  roomId
  registrantId
}
    `;
export const PrefetchShuffleQueueEntryDataFragmentDoc = gql`
    fragment PrefetchShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  registrantId
  created_at
  updated_at
  shuffleRoom {
    id
    startedAt
    isEnded
    roomId
  }
}
    `;
export const ShufflePeriodDataFragmentDoc = gql`
    fragment ShufflePeriodData on room_ShufflePeriod {
  id
  conferenceId
  endAt
  maxRegistrantsPerRoom
  name
  queueEntries(
    distinct_on: [registrantId]
    order_by: {registrantId: asc, id: desc}
  ) {
    ...PrefetchShuffleQueueEntryData
  }
  roomDurationMinutes
  startAt
  targetRegistrantsPerRoom
  waitRoomMaxDurationSeconds
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export const SubdShuffleQueueEntryDataFragmentDoc = gql`
    fragment SubdShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  allocatedShuffleRoomId
}
    `;
export const RegistrantFieldsFragmentDoc = gql`
    fragment RegistrantFields on registrant_Registrant {
  id
  userId
  conferenceId
  displayName
  createdAt
  updatedAt
  profile {
    registrantId
    photoURL_50x50
  }
  conference {
    id
    name
    shortName
    slug
  }
  groupRegistrants {
    id
    group {
      id
      enabled
      name
      groupRoles {
        id
        role {
          id
          name
          rolePermissions {
            id
            permissionName
          }
        }
      }
    }
  }
}
    `;
export const UserInfoFragmentDoc = gql`
    fragment UserInfo on User {
  id
  email
  acceptedTermsAt
  acceptedPrivacyPolicyAt
  registrants {
    ...RegistrantFields
  }
}
    ${RegistrantFieldsFragmentDoc}`;
export const InitialChatStateDocument = gql`
    query InitialChatState($registrantId: uuid!) {
  chat_Pin(where: {registrantId: {_eq: $registrantId}}) {
    chatId
    registrantId
    chat {
      ...InitialChatState_Chat
    }
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useInitialChatStateQuery__
 *
 * To run a query within a React component, call `useInitialChatStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useInitialChatStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInitialChatStateQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useInitialChatStateQuery(baseOptions: Apollo.QueryHookOptions<InitialChatStateQuery, InitialChatStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InitialChatStateQuery, InitialChatStateQueryVariables>(InitialChatStateDocument, options);
      }
export function useInitialChatStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InitialChatStateQuery, InitialChatStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InitialChatStateQuery, InitialChatStateQueryVariables>(InitialChatStateDocument, options);
        }
export type InitialChatStateQueryHookResult = ReturnType<typeof useInitialChatStateQuery>;
export type InitialChatStateLazyQueryHookResult = ReturnType<typeof useInitialChatStateLazyQuery>;
export type InitialChatStateQueryResult = Apollo.QueryResult<InitialChatStateQuery, InitialChatStateQueryVariables>;
export const SelectInitialChatStateDocument = gql`
    query SelectInitialChatState($chatId: uuid!, $registrantId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    ...InitialChatState_Chat
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useSelectInitialChatStateQuery__
 *
 * To run a query within a React component, call `useSelectInitialChatStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInitialChatStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInitialChatStateQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useSelectInitialChatStateQuery(baseOptions: Apollo.QueryHookOptions<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>(SelectInitialChatStateDocument, options);
      }
export function useSelectInitialChatStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>(SelectInitialChatStateDocument, options);
        }
export type SelectInitialChatStateQueryHookResult = ReturnType<typeof useSelectInitialChatStateQuery>;
export type SelectInitialChatStateLazyQueryHookResult = ReturnType<typeof useSelectInitialChatStateLazyQuery>;
export type SelectInitialChatStateQueryResult = Apollo.QueryResult<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>;
export const SelectInitialChatStatesDocument = gql`
    query SelectInitialChatStates($chatIds: [uuid!]!, $registrantId: uuid!) {
  chat_Chat(where: {id: {_in: $chatIds}}) {
    ...InitialChatState_Chat
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useSelectInitialChatStatesQuery__
 *
 * To run a query within a React component, call `useSelectInitialChatStatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInitialChatStatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInitialChatStatesQuery({
 *   variables: {
 *      chatIds: // value for 'chatIds'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useSelectInitialChatStatesQuery(baseOptions: Apollo.QueryHookOptions<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>(SelectInitialChatStatesDocument, options);
      }
export function useSelectInitialChatStatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>(SelectInitialChatStatesDocument, options);
        }
export type SelectInitialChatStatesQueryHookResult = ReturnType<typeof useSelectInitialChatStatesQuery>;
export type SelectInitialChatStatesLazyQueryHookResult = ReturnType<typeof useSelectInitialChatStatesLazyQuery>;
export type SelectInitialChatStatesQueryResult = Apollo.QueryResult<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>;
export const SubscribeChatDocument = gql`
    mutation SubscribeChat($chatId: uuid!, $registrantId: uuid!) {
  insert_chat_Subscription(
    objects: {chatId: $chatId, registrantId: $registrantId}
    on_conflict: {constraint: Subscription_pkey, update_columns: wasManuallySubscribed}
  ) {
    returning {
      chatId
      registrantId
    }
  }
}
    `;
export type SubscribeChatMutationFn = Apollo.MutationFunction<SubscribeChatMutation, SubscribeChatMutationVariables>;

/**
 * __useSubscribeChatMutation__
 *
 * To run a mutation, you first call `useSubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [subscribeChatMutation, { data, loading, error }] = useSubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useSubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<SubscribeChatMutation, SubscribeChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubscribeChatMutation, SubscribeChatMutationVariables>(SubscribeChatDocument, options);
      }
export type SubscribeChatMutationHookResult = ReturnType<typeof useSubscribeChatMutation>;
export type SubscribeChatMutationResult = Apollo.MutationResult<SubscribeChatMutation>;
export type SubscribeChatMutationOptions = Apollo.BaseMutationOptions<SubscribeChatMutation, SubscribeChatMutationVariables>;
export const UnsubscribeChatDocument = gql`
    mutation UnsubscribeChat($chatId: uuid!, $registrantId: uuid!) {
  delete_chat_Subscription_by_pk(chatId: $chatId, registrantId: $registrantId) {
    registrantId
    chatId
  }
}
    `;
export type UnsubscribeChatMutationFn = Apollo.MutationFunction<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;

/**
 * __useUnsubscribeChatMutation__
 *
 * To run a mutation, you first call `useUnsubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnsubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unsubscribeChatMutation, { data, loading, error }] = useUnsubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUnsubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>(UnsubscribeChatDocument, options);
      }
export type UnsubscribeChatMutationHookResult = ReturnType<typeof useUnsubscribeChatMutation>;
export type UnsubscribeChatMutationResult = Apollo.MutationResult<UnsubscribeChatMutation>;
export type UnsubscribeChatMutationOptions = Apollo.BaseMutationOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;
export const PinChatDocument = gql`
    mutation PinChat($chatId: uuid!, $registrantId: uuid!) {
  insert_chat_Pin(
    objects: {chatId: $chatId, registrantId: $registrantId}
    on_conflict: {constraint: ChatPin_pkey, update_columns: wasManuallyPinned}
  ) {
    returning {
      chatId
      registrantId
    }
  }
}
    `;
export type PinChatMutationFn = Apollo.MutationFunction<PinChatMutation, PinChatMutationVariables>;

/**
 * __usePinChatMutation__
 *
 * To run a mutation, you first call `usePinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [pinChatMutation, { data, loading, error }] = usePinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function usePinChatMutation(baseOptions?: Apollo.MutationHookOptions<PinChatMutation, PinChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PinChatMutation, PinChatMutationVariables>(PinChatDocument, options);
      }
export type PinChatMutationHookResult = ReturnType<typeof usePinChatMutation>;
export type PinChatMutationResult = Apollo.MutationResult<PinChatMutation>;
export type PinChatMutationOptions = Apollo.BaseMutationOptions<PinChatMutation, PinChatMutationVariables>;
export const UnpinChatDocument = gql`
    mutation UnpinChat($chatId: uuid!, $registrantId: uuid!) {
  delete_chat_Pin_by_pk(chatId: $chatId, registrantId: $registrantId) {
    registrantId
    chatId
  }
}
    `;
export type UnpinChatMutationFn = Apollo.MutationFunction<UnpinChatMutation, UnpinChatMutationVariables>;

/**
 * __useUnpinChatMutation__
 *
 * To run a mutation, you first call `useUnpinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpinChatMutation, { data, loading, error }] = useUnpinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUnpinChatMutation(baseOptions?: Apollo.MutationHookOptions<UnpinChatMutation, UnpinChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnpinChatMutation, UnpinChatMutationVariables>(UnpinChatDocument, options);
      }
export type UnpinChatMutationHookResult = ReturnType<typeof useUnpinChatMutation>;
export type UnpinChatMutationResult = Apollo.MutationResult<UnpinChatMutation>;
export type UnpinChatMutationOptions = Apollo.BaseMutationOptions<UnpinChatMutation, UnpinChatMutationVariables>;
export const SelectMessagesPageDocument = gql`
    query SelectMessagesPage($chatId: uuid!, $startAtIndex: Int!, $maxCount: Int!) {
  chat_Message(
    order_by: {id: desc}
    where: {chatId: {_eq: $chatId}, id: {_lte: $startAtIndex}, type: {_neq: EMOTE}}
    limit: $maxCount
  ) {
    ...ChatMessageData
  }
}
    ${ChatMessageDataFragmentDoc}`;

/**
 * __useSelectMessagesPageQuery__
 *
 * To run a query within a React component, call `useSelectMessagesPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectMessagesPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectMessagesPageQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      startAtIndex: // value for 'startAtIndex'
 *      maxCount: // value for 'maxCount'
 *   },
 * });
 */
export function useSelectMessagesPageQuery(baseOptions: Apollo.QueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, options);
      }
export function useSelectMessagesPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, options);
        }
export type SelectMessagesPageQueryHookResult = ReturnType<typeof useSelectMessagesPageQuery>;
export type SelectMessagesPageLazyQueryHookResult = ReturnType<typeof useSelectMessagesPageLazyQuery>;
export type SelectMessagesPageQueryResult = Apollo.QueryResult<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>;
export const GetChatPathDocument = gql`
    query GetChatPath($chatId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    id
    rooms {
      id
    }
    items {
      id
    }
  }
}
    `;

/**
 * __useGetChatPathQuery__
 *
 * To run a query within a React component, call `useGetChatPathQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChatPathQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChatPathQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useGetChatPathQuery(baseOptions: Apollo.QueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, options);
      }
export function useGetChatPathLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, options);
        }
export type GetChatPathQueryHookResult = ReturnType<typeof useGetChatPathQuery>;
export type GetChatPathLazyQueryHookResult = ReturnType<typeof useGetChatPathLazyQuery>;
export type GetChatPathQueryResult = Apollo.QueryResult<GetChatPathQuery, GetChatPathQueryVariables>;
export const ConferenceLandingPageItemDocument = gql`
    query ConferenceLandingPageItem($conferenceId: uuid!) {
  content_Item(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {typeName: {_eq: LANDING_PAGE}}]}
  ) {
    ...ItemData
  }
}
    ${ItemDataFragmentDoc}`;

/**
 * __useConferenceLandingPageItemQuery__
 *
 * To run a query within a React component, call `useConferenceLandingPageItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceLandingPageItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceLandingPageItemQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferenceLandingPageItemQuery(baseOptions: Apollo.QueryHookOptions<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>(ConferenceLandingPageItemDocument, options);
      }
export function useConferenceLandingPageItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>(ConferenceLandingPageItemDocument, options);
        }
export type ConferenceLandingPageItemQueryHookResult = ReturnType<typeof useConferenceLandingPageItemQuery>;
export type ConferenceLandingPageItemLazyQueryHookResult = ReturnType<typeof useConferenceLandingPageItemLazyQuery>;
export type ConferenceLandingPageItemQueryResult = Apollo.QueryResult<ConferenceLandingPageItemQuery, ConferenceLandingPageItemQueryVariables>;
export const ItemElements_GetItemDocument = gql`
    query ItemElements_GetItem($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    ...ItemElements_ItemData
  }
}
    ${ItemElements_ItemDataFragmentDoc}`;

/**
 * __useItemElements_GetItemQuery__
 *
 * To run a query within a React component, call `useItemElements_GetItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useItemElements_GetItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useItemElements_GetItemQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useItemElements_GetItemQuery(baseOptions: Apollo.QueryHookOptions<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>(ItemElements_GetItemDocument, options);
      }
export function useItemElements_GetItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>(ItemElements_GetItemDocument, options);
        }
export type ItemElements_GetItemQueryHookResult = ReturnType<typeof useItemElements_GetItemQuery>;
export type ItemElements_GetItemLazyQueryHookResult = ReturnType<typeof useItemElements_GetItemLazyQuery>;
export type ItemElements_GetItemQueryResult = Apollo.QueryResult<ItemElements_GetItemQuery, ItemElements_GetItemQueryVariables>;
export const ContentOfTagDocument = gql`
    query ContentOfTag($id: uuid!) {
  content_ItemTag(where: {tagId: {_eq: $id}}) {
    ...ItemList_ItemTagData
  }
}
    ${ItemList_ItemTagDataFragmentDoc}`;

/**
 * __useContentOfTagQuery__
 *
 * To run a query within a React component, call `useContentOfTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentOfTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentOfTagQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useContentOfTagQuery(baseOptions: Apollo.QueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, options);
      }
export function useContentOfTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, options);
        }
export type ContentOfTagQueryHookResult = ReturnType<typeof useContentOfTagQuery>;
export type ContentOfTagLazyQueryHookResult = ReturnType<typeof useContentOfTagLazyQuery>;
export type ContentOfTagQueryResult = Apollo.QueryResult<ContentOfTagQuery, ContentOfTagQueryVariables>;
export const TagsDocument = gql`
    query Tags($conferenceId: uuid!) {
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ItemList_TagInfo
  }
}
    ${ItemList_TagInfoFragmentDoc}`;

/**
 * __useTagsQuery__
 *
 * To run a query within a React component, call `useTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useTagsQuery(baseOptions: Apollo.QueryHookOptions<TagsQuery, TagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options);
      }
export function useTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TagsQuery, TagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options);
        }
export type TagsQueryHookResult = ReturnType<typeof useTagsQuery>;
export type TagsLazyQueryHookResult = ReturnType<typeof useTagsLazyQuery>;
export type TagsQueryResult = Apollo.QueryResult<TagsQuery, TagsQueryVariables>;
export const GetItemDocument = gql`
    query GetItem($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    ...ItemData
    ...ItemPage_ItemRooms
  }
  schedule_Event(
    where: {_or: [{itemId: {_eq: $itemId}}, {exhibition: {items: {itemId: {_eq: $itemId}}}}]}
  ) {
    ...ItemEvent
  }
}
    ${ItemDataFragmentDoc}
${ItemPage_ItemRoomsFragmentDoc}
${ItemEventFragmentDoc}`;

/**
 * __useGetItemQuery__
 *
 * To run a query within a React component, call `useGetItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetItemQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useGetItemQuery(baseOptions: Apollo.QueryHookOptions<GetItemQuery, GetItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetItemQuery, GetItemQueryVariables>(GetItemDocument, options);
      }
export function useGetItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetItemQuery, GetItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetItemQuery, GetItemQueryVariables>(GetItemDocument, options);
        }
export type GetItemQueryHookResult = ReturnType<typeof useGetItemQuery>;
export type GetItemLazyQueryHookResult = ReturnType<typeof useGetItemLazyQuery>;
export type GetItemQueryResult = Apollo.QueryResult<GetItemQuery, GetItemQueryVariables>;
export const SelectExhibitionDocument = gql`
    query SelectExhibition($id: uuid!) {
  collection_Exhibition_by_pk(id: $id) {
    ...ExhibitionWithContent
  }
}
    ${ExhibitionWithContentFragmentDoc}`;

/**
 * __useSelectExhibitionQuery__
 *
 * To run a query within a React component, call `useSelectExhibitionQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectExhibitionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectExhibitionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSelectExhibitionQuery(baseOptions: Apollo.QueryHookOptions<SelectExhibitionQuery, SelectExhibitionQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectExhibitionQuery, SelectExhibitionQueryVariables>(SelectExhibitionDocument, options);
      }
export function useSelectExhibitionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectExhibitionQuery, SelectExhibitionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectExhibitionQuery, SelectExhibitionQueryVariables>(SelectExhibitionDocument, options);
        }
export type SelectExhibitionQueryHookResult = ReturnType<typeof useSelectExhibitionQuery>;
export type SelectExhibitionLazyQueryHookResult = ReturnType<typeof useSelectExhibitionLazyQuery>;
export type SelectExhibitionQueryResult = Apollo.QueryResult<SelectExhibitionQuery, SelectExhibitionQueryVariables>;
export const SelectAllExhibitionsDocument = gql`
    query SelectAllExhibitions($conferenceId: uuid!) {
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ExhibitionSummary
  }
}
    ${ExhibitionSummaryFragmentDoc}`;

/**
 * __useSelectAllExhibitionsQuery__
 *
 * To run a query within a React component, call `useSelectAllExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllExhibitionsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>(SelectAllExhibitionsDocument, options);
      }
export function useSelectAllExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>(SelectAllExhibitionsDocument, options);
        }
export type SelectAllExhibitionsQueryHookResult = ReturnType<typeof useSelectAllExhibitionsQuery>;
export type SelectAllExhibitionsLazyQueryHookResult = ReturnType<typeof useSelectAllExhibitionsLazyQuery>;
export type SelectAllExhibitionsQueryResult = Apollo.QueryResult<SelectAllExhibitionsQuery, SelectAllExhibitionsQueryVariables>;
export const RegistrantByIdDocument = gql`
    query RegistrantById($conferenceId: uuid!, $registrantId: uuid!) {
  registrant_Registrant(
    where: {id: {_eq: $registrantId}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useRegistrantByIdQuery__
 *
 * To run a query within a React component, call `useRegistrantByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useRegistrantByIdQuery(baseOptions: Apollo.QueryHookOptions<RegistrantByIdQuery, RegistrantByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantByIdQuery, RegistrantByIdQueryVariables>(RegistrantByIdDocument, options);
      }
export function useRegistrantByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantByIdQuery, RegistrantByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantByIdQuery, RegistrantByIdQueryVariables>(RegistrantByIdDocument, options);
        }
export type RegistrantByIdQueryHookResult = ReturnType<typeof useRegistrantByIdQuery>;
export type RegistrantByIdLazyQueryHookResult = ReturnType<typeof useRegistrantByIdLazyQuery>;
export type RegistrantByIdQueryResult = Apollo.QueryResult<RegistrantByIdQuery, RegistrantByIdQueryVariables>;
export const UpdateProfileDocument = gql`
    mutation UpdateProfile($registrantId: uuid!, $profile: registrant_Profile_set_input = {}) {
  update_registrant_Profile_by_pk(
    pk_columns: {registrantId: $registrantId}
    _set: $profile
  ) {
    ...ProfileData
  }
}
    ${ProfileDataFragmentDoc}`;
export type UpdateProfileMutationFn = Apollo.MutationFunction<UpdateProfileMutation, UpdateProfileMutationVariables>;

/**
 * __useUpdateProfileMutation__
 *
 * To run a mutation, you first call `useUpdateProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProfileMutation, { data, loading, error }] = useUpdateProfileMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      profile: // value for 'profile'
 *   },
 * });
 */
export function useUpdateProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProfileMutation, UpdateProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProfileMutation, UpdateProfileMutationVariables>(UpdateProfileDocument, options);
      }
export type UpdateProfileMutationHookResult = ReturnType<typeof useUpdateProfileMutation>;
export type UpdateProfileMutationResult = Apollo.MutationResult<UpdateProfileMutation>;
export type UpdateProfileMutationOptions = Apollo.BaseMutationOptions<UpdateProfileMutation, UpdateProfileMutationVariables>;
export const UpdateRegistrantDisplayNameDocument = gql`
    mutation UpdateRegistrantDisplayName($registrantId: uuid!, $name: String!) {
  update_registrant_Registrant_by_pk(
    pk_columns: {id: $registrantId}
    _set: {displayName: $name}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;
export type UpdateRegistrantDisplayNameMutationFn = Apollo.MutationFunction<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>;

/**
 * __useUpdateRegistrantDisplayNameMutation__
 *
 * To run a mutation, you first call `useUpdateRegistrantDisplayNameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRegistrantDisplayNameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRegistrantDisplayNameMutation, { data, loading, error }] = useUpdateRegistrantDisplayNameMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateRegistrantDisplayNameMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>(UpdateRegistrantDisplayNameDocument, options);
      }
export type UpdateRegistrantDisplayNameMutationHookResult = ReturnType<typeof useUpdateRegistrantDisplayNameMutation>;
export type UpdateRegistrantDisplayNameMutationResult = Apollo.MutationResult<UpdateRegistrantDisplayNameMutation>;
export type UpdateRegistrantDisplayNameMutationOptions = Apollo.BaseMutationOptions<UpdateRegistrantDisplayNameMutation, UpdateRegistrantDisplayNameMutationVariables>;
export const SubmitProfilePhotoDocument = gql`
    mutation SubmitProfilePhoto($registrantId: uuid!, $s3URL: String!) {
  updateProfilePhoto(registrantId: $registrantId, s3URL: $s3URL) {
    ok
    photoURL_350x350
    photoURL_50x50
  }
}
    `;
export type SubmitProfilePhotoMutationFn = Apollo.MutationFunction<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;

/**
 * __useSubmitProfilePhotoMutation__
 *
 * To run a mutation, you first call `useSubmitProfilePhotoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitProfilePhotoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitProfilePhotoMutation, { data, loading, error }] = useSubmitProfilePhotoMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      s3URL: // value for 's3URL'
 *   },
 * });
 */
export function useSubmitProfilePhotoMutation(baseOptions?: Apollo.MutationHookOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>(SubmitProfilePhotoDocument, options);
      }
export type SubmitProfilePhotoMutationHookResult = ReturnType<typeof useSubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationResult = Apollo.MutationResult<SubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationOptions = Apollo.BaseMutationOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;
export const RegistrantEventsWithBackstagesDocument = gql`
    query RegistrantEventsWithBackstages($registrantId: uuid!) {
  schedule_Event(
    where: {eventPeople: {person: {registrantId: {_eq: $registrantId}}}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}}
  ) {
    ...MyBackstages_Event
  }
}
    ${MyBackstages_EventFragmentDoc}`;

/**
 * __useRegistrantEventsWithBackstagesQuery__
 *
 * To run a query within a React component, call `useRegistrantEventsWithBackstagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantEventsWithBackstagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantEventsWithBackstagesQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useRegistrantEventsWithBackstagesQuery(baseOptions: Apollo.QueryHookOptions<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>(RegistrantEventsWithBackstagesDocument, options);
      }
export function useRegistrantEventsWithBackstagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>(RegistrantEventsWithBackstagesDocument, options);
        }
export type RegistrantEventsWithBackstagesQueryHookResult = ReturnType<typeof useRegistrantEventsWithBackstagesQuery>;
export type RegistrantEventsWithBackstagesLazyQueryHookResult = ReturnType<typeof useRegistrantEventsWithBackstagesLazyQuery>;
export type RegistrantEventsWithBackstagesQueryResult = Apollo.QueryResult<RegistrantEventsWithBackstagesQuery, RegistrantEventsWithBackstagesQueryVariables>;
export const SelectRegistrantsDocument = gql`
    query SelectRegistrants($conferenceId: uuid!) {
  registrant_Registrant(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {displayName: asc}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useSelectRegistrantsQuery__
 *
 * To run a query within a React component, call `useSelectRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>(SelectRegistrantsDocument, options);
      }
export function useSelectRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>(SelectRegistrantsDocument, options);
        }
export type SelectRegistrantsQueryHookResult = ReturnType<typeof useSelectRegistrantsQuery>;
export type SelectRegistrantsLazyQueryHookResult = ReturnType<typeof useSelectRegistrantsLazyQuery>;
export type SelectRegistrantsQueryResult = Apollo.QueryResult<SelectRegistrantsQuery, SelectRegistrantsQueryVariables>;
export const SearchRegistrantsDocument = gql`
    query SearchRegistrants($conferenceId: uuid!, $search: String!) {
  registrant_Registrant(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {_or: [{displayName: {_ilike: $search}}, {profile: {_or: [{affiliation: {_ilike: $search}}, {bio: {_ilike: $search}}]}}, {badges: {name: {_ilike: $search}}}]}]}
    order_by: {displayName: asc}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useSearchRegistrantsQuery__
 *
 * To run a query within a React component, call `useSearchRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>(SearchRegistrantsDocument, options);
      }
export function useSearchRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>(SearchRegistrantsDocument, options);
        }
export type SearchRegistrantsQueryHookResult = ReturnType<typeof useSearchRegistrantsQuery>;
export type SearchRegistrantsLazyQueryHookResult = ReturnType<typeof useSearchRegistrantsLazyQuery>;
export type SearchRegistrantsQueryResult = Apollo.QueryResult<SearchRegistrantsQuery, SearchRegistrantsQueryVariables>;
export const GetRoomChimeDataDocument = gql`
    mutation GetRoomChimeData($roomId: uuid!) {
  joinRoomChimeSession(roomId: $roomId) {
    registrant
    meeting
    message
  }
}
    `;
export type GetRoomChimeDataMutationFn = Apollo.MutationFunction<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>;

/**
 * __useGetRoomChimeDataMutation__
 *
 * To run a mutation, you first call `useGetRoomChimeDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetRoomChimeDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getRoomChimeDataMutation, { data, loading, error }] = useGetRoomChimeDataMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomChimeDataMutation(baseOptions?: Apollo.MutationHookOptions<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>(GetRoomChimeDataDocument, options);
      }
export type GetRoomChimeDataMutationHookResult = ReturnType<typeof useGetRoomChimeDataMutation>;
export type GetRoomChimeDataMutationResult = Apollo.MutationResult<GetRoomChimeDataMutation>;
export type GetRoomChimeDataMutationOptions = Apollo.BaseMutationOptions<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>;
export const GetRoomVonageTokenDocument = gql`
    mutation GetRoomVonageToken($roomId: uuid!) {
  joinRoomVonageSession(roomId: $roomId) {
    accessToken
    sessionId
  }
}
    `;
export type GetRoomVonageTokenMutationFn = Apollo.MutationFunction<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;

/**
 * __useGetRoomVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetRoomVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetRoomVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getRoomVonageTokenMutation, { data, loading, error }] = useGetRoomVonageTokenMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>(GetRoomVonageTokenDocument, options);
      }
export type GetRoomVonageTokenMutationHookResult = ReturnType<typeof useGetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationResult = Apollo.MutationResult<GetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;
export const Registrant_RegistrantCreateRoomDocument = gql`
    mutation registrant_RegistrantCreateRoom($conferenceId: uuid!, $name: String!, $managementModeName: room_ManagementMode_enum!) {
  insert_room_Room_one(
    object: {capacity: 50, conferenceId: $conferenceId, currentModeName: BREAKOUT, name: $name, managementModeName: $managementModeName}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;
export type Registrant_RegistrantCreateRoomMutationFn = Apollo.MutationFunction<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>;

/**
 * __useRegistrant_RegistrantCreateRoomMutation__
 *
 * To run a mutation, you first call `useRegistrant_RegistrantCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRegistrant_RegistrantCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [registrantRegistrantCreateRoomMutation, { data, loading, error }] = useRegistrant_RegistrantCreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      name: // value for 'name'
 *      managementModeName: // value for 'managementModeName'
 *   },
 * });
 */
export function useRegistrant_RegistrantCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>(Registrant_RegistrantCreateRoomDocument, options);
      }
export type Registrant_RegistrantCreateRoomMutationHookResult = ReturnType<typeof useRegistrant_RegistrantCreateRoomMutation>;
export type Registrant_RegistrantCreateRoomMutationResult = Apollo.MutationResult<Registrant_RegistrantCreateRoomMutation>;
export type Registrant_RegistrantCreateRoomMutationOptions = Apollo.BaseMutationOptions<Registrant_RegistrantCreateRoomMutation, Registrant_RegistrantCreateRoomMutationVariables>;
export const UpdateEventVonageSessionLayoutDocument = gql`
    mutation UpdateEventVonageSessionLayout($eventVonageSessionId: uuid!, $layoutData: jsonb!) {
  update_video_EventVonageSession_by_pk(
    pk_columns: {id: $eventVonageSessionId}
    _set: {layoutData: $layoutData}
  ) {
    id
  }
}
    `;
export type UpdateEventVonageSessionLayoutMutationFn = Apollo.MutationFunction<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;

/**
 * __useUpdateEventVonageSessionLayoutMutation__
 *
 * To run a mutation, you first call `useUpdateEventVonageSessionLayoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventVonageSessionLayoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventVonageSessionLayoutMutation, { data, loading, error }] = useUpdateEventVonageSessionLayoutMutation({
 *   variables: {
 *      eventVonageSessionId: // value for 'eventVonageSessionId'
 *      layoutData: // value for 'layoutData'
 *   },
 * });
 */
export function useUpdateEventVonageSessionLayoutMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>(UpdateEventVonageSessionLayoutDocument, options);
      }
export type UpdateEventVonageSessionLayoutMutationHookResult = ReturnType<typeof useUpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationResult = Apollo.MutationResult<UpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationOptions = Apollo.BaseMutationOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;
export const DeleteEventProgramPersonDocument = gql`
    mutation DeleteEventProgramPerson($eventProgramPersonId: uuid!) {
  delete_schedule_EventProgramPerson_by_pk(id: $eventProgramPersonId) {
    id
  }
}
    `;
export type DeleteEventProgramPersonMutationFn = Apollo.MutationFunction<DeleteEventProgramPersonMutation, DeleteEventProgramPersonMutationVariables>;

/**
 * __useDeleteEventProgramPersonMutation__
 *
 * To run a mutation, you first call `useDeleteEventProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventProgramPersonMutation, { data, loading, error }] = useDeleteEventProgramPersonMutation({
 *   variables: {
 *      eventProgramPersonId: // value for 'eventProgramPersonId'
 *   },
 * });
 */
export function useDeleteEventProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventProgramPersonMutation, DeleteEventProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventProgramPersonMutation, DeleteEventProgramPersonMutationVariables>(DeleteEventProgramPersonDocument, options);
      }
export type DeleteEventProgramPersonMutationHookResult = ReturnType<typeof useDeleteEventProgramPersonMutation>;
export type DeleteEventProgramPersonMutationResult = Apollo.MutationResult<DeleteEventProgramPersonMutation>;
export type DeleteEventProgramPersonMutationOptions = Apollo.BaseMutationOptions<DeleteEventProgramPersonMutation, DeleteEventProgramPersonMutationVariables>;
export const GetEventParticipantStreamsDocument = gql`
    subscription GetEventParticipantStreams($eventId: uuid!) {
  video_EventParticipantStream(where: {eventId: {_eq: $eventId}}) {
    ...EventParticipantStreamDetails
  }
}
    ${EventParticipantStreamDetailsFragmentDoc}`;

/**
 * __useGetEventParticipantStreamsSubscription__
 *
 * To run a query within a React component, call `useGetEventParticipantStreamsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetEventParticipantStreamsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventParticipantStreamsSubscription({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventParticipantStreamsSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>(GetEventParticipantStreamsDocument, options);
      }
export type GetEventParticipantStreamsSubscriptionHookResult = ReturnType<typeof useGetEventParticipantStreamsSubscription>;
export type GetEventParticipantStreamsSubscriptionResult = Apollo.SubscriptionResult<GetEventParticipantStreamsSubscription>;
export const UnapprovedEventRoomJoinRequestsDocument = gql`
    subscription UnapprovedEventRoomJoinRequests($conferenceId: uuid!, $eventId: uuid!) {
  schedule_EventRoomJoinRequest(
    where: {conferenceId: {_eq: $conferenceId}, eventId: {_eq: $eventId}, approved: {_eq: false}}
  ) {
    ...EventRoomJoinRequestDetails
  }
}
    ${EventRoomJoinRequestDetailsFragmentDoc}`;

/**
 * __useUnapprovedEventRoomJoinRequestsSubscription__
 *
 * To run a query within a React component, call `useUnapprovedEventRoomJoinRequestsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useUnapprovedEventRoomJoinRequestsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnapprovedEventRoomJoinRequestsSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useUnapprovedEventRoomJoinRequestsSubscription(baseOptions: Apollo.SubscriptionHookOptions<UnapprovedEventRoomJoinRequestsSubscription, UnapprovedEventRoomJoinRequestsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<UnapprovedEventRoomJoinRequestsSubscription, UnapprovedEventRoomJoinRequestsSubscriptionVariables>(UnapprovedEventRoomJoinRequestsDocument, options);
      }
export type UnapprovedEventRoomJoinRequestsSubscriptionHookResult = ReturnType<typeof useUnapprovedEventRoomJoinRequestsSubscription>;
export type UnapprovedEventRoomJoinRequestsSubscriptionResult = Apollo.SubscriptionResult<UnapprovedEventRoomJoinRequestsSubscription>;
export const GetEventVonageTokenDocument = gql`
    mutation GetEventVonageToken($eventId: uuid!) {
  joinEventVonageSession(eventId: $eventId) {
    accessToken
  }
}
    `;
export type GetEventVonageTokenMutationFn = Apollo.MutationFunction<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;

/**
 * __useGetEventVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetEventVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getEventVonageTokenMutation, { data, loading, error }] = useGetEventVonageTokenMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>(GetEventVonageTokenDocument, options);
      }
export type GetEventVonageTokenMutationHookResult = ReturnType<typeof useGetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationResult = Apollo.MutationResult<GetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;
export const GetEventDetailsDocument = gql`
    query GetEventDetails($eventId: uuid!) {
  schedule_Event_by_pk(id: $eventId) {
    ...RoomEventDetails
  }
}
    ${RoomEventDetailsFragmentDoc}`;

/**
 * __useGetEventDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
      }
export function useGetEventDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
        }
export type GetEventDetailsQueryHookResult = ReturnType<typeof useGetEventDetailsQuery>;
export type GetEventDetailsLazyQueryHookResult = ReturnType<typeof useGetEventDetailsLazyQuery>;
export type GetEventDetailsQueryResult = Apollo.QueryResult<GetEventDetailsQuery, GetEventDetailsQueryVariables>;
export const ImmediateSwitch_GetElementsDocument = gql`
    query ImmediateSwitch_GetElements($eventId: uuid!) {
  schedule_Event_by_pk(id: $eventId) {
    id
    item {
      id
      elements(where: {typeName: {_eq: VIDEO_BROADCAST}}) {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useImmediateSwitch_GetElementsQuery__
 *
 * To run a query within a React component, call `useImmediateSwitch_GetElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useImmediateSwitch_GetElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useImmediateSwitch_GetElementsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useImmediateSwitch_GetElementsQuery(baseOptions: Apollo.QueryHookOptions<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>(ImmediateSwitch_GetElementsDocument, options);
      }
export function useImmediateSwitch_GetElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>(ImmediateSwitch_GetElementsDocument, options);
        }
export type ImmediateSwitch_GetElementsQueryHookResult = ReturnType<typeof useImmediateSwitch_GetElementsQuery>;
export type ImmediateSwitch_GetElementsLazyQueryHookResult = ReturnType<typeof useImmediateSwitch_GetElementsLazyQuery>;
export type ImmediateSwitch_GetElementsQueryResult = Apollo.QueryResult<ImmediateSwitch_GetElementsQuery, ImmediateSwitch_GetElementsQueryVariables>;
export const ImmediateSwitch_CreateDocument = gql`
    mutation ImmediateSwitch_Create($data: jsonb!, $eventId: uuid!, $conferenceId: uuid!) {
  insert_video_ImmediateSwitch_one(
    object: {data: $data, eventId: $eventId, conferenceId: $conferenceId}
  ) {
    id
  }
}
    `;
export type ImmediateSwitch_CreateMutationFn = Apollo.MutationFunction<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>;

/**
 * __useImmediateSwitch_CreateMutation__
 *
 * To run a mutation, you first call `useImmediateSwitch_CreateMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImmediateSwitch_CreateMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [immediateSwitchCreateMutation, { data, loading, error }] = useImmediateSwitch_CreateMutation({
 *   variables: {
 *      data: // value for 'data'
 *      eventId: // value for 'eventId'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useImmediateSwitch_CreateMutation(baseOptions?: Apollo.MutationHookOptions<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>(ImmediateSwitch_CreateDocument, options);
      }
export type ImmediateSwitch_CreateMutationHookResult = ReturnType<typeof useImmediateSwitch_CreateMutation>;
export type ImmediateSwitch_CreateMutationResult = Apollo.MutationResult<ImmediateSwitch_CreateMutation>;
export type ImmediateSwitch_CreateMutationOptions = Apollo.BaseMutationOptions<ImmediateSwitch_CreateMutation, ImmediateSwitch_CreateMutationVariables>;
export const ApproveEventRoomJoinRequestDocument = gql`
    mutation ApproveEventRoomJoinRequest($eventRoomJoinRequestId: uuid!) {
  update_schedule_EventRoomJoinRequest_by_pk(
    pk_columns: {id: $eventRoomJoinRequestId}
    _set: {approved: true}
  ) {
    id
  }
}
    `;
export type ApproveEventRoomJoinRequestMutationFn = Apollo.MutationFunction<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>;

/**
 * __useApproveEventRoomJoinRequestMutation__
 *
 * To run a mutation, you first call `useApproveEventRoomJoinRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveEventRoomJoinRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveEventRoomJoinRequestMutation, { data, loading, error }] = useApproveEventRoomJoinRequestMutation({
 *   variables: {
 *      eventRoomJoinRequestId: // value for 'eventRoomJoinRequestId'
 *   },
 * });
 */
export function useApproveEventRoomJoinRequestMutation(baseOptions?: Apollo.MutationHookOptions<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>(ApproveEventRoomJoinRequestDocument, options);
      }
export type ApproveEventRoomJoinRequestMutationHookResult = ReturnType<typeof useApproveEventRoomJoinRequestMutation>;
export type ApproveEventRoomJoinRequestMutationResult = Apollo.MutationResult<ApproveEventRoomJoinRequestMutation>;
export type ApproveEventRoomJoinRequestMutationOptions = Apollo.BaseMutationOptions<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>;
export const LiveIndicator_GetLatestDocument = gql`
    query LiveIndicator_GetLatest($eventId: uuid!) {
  video_ImmediateSwitch(
    order_by: {executedAt: desc_nulls_last}
    where: {eventId: {_eq: $eventId}, executedAt: {_is_null: false}}
    limit: 1
  ) {
    id
    data
    executedAt
  }
}
    `;

/**
 * __useLiveIndicator_GetLatestQuery__
 *
 * To run a query within a React component, call `useLiveIndicator_GetLatestQuery` and pass it any options that fit your needs.
 * When your component renders, `useLiveIndicator_GetLatestQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLiveIndicator_GetLatestQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useLiveIndicator_GetLatestQuery(baseOptions: Apollo.QueryHookOptions<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>(LiveIndicator_GetLatestDocument, options);
      }
export function useLiveIndicator_GetLatestLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>(LiveIndicator_GetLatestDocument, options);
        }
export type LiveIndicator_GetLatestQueryHookResult = ReturnType<typeof useLiveIndicator_GetLatestQuery>;
export type LiveIndicator_GetLatestLazyQueryHookResult = ReturnType<typeof useLiveIndicator_GetLatestLazyQuery>;
export type LiveIndicator_GetLatestQueryResult = Apollo.QueryResult<LiveIndicator_GetLatestQuery, LiveIndicator_GetLatestQueryVariables>;
export const LiveIndicator_GetElementDocument = gql`
    query LiveIndicator_GetElement($elementId: uuid!) {
  content_Element_by_pk(id: $elementId) {
    id
    data
  }
}
    `;

/**
 * __useLiveIndicator_GetElementQuery__
 *
 * To run a query within a React component, call `useLiveIndicator_GetElementQuery` and pass it any options that fit your needs.
 * When your component renders, `useLiveIndicator_GetElementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useLiveIndicator_GetElementQuery({
 *   variables: {
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useLiveIndicator_GetElementQuery(baseOptions: Apollo.QueryHookOptions<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>(LiveIndicator_GetElementDocument, options);
      }
export function useLiveIndicator_GetElementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>(LiveIndicator_GetElementDocument, options);
        }
export type LiveIndicator_GetElementQueryHookResult = ReturnType<typeof useLiveIndicator_GetElementQuery>;
export type LiveIndicator_GetElementLazyQueryHookResult = ReturnType<typeof useLiveIndicator_GetElementLazyQuery>;
export type LiveIndicator_GetElementQueryResult = Apollo.QueryResult<LiveIndicator_GetElementQuery, LiveIndicator_GetElementQueryVariables>;
export const GetBreakoutRoomFromEventDocument = gql`
    query GetBreakoutRoomFromEvent($originatingEventId: uuid!) {
  room_Room(where: {originatingEventId: {_eq: $originatingEventId}}) {
    id
  }
}
    `;

/**
 * __useGetBreakoutRoomFromEventQuery__
 *
 * To run a query within a React component, call `useGetBreakoutRoomFromEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBreakoutRoomFromEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBreakoutRoomFromEventQuery({
 *   variables: {
 *      originatingEventId: // value for 'originatingEventId'
 *   },
 * });
 */
export function useGetBreakoutRoomFromEventQuery(baseOptions: Apollo.QueryHookOptions<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>(GetBreakoutRoomFromEventDocument, options);
      }
export function useGetBreakoutRoomFromEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>(GetBreakoutRoomFromEventDocument, options);
        }
export type GetBreakoutRoomFromEventQueryHookResult = ReturnType<typeof useGetBreakoutRoomFromEventQuery>;
export type GetBreakoutRoomFromEventLazyQueryHookResult = ReturnType<typeof useGetBreakoutRoomFromEventLazyQuery>;
export type GetBreakoutRoomFromEventQueryResult = Apollo.QueryResult<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>;
export const MakeEventRoomJoinRequestDocument = gql`
    mutation MakeEventRoomJoinRequest($registrantId: uuid!, $conferenceId: uuid!, $eventId: uuid!) {
  insert_schedule_EventRoomJoinRequest_one(
    object: {registrantId: $registrantId, conferenceId: $conferenceId, eventId: $eventId}
  ) {
    id
  }
}
    `;
export type MakeEventRoomJoinRequestMutationFn = Apollo.MutationFunction<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>;

/**
 * __useMakeEventRoomJoinRequestMutation__
 *
 * To run a mutation, you first call `useMakeEventRoomJoinRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMakeEventRoomJoinRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [makeEventRoomJoinRequestMutation, { data, loading, error }] = useMakeEventRoomJoinRequestMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useMakeEventRoomJoinRequestMutation(baseOptions?: Apollo.MutationHookOptions<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>(MakeEventRoomJoinRequestDocument, options);
      }
export type MakeEventRoomJoinRequestMutationHookResult = ReturnType<typeof useMakeEventRoomJoinRequestMutation>;
export type MakeEventRoomJoinRequestMutationResult = Apollo.MutationResult<MakeEventRoomJoinRequestMutation>;
export type MakeEventRoomJoinRequestMutationOptions = Apollo.BaseMutationOptions<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>;
export const MyEventRoomJoinRequestDocument = gql`
    subscription MyEventRoomJoinRequest($registrantId: uuid!, $conferenceId: uuid!, $eventId: uuid!) {
  schedule_EventRoomJoinRequest(
    where: {registrantId: {_eq: $registrantId}, conferenceId: {_eq: $conferenceId}, eventId: {_eq: $eventId}}
  ) {
    id
    approved
  }
}
    `;

/**
 * __useMyEventRoomJoinRequestSubscription__
 *
 * To run a query within a React component, call `useMyEventRoomJoinRequestSubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyEventRoomJoinRequestSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyEventRoomJoinRequestSubscription({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useMyEventRoomJoinRequestSubscription(baseOptions: Apollo.SubscriptionHookOptions<MyEventRoomJoinRequestSubscription, MyEventRoomJoinRequestSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<MyEventRoomJoinRequestSubscription, MyEventRoomJoinRequestSubscriptionVariables>(MyEventRoomJoinRequestDocument, options);
      }
export type MyEventRoomJoinRequestSubscriptionHookResult = ReturnType<typeof useMyEventRoomJoinRequestSubscription>;
export type MyEventRoomJoinRequestSubscriptionResult = Apollo.SubscriptionResult<MyEventRoomJoinRequestSubscription>;
export const Room_GetEventsDocument = gql`
    query Room_GetEvents($roomId: uuid!, $now: timestamptz!, $cutoff: timestamptz!) {
  schedule_Event(
    where: {roomId: {_eq: $roomId}, endTime: {_gte: $now}, startTime: {_lte: $cutoff}}
  ) {
    ...Room_EventSummary
  }
}
    ${Room_EventSummaryFragmentDoc}`;

/**
 * __useRoom_GetEventsQuery__
 *
 * To run a query within a React component, call `useRoom_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetEventsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *      now: // value for 'now'
 *      cutoff: // value for 'cutoff'
 *   },
 * });
 */
export function useRoom_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, options);
      }
export function useRoom_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, options);
        }
export type Room_GetEventsQueryHookResult = ReturnType<typeof useRoom_GetEventsQuery>;
export type Room_GetEventsLazyQueryHookResult = ReturnType<typeof useRoom_GetEventsLazyQuery>;
export type Room_GetEventsQueryResult = Apollo.QueryResult<Room_GetEventsQuery, Room_GetEventsQueryVariables>;
export const Room_GetEventBreakoutRoomDocument = gql`
    query Room_GetEventBreakoutRoom($originatingItemId: uuid!) {
  room_Room(
    where: {originatingEventId: {_is_null: true}, originatingItemId: {_eq: $originatingItemId}}
    order_by: {created_at: asc}
    limit: 1
  ) {
    id
  }
}
    `;

/**
 * __useRoom_GetEventBreakoutRoomQuery__
 *
 * To run a query within a React component, call `useRoom_GetEventBreakoutRoomQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetEventBreakoutRoomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetEventBreakoutRoomQuery({
 *   variables: {
 *      originatingItemId: // value for 'originatingItemId'
 *   },
 * });
 */
export function useRoom_GetEventBreakoutRoomQuery(baseOptions: Apollo.QueryHookOptions<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>(Room_GetEventBreakoutRoomDocument, options);
      }
export function useRoom_GetEventBreakoutRoomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>(Room_GetEventBreakoutRoomDocument, options);
        }
export type Room_GetEventBreakoutRoomQueryHookResult = ReturnType<typeof useRoom_GetEventBreakoutRoomQuery>;
export type Room_GetEventBreakoutRoomLazyQueryHookResult = ReturnType<typeof useRoom_GetEventBreakoutRoomLazyQuery>;
export type Room_GetEventBreakoutRoomQueryResult = Apollo.QueryResult<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>;
export const Room_GetDefaultVideoRoomBackendDocument = gql`
    query Room_GetDefaultVideoRoomBackend {
  system_Configuration_by_pk(key: DEFAULT_VIDEO_ROOM_BACKEND) {
    value
  }
}
    `;

/**
 * __useRoom_GetDefaultVideoRoomBackendQuery__
 *
 * To run a query within a React component, call `useRoom_GetDefaultVideoRoomBackendQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetDefaultVideoRoomBackendQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetDefaultVideoRoomBackendQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoom_GetDefaultVideoRoomBackendQuery(baseOptions?: Apollo.QueryHookOptions<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>(Room_GetDefaultVideoRoomBackendDocument, options);
      }
export function useRoom_GetDefaultVideoRoomBackendLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>(Room_GetDefaultVideoRoomBackendDocument, options);
        }
export type Room_GetDefaultVideoRoomBackendQueryHookResult = ReturnType<typeof useRoom_GetDefaultVideoRoomBackendQuery>;
export type Room_GetDefaultVideoRoomBackendLazyQueryHookResult = ReturnType<typeof useRoom_GetDefaultVideoRoomBackendLazyQuery>;
export type Room_GetDefaultVideoRoomBackendQueryResult = Apollo.QueryResult<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>;
export const AddParticipantToRoomDocument = gql`
    mutation AddParticipantToRoom($registrantId: uuid!, $roomId: uuid!) {
  insert_room_RoomPerson_one(
    object: {registrantId: $registrantId, roomId: $roomId, personRoleName: PARTICIPANT}
  ) {
    id
  }
}
    `;
export type AddParticipantToRoomMutationFn = Apollo.MutationFunction<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;

/**
 * __useAddParticipantToRoomMutation__
 *
 * To run a mutation, you first call `useAddParticipantToRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddParticipantToRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addParticipantToRoomMutation, { data, loading, error }] = useAddParticipantToRoomMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useAddParticipantToRoomMutation(baseOptions?: Apollo.MutationHookOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>(AddParticipantToRoomDocument, options);
      }
export type AddParticipantToRoomMutationHookResult = ReturnType<typeof useAddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationResult = Apollo.MutationResult<AddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationOptions = Apollo.BaseMutationOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;
export const GetAllRoomsDocument = gql`
    query GetAllRooms($conferenceId: uuid!) {
  socialRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatoryPin: {_eq: true}}}]}, originatingItemId: {_is_null: true}, originatingEventId: {_is_null: true}, managementModeName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
  programRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, events: {}, managementModeName: {_in: [PUBLIC, PRIVATE]}, _or: [{originatingItemId: {_is_null: true}}, {originatingItem: {typeName: {_neq: SPONSOR}}}]}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;

/**
 * __useGetAllRoomsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetAllRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, options);
      }
export function useGetAllRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, options);
        }
export type GetAllRoomsQueryHookResult = ReturnType<typeof useGetAllRoomsQuery>;
export type GetAllRoomsLazyQueryHookResult = ReturnType<typeof useGetAllRoomsLazyQuery>;
export type GetAllRoomsQueryResult = Apollo.QueryResult<GetAllRoomsQuery, GetAllRoomsQueryVariables>;
export const GetAllTodaysRoomsDocument = gql`
    query GetAllTodaysRooms($conferenceId: uuid!, $todayStart: timestamptz!, $todayEnd: timestamptz!) {
  socialOrDiscussionRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatorySubscribe: {_eq: true}}}]}, _or: [{originatingItemId: {_is_null: true}}, {originatingItem: {typeName: {_neq: SPONSOR}}}], managementModeName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
  programRooms: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, events: {startTime: {_lte: $todayEnd}, endTime: {_gte: $todayStart}}, _or: [{originatingItemId: {_is_null: true}}, {originatingItem: {typeName: {_neq: SPONSOR}}}], managementModeName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;

/**
 * __useGetAllTodaysRoomsQuery__
 *
 * To run a query within a React component, call `useGetAllTodaysRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllTodaysRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllTodaysRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      todayStart: // value for 'todayStart'
 *      todayEnd: // value for 'todayEnd'
 *   },
 * });
 */
export function useGetAllTodaysRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>(GetAllTodaysRoomsDocument, options);
      }
export function useGetAllTodaysRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>(GetAllTodaysRoomsDocument, options);
        }
export type GetAllTodaysRoomsQueryHookResult = ReturnType<typeof useGetAllTodaysRoomsQuery>;
export type GetAllTodaysRoomsLazyQueryHookResult = ReturnType<typeof useGetAllTodaysRoomsLazyQuery>;
export type GetAllTodaysRoomsQueryResult = Apollo.QueryResult<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>;
export const RoomPage_GetRoomDetailsDocument = gql`
    query RoomPage_GetRoomDetails($roomId: uuid!) {
  room_Room_by_pk(id: $roomId) {
    ...RoomPage_RoomDetails
  }
}
    ${RoomPage_RoomDetailsFragmentDoc}`;

/**
 * __useRoomPage_GetRoomDetailsQuery__
 *
 * To run a query within a React component, call `useRoomPage_GetRoomDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomPage_GetRoomDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomPage_GetRoomDetailsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useRoomPage_GetRoomDetailsQuery(baseOptions: Apollo.QueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, options);
      }
export function useRoomPage_GetRoomDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, options);
        }
export type RoomPage_GetRoomDetailsQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsQuery>;
export type RoomPage_GetRoomDetailsLazyQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsLazyQuery>;
export type RoomPage_GetRoomDetailsQueryResult = Apollo.QueryResult<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>;
export const GetEventVonageDetailsDocument = gql`
    query GetEventVonageDetails($eventId: uuid!) {
  schedule_Event_by_pk(id: $eventId) {
    eventVonageSession {
      sessionId
      id
    }
    id
  }
}
    `;

/**
 * __useGetEventVonageDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventVonageDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventVonageDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, options);
      }
export function useGetEventVonageDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, options);
        }
export type GetEventVonageDetailsQueryHookResult = ReturnType<typeof useGetEventVonageDetailsQuery>;
export type GetEventVonageDetailsLazyQueryHookResult = ReturnType<typeof useGetEventVonageDetailsLazyQuery>;
export type GetEventVonageDetailsQueryResult = Apollo.QueryResult<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>;
export const RoomSponsorContent_GetElementsDocument = gql`
    query RoomSponsorContent_GetElements($itemId: uuid!) {
  content_Item(where: {id: {_eq: $itemId}, typeName: {_eq: SPONSOR}}) {
    ...RoomSponsorContent_ItemData
  }
}
    ${RoomSponsorContent_ItemDataFragmentDoc}`;

/**
 * __useRoomSponsorContent_GetElementsQuery__
 *
 * To run a query within a React component, call `useRoomSponsorContent_GetElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomSponsorContent_GetElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomSponsorContent_GetElementsQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useRoomSponsorContent_GetElementsQuery(baseOptions: Apollo.QueryHookOptions<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>(RoomSponsorContent_GetElementsDocument, options);
      }
export function useRoomSponsorContent_GetElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>(RoomSponsorContent_GetElementsDocument, options);
        }
export type RoomSponsorContent_GetElementsQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetElementsQuery>;
export type RoomSponsorContent_GetElementsLazyQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetElementsLazyQuery>;
export type RoomSponsorContent_GetElementsQueryResult = Apollo.QueryResult<RoomSponsorContent_GetElementsQuery, RoomSponsorContent_GetElementsQueryVariables>;
export const Schedule_SelectItemDocument = gql`
    query Schedule_SelectItem($id: uuid!) {
  content_Item_by_pk(id: $id) {
    ...Schedule_Item
  }
}
    ${Schedule_ItemFragmentDoc}`;

/**
 * __useSchedule_SelectItemQuery__
 *
 * To run a query within a React component, call `useSchedule_SelectItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchedule_SelectItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchedule_SelectItemQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSchedule_SelectItemQuery(baseOptions: Apollo.QueryHookOptions<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>(Schedule_SelectItemDocument, options);
      }
export function useSchedule_SelectItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>(Schedule_SelectItemDocument, options);
        }
export type Schedule_SelectItemQueryHookResult = ReturnType<typeof useSchedule_SelectItemQuery>;
export type Schedule_SelectItemLazyQueryHookResult = ReturnType<typeof useSchedule_SelectItemLazyQuery>;
export type Schedule_SelectItemQueryResult = Apollo.QueryResult<Schedule_SelectItemQuery, Schedule_SelectItemQueryVariables>;
export const Schedule_SelectSummariesDocument = gql`
    query Schedule_SelectSummaries($conferenceId: uuid!) {
  room_Room(
    where: {conferenceId: {_eq: $conferenceId}, managementModeName: {_in: [PUBLIC, PRIVATE]}, events: {}}
  ) {
    ...Schedule_RoomSummary
  }
  schedule_Event(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_EventSummary
  }
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_ItemElements
  }
}
    ${Schedule_RoomSummaryFragmentDoc}
${Schedule_EventSummaryFragmentDoc}
${Schedule_ItemElementsFragmentDoc}`;

/**
 * __useSchedule_SelectSummariesQuery__
 *
 * To run a query within a React component, call `useSchedule_SelectSummariesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchedule_SelectSummariesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchedule_SelectSummariesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSchedule_SelectSummariesQuery(baseOptions: Apollo.QueryHookOptions<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>(Schedule_SelectSummariesDocument, options);
      }
export function useSchedule_SelectSummariesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>(Schedule_SelectSummariesDocument, options);
        }
export type Schedule_SelectSummariesQueryHookResult = ReturnType<typeof useSchedule_SelectSummariesQuery>;
export type Schedule_SelectSummariesLazyQueryHookResult = ReturnType<typeof useSchedule_SelectSummariesLazyQuery>;
export type Schedule_SelectSummariesQueryResult = Apollo.QueryResult<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>;
export const GetChannelStacksDocument = gql`
    query GetChannelStacks($conferenceId: uuid!) {
  room_Room(where: {channelStack: {}, conferenceId: {_eq: $conferenceId}}) {
    channelStack {
      cloudFrontDomain
      endpointUri
      id
    }
    name
    id
  }
}
    `;

/**
 * __useGetChannelStacksQuery__
 *
 * To run a query within a React component, call `useGetChannelStacksQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChannelStacksQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChannelStacksQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetChannelStacksQuery(baseOptions: Apollo.QueryHookOptions<GetChannelStacksQuery, GetChannelStacksQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetChannelStacksQuery, GetChannelStacksQueryVariables>(GetChannelStacksDocument, options);
      }
export function useGetChannelStacksLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChannelStacksQuery, GetChannelStacksQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetChannelStacksQuery, GetChannelStacksQueryVariables>(GetChannelStacksDocument, options);
        }
export type GetChannelStacksQueryHookResult = ReturnType<typeof useGetChannelStacksQuery>;
export type GetChannelStacksLazyQueryHookResult = ReturnType<typeof useGetChannelStacksLazyQuery>;
export type GetChannelStacksQueryResult = Apollo.QueryResult<GetChannelStacksQuery, GetChannelStacksQueryVariables>;
export const ConferenceConfiguration_GetConferenceConfigurationsDocument = gql`
    query ConferenceConfiguration_GetConferenceConfigurations($conferenceId: uuid!) {
  conference_Configuration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConferenceConfiguration_ConferenceConfigurations
  }
}
    ${ConferenceConfiguration_ConferenceConfigurationsFragmentDoc}`;

/**
 * __useConferenceConfiguration_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useConferenceConfiguration_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceConfiguration_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceConfiguration_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferenceConfiguration_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>(ConferenceConfiguration_GetConferenceConfigurationsDocument, options);
      }
export function useConferenceConfiguration_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>(ConferenceConfiguration_GetConferenceConfigurationsDocument, options);
        }
export type ConferenceConfiguration_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useConferenceConfiguration_GetConferenceConfigurationsQuery>;
export type ConferenceConfiguration_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useConferenceConfiguration_GetConferenceConfigurationsLazyQuery>;
export type ConferenceConfiguration_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>;
export const Conference_Configuration_UpdateConferenceConfigurationsDocument = gql`
    mutation conference_Configuration_UpdateConferenceConfigurations($conferenceConfigurationId: uuid!, $value: jsonb!) {
  update_conference_Configuration_by_pk(
    pk_columns: {id: $conferenceConfigurationId}
    _set: {value: $value}
  ) {
    id
  }
}
    `;
export type Conference_Configuration_UpdateConferenceConfigurationsMutationFn = Apollo.MutationFunction<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>;

/**
 * __useConference_Configuration_UpdateConferenceConfigurationsMutation__
 *
 * To run a mutation, you first call `useConference_Configuration_UpdateConferenceConfigurationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConference_Configuration_UpdateConferenceConfigurationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [conferenceConfigurationUpdateConferenceConfigurationsMutation, { data, loading, error }] = useConference_Configuration_UpdateConferenceConfigurationsMutation({
 *   variables: {
 *      conferenceConfigurationId: // value for 'conferenceConfigurationId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useConference_Configuration_UpdateConferenceConfigurationsMutation(baseOptions?: Apollo.MutationHookOptions<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>(Conference_Configuration_UpdateConferenceConfigurationsDocument, options);
      }
export type Conference_Configuration_UpdateConferenceConfigurationsMutationHookResult = ReturnType<typeof useConference_Configuration_UpdateConferenceConfigurationsMutation>;
export type Conference_Configuration_UpdateConferenceConfigurationsMutationResult = Apollo.MutationResult<Conference_Configuration_UpdateConferenceConfigurationsMutation>;
export type Conference_Configuration_UpdateConferenceConfigurationsMutationOptions = Apollo.BaseMutationOptions<Conference_Configuration_UpdateConferenceConfigurationsMutation, Conference_Configuration_UpdateConferenceConfigurationsMutationVariables>;
export const EventVonageControls_GetEventsDocument = gql`
    query EventVonageControls_GetEvents($conferenceId: uuid!) {
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [Q_AND_A, PRESENTATION]}}
  ) {
    id
    name
    item {
      id
      title
    }
  }
}
    `;

/**
 * __useEventVonageControls_GetEventsQuery__
 *
 * To run a query within a React component, call `useEventVonageControls_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventVonageControls_GetEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useEventVonageControls_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, options);
      }
export function useEventVonageControls_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, options);
        }
export type EventVonageControls_GetEventsQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsQuery>;
export type EventVonageControls_GetEventsLazyQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsLazyQuery>;
export type EventVonageControls_GetEventsQueryResult = Apollo.QueryResult<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>;
export const EventVonageControls_StopEventBroadcastDocument = gql`
    mutation EventVonageControls_StopEventBroadcast($eventId: uuid!) {
  stopEventBroadcast(eventId: $eventId) {
    broadcastsStopped
  }
}
    `;
export type EventVonageControls_StopEventBroadcastMutationFn = Apollo.MutationFunction<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;

/**
 * __useEventVonageControls_StopEventBroadcastMutation__
 *
 * To run a mutation, you first call `useEventVonageControls_StopEventBroadcastMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_StopEventBroadcastMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [eventVonageControlsStopEventBroadcastMutation, { data, loading, error }] = useEventVonageControls_StopEventBroadcastMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useEventVonageControls_StopEventBroadcastMutation(baseOptions?: Apollo.MutationHookOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>(EventVonageControls_StopEventBroadcastDocument, options);
      }
export type EventVonageControls_StopEventBroadcastMutationHookResult = ReturnType<typeof useEventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationResult = Apollo.MutationResult<EventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationOptions = Apollo.BaseMutationOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;
export const CreateConferencePrepareJobDocument = gql`
    mutation CreateConferencePrepareJob($conferenceId: uuid!) {
  insert_conference_PrepareJob_one(object: {conferenceId: $conferenceId}) {
    id
    conferenceId
  }
}
    `;
export type CreateConferencePrepareJobMutationFn = Apollo.MutationFunction<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;

/**
 * __useCreateConferencePrepareJobMutation__
 *
 * To run a mutation, you first call `useCreateConferencePrepareJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferencePrepareJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferencePrepareJobMutation, { data, loading, error }] = useCreateConferencePrepareJobMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateConferencePrepareJobMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>(CreateConferencePrepareJobDocument, options);
      }
export type CreateConferencePrepareJobMutationHookResult = ReturnType<typeof useCreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationResult = Apollo.MutationResult<CreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationOptions = Apollo.BaseMutationOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;
export const ConferencePrepareJobSubscriptionDocument = gql`
    subscription ConferencePrepareJobSubscription($conferenceId: uuid!) {
  conference_PrepareJob(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {createdAt: desc}
    limit: 10
  ) {
    id
    jobStatusName
    message
    updatedAt
    createdAt
    videoRenderJobs {
      id
      jobStatusName
      updated_at
      created_at
    }
  }
}
    `;

/**
 * __useConferencePrepareJobSubscriptionSubscription__
 *
 * To run a query within a React component, call `useConferencePrepareJobSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useConferencePrepareJobSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferencePrepareJobSubscriptionSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferencePrepareJobSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>(ConferencePrepareJobSubscriptionDocument, options);
      }
export type ConferencePrepareJobSubscriptionSubscriptionHookResult = ReturnType<typeof useConferencePrepareJobSubscriptionSubscription>;
export type ConferencePrepareJobSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ConferencePrepareJobSubscriptionSubscription>;
export const PreshowChecklistDocument = gql`
    query PreshowChecklist($conferenceId: uuid!) {
  requiredProgramPeopleNotLinkedToRegistrant: collection_ProgramPerson(
    where: {conferenceId: {_eq: $conferenceId}, eventPeople: {event: {intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}}}, registrantId: {_is_null: true}}
  ) {
    id
    name
    affiliation
    email
  }
  requiredProgramPeopleNotRegistered: collection_ProgramPerson(
    where: {conferenceId: {_eq: $conferenceId}, eventPeople: {event: {intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}}}, registrant: {userId: {_is_null: true}}}
  ) {
    id
    name
    affiliation
    email
  }
  submissionsNotReceived: content_UploadableElement(
    where: {conferenceId: {_eq: $conferenceId}, _not: {element: {}}}
  ) {
    id
    name
    typeName
    item {
      id
      title
    }
  }
  livestreamEventsWithoutRegisteredPresenter: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, _not: {eventPeople: {roleName: {_eq: PRESENTER}, person: {registrantId: {_is_null: false}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  livestreamEventsWithoutRegisteredChair: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, _not: {eventPeople: {roleName: {_eq: CHAIR}, person: {registrantId: {_is_null: false}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  prerecordedEventsWithoutVideo: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_eq: PRERECORDED}, _not: {item: {elements: {typeName: {_eq: VIDEO_BROADCAST}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  prerecordedEventsWithVideo: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_eq: PRERECORDED}, item: {elements: {typeName: {_eq: VIDEO_BROADCAST}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
      elements(where: {typeName: {_eq: VIDEO_BROADCAST}}) {
        id
        name
        data
      }
    }
  }
  allLiveEventsWithPeople: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}}
  ) {
    id
    name
    intendedRoomModeName
    room {
      id
      name
    }
    item {
      id
      title
      itemPeopleWithRegistrant: itemPeople(
        where: {person: {registrantId: {_is_null: false}}}
      ) {
        personId
      }
      itemPeopleWithoutRegistrant: itemPeople(
        where: {person: {registrantId: {_is_null: true}}}
      ) {
        personId
      }
    }
    exhibition {
      id
      name
    }
    startTime
    endTime
    eventPeople {
      id
      personId
    }
  }
  emptyExhibitions: collection_Exhibition(
    where: {conferenceId: {_eq: $conferenceId}, _not: {items: {}}}
  ) {
    id
    name
  }
  emptyTags: collection_Tag(
    where: {conferenceId: {_eq: $conferenceId}, _not: {itemTags: {}}}
  ) {
    id
    name
  }
  exhibitionEventsWithoutExhibition: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [EXHIBITION]}, exhibitionId: {_is_null: true}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
  }
  exhibitionEventsWithoutDiscussionRooms: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [EXHIBITION, NONE]}, exhibition: {items: {item: {_not: {rooms: {}}}}}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    exhibition {
      id
      name
      items(where: {item: {_not: {rooms: {}}}}) {
        id
        item {
          id
          title
        }
      }
    }
  }
  liveEventsWithoutContent: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}, itemId: {_is_null: true}}
  ) {
    id
    name
    startTime
    endTime
    item {
      id
      title
    }
    room {
      id
      name
    }
  }
  overlappingEvents: schedule_OverlappingEvents(
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    eventX {
      id
      name
      startTime
      endTime
      room {
        id
        name
      }
    }
    eventY {
      id
      name
      startTime
      endTime
    }
  }
  shortEvents: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, durationSeconds: {_lte: 60}}
  ) {
    id
    name
    startTime
    endTime
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
  roomsWithStreams: room_Room(
    where: {conferenceId: {_eq: $conferenceId}, livestreamDuration: {}}
  ) {
    id
    name
    livestreamDuration {
      sum
    }
  }
  eventsWithNegativeDuration: schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, durationSeconds: {_lt: 0}}
  ) {
    id
    name
    startTime
    durationSeconds
    room {
      id
      name
    }
    item {
      id
      title
    }
  }
}
    `;

/**
 * __usePreshowChecklistQuery__
 *
 * To run a query within a React component, call `usePreshowChecklistQuery` and pass it any options that fit your needs.
 * When your component renders, `usePreshowChecklistQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = usePreshowChecklistQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function usePreshowChecklistQuery(baseOptions: Apollo.QueryHookOptions<PreshowChecklistQuery, PreshowChecklistQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<PreshowChecklistQuery, PreshowChecklistQueryVariables>(PreshowChecklistDocument, options);
      }
export function usePreshowChecklistLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<PreshowChecklistQuery, PreshowChecklistQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<PreshowChecklistQuery, PreshowChecklistQueryVariables>(PreshowChecklistDocument, options);
        }
export type PreshowChecklistQueryHookResult = ReturnType<typeof usePreshowChecklistQuery>;
export type PreshowChecklistLazyQueryHookResult = ReturnType<typeof usePreshowChecklistLazyQuery>;
export type PreshowChecklistQueryResult = Apollo.QueryResult<PreshowChecklistQuery, PreshowChecklistQueryVariables>;
export const CombineVideosModal_CreateCombineVideosJobDocument = gql`
    mutation CombineVideosModal_CreateCombineVideosJob($conferenceId: uuid!, $createdByRegistrantId: uuid!, $outputName: String!, $data: jsonb!) {
  insert_job_queues_CombineVideosJob_one(
    object: {conferenceId: $conferenceId, createdByRegistrantId: $createdByRegistrantId, outputName: $outputName, data: $data}
  ) {
    id
  }
}
    `;
export type CombineVideosModal_CreateCombineVideosJobMutationFn = Apollo.MutationFunction<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>;

/**
 * __useCombineVideosModal_CreateCombineVideosJobMutation__
 *
 * To run a mutation, you first call `useCombineVideosModal_CreateCombineVideosJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCombineVideosModal_CreateCombineVideosJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [combineVideosModalCreateCombineVideosJobMutation, { data, loading, error }] = useCombineVideosModal_CreateCombineVideosJobMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      createdByRegistrantId: // value for 'createdByRegistrantId'
 *      outputName: // value for 'outputName'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCombineVideosModal_CreateCombineVideosJobMutation(baseOptions?: Apollo.MutationHookOptions<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>(CombineVideosModal_CreateCombineVideosJobDocument, options);
      }
export type CombineVideosModal_CreateCombineVideosJobMutationHookResult = ReturnType<typeof useCombineVideosModal_CreateCombineVideosJobMutation>;
export type CombineVideosModal_CreateCombineVideosJobMutationResult = Apollo.MutationResult<CombineVideosModal_CreateCombineVideosJobMutation>;
export type CombineVideosModal_CreateCombineVideosJobMutationOptions = Apollo.BaseMutationOptions<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>;
export const CombineVideosModal_GetCombineVideosJobDocument = gql`
    query CombineVideosModal_GetCombineVideosJob($id: uuid!) {
  job_queues_CombineVideosJob_by_pk(id: $id) {
    id
    message
    jobStatusName
  }
}
    `;

/**
 * __useCombineVideosModal_GetCombineVideosJobQuery__
 *
 * To run a query within a React component, call `useCombineVideosModal_GetCombineVideosJobQuery` and pass it any options that fit your needs.
 * When your component renders, `useCombineVideosModal_GetCombineVideosJobQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCombineVideosModal_GetCombineVideosJobQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCombineVideosModal_GetCombineVideosJobQuery(baseOptions: Apollo.QueryHookOptions<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>(CombineVideosModal_GetCombineVideosJobDocument, options);
      }
export function useCombineVideosModal_GetCombineVideosJobLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>(CombineVideosModal_GetCombineVideosJobDocument, options);
        }
export type CombineVideosModal_GetCombineVideosJobQueryHookResult = ReturnType<typeof useCombineVideosModal_GetCombineVideosJobQuery>;
export type CombineVideosModal_GetCombineVideosJobLazyQueryHookResult = ReturnType<typeof useCombineVideosModal_GetCombineVideosJobLazyQuery>;
export type CombineVideosModal_GetCombineVideosJobQueryResult = Apollo.QueryResult<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>;
export const Item_CreateRoomDocument = gql`
    mutation Item_CreateRoom($conferenceId: uuid!, $itemId: uuid!) {
  createItemRoom(conferenceId: $conferenceId, itemId: $itemId) {
    roomId
    message
  }
}
    `;
export type Item_CreateRoomMutationFn = Apollo.MutationFunction<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>;

/**
 * __useItem_CreateRoomMutation__
 *
 * To run a mutation, you first call `useItem_CreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useItem_CreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [itemCreateRoomMutation, { data, loading, error }] = useItem_CreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useItem_CreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>(Item_CreateRoomDocument, options);
      }
export type Item_CreateRoomMutationHookResult = ReturnType<typeof useItem_CreateRoomMutation>;
export type Item_CreateRoomMutationResult = Apollo.MutationResult<Item_CreateRoomMutation>;
export type Item_CreateRoomMutationOptions = Apollo.BaseMutationOptions<Item_CreateRoomMutation, Item_CreateRoomMutationVariables>;
export const SubmissionRequestsModal_GetConferenceConfigurationsDocument = gql`
    query SubmissionRequestsModal_GetConferenceConfigurations($conferenceId: uuid!) {
  conference_Configuration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConfigureEmailTemplates_ConferenceConfiguration
  }
}
    ${ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc}`;

/**
 * __useSubmissionRequestsModal_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useSubmissionRequestsModal_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissionRequestsModal_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissionRequestsModal_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSubmissionRequestsModal_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>(SubmissionRequestsModal_GetConferenceConfigurationsDocument, options);
      }
export function useSubmissionRequestsModal_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>(SubmissionRequestsModal_GetConferenceConfigurationsDocument, options);
        }
export type SubmissionRequestsModal_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useSubmissionRequestsModal_GetConferenceConfigurationsQuery>;
export type SubmissionRequestsModal_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useSubmissionRequestsModal_GetConferenceConfigurationsLazyQuery>;
export type SubmissionRequestsModal_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>;
export const InsertSubmissionRequestEmailJobsDocument = gql`
    mutation InsertSubmissionRequestEmailJobs($objs: [job_queues_SubmissionRequestEmailJob_insert_input!]!) {
  insert_job_queues_SubmissionRequestEmailJob(objects: $objs) {
    affected_rows
  }
}
    `;
export type InsertSubmissionRequestEmailJobsMutationFn = Apollo.MutationFunction<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;

/**
 * __useInsertSubmissionRequestEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertSubmissionRequestEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertSubmissionRequestEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertSubmissionRequestEmailJobsMutation, { data, loading, error }] = useInsertSubmissionRequestEmailJobsMutation({
 *   variables: {
 *      objs: // value for 'objs'
 *   },
 * });
 */
export function useInsertSubmissionRequestEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>(InsertSubmissionRequestEmailJobsDocument, options);
      }
export type InsertSubmissionRequestEmailJobsMutationHookResult = ReturnType<typeof useInsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationResult = Apollo.MutationResult<InsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;
export const SelectAllContentDocument = gql`
    query SelectAllContent($conferenceId: uuid!) {
  content_Item(
    where: {conferenceId: {_eq: $conferenceId}, typeName: {_neq: SPONSOR}}
  ) {
    ...ItemFullNestedInfo
  }
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ProgramPersonInfo
  }
  conference_OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ExhibitionInfo
  }
}
    ${ItemFullNestedInfoFragmentDoc}
${ProgramPersonInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${ExhibitionInfoFragmentDoc}`;

/**
 * __useSelectAllContentQuery__
 *
 * To run a query within a React component, call `useSelectAllContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllContentQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllContentQuery(baseOptions: Apollo.QueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, options);
      }
export function useSelectAllContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, options);
        }
export type SelectAllContentQueryHookResult = ReturnType<typeof useSelectAllContentQuery>;
export type SelectAllContentLazyQueryHookResult = ReturnType<typeof useSelectAllContentLazyQuery>;
export type SelectAllContentQueryResult = Apollo.QueryResult<SelectAllContentQuery, SelectAllContentQueryVariables>;
export const InsertDeleteItemsDocument = gql`
    mutation InsertDeleteItems($newGroups: [content_Item_insert_input!]!, $deleteGroupIds: [uuid!]!) {
  insert_content_Item(objects: $newGroups) {
    returning {
      ...ItemFullNestedInfo
    }
  }
  delete_content_Item(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
}
    ${ItemFullNestedInfoFragmentDoc}`;
export type InsertDeleteItemsMutationFn = Apollo.MutationFunction<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>;

/**
 * __useInsertDeleteItemsMutation__
 *
 * To run a mutation, you first call `useInsertDeleteItemsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertDeleteItemsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertDeleteItemsMutation, { data, loading, error }] = useInsertDeleteItemsMutation({
 *   variables: {
 *      newGroups: // value for 'newGroups'
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *   },
 * });
 */
export function useInsertDeleteItemsMutation(baseOptions?: Apollo.MutationHookOptions<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>(InsertDeleteItemsDocument, options);
      }
export type InsertDeleteItemsMutationHookResult = ReturnType<typeof useInsertDeleteItemsMutation>;
export type InsertDeleteItemsMutationResult = Apollo.MutationResult<InsertDeleteItemsMutation>;
export type InsertDeleteItemsMutationOptions = Apollo.BaseMutationOptions<InsertDeleteItemsMutation, InsertDeleteItemsMutationVariables>;
export const InsertOriginatingDatasDocument = gql`
    mutation InsertOriginatingDatas($newDatas: [conference_OriginatingData_insert_input!]!) {
  insert_conference_OriginatingData(objects: $newDatas) {
    returning {
      ...OriginatingDataInfo
    }
  }
}
    ${OriginatingDataInfoFragmentDoc}`;
export type InsertOriginatingDatasMutationFn = Apollo.MutationFunction<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;

/**
 * __useInsertOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useInsertOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertOriginatingDatasMutation, { data, loading, error }] = useInsertOriginatingDatasMutation({
 *   variables: {
 *      newDatas: // value for 'newDatas'
 *   },
 * });
 */
export function useInsertOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>(InsertOriginatingDatasDocument, options);
      }
export type InsertOriginatingDatasMutationHookResult = ReturnType<typeof useInsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationResult = Apollo.MutationResult<InsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;
export const DeleteOriginatingDatasDocument = gql`
    mutation DeleteOriginatingDatas($deleteDataIds: [uuid!]!) {
  delete_conference_OriginatingData(where: {id: {_in: $deleteDataIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteOriginatingDatasMutationFn = Apollo.MutationFunction<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;

/**
 * __useDeleteOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useDeleteOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOriginatingDatasMutation, { data, loading, error }] = useDeleteOriginatingDatasMutation({
 *   variables: {
 *      deleteDataIds: // value for 'deleteDataIds'
 *   },
 * });
 */
export function useDeleteOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>(DeleteOriginatingDatasDocument, options);
      }
export type DeleteOriginatingDatasMutationHookResult = ReturnType<typeof useDeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationResult = Apollo.MutationResult<DeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;
export const InsertTagsDocument = gql`
    mutation InsertTags($newTags: [collection_Tag_insert_input!]!) {
  insert_collection_Tag(objects: $newTags) {
    returning {
      ...TagInfo
    }
  }
}
    ${TagInfoFragmentDoc}`;
export type InsertTagsMutationFn = Apollo.MutationFunction<InsertTagsMutation, InsertTagsMutationVariables>;

/**
 * __useInsertTagsMutation__
 *
 * To run a mutation, you first call `useInsertTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertTagsMutation, { data, loading, error }] = useInsertTagsMutation({
 *   variables: {
 *      newTags: // value for 'newTags'
 *   },
 * });
 */
export function useInsertTagsMutation(baseOptions?: Apollo.MutationHookOptions<InsertTagsMutation, InsertTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertTagsMutation, InsertTagsMutationVariables>(InsertTagsDocument, options);
      }
export type InsertTagsMutationHookResult = ReturnType<typeof useInsertTagsMutation>;
export type InsertTagsMutationResult = Apollo.MutationResult<InsertTagsMutation>;
export type InsertTagsMutationOptions = Apollo.BaseMutationOptions<InsertTagsMutation, InsertTagsMutationVariables>;
export const InsertExhibitionsDocument = gql`
    mutation InsertExhibitions($newExhibitions: [collection_Exhibition_insert_input!]!) {
  insert_collection_Exhibition(objects: $newExhibitions) {
    returning {
      ...ExhibitionInfo
    }
  }
}
    ${ExhibitionInfoFragmentDoc}`;
export type InsertExhibitionsMutationFn = Apollo.MutationFunction<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>;

/**
 * __useInsertExhibitionsMutation__
 *
 * To run a mutation, you first call `useInsertExhibitionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertExhibitionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertExhibitionsMutation, { data, loading, error }] = useInsertExhibitionsMutation({
 *   variables: {
 *      newExhibitions: // value for 'newExhibitions'
 *   },
 * });
 */
export function useInsertExhibitionsMutation(baseOptions?: Apollo.MutationHookOptions<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>(InsertExhibitionsDocument, options);
      }
export type InsertExhibitionsMutationHookResult = ReturnType<typeof useInsertExhibitionsMutation>;
export type InsertExhibitionsMutationResult = Apollo.MutationResult<InsertExhibitionsMutation>;
export type InsertExhibitionsMutationOptions = Apollo.BaseMutationOptions<InsertExhibitionsMutation, InsertExhibitionsMutationVariables>;
export const DeleteTagsDocument = gql`
    mutation DeleteTags($deleteTagIds: [uuid!]!) {
  delete_collection_Tag(where: {id: {_in: $deleteTagIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteTagsMutationFn = Apollo.MutationFunction<DeleteTagsMutation, DeleteTagsMutationVariables>;

/**
 * __useDeleteTagsMutation__
 *
 * To run a mutation, you first call `useDeleteTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTagsMutation, { data, loading, error }] = useDeleteTagsMutation({
 *   variables: {
 *      deleteTagIds: // value for 'deleteTagIds'
 *   },
 * });
 */
export function useDeleteTagsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTagsMutation, DeleteTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTagsMutation, DeleteTagsMutationVariables>(DeleteTagsDocument, options);
      }
export type DeleteTagsMutationHookResult = ReturnType<typeof useDeleteTagsMutation>;
export type DeleteTagsMutationResult = Apollo.MutationResult<DeleteTagsMutation>;
export type DeleteTagsMutationOptions = Apollo.BaseMutationOptions<DeleteTagsMutation, DeleteTagsMutationVariables>;
export const DeleteExhibitionsDocument = gql`
    mutation DeleteExhibitions($deleteExhibitionIds: [uuid!]!) {
  delete_collection_Exhibition(where: {id: {_in: $deleteExhibitionIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteExhibitionsMutationFn = Apollo.MutationFunction<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>;

/**
 * __useDeleteExhibitionsMutation__
 *
 * To run a mutation, you first call `useDeleteExhibitionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteExhibitionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteExhibitionsMutation, { data, loading, error }] = useDeleteExhibitionsMutation({
 *   variables: {
 *      deleteExhibitionIds: // value for 'deleteExhibitionIds'
 *   },
 * });
 */
export function useDeleteExhibitionsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>(DeleteExhibitionsDocument, options);
      }
export type DeleteExhibitionsMutationHookResult = ReturnType<typeof useDeleteExhibitionsMutation>;
export type DeleteExhibitionsMutationResult = Apollo.MutationResult<DeleteExhibitionsMutation>;
export type DeleteExhibitionsMutationOptions = Apollo.BaseMutationOptions<DeleteExhibitionsMutation, DeleteExhibitionsMutationVariables>;
export const InsertProgramPeopleDocument = gql`
    mutation InsertProgramPeople($newPeople: [collection_ProgramPerson_insert_input!]!) {
  insert_collection_ProgramPerson(objects: $newPeople) {
    returning {
      ...ProgramPersonInfo
    }
  }
}
    ${ProgramPersonInfoFragmentDoc}`;
export type InsertProgramPeopleMutationFn = Apollo.MutationFunction<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>;

/**
 * __useInsertProgramPeopleMutation__
 *
 * To run a mutation, you first call `useInsertProgramPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertProgramPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertProgramPeopleMutation, { data, loading, error }] = useInsertProgramPeopleMutation({
 *   variables: {
 *      newPeople: // value for 'newPeople'
 *   },
 * });
 */
export function useInsertProgramPeopleMutation(baseOptions?: Apollo.MutationHookOptions<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>(InsertProgramPeopleDocument, options);
      }
export type InsertProgramPeopleMutationHookResult = ReturnType<typeof useInsertProgramPeopleMutation>;
export type InsertProgramPeopleMutationResult = Apollo.MutationResult<InsertProgramPeopleMutation>;
export type InsertProgramPeopleMutationOptions = Apollo.BaseMutationOptions<InsertProgramPeopleMutation, InsertProgramPeopleMutationVariables>;
export const DeleteProgramPeopleDocument = gql`
    mutation DeleteProgramPeople($deletePersonIds: [uuid!]!) {
  delete_collection_ProgramPerson(where: {id: {_in: $deletePersonIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteProgramPeopleMutationFn = Apollo.MutationFunction<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>;

/**
 * __useDeleteProgramPeopleMutation__
 *
 * To run a mutation, you first call `useDeleteProgramPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProgramPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProgramPeopleMutation, { data, loading, error }] = useDeleteProgramPeopleMutation({
 *   variables: {
 *      deletePersonIds: // value for 'deletePersonIds'
 *   },
 * });
 */
export function useDeleteProgramPeopleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>(DeleteProgramPeopleDocument, options);
      }
export type DeleteProgramPeopleMutationHookResult = ReturnType<typeof useDeleteProgramPeopleMutation>;
export type DeleteProgramPeopleMutationResult = Apollo.MutationResult<DeleteProgramPeopleMutation>;
export type DeleteProgramPeopleMutationOptions = Apollo.BaseMutationOptions<DeleteProgramPeopleMutation, DeleteProgramPeopleMutationVariables>;
export const UpdateItemDocument = gql`
    mutation UpdateItem($newItems: [content_Element_insert_input!]!, $newUploadableItems: [content_UploadableElement_insert_input!]!, $newGroupTags: [content_ItemTag_insert_input!]!, $newGroupExhibitions: [content_ItemExhibition_insert_input!]!, $groupId: uuid!, $typeName: content_ItemType_enum!, $originatingDataId: uuid = null, $shortTitle: String = null, $title: String!, $deleteItemIds: [uuid!]!, $deleteUploadableItemIds: [uuid!]!, $deleteGroupTagIds: [uuid!]!, $deleteGroupExhibitionIds: [uuid!]!, $newUploaders: [content_Uploader_insert_input!]!, $deleteUploaderIds: [uuid!]!, $newGroupPeople: [content_ItemProgramPerson_insert_input!]!, $deleteGroupPeopleIds: [uuid!]!) {
  insert_content_Element(objects: $newItems) {
    returning {
      ...ElementInfo
    }
  }
  insert_content_UploadableElement(objects: $newUploadableItems) {
    returning {
      ...UploadableElementInfo
    }
  }
  insert_content_ItemTag(objects: $newGroupTags) {
    returning {
      ...ItemTagInfo
    }
  }
  insert_content_ItemExhibition(objects: $newGroupExhibitions) {
    returning {
      ...ItemExhibitionInfo
    }
  }
  insert_content_Uploader(objects: $newUploaders) {
    returning {
      ...UploaderInfo
    }
  }
  insert_content_ItemProgramPerson(objects: $newGroupPeople) {
    returning {
      ...ItemPersonInfo
    }
  }
  update_content_Item_by_pk(
    pk_columns: {id: $groupId}
    _set: {typeName: $typeName, originatingDataId: $originatingDataId, shortTitle: $shortTitle, title: $title}
  ) {
    ...ItemFullNestedInfo
  }
  delete_content_Element(where: {id: {_in: $deleteItemIds}}) {
    returning {
      id
    }
  }
  delete_content_UploadableElement(where: {id: {_in: $deleteUploadableItemIds}}) {
    returning {
      id
    }
  }
  delete_content_ItemTag(
    where: {itemId: {_eq: $groupId}, tagId: {_in: $deleteGroupTagIds}}
  ) {
    returning {
      id
    }
  }
  delete_content_ItemExhibition(where: {id: {_in: $deleteGroupExhibitionIds}}) {
    returning {
      id
    }
  }
  delete_content_Uploader(where: {id: {_in: $deleteUploaderIds}}) {
    returning {
      id
    }
  }
  delete_content_ItemProgramPerson(where: {id: {_in: $deleteGroupPeopleIds}}) {
    returning {
      id
    }
  }
}
    ${ElementInfoFragmentDoc}
${UploadableElementInfoFragmentDoc}
${ItemTagInfoFragmentDoc}
${ItemExhibitionInfoFragmentDoc}
${UploaderInfoFragmentDoc}
${ItemPersonInfoFragmentDoc}
${ItemFullNestedInfoFragmentDoc}`;
export type UpdateItemMutationFn = Apollo.MutationFunction<UpdateItemMutation, UpdateItemMutationVariables>;

/**
 * __useUpdateItemMutation__
 *
 * To run a mutation, you first call `useUpdateItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateItemMutation, { data, loading, error }] = useUpdateItemMutation({
 *   variables: {
 *      newItems: // value for 'newItems'
 *      newUploadableItems: // value for 'newUploadableItems'
 *      newGroupTags: // value for 'newGroupTags'
 *      newGroupExhibitions: // value for 'newGroupExhibitions'
 *      groupId: // value for 'groupId'
 *      typeName: // value for 'typeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      shortTitle: // value for 'shortTitle'
 *      title: // value for 'title'
 *      deleteItemIds: // value for 'deleteItemIds'
 *      deleteUploadableItemIds: // value for 'deleteUploadableItemIds'
 *      deleteGroupTagIds: // value for 'deleteGroupTagIds'
 *      deleteGroupExhibitionIds: // value for 'deleteGroupExhibitionIds'
 *      newUploaders: // value for 'newUploaders'
 *      deleteUploaderIds: // value for 'deleteUploaderIds'
 *      newGroupPeople: // value for 'newGroupPeople'
 *      deleteGroupPeopleIds: // value for 'deleteGroupPeopleIds'
 *   },
 * });
 */
export function useUpdateItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateItemMutation, UpdateItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateItemMutation, UpdateItemMutationVariables>(UpdateItemDocument, options);
      }
export type UpdateItemMutationHookResult = ReturnType<typeof useUpdateItemMutation>;
export type UpdateItemMutationResult = Apollo.MutationResult<UpdateItemMutation>;
export type UpdateItemMutationOptions = Apollo.BaseMutationOptions<UpdateItemMutation, UpdateItemMutationVariables>;
export const UpdateElementDocument = gql`
    mutation UpdateElement($id: uuid!, $typeName: content_ElementType_enum!, $layoutData: jsonb = null, $name: String!, $data: jsonb!, $isHidden: Boolean!, $originatingDataId: uuid = null, $uploadableId: uuid = null) {
  update_content_Element_by_pk(
    pk_columns: {id: $id}
    _set: {typeName: $typeName, layoutData: $layoutData, name: $name, data: $data, isHidden: $isHidden, originatingDataId: $originatingDataId, uploadableId: $uploadableId}
  ) {
    ...ElementInfo
  }
}
    ${ElementInfoFragmentDoc}`;
export type UpdateElementMutationFn = Apollo.MutationFunction<UpdateElementMutation, UpdateElementMutationVariables>;

/**
 * __useUpdateElementMutation__
 *
 * To run a mutation, you first call `useUpdateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateElementMutation, { data, loading, error }] = useUpdateElementMutation({
 *   variables: {
 *      id: // value for 'id'
 *      typeName: // value for 'typeName'
 *      layoutData: // value for 'layoutData'
 *      name: // value for 'name'
 *      data: // value for 'data'
 *      isHidden: // value for 'isHidden'
 *      originatingDataId: // value for 'originatingDataId'
 *      uploadableId: // value for 'uploadableId'
 *   },
 * });
 */
export function useUpdateElementMutation(baseOptions?: Apollo.MutationHookOptions<UpdateElementMutation, UpdateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateElementMutation, UpdateElementMutationVariables>(UpdateElementDocument, options);
      }
export type UpdateElementMutationHookResult = ReturnType<typeof useUpdateElementMutation>;
export type UpdateElementMutationResult = Apollo.MutationResult<UpdateElementMutation>;
export type UpdateElementMutationOptions = Apollo.BaseMutationOptions<UpdateElementMutation, UpdateElementMutationVariables>;
export const UpdateUploadableElementDocument = gql`
    mutation UpdateUploadableElement($id: uuid!, $typeName: content_ElementType_enum!, $name: String!, $isHidden: Boolean!, $uploadsRemaining: Int = null, $originatingDataId: uuid = null) {
  update_content_UploadableElement_by_pk(
    pk_columns: {id: $id}
    _set: {typeName: $typeName, name: $name, isHidden: $isHidden, originatingDataId: $originatingDataId, uploadsRemaining: $uploadsRemaining}
  ) {
    ...UploadableElementInfo
  }
}
    ${UploadableElementInfoFragmentDoc}`;
export type UpdateUploadableElementMutationFn = Apollo.MutationFunction<UpdateUploadableElementMutation, UpdateUploadableElementMutationVariables>;

/**
 * __useUpdateUploadableElementMutation__
 *
 * To run a mutation, you first call `useUpdateUploadableElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUploadableElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUploadableElementMutation, { data, loading, error }] = useUpdateUploadableElementMutation({
 *   variables: {
 *      id: // value for 'id'
 *      typeName: // value for 'typeName'
 *      name: // value for 'name'
 *      isHidden: // value for 'isHidden'
 *      uploadsRemaining: // value for 'uploadsRemaining'
 *      originatingDataId: // value for 'originatingDataId'
 *   },
 * });
 */
export function useUpdateUploadableElementMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUploadableElementMutation, UpdateUploadableElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUploadableElementMutation, UpdateUploadableElementMutationVariables>(UpdateUploadableElementDocument, options);
      }
export type UpdateUploadableElementMutationHookResult = ReturnType<typeof useUpdateUploadableElementMutation>;
export type UpdateUploadableElementMutationResult = Apollo.MutationResult<UpdateUploadableElementMutation>;
export type UpdateUploadableElementMutationOptions = Apollo.BaseMutationOptions<UpdateUploadableElementMutation, UpdateUploadableElementMutationVariables>;
export const UpdateUploaderDocument = gql`
    mutation UpdateUploader($id: uuid!, $email: String!, $name: String!) {
  update_content_Uploader_by_pk(
    pk_columns: {id: $id}
    _set: {email: $email, name: $name}
  ) {
    ...UploaderInfo
  }
}
    ${UploaderInfoFragmentDoc}`;
export type UpdateUploaderMutationFn = Apollo.MutationFunction<UpdateUploaderMutation, UpdateUploaderMutationVariables>;

/**
 * __useUpdateUploaderMutation__
 *
 * To run a mutation, you first call `useUpdateUploaderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUploaderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUploaderMutation, { data, loading, error }] = useUpdateUploaderMutation({
 *   variables: {
 *      id: // value for 'id'
 *      email: // value for 'email'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateUploaderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUploaderMutation, UpdateUploaderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUploaderMutation, UpdateUploaderMutationVariables>(UpdateUploaderDocument, options);
      }
export type UpdateUploaderMutationHookResult = ReturnType<typeof useUpdateUploaderMutation>;
export type UpdateUploaderMutationResult = Apollo.MutationResult<UpdateUploaderMutation>;
export type UpdateUploaderMutationOptions = Apollo.BaseMutationOptions<UpdateUploaderMutation, UpdateUploaderMutationVariables>;
export const UpdateGroupPersonDocument = gql`
    mutation UpdateGroupPerson($id: uuid!, $roleName: String!, $priority: Int = null) {
  update_content_ItemProgramPerson_by_pk(
    pk_columns: {id: $id}
    _set: {roleName: $roleName, priority: $priority}
  ) {
    ...ItemPersonInfo
  }
}
    ${ItemPersonInfoFragmentDoc}`;
export type UpdateGroupPersonMutationFn = Apollo.MutationFunction<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;

/**
 * __useUpdateGroupPersonMutation__
 *
 * To run a mutation, you first call `useUpdateGroupPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupPersonMutation, { data, loading, error }] = useUpdateGroupPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      roleName: // value for 'roleName'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateGroupPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>(UpdateGroupPersonDocument, options);
      }
export type UpdateGroupPersonMutationHookResult = ReturnType<typeof useUpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationResult = Apollo.MutationResult<UpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationOptions = Apollo.BaseMutationOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;
export const UpdateGroupExhibitionDocument = gql`
    mutation UpdateGroupExhibition($id: uuid!, $priority: Int = null, $layout: jsonb = null) {
  update_content_ItemExhibition_by_pk(
    pk_columns: {id: $id}
    _set: {layout: $layout, priority: $priority}
  ) {
    ...ItemExhibitionInfo
  }
}
    ${ItemExhibitionInfoFragmentDoc}`;
export type UpdateGroupExhibitionMutationFn = Apollo.MutationFunction<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>;

/**
 * __useUpdateGroupExhibitionMutation__
 *
 * To run a mutation, you first call `useUpdateGroupExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupExhibitionMutation, { data, loading, error }] = useUpdateGroupExhibitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      priority: // value for 'priority'
 *      layout: // value for 'layout'
 *   },
 * });
 */
export function useUpdateGroupExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>(UpdateGroupExhibitionDocument, options);
      }
export type UpdateGroupExhibitionMutationHookResult = ReturnType<typeof useUpdateGroupExhibitionMutation>;
export type UpdateGroupExhibitionMutationResult = Apollo.MutationResult<UpdateGroupExhibitionMutation>;
export type UpdateGroupExhibitionMutationOptions = Apollo.BaseMutationOptions<UpdateGroupExhibitionMutation, UpdateGroupExhibitionMutationVariables>;
export const UpdatePersonDocument = gql`
    mutation UpdatePerson($id: uuid!, $name: String!, $affiliation: String = null, $email: String = null, $originatingDataId: uuid = null, $registrantId: uuid = null) {
  update_collection_ProgramPerson_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, affiliation: $affiliation, email: $email, originatingDataId: $originatingDataId, registrantId: $registrantId}
  ) {
    ...ProgramPersonInfo
  }
}
    ${ProgramPersonInfoFragmentDoc}`;
export type UpdatePersonMutationFn = Apollo.MutationFunction<UpdatePersonMutation, UpdatePersonMutationVariables>;

/**
 * __useUpdatePersonMutation__
 *
 * To run a mutation, you first call `useUpdatePersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePersonMutation, { data, loading, error }] = useUpdatePersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      email: // value for 'email'
 *      originatingDataId: // value for 'originatingDataId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUpdatePersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePersonMutation, UpdatePersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePersonMutation, UpdatePersonMutationVariables>(UpdatePersonDocument, options);
      }
export type UpdatePersonMutationHookResult = ReturnType<typeof useUpdatePersonMutation>;
export type UpdatePersonMutationResult = Apollo.MutationResult<UpdatePersonMutation>;
export type UpdatePersonMutationOptions = Apollo.BaseMutationOptions<UpdatePersonMutation, UpdatePersonMutationVariables>;
export const UpdateTagDocument = gql`
    mutation UpdateTag($id: uuid!, $name: String!, $colour: String!, $originatingDataId: uuid = null, $priority: Int! = 10) {
  update_collection_Tag_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, originatingDataId: $originatingDataId, priority: $priority}
  ) {
    ...TagInfo
  }
}
    ${TagInfoFragmentDoc}`;
export type UpdateTagMutationFn = Apollo.MutationFunction<UpdateTagMutation, UpdateTagMutationVariables>;

/**
 * __useUpdateTagMutation__
 *
 * To run a mutation, you first call `useUpdateTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTagMutation, { data, loading, error }] = useUpdateTagMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      originatingDataId: // value for 'originatingDataId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateTagMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTagMutation, UpdateTagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTagMutation, UpdateTagMutationVariables>(UpdateTagDocument, options);
      }
export type UpdateTagMutationHookResult = ReturnType<typeof useUpdateTagMutation>;
export type UpdateTagMutationResult = Apollo.MutationResult<UpdateTagMutation>;
export type UpdateTagMutationOptions = Apollo.BaseMutationOptions<UpdateTagMutation, UpdateTagMutationVariables>;
export const UpdateExhibitionDocument = gql`
    mutation UpdateExhibition($id: uuid!, $name: String!, $colour: String!, $priority: Int!) {
  update_collection_Exhibition_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, priority: $priority}
  ) {
    ...ExhibitionInfo
  }
}
    ${ExhibitionInfoFragmentDoc}`;
export type UpdateExhibitionMutationFn = Apollo.MutationFunction<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>;

/**
 * __useUpdateExhibitionMutation__
 *
 * To run a mutation, you first call `useUpdateExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateExhibitionMutation, { data, loading, error }] = useUpdateExhibitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>(UpdateExhibitionDocument, options);
      }
export type UpdateExhibitionMutationHookResult = ReturnType<typeof useUpdateExhibitionMutation>;
export type UpdateExhibitionMutationResult = Apollo.MutationResult<UpdateExhibitionMutation>;
export type UpdateExhibitionMutationOptions = Apollo.BaseMutationOptions<UpdateExhibitionMutation, UpdateExhibitionMutationVariables>;
export const SEoUm_InfosDocument = gql`
    query SEoUM_Infos($itemIds: [uuid!]!) {
  content_Element(
    where: {itemId: {_in: $itemIds}, uploadableId: {_is_null: true}}
  ) {
    ...SEoUM_Element
  }
  content_UploadableElement(where: {itemId: {_in: $itemIds}}) {
    ...SEoUM_Uploadable
  }
}
    ${SEoUm_ElementFragmentDoc}
${SEoUm_UploadableFragmentDoc}`;

/**
 * __useSEoUm_InfosQuery__
 *
 * To run a query within a React component, call `useSEoUm_InfosQuery` and pass it any options that fit your needs.
 * When your component renders, `useSEoUm_InfosQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSEoUm_InfosQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useSEoUm_InfosQuery(baseOptions: Apollo.QueryHookOptions<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>(SEoUm_InfosDocument, options);
      }
export function useSEoUm_InfosLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>(SEoUm_InfosDocument, options);
        }
export type SEoUm_InfosQueryHookResult = ReturnType<typeof useSEoUm_InfosQuery>;
export type SEoUm_InfosLazyQueryHookResult = ReturnType<typeof useSEoUm_InfosLazyQuery>;
export type SEoUm_InfosQueryResult = Apollo.QueryResult<SEoUm_InfosQuery, SEoUm_InfosQueryVariables>;
export const ManageContent_DeleteElementDocument = gql`
    mutation ManageContent_DeleteElement($elementId: uuid!) {
  delete_content_Element_by_pk(id: $elementId) {
    id
  }
}
    `;
export type ManageContent_DeleteElementMutationFn = Apollo.MutationFunction<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>;

/**
 * __useManageContent_DeleteElementMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteElementMutation, { data, loading, error }] = useManageContent_DeleteElementMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useManageContent_DeleteElementMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>(ManageContent_DeleteElementDocument, options);
      }
export type ManageContent_DeleteElementMutationHookResult = ReturnType<typeof useManageContent_DeleteElementMutation>;
export type ManageContent_DeleteElementMutationResult = Apollo.MutationResult<ManageContent_DeleteElementMutation>;
export type ManageContent_DeleteElementMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteElementMutation, ManageContent_DeleteElementMutationVariables>;
export const ManageContent_UpdateElementDocument = gql`
    mutation ManageContent_UpdateElement($elementId: uuid!, $element: content_Element_set_input!) {
  update_content_Element_by_pk(pk_columns: {id: $elementId}, _set: $element) {
    ...ManageContent_Element
  }
}
    ${ManageContent_ElementFragmentDoc}`;
export type ManageContent_UpdateElementMutationFn = Apollo.MutationFunction<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>;

/**
 * __useManageContent_UpdateElementMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateElementMutation, { data, loading, error }] = useManageContent_UpdateElementMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *      element: // value for 'element'
 *   },
 * });
 */
export function useManageContent_UpdateElementMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>(ManageContent_UpdateElementDocument, options);
      }
export type ManageContent_UpdateElementMutationHookResult = ReturnType<typeof useManageContent_UpdateElementMutation>;
export type ManageContent_UpdateElementMutationResult = Apollo.MutationResult<ManageContent_UpdateElementMutation>;
export type ManageContent_UpdateElementMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateElementMutation, ManageContent_UpdateElementMutationVariables>;
export const ManageContent_DeleteUploadableElementDocument = gql`
    mutation ManageContent_DeleteUploadableElement($uploadableElementId: uuid!) {
  delete_content_UploadableElement_by_pk(id: $uploadableElementId) {
    id
  }
}
    `;
export type ManageContent_DeleteUploadableElementMutationFn = Apollo.MutationFunction<ManageContent_DeleteUploadableElementMutation, ManageContent_DeleteUploadableElementMutationVariables>;

/**
 * __useManageContent_DeleteUploadableElementMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteUploadableElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteUploadableElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteUploadableElementMutation, { data, loading, error }] = useManageContent_DeleteUploadableElementMutation({
 *   variables: {
 *      uploadableElementId: // value for 'uploadableElementId'
 *   },
 * });
 */
export function useManageContent_DeleteUploadableElementMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteUploadableElementMutation, ManageContent_DeleteUploadableElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteUploadableElementMutation, ManageContent_DeleteUploadableElementMutationVariables>(ManageContent_DeleteUploadableElementDocument, options);
      }
export type ManageContent_DeleteUploadableElementMutationHookResult = ReturnType<typeof useManageContent_DeleteUploadableElementMutation>;
export type ManageContent_DeleteUploadableElementMutationResult = Apollo.MutationResult<ManageContent_DeleteUploadableElementMutation>;
export type ManageContent_DeleteUploadableElementMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteUploadableElementMutation, ManageContent_DeleteUploadableElementMutationVariables>;
export const ManageContent_UpdateUploadableElementDocument = gql`
    mutation ManageContent_UpdateUploadableElement($uploadableElementId: uuid!, $uploadableElement: content_UploadableElement_set_input!) {
  update_content_UploadableElement_by_pk(
    pk_columns: {id: $uploadableElementId}
    _set: $uploadableElement
  ) {
    ...ManageContent_UploadableElement
  }
}
    ${ManageContent_UploadableElementFragmentDoc}`;
export type ManageContent_UpdateUploadableElementMutationFn = Apollo.MutationFunction<ManageContent_UpdateUploadableElementMutation, ManageContent_UpdateUploadableElementMutationVariables>;

/**
 * __useManageContent_UpdateUploadableElementMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateUploadableElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateUploadableElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateUploadableElementMutation, { data, loading, error }] = useManageContent_UpdateUploadableElementMutation({
 *   variables: {
 *      uploadableElementId: // value for 'uploadableElementId'
 *      uploadableElement: // value for 'uploadableElement'
 *   },
 * });
 */
export function useManageContent_UpdateUploadableElementMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateUploadableElementMutation, ManageContent_UpdateUploadableElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateUploadableElementMutation, ManageContent_UpdateUploadableElementMutationVariables>(ManageContent_UpdateUploadableElementDocument, options);
      }
export type ManageContent_UpdateUploadableElementMutationHookResult = ReturnType<typeof useManageContent_UpdateUploadableElementMutation>;
export type ManageContent_UpdateUploadableElementMutationResult = Apollo.MutationResult<ManageContent_UpdateUploadableElementMutation>;
export type ManageContent_UpdateUploadableElementMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateUploadableElementMutation, ManageContent_UpdateUploadableElementMutationVariables>;
export const ManageContent_SelectUploadersDocument = gql`
    query ManageContent_SelectUploaders($uploadableElementId: uuid!) {
  content_Uploader(where: {uploadableElementId: {_eq: $uploadableElementId}}) {
    ...ManageContent_Uploader
  }
}
    ${ManageContent_UploaderFragmentDoc}`;

/**
 * __useManageContent_SelectUploadersQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectUploadersQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectUploadersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectUploadersQuery({
 *   variables: {
 *      uploadableElementId: // value for 'uploadableElementId'
 *   },
 * });
 */
export function useManageContent_SelectUploadersQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectUploadersQuery, ManageContent_SelectUploadersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectUploadersQuery, ManageContent_SelectUploadersQueryVariables>(ManageContent_SelectUploadersDocument, options);
      }
export function useManageContent_SelectUploadersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectUploadersQuery, ManageContent_SelectUploadersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectUploadersQuery, ManageContent_SelectUploadersQueryVariables>(ManageContent_SelectUploadersDocument, options);
        }
export type ManageContent_SelectUploadersQueryHookResult = ReturnType<typeof useManageContent_SelectUploadersQuery>;
export type ManageContent_SelectUploadersLazyQueryHookResult = ReturnType<typeof useManageContent_SelectUploadersLazyQuery>;
export type ManageContent_SelectUploadersQueryResult = Apollo.QueryResult<ManageContent_SelectUploadersQuery, ManageContent_SelectUploadersQueryVariables>;
export const ManageContent_InsertUploadersDocument = gql`
    mutation ManageContent_InsertUploaders($objects: [content_Uploader_insert_input!]!) {
  insert_content_Uploader(objects: $objects) {
    returning {
      ...ManageContent_Uploader
    }
  }
}
    ${ManageContent_UploaderFragmentDoc}`;
export type ManageContent_InsertUploadersMutationFn = Apollo.MutationFunction<ManageContent_InsertUploadersMutation, ManageContent_InsertUploadersMutationVariables>;

/**
 * __useManageContent_InsertUploadersMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertUploadersMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertUploadersMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertUploadersMutation, { data, loading, error }] = useManageContent_InsertUploadersMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useManageContent_InsertUploadersMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertUploadersMutation, ManageContent_InsertUploadersMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertUploadersMutation, ManageContent_InsertUploadersMutationVariables>(ManageContent_InsertUploadersDocument, options);
      }
export type ManageContent_InsertUploadersMutationHookResult = ReturnType<typeof useManageContent_InsertUploadersMutation>;
export type ManageContent_InsertUploadersMutationResult = Apollo.MutationResult<ManageContent_InsertUploadersMutation>;
export type ManageContent_InsertUploadersMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertUploadersMutation, ManageContent_InsertUploadersMutationVariables>;
export const ManageContent_UpdateUploaderDocument = gql`
    mutation ManageContent_UpdateUploader($id: uuid!, $update: content_Uploader_set_input!) {
  update_content_Uploader_by_pk(pk_columns: {id: $id}, _set: $update) {
    ...ManageContent_Uploader
  }
}
    ${ManageContent_UploaderFragmentDoc}`;
export type ManageContent_UpdateUploaderMutationFn = Apollo.MutationFunction<ManageContent_UpdateUploaderMutation, ManageContent_UpdateUploaderMutationVariables>;

/**
 * __useManageContent_UpdateUploaderMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateUploaderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateUploaderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateUploaderMutation, { data, loading, error }] = useManageContent_UpdateUploaderMutation({
 *   variables: {
 *      id: // value for 'id'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useManageContent_UpdateUploaderMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateUploaderMutation, ManageContent_UpdateUploaderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateUploaderMutation, ManageContent_UpdateUploaderMutationVariables>(ManageContent_UpdateUploaderDocument, options);
      }
export type ManageContent_UpdateUploaderMutationHookResult = ReturnType<typeof useManageContent_UpdateUploaderMutation>;
export type ManageContent_UpdateUploaderMutationResult = Apollo.MutationResult<ManageContent_UpdateUploaderMutation>;
export type ManageContent_UpdateUploaderMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateUploaderMutation, ManageContent_UpdateUploaderMutationVariables>;
export const ManageContent_DeleteUploadersDocument = gql`
    mutation ManageContent_DeleteUploaders($ids: [uuid!]!) {
  delete_content_Uploader(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContent_DeleteUploadersMutationFn = Apollo.MutationFunction<ManageContent_DeleteUploadersMutation, ManageContent_DeleteUploadersMutationVariables>;

/**
 * __useManageContent_DeleteUploadersMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteUploadersMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteUploadersMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteUploadersMutation, { data, loading, error }] = useManageContent_DeleteUploadersMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContent_DeleteUploadersMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteUploadersMutation, ManageContent_DeleteUploadersMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteUploadersMutation, ManageContent_DeleteUploadersMutationVariables>(ManageContent_DeleteUploadersDocument, options);
      }
export type ManageContent_DeleteUploadersMutationHookResult = ReturnType<typeof useManageContent_DeleteUploadersMutation>;
export type ManageContent_DeleteUploadersMutationResult = Apollo.MutationResult<ManageContent_DeleteUploadersMutation>;
export type ManageContent_DeleteUploadersMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteUploadersMutation, ManageContent_DeleteUploadersMutationVariables>;
export const ManageContent_SelectItemExhibitionsDocument = gql`
    query ManageContent_SelectItemExhibitions($exhibitionId: uuid!) {
  content_ItemExhibition(where: {exhibitionId: {_eq: $exhibitionId}}) {
    ...ManageContent_ItemExhibition
  }
}
    ${ManageContent_ItemExhibitionFragmentDoc}`;

/**
 * __useManageContent_SelectItemExhibitionsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectItemExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectItemExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectItemExhibitionsQuery({
 *   variables: {
 *      exhibitionId: // value for 'exhibitionId'
 *   },
 * });
 */
export function useManageContent_SelectItemExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>(ManageContent_SelectItemExhibitionsDocument, options);
      }
export function useManageContent_SelectItemExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>(ManageContent_SelectItemExhibitionsDocument, options);
        }
export type ManageContent_SelectItemExhibitionsQueryHookResult = ReturnType<typeof useManageContent_SelectItemExhibitionsQuery>;
export type ManageContent_SelectItemExhibitionsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectItemExhibitionsLazyQuery>;
export type ManageContent_SelectItemExhibitionsQueryResult = Apollo.QueryResult<ManageContent_SelectItemExhibitionsQuery, ManageContent_SelectItemExhibitionsQueryVariables>;
export const ManageContent_InsertItemExhibitionDocument = gql`
    mutation ManageContent_InsertItemExhibition($conferenceId: uuid!, $exhibitionId: uuid!, $itemId: uuid!, $priority: Int!) {
  insert_content_ItemExhibition_one(
    object: {conferenceId: $conferenceId, exhibitionId: $exhibitionId, itemId: $itemId, priority: $priority}
  ) {
    ...ManageContent_ItemExhibition
  }
}
    ${ManageContent_ItemExhibitionFragmentDoc}`;
export type ManageContent_InsertItemExhibitionMutationFn = Apollo.MutationFunction<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>;

/**
 * __useManageContent_InsertItemExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertItemExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertItemExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertItemExhibitionMutation, { data, loading, error }] = useManageContent_InsertItemExhibitionMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      exhibitionId: // value for 'exhibitionId'
 *      itemId: // value for 'itemId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useManageContent_InsertItemExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>(ManageContent_InsertItemExhibitionDocument, options);
      }
export type ManageContent_InsertItemExhibitionMutationHookResult = ReturnType<typeof useManageContent_InsertItemExhibitionMutation>;
export type ManageContent_InsertItemExhibitionMutationResult = Apollo.MutationResult<ManageContent_InsertItemExhibitionMutation>;
export type ManageContent_InsertItemExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertItemExhibitionMutation, ManageContent_InsertItemExhibitionMutationVariables>;
export const ManageContent_UpdateItemExhibitionDocument = gql`
    mutation ManageContent_UpdateItemExhibition($itemExhibitionId: uuid!, $priority: Int!) {
  update_content_ItemExhibition_by_pk(
    pk_columns: {id: $itemExhibitionId}
    _set: {priority: $priority}
  ) {
    ...ManageContent_ItemExhibition
  }
}
    ${ManageContent_ItemExhibitionFragmentDoc}`;
export type ManageContent_UpdateItemExhibitionMutationFn = Apollo.MutationFunction<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>;

/**
 * __useManageContent_UpdateItemExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateItemExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateItemExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateItemExhibitionMutation, { data, loading, error }] = useManageContent_UpdateItemExhibitionMutation({
 *   variables: {
 *      itemExhibitionId: // value for 'itemExhibitionId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useManageContent_UpdateItemExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>(ManageContent_UpdateItemExhibitionDocument, options);
      }
export type ManageContent_UpdateItemExhibitionMutationHookResult = ReturnType<typeof useManageContent_UpdateItemExhibitionMutation>;
export type ManageContent_UpdateItemExhibitionMutationResult = Apollo.MutationResult<ManageContent_UpdateItemExhibitionMutation>;
export type ManageContent_UpdateItemExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateItemExhibitionMutation, ManageContent_UpdateItemExhibitionMutationVariables>;
export const ManageContent_DeleteItemExhibitionDocument = gql`
    mutation ManageContent_DeleteItemExhibition($itemExhibitionId: uuid!) {
  delete_content_ItemExhibition_by_pk(id: $itemExhibitionId) {
    id
  }
}
    `;
export type ManageContent_DeleteItemExhibitionMutationFn = Apollo.MutationFunction<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>;

/**
 * __useManageContent_DeleteItemExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteItemExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteItemExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteItemExhibitionMutation, { data, loading, error }] = useManageContent_DeleteItemExhibitionMutation({
 *   variables: {
 *      itemExhibitionId: // value for 'itemExhibitionId'
 *   },
 * });
 */
export function useManageContent_DeleteItemExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>(ManageContent_DeleteItemExhibitionDocument, options);
      }
export type ManageContent_DeleteItemExhibitionMutationHookResult = ReturnType<typeof useManageContent_DeleteItemExhibitionMutation>;
export type ManageContent_DeleteItemExhibitionMutationResult = Apollo.MutationResult<ManageContent_DeleteItemExhibitionMutation>;
export type ManageContent_DeleteItemExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteItemExhibitionMutation, ManageContent_DeleteItemExhibitionMutationVariables>;
export const ManageContent_InsertExhibitionDocument = gql`
    mutation ManageContent_InsertExhibition($exhibition: collection_Exhibition_insert_input!) {
  insert_collection_Exhibition_one(object: $exhibition) {
    ...ManageContent_Exhibition
  }
}
    ${ManageContent_ExhibitionFragmentDoc}`;
export type ManageContent_InsertExhibitionMutationFn = Apollo.MutationFunction<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>;

/**
 * __useManageContent_InsertExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertExhibitionMutation, { data, loading, error }] = useManageContent_InsertExhibitionMutation({
 *   variables: {
 *      exhibition: // value for 'exhibition'
 *   },
 * });
 */
export function useManageContent_InsertExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>(ManageContent_InsertExhibitionDocument, options);
      }
export type ManageContent_InsertExhibitionMutationHookResult = ReturnType<typeof useManageContent_InsertExhibitionMutation>;
export type ManageContent_InsertExhibitionMutationResult = Apollo.MutationResult<ManageContent_InsertExhibitionMutation>;
export type ManageContent_InsertExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertExhibitionMutation, ManageContent_InsertExhibitionMutationVariables>;
export const ManageContent_UpdateExhibitionDocument = gql`
    mutation ManageContent_UpdateExhibition($id: uuid!, $update: collection_Exhibition_set_input!) {
  update_collection_Exhibition_by_pk(pk_columns: {id: $id}, _set: $update) {
    ...ManageContent_Exhibition
  }
}
    ${ManageContent_ExhibitionFragmentDoc}`;
export type ManageContent_UpdateExhibitionMutationFn = Apollo.MutationFunction<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>;

/**
 * __useManageContent_UpdateExhibitionMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateExhibitionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateExhibitionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateExhibitionMutation, { data, loading, error }] = useManageContent_UpdateExhibitionMutation({
 *   variables: {
 *      id: // value for 'id'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useManageContent_UpdateExhibitionMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>(ManageContent_UpdateExhibitionDocument, options);
      }
export type ManageContent_UpdateExhibitionMutationHookResult = ReturnType<typeof useManageContent_UpdateExhibitionMutation>;
export type ManageContent_UpdateExhibitionMutationResult = Apollo.MutationResult<ManageContent_UpdateExhibitionMutation>;
export type ManageContent_UpdateExhibitionMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateExhibitionMutation, ManageContent_UpdateExhibitionMutationVariables>;
export const ManageContent_DeleteExhibitionsDocument = gql`
    mutation ManageContent_DeleteExhibitions($ids: [uuid!]!) {
  delete_collection_Exhibition(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContent_DeleteExhibitionsMutationFn = Apollo.MutationFunction<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>;

/**
 * __useManageContent_DeleteExhibitionsMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteExhibitionsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteExhibitionsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteExhibitionsMutation, { data, loading, error }] = useManageContent_DeleteExhibitionsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContent_DeleteExhibitionsMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>(ManageContent_DeleteExhibitionsDocument, options);
      }
export type ManageContent_DeleteExhibitionsMutationHookResult = ReturnType<typeof useManageContent_DeleteExhibitionsMutation>;
export type ManageContent_DeleteExhibitionsMutationResult = Apollo.MutationResult<ManageContent_DeleteExhibitionsMutation>;
export type ManageContent_DeleteExhibitionsMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteExhibitionsMutation, ManageContent_DeleteExhibitionsMutationVariables>;
export const AddContentMenu_CreateElementDocument = gql`
    mutation AddContentMenu_CreateElement($object: content_Element_insert_input!) {
  insert_content_Element_one(object: $object) {
    ...ManageContent_Element
  }
}
    ${ManageContent_ElementFragmentDoc}`;
export type AddContentMenu_CreateElementMutationFn = Apollo.MutationFunction<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>;

/**
 * __useAddContentMenu_CreateElementMutation__
 *
 * To run a mutation, you first call `useAddContentMenu_CreateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddContentMenu_CreateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addContentMenuCreateElementMutation, { data, loading, error }] = useAddContentMenu_CreateElementMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useAddContentMenu_CreateElementMutation(baseOptions?: Apollo.MutationHookOptions<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>(AddContentMenu_CreateElementDocument, options);
      }
export type AddContentMenu_CreateElementMutationHookResult = ReturnType<typeof useAddContentMenu_CreateElementMutation>;
export type AddContentMenu_CreateElementMutationResult = Apollo.MutationResult<AddContentMenu_CreateElementMutation>;
export type AddContentMenu_CreateElementMutationOptions = Apollo.BaseMutationOptions<AddContentMenu_CreateElementMutation, AddContentMenu_CreateElementMutationVariables>;
export const AddContentMenu_CreateUploadableElementDocument = gql`
    mutation AddContentMenu_CreateUploadableElement($object: content_UploadableElement_insert_input!) {
  insert_content_UploadableElement_one(object: $object) {
    ...ManageContent_UploadableElement
  }
}
    ${ManageContent_UploadableElementFragmentDoc}`;
export type AddContentMenu_CreateUploadableElementMutationFn = Apollo.MutationFunction<AddContentMenu_CreateUploadableElementMutation, AddContentMenu_CreateUploadableElementMutationVariables>;

/**
 * __useAddContentMenu_CreateUploadableElementMutation__
 *
 * To run a mutation, you first call `useAddContentMenu_CreateUploadableElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddContentMenu_CreateUploadableElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addContentMenuCreateUploadableElementMutation, { data, loading, error }] = useAddContentMenu_CreateUploadableElementMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useAddContentMenu_CreateUploadableElementMutation(baseOptions?: Apollo.MutationHookOptions<AddContentMenu_CreateUploadableElementMutation, AddContentMenu_CreateUploadableElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddContentMenu_CreateUploadableElementMutation, AddContentMenu_CreateUploadableElementMutationVariables>(AddContentMenu_CreateUploadableElementDocument, options);
      }
export type AddContentMenu_CreateUploadableElementMutationHookResult = ReturnType<typeof useAddContentMenu_CreateUploadableElementMutation>;
export type AddContentMenu_CreateUploadableElementMutationResult = Apollo.MutationResult<AddContentMenu_CreateUploadableElementMutation>;
export type AddContentMenu_CreateUploadableElementMutationOptions = Apollo.BaseMutationOptions<AddContentMenu_CreateUploadableElementMutation, AddContentMenu_CreateUploadableElementMutationVariables>;
export const ManageContent_SelectProgramPeopleDocument = gql`
    query ManageContent_SelectProgramPeople($conferenceId: uuid!) {
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContent_ProgramPerson
  }
}
    ${ManageContent_ProgramPersonFragmentDoc}`;

/**
 * __useManageContent_SelectProgramPeopleQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectProgramPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectProgramPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectProgramPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectProgramPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>(ManageContent_SelectProgramPeopleDocument, options);
      }
export function useManageContent_SelectProgramPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>(ManageContent_SelectProgramPeopleDocument, options);
        }
export type ManageContent_SelectProgramPeopleQueryHookResult = ReturnType<typeof useManageContent_SelectProgramPeopleQuery>;
export type ManageContent_SelectProgramPeopleLazyQueryHookResult = ReturnType<typeof useManageContent_SelectProgramPeopleLazyQuery>;
export type ManageContent_SelectProgramPeopleQueryResult = Apollo.QueryResult<ManageContent_SelectProgramPeopleQuery, ManageContent_SelectProgramPeopleQueryVariables>;
export const ManageContent_InsertItemProgramPersonDocument = gql`
    mutation ManageContent_InsertItemProgramPerson($conferenceId: uuid!, $personId: uuid!, $roleName: String!, $priority: Int!, $itemId: uuid!) {
  insert_content_ItemProgramPerson_one(
    object: {conferenceId: $conferenceId, personId: $personId, itemId: $itemId, priority: $priority, roleName: $roleName}
  ) {
    ...ManageContent_ItemProgramPerson
  }
}
    ${ManageContent_ItemProgramPersonFragmentDoc}`;
export type ManageContent_InsertItemProgramPersonMutationFn = Apollo.MutationFunction<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>;

/**
 * __useManageContent_InsertItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertItemProgramPersonMutation, { data, loading, error }] = useManageContent_InsertItemProgramPersonMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      personId: // value for 'personId'
 *      roleName: // value for 'roleName'
 *      priority: // value for 'priority'
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useManageContent_InsertItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>(ManageContent_InsertItemProgramPersonDocument, options);
      }
export type ManageContent_InsertItemProgramPersonMutationHookResult = ReturnType<typeof useManageContent_InsertItemProgramPersonMutation>;
export type ManageContent_InsertItemProgramPersonMutationResult = Apollo.MutationResult<ManageContent_InsertItemProgramPersonMutation>;
export type ManageContent_InsertItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertItemProgramPersonMutation, ManageContent_InsertItemProgramPersonMutationVariables>;
export const ManageContent_UpdateItemProgramPersonDocument = gql`
    mutation ManageContent_UpdateItemProgramPerson($itemPersonId: uuid!, $priority: Int!, $roleName: String!) {
  update_content_ItemProgramPerson_by_pk(
    pk_columns: {id: $itemPersonId}
    _set: {priority: $priority, roleName: $roleName}
  ) {
    ...ManageContent_ItemProgramPerson
  }
}
    ${ManageContent_ItemProgramPersonFragmentDoc}`;
export type ManageContent_UpdateItemProgramPersonMutationFn = Apollo.MutationFunction<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>;

/**
 * __useManageContent_UpdateItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateItemProgramPersonMutation, { data, loading, error }] = useManageContent_UpdateItemProgramPersonMutation({
 *   variables: {
 *      itemPersonId: // value for 'itemPersonId'
 *      priority: // value for 'priority'
 *      roleName: // value for 'roleName'
 *   },
 * });
 */
export function useManageContent_UpdateItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>(ManageContent_UpdateItemProgramPersonDocument, options);
      }
export type ManageContent_UpdateItemProgramPersonMutationHookResult = ReturnType<typeof useManageContent_UpdateItemProgramPersonMutation>;
export type ManageContent_UpdateItemProgramPersonMutationResult = Apollo.MutationResult<ManageContent_UpdateItemProgramPersonMutation>;
export type ManageContent_UpdateItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateItemProgramPersonMutation, ManageContent_UpdateItemProgramPersonMutationVariables>;
export const ManageContent_DeleteItemProgramPersonDocument = gql`
    mutation ManageContent_DeleteItemProgramPerson($itemPersonId: uuid!) {
  delete_content_ItemProgramPerson_by_pk(id: $itemPersonId) {
    id
  }
}
    `;
export type ManageContent_DeleteItemProgramPersonMutationFn = Apollo.MutationFunction<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>;

/**
 * __useManageContent_DeleteItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteItemProgramPersonMutation, { data, loading, error }] = useManageContent_DeleteItemProgramPersonMutation({
 *   variables: {
 *      itemPersonId: // value for 'itemPersonId'
 *   },
 * });
 */
export function useManageContent_DeleteItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>(ManageContent_DeleteItemProgramPersonDocument, options);
      }
export type ManageContent_DeleteItemProgramPersonMutationHookResult = ReturnType<typeof useManageContent_DeleteItemProgramPersonMutation>;
export type ManageContent_DeleteItemProgramPersonMutationResult = Apollo.MutationResult<ManageContent_DeleteItemProgramPersonMutation>;
export type ManageContent_DeleteItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteItemProgramPersonMutation, ManageContent_DeleteItemProgramPersonMutationVariables>;
export const ManageContent_InsertTagDocument = gql`
    mutation ManageContent_InsertTag($tag: collection_Tag_insert_input!) {
  insert_collection_Tag_one(object: $tag) {
    ...ManageContent_Tag
  }
}
    ${ManageContent_TagFragmentDoc}`;
export type ManageContent_InsertTagMutationFn = Apollo.MutationFunction<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>;

/**
 * __useManageContent_InsertTagMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertTagMutation, { data, loading, error }] = useManageContent_InsertTagMutation({
 *   variables: {
 *      tag: // value for 'tag'
 *   },
 * });
 */
export function useManageContent_InsertTagMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>(ManageContent_InsertTagDocument, options);
      }
export type ManageContent_InsertTagMutationHookResult = ReturnType<typeof useManageContent_InsertTagMutation>;
export type ManageContent_InsertTagMutationResult = Apollo.MutationResult<ManageContent_InsertTagMutation>;
export type ManageContent_InsertTagMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertTagMutation, ManageContent_InsertTagMutationVariables>;
export const ManageContent_UpdateTagDocument = gql`
    mutation ManageContent_UpdateTag($id: uuid!, $update: collection_Tag_set_input!) {
  update_collection_Tag_by_pk(pk_columns: {id: $id}, _set: $update) {
    ...ManageContent_Tag
  }
}
    ${ManageContent_TagFragmentDoc}`;
export type ManageContent_UpdateTagMutationFn = Apollo.MutationFunction<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>;

/**
 * __useManageContent_UpdateTagMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateTagMutation, { data, loading, error }] = useManageContent_UpdateTagMutation({
 *   variables: {
 *      id: // value for 'id'
 *      update: // value for 'update'
 *   },
 * });
 */
export function useManageContent_UpdateTagMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>(ManageContent_UpdateTagDocument, options);
      }
export type ManageContent_UpdateTagMutationHookResult = ReturnType<typeof useManageContent_UpdateTagMutation>;
export type ManageContent_UpdateTagMutationResult = Apollo.MutationResult<ManageContent_UpdateTagMutation>;
export type ManageContent_UpdateTagMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateTagMutation, ManageContent_UpdateTagMutationVariables>;
export const ManageContent_DeleteTagsDocument = gql`
    mutation ManageContent_DeleteTags($ids: [uuid!]!) {
  delete_collection_Tag(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContent_DeleteTagsMutationFn = Apollo.MutationFunction<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>;

/**
 * __useManageContent_DeleteTagsMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteTagsMutation, { data, loading, error }] = useManageContent_DeleteTagsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContent_DeleteTagsMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>(ManageContent_DeleteTagsDocument, options);
      }
export type ManageContent_DeleteTagsMutationHookResult = ReturnType<typeof useManageContent_DeleteTagsMutation>;
export type ManageContent_DeleteTagsMutationResult = Apollo.MutationResult<ManageContent_DeleteTagsMutation>;
export type ManageContent_DeleteTagsMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteTagsMutation, ManageContent_DeleteTagsMutationVariables>;
export const ElementSecurity_SelectGrantsDocument = gql`
    query ElementSecurity_SelectGrants($elementIds: [uuid!]!, $uploadableIds: [uuid!]!, $conferenceId: uuid!) {
  content_ElementPermissionGrant(
    where: {_or: [{_and: [{entityId: {_is_null: true}}, {conference: {id: {_eq: $conferenceId}}}]}, {entityId: {_in: $elementIds}}]}
  ) {
    ...ElementSecurity_ElementPG
  }
  content_UploadableElementPermissionGrant(
    where: {_or: [{_and: [{entityId: {_is_null: true}}, {conference: {id: {_eq: $conferenceId}}}]}, {entityId: {_in: $uploadableIds}}]}
  ) {
    ...ElementSecurity_UploadablePG
  }
  permissions_Role(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ElementSecurity_PermissionSet
  }
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ElementSecurity_Group
  }
}
    ${ElementSecurity_ElementPgFragmentDoc}
${ElementSecurity_UploadablePgFragmentDoc}
${ElementSecurity_PermissionSetFragmentDoc}
${ElementSecurity_GroupFragmentDoc}`;

/**
 * __useElementSecurity_SelectGrantsQuery__
 *
 * To run a query within a React component, call `useElementSecurity_SelectGrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useElementSecurity_SelectGrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useElementSecurity_SelectGrantsQuery({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *      uploadableIds: // value for 'uploadableIds'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useElementSecurity_SelectGrantsQuery(baseOptions: Apollo.QueryHookOptions<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>(ElementSecurity_SelectGrantsDocument, options);
      }
export function useElementSecurity_SelectGrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>(ElementSecurity_SelectGrantsDocument, options);
        }
export type ElementSecurity_SelectGrantsQueryHookResult = ReturnType<typeof useElementSecurity_SelectGrantsQuery>;
export type ElementSecurity_SelectGrantsLazyQueryHookResult = ReturnType<typeof useElementSecurity_SelectGrantsLazyQuery>;
export type ElementSecurity_SelectGrantsQueryResult = Apollo.QueryResult<ElementSecurity_SelectGrantsQuery, ElementSecurity_SelectGrantsQueryVariables>;
export const ElementSecurity_InsertGrantsDocument = gql`
    mutation ElementSecurity_InsertGrants($elementGrants: [content_ElementPermissionGrant_insert_input!]!, $uploadableGrants: [content_UploadableElementPermissionGrant_insert_input!]!) {
  insert_content_ElementPermissionGrant(
    objects: $elementGrants
    on_conflict: {constraint: ElementPermissionGrant_permissionSetId_groupId_entityId_key, update_columns: []}
  ) {
    returning {
      ...ElementSecurity_ElementPG
    }
  }
  insert_content_UploadableElementPermissionGrant(
    objects: $uploadableGrants
    on_conflict: {constraint: UploadableElementPermissionGr_permissionSetId_groupId_entit_key, update_columns: []}
  ) {
    returning {
      ...ElementSecurity_UploadablePG
    }
  }
}
    ${ElementSecurity_ElementPgFragmentDoc}
${ElementSecurity_UploadablePgFragmentDoc}`;
export type ElementSecurity_InsertGrantsMutationFn = Apollo.MutationFunction<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>;

/**
 * __useElementSecurity_InsertGrantsMutation__
 *
 * To run a mutation, you first call `useElementSecurity_InsertGrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useElementSecurity_InsertGrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [elementSecurityInsertGrantsMutation, { data, loading, error }] = useElementSecurity_InsertGrantsMutation({
 *   variables: {
 *      elementGrants: // value for 'elementGrants'
 *      uploadableGrants: // value for 'uploadableGrants'
 *   },
 * });
 */
export function useElementSecurity_InsertGrantsMutation(baseOptions?: Apollo.MutationHookOptions<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>(ElementSecurity_InsertGrantsDocument, options);
      }
export type ElementSecurity_InsertGrantsMutationHookResult = ReturnType<typeof useElementSecurity_InsertGrantsMutation>;
export type ElementSecurity_InsertGrantsMutationResult = Apollo.MutationResult<ElementSecurity_InsertGrantsMutation>;
export type ElementSecurity_InsertGrantsMutationOptions = Apollo.BaseMutationOptions<ElementSecurity_InsertGrantsMutation, ElementSecurity_InsertGrantsMutationVariables>;
export const ElementSecurity_DeleteGrantsDocument = gql`
    mutation ElementSecurity_DeleteGrants($elementGrantIds: [uuid!]!, $uploadableGrantIds: [uuid!]!) {
  delete_content_ElementPermissionGrant(where: {id: {_in: $elementGrantIds}}) {
    returning {
      id
    }
  }
  delete_content_UploadableElementPermissionGrant(
    where: {id: {_in: $uploadableGrantIds}}
  ) {
    returning {
      id
    }
  }
}
    `;
export type ElementSecurity_DeleteGrantsMutationFn = Apollo.MutationFunction<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>;

/**
 * __useElementSecurity_DeleteGrantsMutation__
 *
 * To run a mutation, you first call `useElementSecurity_DeleteGrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useElementSecurity_DeleteGrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [elementSecurityDeleteGrantsMutation, { data, loading, error }] = useElementSecurity_DeleteGrantsMutation({
 *   variables: {
 *      elementGrantIds: // value for 'elementGrantIds'
 *      uploadableGrantIds: // value for 'uploadableGrantIds'
 *   },
 * });
 */
export function useElementSecurity_DeleteGrantsMutation(baseOptions?: Apollo.MutationHookOptions<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>(ElementSecurity_DeleteGrantsDocument, options);
      }
export type ElementSecurity_DeleteGrantsMutationHookResult = ReturnType<typeof useElementSecurity_DeleteGrantsMutation>;
export type ElementSecurity_DeleteGrantsMutationResult = Apollo.MutationResult<ElementSecurity_DeleteGrantsMutation>;
export type ElementSecurity_DeleteGrantsMutationOptions = Apollo.BaseMutationOptions<ElementSecurity_DeleteGrantsMutation, ElementSecurity_DeleteGrantsMutationVariables>;
export const SubmissionRequestsModalDataDocument = gql`
    query SubmissionRequestsModalData($conferenceId: uuid!, $itemIds: [uuid!]!) {
  conference_Configuration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConfigureEmailTemplates_ConferenceConfiguration
  }
  content_UploadableElement(where: {itemId: {_in: $itemIds}}) {
    ...SubmissionRequestsModal_UploadableElement
  }
}
    ${ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc}
${SubmissionRequestsModal_UploadableElementFragmentDoc}`;

/**
 * __useSubmissionRequestsModalDataQuery__
 *
 * To run a query within a React component, call `useSubmissionRequestsModalDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissionRequestsModalDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissionRequestsModalDataQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useSubmissionRequestsModalDataQuery(baseOptions: Apollo.QueryHookOptions<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>(SubmissionRequestsModalDataDocument, options);
      }
export function useSubmissionRequestsModalDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>(SubmissionRequestsModalDataDocument, options);
        }
export type SubmissionRequestsModalDataQueryHookResult = ReturnType<typeof useSubmissionRequestsModalDataQuery>;
export type SubmissionRequestsModalDataLazyQueryHookResult = ReturnType<typeof useSubmissionRequestsModalDataLazyQuery>;
export type SubmissionRequestsModalDataQueryResult = Apollo.QueryResult<SubmissionRequestsModalDataQuery, SubmissionRequestsModalDataQueryVariables>;
export const SubmissionsReviewModalDataDocument = gql`
    query SubmissionsReviewModalData($itemIds: [uuid!]!) {
  content_UploadableElement(where: {itemId: {_in: $itemIds}}) {
    ...SubmissionsReviewModal_UploadableElement
  }
}
    ${SubmissionsReviewModal_UploadableElementFragmentDoc}`;

/**
 * __useSubmissionsReviewModalDataQuery__
 *
 * To run a query within a React component, call `useSubmissionsReviewModalDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissionsReviewModalDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissionsReviewModalDataQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useSubmissionsReviewModalDataQuery(baseOptions: Apollo.QueryHookOptions<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>(SubmissionsReviewModalDataDocument, options);
      }
export function useSubmissionsReviewModalDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>(SubmissionsReviewModalDataDocument, options);
        }
export type SubmissionsReviewModalDataQueryHookResult = ReturnType<typeof useSubmissionsReviewModalDataQuery>;
export type SubmissionsReviewModalDataLazyQueryHookResult = ReturnType<typeof useSubmissionsReviewModalDataLazyQuery>;
export type SubmissionsReviewModalDataQueryResult = Apollo.QueryResult<SubmissionsReviewModalDataQuery, SubmissionsReviewModalDataQueryVariables>;
export const ConfigureEmailTemplates_GetConferenceConfigurationsDocument = gql`
    query ConfigureEmailTemplates_GetConferenceConfigurations($conferenceId: uuid!) {
  conference_Configuration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConfigureEmailTemplates_ConferenceConfiguration
  }
}
    ${ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc}`;

/**
 * __useConfigureEmailTemplates_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useConfigureEmailTemplates_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConfigureEmailTemplates_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConfigureEmailTemplates_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConfigureEmailTemplates_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>(ConfigureEmailTemplates_GetConferenceConfigurationsDocument, options);
      }
export function useConfigureEmailTemplates_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>(ConfigureEmailTemplates_GetConferenceConfigurationsDocument, options);
        }
export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useConfigureEmailTemplates_GetConferenceConfigurationsQuery>;
export type ConfigureEmailTemplates_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useConfigureEmailTemplates_GetConferenceConfigurationsLazyQuery>;
export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>;
export const ConfigureEmailTemplates_UpdateConferenceConfigurationDocument = gql`
    mutation ConfigureEmailTemplates_UpdateConferenceConfiguration($value: jsonb!, $conferenceId: uuid!, $key: String!) {
  insert_conference_Configuration_one(
    object: {value: $value, conferenceId: $conferenceId, key: $key}
    on_conflict: {constraint: Configuration_conferenceId_key_key, update_columns: value}
  ) {
    id
  }
}
    `;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationFn = Apollo.MutationFunction<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>;

/**
 * __useConfigureEmailTemplates_UpdateConferenceConfigurationMutation__
 *
 * To run a mutation, you first call `useConfigureEmailTemplates_UpdateConferenceConfigurationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConfigureEmailTemplates_UpdateConferenceConfigurationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [configureEmailTemplatesUpdateConferenceConfigurationMutation, { data, loading, error }] = useConfigureEmailTemplates_UpdateConferenceConfigurationMutation({
 *   variables: {
 *      value: // value for 'value'
 *      conferenceId: // value for 'conferenceId'
 *      key: // value for 'key'
 *   },
 * });
 */
export function useConfigureEmailTemplates_UpdateConferenceConfigurationMutation(baseOptions?: Apollo.MutationHookOptions<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>(ConfigureEmailTemplates_UpdateConferenceConfigurationDocument, options);
      }
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationHookResult = ReturnType<typeof useConfigureEmailTemplates_UpdateConferenceConfigurationMutation>;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationResult = Apollo.MutationResult<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation>;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationOptions = Apollo.BaseMutationOptions<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>;
export const ChooseElementByTagModal_GetTagsDocument = gql`
    query ChooseElementByTagModal_GetTags($conferenceId: uuid!) {
  collection_Tag(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {name: asc}
  ) {
    id
    name
  }
}
    `;

/**
 * __useChooseElementByTagModal_GetTagsQuery__
 *
 * To run a query within a React component, call `useChooseElementByTagModal_GetTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementByTagModal_GetTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementByTagModal_GetTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useChooseElementByTagModal_GetTagsQuery(baseOptions: Apollo.QueryHookOptions<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>(ChooseElementByTagModal_GetTagsDocument, options);
      }
export function useChooseElementByTagModal_GetTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>(ChooseElementByTagModal_GetTagsDocument, options);
        }
export type ChooseElementByTagModal_GetTagsQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetTagsQuery>;
export type ChooseElementByTagModal_GetTagsLazyQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetTagsLazyQuery>;
export type ChooseElementByTagModal_GetTagsQueryResult = Apollo.QueryResult<ChooseElementByTagModal_GetTagsQuery, ChooseElementByTagModal_GetTagsQueryVariables>;
export const ChooseElementByTagModal_GetVideoElementsDocument = gql`
    query ChooseElementByTagModal_GetVideoElements($tagId: uuid!, $name: String!) {
  content_Element(
    where: {typeName: {_in: [VIDEO_FILE, VIDEO_BROADCAST, VIDEO_PREPUBLISH]}, item: {itemTags: {tag: {id: {_eq: $tagId}}}}, name: {_ilike: $name}}
    order_by: {item: {title: asc}, name: asc}
  ) {
    id
    name
    item {
      id
      title
    }
  }
}
    `;

/**
 * __useChooseElementByTagModal_GetVideoElementsQuery__
 *
 * To run a query within a React component, call `useChooseElementByTagModal_GetVideoElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementByTagModal_GetVideoElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementByTagModal_GetVideoElementsQuery({
 *   variables: {
 *      tagId: // value for 'tagId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useChooseElementByTagModal_GetVideoElementsQuery(baseOptions: Apollo.QueryHookOptions<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>(ChooseElementByTagModal_GetVideoElementsDocument, options);
      }
export function useChooseElementByTagModal_GetVideoElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>(ChooseElementByTagModal_GetVideoElementsDocument, options);
        }
export type ChooseElementByTagModal_GetVideoElementsQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetVideoElementsQuery>;
export type ChooseElementByTagModal_GetVideoElementsLazyQueryHookResult = ReturnType<typeof useChooseElementByTagModal_GetVideoElementsLazyQuery>;
export type ChooseElementByTagModal_GetVideoElementsQueryResult = Apollo.QueryResult<ChooseElementByTagModal_GetVideoElementsQuery, ChooseElementByTagModal_GetVideoElementsQueryVariables>;
export const ChooseElementModal_GetItemsDocument = gql`
    query ChooseElementModal_GetItems($conferenceId: uuid!) {
  content_Item(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {title: asc}
  ) {
    id
    title
  }
}
    `;

/**
 * __useChooseElementModal_GetItemsQuery__
 *
 * To run a query within a React component, call `useChooseElementModal_GetItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementModal_GetItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementModal_GetItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useChooseElementModal_GetItemsQuery(baseOptions: Apollo.QueryHookOptions<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>(ChooseElementModal_GetItemsDocument, options);
      }
export function useChooseElementModal_GetItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>(ChooseElementModal_GetItemsDocument, options);
        }
export type ChooseElementModal_GetItemsQueryHookResult = ReturnType<typeof useChooseElementModal_GetItemsQuery>;
export type ChooseElementModal_GetItemsLazyQueryHookResult = ReturnType<typeof useChooseElementModal_GetItemsLazyQuery>;
export type ChooseElementModal_GetItemsQueryResult = Apollo.QueryResult<ChooseElementModal_GetItemsQuery, ChooseElementModal_GetItemsQueryVariables>;
export const ChooseElementModal_GetVideoElementsDocument = gql`
    query ChooseElementModal_GetVideoElements($itemId: uuid) {
  content_Element(
    where: {itemId: {_eq: $itemId}, typeName: {_in: [VIDEO_FILE, VIDEO_BROADCAST, VIDEO_PREPUBLISH]}}
    order_by: {name: asc}
  ) {
    id
    name
  }
}
    `;

/**
 * __useChooseElementModal_GetVideoElementsQuery__
 *
 * To run a query within a React component, call `useChooseElementModal_GetVideoElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseElementModal_GetVideoElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseElementModal_GetVideoElementsQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useChooseElementModal_GetVideoElementsQuery(baseOptions?: Apollo.QueryHookOptions<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>(ChooseElementModal_GetVideoElementsDocument, options);
      }
export function useChooseElementModal_GetVideoElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>(ChooseElementModal_GetVideoElementsDocument, options);
        }
export type ChooseElementModal_GetVideoElementsQueryHookResult = ReturnType<typeof useChooseElementModal_GetVideoElementsQuery>;
export type ChooseElementModal_GetVideoElementsLazyQueryHookResult = ReturnType<typeof useChooseElementModal_GetVideoElementsLazyQuery>;
export type ChooseElementModal_GetVideoElementsQueryResult = Apollo.QueryResult<ChooseElementModal_GetVideoElementsQuery, ChooseElementModal_GetVideoElementsQueryVariables>;
export const ManageConferenceExportPage_GetGoogleOAuthUrlDocument = gql`
    mutation ManageConferenceExportPage_GetGoogleOAuthUrl($registrantId: uuid!, $scopes: [String!]!) {
  getGoogleOAuthUrl(registrantId: $registrantId, scopes: $scopes) {
    url
  }
}
    `;
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationFn = Apollo.MutationFunction<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>;

/**
 * __useManageConferenceExportPage_GetGoogleOAuthUrlMutation__
 *
 * To run a mutation, you first call `useManageConferenceExportPage_GetGoogleOAuthUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageConferenceExportPage_GetGoogleOAuthUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageConferenceExportPageGetGoogleOAuthUrlMutation, { data, loading, error }] = useManageConferenceExportPage_GetGoogleOAuthUrlMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      scopes: // value for 'scopes'
 *   },
 * });
 */
export function useManageConferenceExportPage_GetGoogleOAuthUrlMutation(baseOptions?: Apollo.MutationHookOptions<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>(ManageConferenceExportPage_GetGoogleOAuthUrlDocument, options);
      }
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationHookResult = ReturnType<typeof useManageConferenceExportPage_GetGoogleOAuthUrlMutation>;
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationResult = Apollo.MutationResult<ManageConferenceExportPage_GetGoogleOAuthUrlMutation>;
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationOptions = Apollo.BaseMutationOptions<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>;
export const ManageConferenceExportPage_GetRegistrantGoogleAccountsDocument = gql`
    query ManageConferenceExportPage_GetRegistrantGoogleAccounts($registrantId: uuid!) {
  registrant_GoogleAccount(where: {registrantId: {_eq: $registrantId}}) {
    ...ManageConferenceExportPage_RegistrantGoogleAccount
  }
}
    ${ManageConferenceExportPage_RegistrantGoogleAccountFragmentDoc}`;

/**
 * __useManageConferenceExportPage_GetRegistrantGoogleAccountsQuery__
 *
 * To run a query within a React component, call `useManageConferenceExportPage_GetRegistrantGoogleAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageConferenceExportPage_GetRegistrantGoogleAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageConferenceExportPage_GetRegistrantGoogleAccountsQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useManageConferenceExportPage_GetRegistrantGoogleAccountsQuery(baseOptions: Apollo.QueryHookOptions<ManageConferenceExportPage_GetRegistrantGoogleAccountsQuery, ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageConferenceExportPage_GetRegistrantGoogleAccountsQuery, ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryVariables>(ManageConferenceExportPage_GetRegistrantGoogleAccountsDocument, options);
      }
export function useManageConferenceExportPage_GetRegistrantGoogleAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageConferenceExportPage_GetRegistrantGoogleAccountsQuery, ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageConferenceExportPage_GetRegistrantGoogleAccountsQuery, ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryVariables>(ManageConferenceExportPage_GetRegistrantGoogleAccountsDocument, options);
        }
export type ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryHookResult = ReturnType<typeof useManageConferenceExportPage_GetRegistrantGoogleAccountsQuery>;
export type ManageConferenceExportPage_GetRegistrantGoogleAccountsLazyQueryHookResult = ReturnType<typeof useManageConferenceExportPage_GetRegistrantGoogleAccountsLazyQuery>;
export type ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryResult = Apollo.QueryResult<ManageConferenceExportPage_GetRegistrantGoogleAccountsQuery, ManageConferenceExportPage_GetRegistrantGoogleAccountsQueryVariables>;
export const ManageConferenceExportPage_DeleteRegistrantGoogleAccountDocument = gql`
    mutation ManageConferenceExportPage_DeleteRegistrantGoogleAccount($registrantGoogleAccountId: uuid!) {
  delete_registrant_GoogleAccount_by_pk(id: $registrantGoogleAccountId) {
    id
  }
}
    `;
export type ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationFn = Apollo.MutationFunction<ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation, ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationVariables>;

/**
 * __useManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation__
 *
 * To run a mutation, you first call `useManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageConferenceExportPageDeleteRegistrantGoogleAccountMutation, { data, loading, error }] = useManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation({
 *   variables: {
 *      registrantGoogleAccountId: // value for 'registrantGoogleAccountId'
 *   },
 * });
 */
export function useManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation(baseOptions?: Apollo.MutationHookOptions<ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation, ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation, ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationVariables>(ManageConferenceExportPage_DeleteRegistrantGoogleAccountDocument, options);
      }
export type ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationHookResult = ReturnType<typeof useManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation>;
export type ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationResult = Apollo.MutationResult<ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation>;
export type ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationOptions = Apollo.BaseMutationOptions<ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutation, ManageConferenceExportPage_DeleteRegistrantGoogleAccountMutationVariables>;
export const UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument = gql`
    query UploadYouTubeVideos_GetUploadYouTubeVideoJobs($conferenceId: uuid!) {
  job_queues_UploadYouTubeVideoJob(
    where: {conferenceId: {_eq: $conferenceId}, jobStatusName: {_neq: COMPLETED}}
    order_by: {createdAt: desc}
  ) {
    ...UploadYouTubeVideos_UploadYouTubeVideoJob
  }
}
    ${UploadYouTubeVideos_UploadYouTubeVideoJobFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>(UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument, options);
      }
export function useUploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>(UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument, options);
        }
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery>;
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQuery>;
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>;
export const UploadYouTubeVideos_GetRegistrantGoogleAccountsDocument = gql`
    query UploadYouTubeVideos_GetRegistrantGoogleAccounts($registrantId: uuid!) {
  registrant_GoogleAccount(where: {registrantId: {_eq: $registrantId}}) {
    id
    googleAccountEmail
    youTubeData
  }
}
    `;

/**
 * __useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>(UploadYouTubeVideos_GetRegistrantGoogleAccountsDocument, options);
      }
export function useUploadYouTubeVideos_GetRegistrantGoogleAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>(UploadYouTubeVideos_GetRegistrantGoogleAccountsDocument, options);
        }
export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetRegistrantGoogleAccountsQuery>;
export type UploadYouTubeVideos_GetRegistrantGoogleAccountsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetRegistrantGoogleAccountsLazyQuery>;
export type UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetRegistrantGoogleAccountsQuery, UploadYouTubeVideos_GetRegistrantGoogleAccountsQueryVariables>;
export const UploadYouTubeVideos_CreateUploadYouTubeVideoJobsDocument = gql`
    mutation UploadYouTubeVideos_CreateUploadYouTubeVideoJobs($objects: [job_queues_UploadYouTubeVideoJob_insert_input!]!) {
  insert_job_queues_UploadYouTubeVideoJob(objects: $objects) {
    returning {
      id
    }
  }
}
    `;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationFn = Apollo.MutationFunction<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>;

/**
 * __useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation__
 *
 * To run a mutation, you first call `useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadYouTubeVideosCreateUploadYouTubeVideoJobsMutation, { data, loading, error }] = useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation(baseOptions?: Apollo.MutationHookOptions<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>(UploadYouTubeVideos_CreateUploadYouTubeVideoJobsDocument, options);
      }
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationHookResult = ReturnType<typeof useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation>;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationResult = Apollo.MutationResult<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation>;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationOptions = Apollo.BaseMutationOptions<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>;
export const UploadYouTubeVideos_GetElementsDocument = gql`
    query UploadYouTubeVideos_GetElements($elementIds: [uuid!]!) {
  content_Element(where: {id: {_in: $elementIds}}) {
    id
    name
    item {
      id
      title
    }
  }
}
    `;

/**
 * __useUploadYouTubeVideos_GetElementsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetElementsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetElementsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetElementsQuery({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetElementsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>(UploadYouTubeVideos_GetElementsDocument, options);
      }
export function useUploadYouTubeVideos_GetElementsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>(UploadYouTubeVideos_GetElementsDocument, options);
        }
export type UploadYouTubeVideos_GetElementsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetElementsQuery>;
export type UploadYouTubeVideos_GetElementsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetElementsLazyQuery>;
export type UploadYouTubeVideos_GetElementsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetElementsQuery, UploadYouTubeVideos_GetElementsQueryVariables>;
export const UploadYouTubeVideos_GetTemplateDataDocument = gql`
    query UploadYouTubeVideos_GetTemplateData($elementIds: [uuid!]!) {
  content_Element(where: {id: {_in: $elementIds}}) {
    id
    name
    item {
      id
      shortTitle
      title
      elements {
        id
        youTubeUploads {
          id
          videoTitle
          videoId
        }
      }
      abstractElements: elements(
        where: {typeName: {_eq: ABSTRACT}}
        order_by: {updatedAt: desc}
        limit: 1
      ) {
        ...UploadYouTubeVideos_Element
      }
      paperLinkElements: elements(where: {typeName: {_eq: PAPER_LINK}}) {
        ...UploadYouTubeVideos_Element
      }
      paperUrlElements: elements(where: {typeName: {_eq: PAPER_URL}}) {
        ...UploadYouTubeVideos_Element
      }
      authors: itemPeople(where: {roleName: {_eq: "AUTHOR"}}) {
        id
        person {
          id
          name
          affiliation
        }
      }
    }
  }
}
    ${UploadYouTubeVideos_ElementFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetTemplateDataQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetTemplateDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetTemplateDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetTemplateDataQuery({
 *   variables: {
 *      elementIds: // value for 'elementIds'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetTemplateDataQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>(UploadYouTubeVideos_GetTemplateDataDocument, options);
      }
export function useUploadYouTubeVideos_GetTemplateDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>(UploadYouTubeVideos_GetTemplateDataDocument, options);
        }
export type UploadYouTubeVideos_GetTemplateDataQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetTemplateDataQuery>;
export type UploadYouTubeVideos_GetTemplateDataLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetTemplateDataLazyQuery>;
export type UploadYouTubeVideos_GetTemplateDataQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>;
export const UploadYouTubeVideos_RefreshYouTubeDataDocument = gql`
    mutation UploadYouTubeVideos_RefreshYouTubeData($registrantId: uuid!, $registrantGoogleAccountId: uuid!) {
  refreshYouTubeData(
    registrantId: $registrantId
    registrantGoogleAccountId: $registrantGoogleAccountId
  ) {
    message
    success
  }
}
    `;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationFn = Apollo.MutationFunction<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>;

/**
 * __useUploadYouTubeVideos_RefreshYouTubeDataMutation__
 *
 * To run a mutation, you first call `useUploadYouTubeVideos_RefreshYouTubeDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_RefreshYouTubeDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadYouTubeVideosRefreshYouTubeDataMutation, { data, loading, error }] = useUploadYouTubeVideos_RefreshYouTubeDataMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      registrantGoogleAccountId: // value for 'registrantGoogleAccountId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_RefreshYouTubeDataMutation(baseOptions?: Apollo.MutationHookOptions<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>(UploadYouTubeVideos_RefreshYouTubeDataDocument, options);
      }
export type UploadYouTubeVideos_RefreshYouTubeDataMutationHookResult = ReturnType<typeof useUploadYouTubeVideos_RefreshYouTubeDataMutation>;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationResult = Apollo.MutationResult<UploadYouTubeVideos_RefreshYouTubeDataMutation>;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationOptions = Apollo.BaseMutationOptions<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>;
export const UploadYouTubeVideos_GetYouTubeUploadsDocument = gql`
    query UploadYouTubeVideos_GetYouTubeUploads($conferenceId: uuid!) {
  video_YouTubeUpload(where: {conferenceId: {_eq: $conferenceId}}) {
    ...UploadYouTubeVideos_YouTubeUpload
  }
}
    ${UploadYouTubeVideos_YouTubeUploadFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetYouTubeUploadsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetYouTubeUploadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetYouTubeUploadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetYouTubeUploadsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetYouTubeUploadsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>(UploadYouTubeVideos_GetYouTubeUploadsDocument, options);
      }
export function useUploadYouTubeVideos_GetYouTubeUploadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>(UploadYouTubeVideos_GetYouTubeUploadsDocument, options);
        }
export type UploadYouTubeVideos_GetYouTubeUploadsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetYouTubeUploadsQuery>;
export type UploadYouTubeVideos_GetYouTubeUploadsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetYouTubeUploadsLazyQuery>;
export type UploadYouTubeVideos_GetYouTubeUploadsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>;
export const ImportRegistrantsDocument = gql`
    mutation ImportRegistrants($insertRegistrants: [registrant_Registrant_insert_input!]!, $insertInvitations: [registrant_Invitation_insert_input!]!, $insertGroupRegistrants: [permissions_GroupRegistrant_insert_input!]!) {
  insert_registrant_Registrant(objects: $insertRegistrants) {
    affected_rows
  }
  insert_registrant_Invitation(objects: $insertInvitations) {
    affected_rows
  }
  insert_permissions_GroupRegistrant(objects: $insertGroupRegistrants) {
    affected_rows
  }
}
    `;
export type ImportRegistrantsMutationFn = Apollo.MutationFunction<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>;

/**
 * __useImportRegistrantsMutation__
 *
 * To run a mutation, you first call `useImportRegistrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportRegistrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importRegistrantsMutation, { data, loading, error }] = useImportRegistrantsMutation({
 *   variables: {
 *      insertRegistrants: // value for 'insertRegistrants'
 *      insertInvitations: // value for 'insertInvitations'
 *      insertGroupRegistrants: // value for 'insertGroupRegistrants'
 *   },
 * });
 */
export function useImportRegistrantsMutation(baseOptions?: Apollo.MutationHookOptions<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>(ImportRegistrantsDocument, options);
      }
export type ImportRegistrantsMutationHookResult = ReturnType<typeof useImportRegistrantsMutation>;
export type ImportRegistrantsMutationResult = Apollo.MutationResult<ImportRegistrantsMutation>;
export type ImportRegistrantsMutationOptions = Apollo.BaseMutationOptions<ImportRegistrantsMutation, ImportRegistrantsMutationVariables>;
export const ManageContent_SelectAllItemsDocument = gql`
    query ManageContent_SelectAllItems($conferenceId: uuid!) {
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContent_Item
  }
}
    ${ManageContent_ItemFragmentDoc}`;

/**
 * __useManageContent_SelectAllItemsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectAllItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectAllItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectAllItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectAllItemsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>(ManageContent_SelectAllItemsDocument, options);
      }
export function useManageContent_SelectAllItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>(ManageContent_SelectAllItemsDocument, options);
        }
export type ManageContent_SelectAllItemsQueryHookResult = ReturnType<typeof useManageContent_SelectAllItemsQuery>;
export type ManageContent_SelectAllItemsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectAllItemsLazyQuery>;
export type ManageContent_SelectAllItemsQueryResult = Apollo.QueryResult<ManageContent_SelectAllItemsQuery, ManageContent_SelectAllItemsQueryVariables>;
export const ManageContent_SelectItemDocument = gql`
    query ManageContent_SelectItem($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    ...ManageContent_ItemSecondary
  }
  content_Element(where: {itemId: {_eq: $itemId}, uploadableId: {_is_null: true}}) {
    ...ManageContent_Element
  }
  content_UploadableElement(where: {itemId: {_eq: $itemId}}) {
    ...ManageContent_UploadableElement
  }
}
    ${ManageContent_ItemSecondaryFragmentDoc}
${ManageContent_ElementFragmentDoc}
${ManageContent_UploadableElementFragmentDoc}`;

/**
 * __useManageContent_SelectItemQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectItemQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useManageContent_SelectItemQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>(ManageContent_SelectItemDocument, options);
      }
export function useManageContent_SelectItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>(ManageContent_SelectItemDocument, options);
        }
export type ManageContent_SelectItemQueryHookResult = ReturnType<typeof useManageContent_SelectItemQuery>;
export type ManageContent_SelectItemLazyQueryHookResult = ReturnType<typeof useManageContent_SelectItemLazyQuery>;
export type ManageContent_SelectItemQueryResult = Apollo.QueryResult<ManageContent_SelectItemQuery, ManageContent_SelectItemQueryVariables>;
export const ManageContent_SelectItemPeopleDocument = gql`
    query ManageContent_SelectItemPeople($itemId: uuid!) {
  content_ItemProgramPerson(where: {itemId: {_eq: $itemId}}) {
    ...ManageContent_ItemProgramPerson
  }
}
    ${ManageContent_ItemProgramPersonFragmentDoc}`;

/**
 * __useManageContent_SelectItemPeopleQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectItemPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectItemPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectItemPeopleQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useManageContent_SelectItemPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>(ManageContent_SelectItemPeopleDocument, options);
      }
export function useManageContent_SelectItemPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>(ManageContent_SelectItemPeopleDocument, options);
        }
export type ManageContent_SelectItemPeopleQueryHookResult = ReturnType<typeof useManageContent_SelectItemPeopleQuery>;
export type ManageContent_SelectItemPeopleLazyQueryHookResult = ReturnType<typeof useManageContent_SelectItemPeopleLazyQuery>;
export type ManageContent_SelectItemPeopleQueryResult = Apollo.QueryResult<ManageContent_SelectItemPeopleQuery, ManageContent_SelectItemPeopleQueryVariables>;
export const ManageContent_InsertItemDocument = gql`
    mutation ManageContent_InsertItem($item: content_Item_insert_input!, $itemTags: [content_ItemTag_insert_input!]!) {
  insert_content_Item_one(object: $item) {
    ...ManageContent_Item
  }
  insert_content_ItemTag(objects: $itemTags) {
    returning {
      id
    }
  }
}
    ${ManageContent_ItemFragmentDoc}`;
export type ManageContent_InsertItemMutationFn = Apollo.MutationFunction<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>;

/**
 * __useManageContent_InsertItemMutation__
 *
 * To run a mutation, you first call `useManageContent_InsertItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_InsertItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentInsertItemMutation, { data, loading, error }] = useManageContent_InsertItemMutation({
 *   variables: {
 *      item: // value for 'item'
 *      itemTags: // value for 'itemTags'
 *   },
 * });
 */
export function useManageContent_InsertItemMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>(ManageContent_InsertItemDocument, options);
      }
export type ManageContent_InsertItemMutationHookResult = ReturnType<typeof useManageContent_InsertItemMutation>;
export type ManageContent_InsertItemMutationResult = Apollo.MutationResult<ManageContent_InsertItemMutation>;
export type ManageContent_InsertItemMutationOptions = Apollo.BaseMutationOptions<ManageContent_InsertItemMutation, ManageContent_InsertItemMutationVariables>;
export const ManageContent_UpdateItemDocument = gql`
    mutation ManageContent_UpdateItem($id: uuid!, $item: content_Item_set_input!, $tags: [content_ItemTag_insert_input!]!, $tagIds: [uuid!]!) {
  insert_content_ItemTag(
    objects: $tags
    on_conflict: {constraint: ItemTag_itemId_tagId_key, update_columns: []}
  ) {
    returning {
      ...ManageContent_ItemTag
    }
  }
  delete_content_ItemTag(where: {tagId: {_nin: $tagIds}, itemId: {_eq: $id}}) {
    returning {
      id
    }
  }
  update_content_Item_by_pk(pk_columns: {id: $id}, _set: $item) {
    ...ManageContent_Item
  }
}
    ${ManageContent_ItemTagFragmentDoc}
${ManageContent_ItemFragmentDoc}`;
export type ManageContent_UpdateItemMutationFn = Apollo.MutationFunction<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>;

/**
 * __useManageContent_UpdateItemMutation__
 *
 * To run a mutation, you first call `useManageContent_UpdateItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_UpdateItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentUpdateItemMutation, { data, loading, error }] = useManageContent_UpdateItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *      item: // value for 'item'
 *      tags: // value for 'tags'
 *      tagIds: // value for 'tagIds'
 *   },
 * });
 */
export function useManageContent_UpdateItemMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>(ManageContent_UpdateItemDocument, options);
      }
export type ManageContent_UpdateItemMutationHookResult = ReturnType<typeof useManageContent_UpdateItemMutation>;
export type ManageContent_UpdateItemMutationResult = Apollo.MutationResult<ManageContent_UpdateItemMutation>;
export type ManageContent_UpdateItemMutationOptions = Apollo.BaseMutationOptions<ManageContent_UpdateItemMutation, ManageContent_UpdateItemMutationVariables>;
export const ManageContent_DeleteItemsDocument = gql`
    mutation ManageContent_DeleteItems($ids: [uuid!]!) {
  delete_content_Item(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContent_DeleteItemsMutationFn = Apollo.MutationFunction<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>;

/**
 * __useManageContent_DeleteItemsMutation__
 *
 * To run a mutation, you first call `useManageContent_DeleteItemsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContent_DeleteItemsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentDeleteItemsMutation, { data, loading, error }] = useManageContent_DeleteItemsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContent_DeleteItemsMutation(baseOptions?: Apollo.MutationHookOptions<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>(ManageContent_DeleteItemsDocument, options);
      }
export type ManageContent_DeleteItemsMutationHookResult = ReturnType<typeof useManageContent_DeleteItemsMutation>;
export type ManageContent_DeleteItemsMutationResult = Apollo.MutationResult<ManageContent_DeleteItemsMutation>;
export type ManageContent_DeleteItemsMutationOptions = Apollo.BaseMutationOptions<ManageContent_DeleteItemsMutation, ManageContent_DeleteItemsMutationVariables>;
export const ManageContent_SelectAllTagsDocument = gql`
    query ManageContent_SelectAllTags($conferenceId: uuid!) {
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContent_Tag
  }
}
    ${ManageContent_TagFragmentDoc}`;

/**
 * __useManageContent_SelectAllTagsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectAllTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectAllTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectAllTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectAllTagsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>(ManageContent_SelectAllTagsDocument, options);
      }
export function useManageContent_SelectAllTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>(ManageContent_SelectAllTagsDocument, options);
        }
export type ManageContent_SelectAllTagsQueryHookResult = ReturnType<typeof useManageContent_SelectAllTagsQuery>;
export type ManageContent_SelectAllTagsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectAllTagsLazyQuery>;
export type ManageContent_SelectAllTagsQueryResult = Apollo.QueryResult<ManageContent_SelectAllTagsQuery, ManageContent_SelectAllTagsQueryVariables>;
export const ManageContent_SelectAllExhibitionsDocument = gql`
    query ManageContent_SelectAllExhibitions($conferenceId: uuid!) {
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContent_Exhibition
  }
}
    ${ManageContent_ExhibitionFragmentDoc}`;

/**
 * __useManageContent_SelectAllExhibitionsQuery__
 *
 * To run a query within a React component, call `useManageContent_SelectAllExhibitionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContent_SelectAllExhibitionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContent_SelectAllExhibitionsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContent_SelectAllExhibitionsQuery(baseOptions: Apollo.QueryHookOptions<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>(ManageContent_SelectAllExhibitionsDocument, options);
      }
export function useManageContent_SelectAllExhibitionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>(ManageContent_SelectAllExhibitionsDocument, options);
        }
export type ManageContent_SelectAllExhibitionsQueryHookResult = ReturnType<typeof useManageContent_SelectAllExhibitionsQuery>;
export type ManageContent_SelectAllExhibitionsLazyQueryHookResult = ReturnType<typeof useManageContent_SelectAllExhibitionsLazyQuery>;
export type ManageContent_SelectAllExhibitionsQueryResult = Apollo.QueryResult<ManageContent_SelectAllExhibitionsQuery, ManageContent_SelectAllExhibitionsQueryVariables>;
export const SelectAllGroupsDocument = gql`
    query SelectAllGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageGroups_Group
  }
}
    ${ManageGroups_GroupFragmentDoc}`;

/**
 * __useSelectAllGroupsQuery__
 *
 * To run a query within a React component, call `useSelectAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllGroupsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, options);
      }
export function useSelectAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, options);
        }
export type SelectAllGroupsQueryHookResult = ReturnType<typeof useSelectAllGroupsQuery>;
export type SelectAllGroupsLazyQueryHookResult = ReturnType<typeof useSelectAllGroupsLazyQuery>;
export type SelectAllGroupsQueryResult = Apollo.QueryResult<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>;
export const CreateDeleteGroupsDocument = gql`
    mutation CreateDeleteGroups($deleteGroupIds: [uuid!] = [], $insertGroups: [permissions_Group_insert_input!]!) {
  delete_permissions_Group(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
  insert_permissions_Group(objects: $insertGroups) {
    returning {
      id
      conferenceId
      name
      enabled
      includeUnauthenticated
      groupRoles {
        id
        groupId
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteGroupsMutationFn = Apollo.MutationFunction<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;

/**
 * __useCreateDeleteGroupsMutation__
 *
 * To run a mutation, you first call `useCreateDeleteGroupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteGroupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteGroupsMutation, { data, loading, error }] = useCreateDeleteGroupsMutation({
 *   variables: {
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *      insertGroups: // value for 'insertGroups'
 *   },
 * });
 */
export function useCreateDeleteGroupsMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>(CreateDeleteGroupsDocument, options);
      }
export type CreateDeleteGroupsMutationHookResult = ReturnType<typeof useCreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationResult = Apollo.MutationResult<CreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationOptions = Apollo.BaseMutationOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;
export const UpdateGroupDocument = gql`
    mutation UpdateGroup($groupId: uuid!, $groupName: String!, $enabled: Boolean!, $includeUnauthenticated: Boolean!, $insertRoles: [permissions_GroupRole_insert_input!]!, $deleteRoleIds: [uuid!] = []) {
  update_permissions_Group(
    where: {id: {_eq: $groupId}}
    _set: {name: $groupName, enabled: $enabled, includeUnauthenticated: $includeUnauthenticated}
  ) {
    returning {
      id
      name
      groupRoles {
        id
        groupId
        roleId
      }
      conferenceId
    }
  }
  insert_permissions_GroupRole(objects: $insertRoles) {
    returning {
      id
      groupId
      roleId
    }
  }
  delete_permissions_GroupRole(
    where: {groupId: {_eq: $groupId}, roleId: {_in: $deleteRoleIds}}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateGroupMutationFn = Apollo.MutationFunction<UpdateGroupMutation, UpdateGroupMutationVariables>;

/**
 * __useUpdateGroupMutation__
 *
 * To run a mutation, you first call `useUpdateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupMutation, { data, loading, error }] = useUpdateGroupMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      groupName: // value for 'groupName'
 *      enabled: // value for 'enabled'
 *      includeUnauthenticated: // value for 'includeUnauthenticated'
 *      insertRoles: // value for 'insertRoles'
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *   },
 * });
 */
export function useUpdateGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupMutation, UpdateGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupMutation, UpdateGroupMutationVariables>(UpdateGroupDocument, options);
      }
export type UpdateGroupMutationHookResult = ReturnType<typeof useUpdateGroupMutation>;
export type UpdateGroupMutationResult = Apollo.MutationResult<UpdateGroupMutation>;
export type UpdateGroupMutationOptions = Apollo.BaseMutationOptions<UpdateGroupMutation, UpdateGroupMutationVariables>;
export const UpdateConferenceDocument = gql`
    mutation UpdateConference($id: uuid!, $name: String = "", $shortName: String = "", $slug: String = "") {
  update_conference_Conference(
    where: {id: {_eq: $id}}
    _set: {name: $name, shortName: $shortName, slug: $slug}
  ) {
    returning {
      id
      name
      shortName
      slug
    }
  }
}
    `;
export type UpdateConferenceMutationFn = Apollo.MutationFunction<UpdateConferenceMutation, UpdateConferenceMutationVariables>;

/**
 * __useUpdateConferenceMutation__
 *
 * To run a mutation, you first call `useUpdateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConferenceMutation, { data, loading, error }] = useUpdateConferenceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useUpdateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConferenceMutation, UpdateConferenceMutationVariables>(UpdateConferenceDocument, options);
      }
export type UpdateConferenceMutationHookResult = ReturnType<typeof useUpdateConferenceMutation>;
export type UpdateConferenceMutationResult = Apollo.MutationResult<UpdateConferenceMutation>;
export type UpdateConferenceMutationOptions = Apollo.BaseMutationOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>;
export const ManageProgramPeople_SelectAllPeopleDocument = gql`
    query ManageProgramPeople_SelectAllPeople($conferenceId: uuid!) {
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageProgramPeople_ProgramPerson
  }
}
    ${ManageProgramPeople_ProgramPersonFragmentDoc}`;

/**
 * __useManageProgramPeople_SelectAllPeopleQuery__
 *
 * To run a query within a React component, call `useManageProgramPeople_SelectAllPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_SelectAllPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageProgramPeople_SelectAllPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageProgramPeople_SelectAllPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>(ManageProgramPeople_SelectAllPeopleDocument, options);
      }
export function useManageProgramPeople_SelectAllPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>(ManageProgramPeople_SelectAllPeopleDocument, options);
        }
export type ManageProgramPeople_SelectAllPeopleQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllPeopleQuery>;
export type ManageProgramPeople_SelectAllPeopleLazyQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllPeopleLazyQuery>;
export type ManageProgramPeople_SelectAllPeopleQueryResult = Apollo.QueryResult<ManageProgramPeople_SelectAllPeopleQuery, ManageProgramPeople_SelectAllPeopleQueryVariables>;
export const ManageProgramPeople_SelectAllRegistrantsDocument = gql`
    query ManageProgramPeople_SelectAllRegistrants($conferenceId: uuid!) {
  registrant_Registrant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageProgramPeople_Registrant
  }
}
    ${ManageProgramPeople_RegistrantFragmentDoc}`;

/**
 * __useManageProgramPeople_SelectAllRegistrantsQuery__
 *
 * To run a query within a React component, call `useManageProgramPeople_SelectAllRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_SelectAllRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageProgramPeople_SelectAllRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageProgramPeople_SelectAllRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>(ManageProgramPeople_SelectAllRegistrantsDocument, options);
      }
export function useManageProgramPeople_SelectAllRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>(ManageProgramPeople_SelectAllRegistrantsDocument, options);
        }
export type ManageProgramPeople_SelectAllRegistrantsQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllRegistrantsQuery>;
export type ManageProgramPeople_SelectAllRegistrantsLazyQueryHookResult = ReturnType<typeof useManageProgramPeople_SelectAllRegistrantsLazyQuery>;
export type ManageProgramPeople_SelectAllRegistrantsQueryResult = Apollo.QueryResult<ManageProgramPeople_SelectAllRegistrantsQuery, ManageProgramPeople_SelectAllRegistrantsQueryVariables>;
export const ManageProgramPeople_InsertProgramPersonDocument = gql`
    mutation ManageProgramPeople_InsertProgramPerson($person: collection_ProgramPerson_insert_input!) {
  insert_collection_ProgramPerson_one(object: $person) {
    ...ManageProgramPeople_ProgramPerson
  }
}
    ${ManageProgramPeople_ProgramPersonFragmentDoc}`;
export type ManageProgramPeople_InsertProgramPersonMutationFn = Apollo.MutationFunction<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>;

/**
 * __useManageProgramPeople_InsertProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageProgramPeople_InsertProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_InsertProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageProgramPeopleInsertProgramPersonMutation, { data, loading, error }] = useManageProgramPeople_InsertProgramPersonMutation({
 *   variables: {
 *      person: // value for 'person'
 *   },
 * });
 */
export function useManageProgramPeople_InsertProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>(ManageProgramPeople_InsertProgramPersonDocument, options);
      }
export type ManageProgramPeople_InsertProgramPersonMutationHookResult = ReturnType<typeof useManageProgramPeople_InsertProgramPersonMutation>;
export type ManageProgramPeople_InsertProgramPersonMutationResult = Apollo.MutationResult<ManageProgramPeople_InsertProgramPersonMutation>;
export type ManageProgramPeople_InsertProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageProgramPeople_InsertProgramPersonMutation, ManageProgramPeople_InsertProgramPersonMutationVariables>;
export const ManageProgramPeople_DeleteProgramPersonsDocument = gql`
    mutation ManageProgramPeople_DeleteProgramPersons($ids: [uuid!] = []) {
  delete_collection_ProgramPerson(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageProgramPeople_DeleteProgramPersonsMutationFn = Apollo.MutationFunction<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>;

/**
 * __useManageProgramPeople_DeleteProgramPersonsMutation__
 *
 * To run a mutation, you first call `useManageProgramPeople_DeleteProgramPersonsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_DeleteProgramPersonsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageProgramPeopleDeleteProgramPersonsMutation, { data, loading, error }] = useManageProgramPeople_DeleteProgramPersonsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageProgramPeople_DeleteProgramPersonsMutation(baseOptions?: Apollo.MutationHookOptions<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>(ManageProgramPeople_DeleteProgramPersonsDocument, options);
      }
export type ManageProgramPeople_DeleteProgramPersonsMutationHookResult = ReturnType<typeof useManageProgramPeople_DeleteProgramPersonsMutation>;
export type ManageProgramPeople_DeleteProgramPersonsMutationResult = Apollo.MutationResult<ManageProgramPeople_DeleteProgramPersonsMutation>;
export type ManageProgramPeople_DeleteProgramPersonsMutationOptions = Apollo.BaseMutationOptions<ManageProgramPeople_DeleteProgramPersonsMutation, ManageProgramPeople_DeleteProgramPersonsMutationVariables>;
export const ManageProgramPeople_UpdateProgramPersonDocument = gql`
    mutation ManageProgramPeople_UpdateProgramPerson($id: uuid!, $name: String!, $affiliation: String, $email: String, $registrantId: uuid) {
  update_collection_ProgramPerson_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, affiliation: $affiliation, email: $email, registrantId: $registrantId}
  ) {
    ...ManageProgramPeople_ProgramPerson
  }
}
    ${ManageProgramPeople_ProgramPersonFragmentDoc}`;
export type ManageProgramPeople_UpdateProgramPersonMutationFn = Apollo.MutationFunction<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>;

/**
 * __useManageProgramPeople_UpdateProgramPersonMutation__
 *
 * To run a mutation, you first call `useManageProgramPeople_UpdateProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageProgramPeople_UpdateProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageProgramPeopleUpdateProgramPersonMutation, { data, loading, error }] = useManageProgramPeople_UpdateProgramPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      email: // value for 'email'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useManageProgramPeople_UpdateProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>(ManageProgramPeople_UpdateProgramPersonDocument, options);
      }
export type ManageProgramPeople_UpdateProgramPersonMutationHookResult = ReturnType<typeof useManageProgramPeople_UpdateProgramPersonMutation>;
export type ManageProgramPeople_UpdateProgramPersonMutationResult = Apollo.MutationResult<ManageProgramPeople_UpdateProgramPersonMutation>;
export type ManageProgramPeople_UpdateProgramPersonMutationOptions = Apollo.BaseMutationOptions<ManageProgramPeople_UpdateProgramPersonMutation, ManageProgramPeople_UpdateProgramPersonMutationVariables>;
export const SelectAllRegistrantsDocument = gql`
    query SelectAllRegistrants($conferenceId: uuid!) {
  registrant_Registrant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RegistrantParts
  }
}
    ${RegistrantPartsFragmentDoc}`;

/**
 * __useSelectAllRegistrantsQuery__
 *
 * To run a query within a React component, call `useSelectAllRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>(SelectAllRegistrantsDocument, options);
      }
export function useSelectAllRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>(SelectAllRegistrantsDocument, options);
        }
export type SelectAllRegistrantsQueryHookResult = ReturnType<typeof useSelectAllRegistrantsQuery>;
export type SelectAllRegistrantsLazyQueryHookResult = ReturnType<typeof useSelectAllRegistrantsLazyQuery>;
export type SelectAllRegistrantsQueryResult = Apollo.QueryResult<SelectAllRegistrantsQuery, SelectAllRegistrantsQueryVariables>;
export const InsertRegistrantDocument = gql`
    mutation InsertRegistrant($registrant: registrant_Registrant_insert_input!, $invitation: registrant_Invitation_insert_input!) {
  insert_registrant_Registrant_one(object: $registrant) {
    ...RegistrantParts
  }
  insert_registrant_Invitation_one(object: $invitation) {
    ...InvitationParts
  }
}
    ${RegistrantPartsFragmentDoc}
${InvitationPartsFragmentDoc}`;
export type InsertRegistrantMutationFn = Apollo.MutationFunction<InsertRegistrantMutation, InsertRegistrantMutationVariables>;

/**
 * __useInsertRegistrantMutation__
 *
 * To run a mutation, you first call `useInsertRegistrantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRegistrantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRegistrantMutation, { data, loading, error }] = useInsertRegistrantMutation({
 *   variables: {
 *      registrant: // value for 'registrant'
 *      invitation: // value for 'invitation'
 *   },
 * });
 */
export function useInsertRegistrantMutation(baseOptions?: Apollo.MutationHookOptions<InsertRegistrantMutation, InsertRegistrantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRegistrantMutation, InsertRegistrantMutationVariables>(InsertRegistrantDocument, options);
      }
export type InsertRegistrantMutationHookResult = ReturnType<typeof useInsertRegistrantMutation>;
export type InsertRegistrantMutationResult = Apollo.MutationResult<InsertRegistrantMutation>;
export type InsertRegistrantMutationOptions = Apollo.BaseMutationOptions<InsertRegistrantMutation, InsertRegistrantMutationVariables>;
export const InsertRegistrantWithoutInviteDocument = gql`
    mutation InsertRegistrantWithoutInvite($registrant: registrant_Registrant_insert_input!) {
  insert_registrant_Registrant_one(object: $registrant) {
    ...RegistrantParts
  }
}
    ${RegistrantPartsFragmentDoc}`;
export type InsertRegistrantWithoutInviteMutationFn = Apollo.MutationFunction<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>;

/**
 * __useInsertRegistrantWithoutInviteMutation__
 *
 * To run a mutation, you first call `useInsertRegistrantWithoutInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRegistrantWithoutInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRegistrantWithoutInviteMutation, { data, loading, error }] = useInsertRegistrantWithoutInviteMutation({
 *   variables: {
 *      registrant: // value for 'registrant'
 *   },
 * });
 */
export function useInsertRegistrantWithoutInviteMutation(baseOptions?: Apollo.MutationHookOptions<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>(InsertRegistrantWithoutInviteDocument, options);
      }
export type InsertRegistrantWithoutInviteMutationHookResult = ReturnType<typeof useInsertRegistrantWithoutInviteMutation>;
export type InsertRegistrantWithoutInviteMutationResult = Apollo.MutationResult<InsertRegistrantWithoutInviteMutation>;
export type InsertRegistrantWithoutInviteMutationOptions = Apollo.BaseMutationOptions<InsertRegistrantWithoutInviteMutation, InsertRegistrantWithoutInviteMutationVariables>;
export const DeleteRegistrantsDocument = gql`
    mutation DeleteRegistrants($deleteRegistrantIds: [uuid!] = []) {
  delete_registrant_Registrant(where: {id: {_in: $deleteRegistrantIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteRegistrantsMutationFn = Apollo.MutationFunction<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>;

/**
 * __useDeleteRegistrantsMutation__
 *
 * To run a mutation, you first call `useDeleteRegistrantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRegistrantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRegistrantsMutation, { data, loading, error }] = useDeleteRegistrantsMutation({
 *   variables: {
 *      deleteRegistrantIds: // value for 'deleteRegistrantIds'
 *   },
 * });
 */
export function useDeleteRegistrantsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>(DeleteRegistrantsDocument, options);
      }
export type DeleteRegistrantsMutationHookResult = ReturnType<typeof useDeleteRegistrantsMutation>;
export type DeleteRegistrantsMutationResult = Apollo.MutationResult<DeleteRegistrantsMutation>;
export type DeleteRegistrantsMutationOptions = Apollo.BaseMutationOptions<DeleteRegistrantsMutation, DeleteRegistrantsMutationVariables>;
export const UpdateRegistrantDocument = gql`
    mutation UpdateRegistrant($registrantId: uuid!, $registrantName: String!, $upsertGroups: [permissions_GroupRegistrant_insert_input!]!, $remainingGroupIds: [uuid!]) {
  update_registrant_Registrant_by_pk(
    pk_columns: {id: $registrantId}
    _set: {displayName: $registrantName}
  ) {
    ...RegistrantParts
  }
  insert_permissions_GroupRegistrant(
    objects: $upsertGroups
    on_conflict: {constraint: GroupRegistrant_groupId_registrantId_key, update_columns: []}
  ) {
    returning {
      id
      registrantId
      groupId
    }
  }
  delete_permissions_GroupRegistrant(
    where: {registrantId: {_eq: $registrantId}, groupId: {_nin: $remainingGroupIds}}
  ) {
    returning {
      id
    }
  }
}
    ${RegistrantPartsFragmentDoc}`;
export type UpdateRegistrantMutationFn = Apollo.MutationFunction<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>;

/**
 * __useUpdateRegistrantMutation__
 *
 * To run a mutation, you first call `useUpdateRegistrantMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRegistrantMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRegistrantMutation, { data, loading, error }] = useUpdateRegistrantMutation({
 *   variables: {
 *      registrantId: // value for 'registrantId'
 *      registrantName: // value for 'registrantName'
 *      upsertGroups: // value for 'upsertGroups'
 *      remainingGroupIds: // value for 'remainingGroupIds'
 *   },
 * });
 */
export function useUpdateRegistrantMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>(UpdateRegistrantDocument, options);
      }
export type UpdateRegistrantMutationHookResult = ReturnType<typeof useUpdateRegistrantMutation>;
export type UpdateRegistrantMutationResult = Apollo.MutationResult<UpdateRegistrantMutation>;
export type UpdateRegistrantMutationOptions = Apollo.BaseMutationOptions<UpdateRegistrantMutation, UpdateRegistrantMutationVariables>;
export const InsertInvitationEmailJobsDocument = gql`
    mutation InsertInvitationEmailJobs($registrantIds: jsonb!, $conferenceId: uuid!, $sendRepeat: Boolean!) {
  insert_job_queues_InvitationEmailJob(
    objects: [{registrantIds: $registrantIds, conferenceId: $conferenceId, sendRepeat: $sendRepeat}]
  ) {
    affected_rows
  }
}
    `;
export type InsertInvitationEmailJobsMutationFn = Apollo.MutationFunction<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;

/**
 * __useInsertInvitationEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertInvitationEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertInvitationEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertInvitationEmailJobsMutation, { data, loading, error }] = useInsertInvitationEmailJobsMutation({
 *   variables: {
 *      registrantIds: // value for 'registrantIds'
 *      conferenceId: // value for 'conferenceId'
 *      sendRepeat: // value for 'sendRepeat'
 *   },
 * });
 */
export function useInsertInvitationEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>(InsertInvitationEmailJobsDocument, options);
      }
export type InsertInvitationEmailJobsMutationHookResult = ReturnType<typeof useInsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationResult = Apollo.MutationResult<InsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;
export const ManageConferencePeoplePage_InsertCustomEmailJobDocument = gql`
    mutation ManageConferencePeoplePage_InsertCustomEmailJob($htmlBody: String!, $subject: String!, $conferenceId: uuid!, $registrantIds: jsonb!) {
  insert_job_queues_CustomEmailJob(
    objects: {htmlBody: $htmlBody, subject: $subject, conferenceId: $conferenceId, registrantIds: $registrantIds}
  ) {
    affected_rows
  }
}
    `;
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationFn = Apollo.MutationFunction<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>;

/**
 * __useManageConferencePeoplePage_InsertCustomEmailJobMutation__
 *
 * To run a mutation, you first call `useManageConferencePeoplePage_InsertCustomEmailJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageConferencePeoplePage_InsertCustomEmailJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageConferencePeoplePageInsertCustomEmailJobMutation, { data, loading, error }] = useManageConferencePeoplePage_InsertCustomEmailJobMutation({
 *   variables: {
 *      htmlBody: // value for 'htmlBody'
 *      subject: // value for 'subject'
 *      conferenceId: // value for 'conferenceId'
 *      registrantIds: // value for 'registrantIds'
 *   },
 * });
 */
export function useManageConferencePeoplePage_InsertCustomEmailJobMutation(baseOptions?: Apollo.MutationHookOptions<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>(ManageConferencePeoplePage_InsertCustomEmailJobDocument, options);
      }
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationHookResult = ReturnType<typeof useManageConferencePeoplePage_InsertCustomEmailJobMutation>;
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationResult = Apollo.MutationResult<ManageConferencePeoplePage_InsertCustomEmailJobMutation>;
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationOptions = Apollo.BaseMutationOptions<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>;
export const SelectAllPermissionsDocument = gql`
    query SelectAllPermissions {
  permissions_Permission {
    name
    description
  }
}
    `;

/**
 * __useSelectAllPermissionsQuery__
 *
 * To run a query within a React component, call `useSelectAllPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllPermissionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSelectAllPermissionsQuery(baseOptions?: Apollo.QueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, options);
      }
export function useSelectAllPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, options);
        }
export type SelectAllPermissionsQueryHookResult = ReturnType<typeof useSelectAllPermissionsQuery>;
export type SelectAllPermissionsLazyQueryHookResult = ReturnType<typeof useSelectAllPermissionsLazyQuery>;
export type SelectAllPermissionsQueryResult = Apollo.QueryResult<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>;
export const SelectAllRolesDocument = gql`
    query SelectAllRoles($conferenceId: uuid!) {
  permissions_Role(where: {conferenceId: {_eq: $conferenceId}}) {
    conferenceId
    id
    name
    rolePermissions {
      id
      permissionName
      roleId
    }
  }
}
    `;

/**
 * __useSelectAllRolesQuery__
 *
 * To run a query within a React component, call `useSelectAllRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRolesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRolesQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, options);
      }
export function useSelectAllRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, options);
        }
export type SelectAllRolesQueryHookResult = ReturnType<typeof useSelectAllRolesQuery>;
export type SelectAllRolesLazyQueryHookResult = ReturnType<typeof useSelectAllRolesLazyQuery>;
export type SelectAllRolesQueryResult = Apollo.QueryResult<SelectAllRolesQuery, SelectAllRolesQueryVariables>;
export const CreateDeleteRolesDocument = gql`
    mutation CreateDeleteRoles($deleteRoleIds: [uuid!] = [], $insertRoles: [permissions_Role_insert_input!]!) {
  delete_permissions_Role(where: {id: {_in: $deleteRoleIds}}) {
    returning {
      id
    }
  }
  insert_permissions_Role(objects: $insertRoles) {
    returning {
      id
      conferenceId
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteRolesMutationFn = Apollo.MutationFunction<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;

/**
 * __useCreateDeleteRolesMutation__
 *
 * To run a mutation, you first call `useCreateDeleteRolesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteRolesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteRolesMutation, { data, loading, error }] = useCreateDeleteRolesMutation({
 *   variables: {
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *      insertRoles: // value for 'insertRoles'
 *   },
 * });
 */
export function useCreateDeleteRolesMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>(CreateDeleteRolesDocument, options);
      }
export type CreateDeleteRolesMutationHookResult = ReturnType<typeof useCreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationResult = Apollo.MutationResult<CreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationOptions = Apollo.BaseMutationOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;
export const UpdateRoleDocument = gql`
    mutation UpdateRole($roleId: uuid!, $roleName: String!, $insertPermissions: [permissions_RolePermission_insert_input!]!, $deletePermissionNames: [permissions_Permission_enum!] = []) {
  update_permissions_Role(where: {id: {_eq: $roleId}}, _set: {name: $roleName}) {
    returning {
      id
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
      conferenceId
    }
  }
  insert_permissions_RolePermission(objects: $insertPermissions) {
    returning {
      id
      permissionName
      roleId
    }
  }
  delete_permissions_RolePermission(
    where: {roleId: {_eq: $roleId}, permissionName: {_in: $deletePermissionNames}}
  ) {
    returning {
      id
    }
  }
}
    `;
export type UpdateRoleMutationFn = Apollo.MutationFunction<UpdateRoleMutation, UpdateRoleMutationVariables>;

/**
 * __useUpdateRoleMutation__
 *
 * To run a mutation, you first call `useUpdateRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoleMutation, { data, loading, error }] = useUpdateRoleMutation({
 *   variables: {
 *      roleId: // value for 'roleId'
 *      roleName: // value for 'roleName'
 *      insertPermissions: // value for 'insertPermissions'
 *      deletePermissionNames: // value for 'deletePermissionNames'
 *   },
 * });
 */
export function useUpdateRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoleMutation, UpdateRoleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoleMutation, UpdateRoleMutationVariables>(UpdateRoleDocument, options);
      }
export type UpdateRoleMutationHookResult = ReturnType<typeof useUpdateRoleMutation>;
export type UpdateRoleMutationResult = Apollo.MutationResult<UpdateRoleMutation>;
export type UpdateRoleMutationOptions = Apollo.BaseMutationOptions<UpdateRoleMutation, UpdateRoleMutationVariables>;
export const SelectAllRoomsWithParticipantsDocument = gql`
    query SelectAllRoomsWithParticipants($conferenceId: uuid!) {
  room_Room(
    where: {conferenceId: {_eq: $conferenceId}, managementModeName: {_in: [PUBLIC, PRIVATE]}}
  ) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;

/**
 * __useSelectAllRoomsWithParticipantsQuery__
 *
 * To run a query within a React component, call `useSelectAllRoomsWithParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRoomsWithParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRoomsWithParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRoomsWithParticipantsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, options);
      }
export function useSelectAllRoomsWithParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, options);
        }
export type SelectAllRoomsWithParticipantsQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsQuery>;
export type SelectAllRoomsWithParticipantsLazyQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsLazyQuery>;
export type SelectAllRoomsWithParticipantsQueryResult = Apollo.QueryResult<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>;
export const ManageRooms_SelectGroupsDocument = gql`
    query ManageRooms_SelectGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
  }
}
    `;

/**
 * __useManageRooms_SelectGroupsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageRooms_SelectGroupsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>(ManageRooms_SelectGroupsDocument, options);
      }
export function useManageRooms_SelectGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>(ManageRooms_SelectGroupsDocument, options);
        }
export type ManageRooms_SelectGroupsQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupsQuery>;
export type ManageRooms_SelectGroupsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupsLazyQuery>;
export type ManageRooms_SelectGroupsQueryResult = Apollo.QueryResult<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>;
export const ManageRooms_SelectItemsDocument = gql`
    query ManageRooms_SelectItems($conferenceId: uuid!) {
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    title
  }
}
    `;

/**
 * __useManageRooms_SelectItemsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectItemsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageRooms_SelectItemsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>(ManageRooms_SelectItemsDocument, options);
      }
export function useManageRooms_SelectItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>(ManageRooms_SelectItemsDocument, options);
        }
export type ManageRooms_SelectItemsQueryHookResult = ReturnType<typeof useManageRooms_SelectItemsQuery>;
export type ManageRooms_SelectItemsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectItemsLazyQuery>;
export type ManageRooms_SelectItemsQueryResult = Apollo.QueryResult<ManageRooms_SelectItemsQuery, ManageRooms_SelectItemsQueryVariables>;
export const ManageRooms_SelectGroupRegistrantsDocument = gql`
    query ManageRooms_SelectGroupRegistrants($groupId: uuid!) {
  permissions_GroupRegistrant(where: {groupId: {_eq: $groupId}}) {
    id
    groupId
    registrantId
  }
}
    `;

/**
 * __useManageRooms_SelectGroupRegistrantsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectGroupRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectGroupRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectGroupRegistrantsQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useManageRooms_SelectGroupRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>(ManageRooms_SelectGroupRegistrantsDocument, options);
      }
export function useManageRooms_SelectGroupRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>(ManageRooms_SelectGroupRegistrantsDocument, options);
        }
export type ManageRooms_SelectGroupRegistrantsQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupRegistrantsQuery>;
export type ManageRooms_SelectGroupRegistrantsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupRegistrantsLazyQuery>;
export type ManageRooms_SelectGroupRegistrantsQueryResult = Apollo.QueryResult<ManageRooms_SelectGroupRegistrantsQuery, ManageRooms_SelectGroupRegistrantsQueryVariables>;
export const ManageRooms_SelectRoomPeopleDocument = gql`
    query ManageRooms_SelectRoomPeople($roomId: uuid!) {
  room_RoomPerson(where: {roomId: {_eq: $roomId}}) {
    ...RoomPersonInfo
  }
}
    ${RoomPersonInfoFragmentDoc}`;

/**
 * __useManageRooms_SelectRoomPeopleQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectRoomPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectRoomPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectRoomPeopleQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useManageRooms_SelectRoomPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>(ManageRooms_SelectRoomPeopleDocument, options);
      }
export function useManageRooms_SelectRoomPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>(ManageRooms_SelectRoomPeopleDocument, options);
        }
export type ManageRooms_SelectRoomPeopleQueryHookResult = ReturnType<typeof useManageRooms_SelectRoomPeopleQuery>;
export type ManageRooms_SelectRoomPeopleLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectRoomPeopleLazyQuery>;
export type ManageRooms_SelectRoomPeopleQueryResult = Apollo.QueryResult<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>;
export const CreateRoomDocument = gql`
    mutation CreateRoom($room: room_Room_insert_input!) {
  insert_room_Room_one(object: $room) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type CreateRoomMutationFn = Apollo.MutationFunction<CreateRoomMutation, CreateRoomMutationVariables>;

/**
 * __useCreateRoomMutation__
 *
 * To run a mutation, you first call `useCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoomMutation, { data, loading, error }] = useCreateRoomMutation({
 *   variables: {
 *      room: // value for 'room'
 *   },
 * });
 */
export function useCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<CreateRoomMutation, CreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRoomMutation, CreateRoomMutationVariables>(CreateRoomDocument, options);
      }
export type CreateRoomMutationHookResult = ReturnType<typeof useCreateRoomMutation>;
export type CreateRoomMutationResult = Apollo.MutationResult<CreateRoomMutation>;
export type CreateRoomMutationOptions = Apollo.BaseMutationOptions<CreateRoomMutation, CreateRoomMutationVariables>;
export const UpdateRoomsWithParticipantsDocument = gql`
    mutation UpdateRoomsWithParticipants($id: uuid!, $name: String!, $capacity: Int, $priority: Int!, $managementModeName: room_ManagementMode_enum!, $originatingItemId: uuid) {
  update_room_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, priority: $priority, managementModeName: $managementModeName, originatingItemId: $originatingItemId}
  ) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type UpdateRoomsWithParticipantsMutationFn = Apollo.MutationFunction<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;

/**
 * __useUpdateRoomsWithParticipantsMutation__
 *
 * To run a mutation, you first call `useUpdateRoomsWithParticipantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomsWithParticipantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomsWithParticipantsMutation, { data, loading, error }] = useUpdateRoomsWithParticipantsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      priority: // value for 'priority'
 *      managementModeName: // value for 'managementModeName'
 *      originatingItemId: // value for 'originatingItemId'
 *   },
 * });
 */
export function useUpdateRoomsWithParticipantsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>(UpdateRoomsWithParticipantsDocument, options);
      }
export type UpdateRoomsWithParticipantsMutationHookResult = ReturnType<typeof useUpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationResult = Apollo.MutationResult<UpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationOptions = Apollo.BaseMutationOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;
export const InsertRoomPeopleDocument = gql`
    mutation InsertRoomPeople($people: [room_RoomPerson_insert_input!]!) {
  insert_room_RoomPerson(
    objects: $people
    on_conflict: {constraint: RoomPerson_registrantId_roomId_key, update_columns: []}
  ) {
    returning {
      ...RoomPersonInfo
    }
  }
}
    ${RoomPersonInfoFragmentDoc}`;
export type InsertRoomPeopleMutationFn = Apollo.MutationFunction<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>;

/**
 * __useInsertRoomPeopleMutation__
 *
 * To run a mutation, you first call `useInsertRoomPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomPeopleMutation, { data, loading, error }] = useInsertRoomPeopleMutation({
 *   variables: {
 *      people: // value for 'people'
 *   },
 * });
 */
export function useInsertRoomPeopleMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>(InsertRoomPeopleDocument, options);
      }
export type InsertRoomPeopleMutationHookResult = ReturnType<typeof useInsertRoomPeopleMutation>;
export type InsertRoomPeopleMutationResult = Apollo.MutationResult<InsertRoomPeopleMutation>;
export type InsertRoomPeopleMutationOptions = Apollo.BaseMutationOptions<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>;
export const InsertEventInfoDocument = gql`
    mutation InsertEventInfo($id: uuid!, $roomId: uuid!, $conferenceId: uuid!, $intendedRoomModeName: room_Mode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $itemId: uuid = null, $exhibitionId: uuid = null) {
  insert_schedule_Event_one(
    object: {id: $id, roomId: $roomId, conferenceId: $conferenceId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, itemId: $itemId, exhibitionId: $exhibitionId}
  ) {
    ...EventInfo
  }
}
    ${EventInfoFragmentDoc}`;
export type InsertEventInfoMutationFn = Apollo.MutationFunction<InsertEventInfoMutation, InsertEventInfoMutationVariables>;

/**
 * __useInsertEventInfoMutation__
 *
 * To run a mutation, you first call `useInsertEventInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventInfoMutation, { data, loading, error }] = useInsertEventInfoMutation({
 *   variables: {
 *      id: // value for 'id'
 *      roomId: // value for 'roomId'
 *      conferenceId: // value for 'conferenceId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      itemId: // value for 'itemId'
 *      exhibitionId: // value for 'exhibitionId'
 *   },
 * });
 */
export function useInsertEventInfoMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventInfoMutation, InsertEventInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventInfoMutation, InsertEventInfoMutationVariables>(InsertEventInfoDocument, options);
      }
export type InsertEventInfoMutationHookResult = ReturnType<typeof useInsertEventInfoMutation>;
export type InsertEventInfoMutationResult = Apollo.MutationResult<InsertEventInfoMutation>;
export type InsertEventInfoMutationOptions = Apollo.BaseMutationOptions<InsertEventInfoMutation, InsertEventInfoMutationVariables>;
export const UpdateEventInfoDocument = gql`
    mutation UpdateEventInfo($eventId: uuid!, $roomId: uuid!, $intendedRoomModeName: room_Mode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $itemId: uuid = null, $exhibitionId: uuid = null) {
  update_schedule_Event_by_pk(
    pk_columns: {id: $eventId}
    _set: {roomId: $roomId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, itemId: $itemId, exhibitionId: $exhibitionId}
  ) {
    ...EventInfo
  }
}
    ${EventInfoFragmentDoc}`;
export type UpdateEventInfoMutationFn = Apollo.MutationFunction<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>;

/**
 * __useUpdateEventInfoMutation__
 *
 * To run a mutation, you first call `useUpdateEventInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventInfoMutation, { data, loading, error }] = useUpdateEventInfoMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      roomId: // value for 'roomId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      itemId: // value for 'itemId'
 *      exhibitionId: // value for 'exhibitionId'
 *   },
 * });
 */
export function useUpdateEventInfoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>(UpdateEventInfoDocument, options);
      }
export type UpdateEventInfoMutationHookResult = ReturnType<typeof useUpdateEventInfoMutation>;
export type UpdateEventInfoMutationResult = Apollo.MutationResult<UpdateEventInfoMutation>;
export type UpdateEventInfoMutationOptions = Apollo.BaseMutationOptions<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>;
export const DeleteEventInfosDocument = gql`
    mutation DeleteEventInfos($eventIds: [uuid!]!) {
  delete_schedule_Event(where: {id: {_in: $eventIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventInfosMutationFn = Apollo.MutationFunction<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>;

/**
 * __useDeleteEventInfosMutation__
 *
 * To run a mutation, you first call `useDeleteEventInfosMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventInfosMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventInfosMutation, { data, loading, error }] = useDeleteEventInfosMutation({
 *   variables: {
 *      eventIds: // value for 'eventIds'
 *   },
 * });
 */
export function useDeleteEventInfosMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>(DeleteEventInfosDocument, options);
      }
export type DeleteEventInfosMutationHookResult = ReturnType<typeof useDeleteEventInfosMutation>;
export type DeleteEventInfosMutationResult = Apollo.MutationResult<DeleteEventInfosMutation>;
export type DeleteEventInfosMutationOptions = Apollo.BaseMutationOptions<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>;
export const ManageShufflePeriods_SelectAllDocument = gql`
    query ManageShufflePeriods_SelectAll($conferenceId: uuid!) {
  room_ShufflePeriod(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageShufflePeriods_ShufflePeriod
  }
}
    ${ManageShufflePeriods_ShufflePeriodFragmentDoc}`;

/**
 * __useManageShufflePeriods_SelectAllQuery__
 *
 * To run a query within a React component, call `useManageShufflePeriods_SelectAllQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageShufflePeriods_SelectAllQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageShufflePeriods_SelectAllQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageShufflePeriods_SelectAllQuery(baseOptions: Apollo.QueryHookOptions<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>(ManageShufflePeriods_SelectAllDocument, options);
      }
export function useManageShufflePeriods_SelectAllLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>(ManageShufflePeriods_SelectAllDocument, options);
        }
export type ManageShufflePeriods_SelectAllQueryHookResult = ReturnType<typeof useManageShufflePeriods_SelectAllQuery>;
export type ManageShufflePeriods_SelectAllLazyQueryHookResult = ReturnType<typeof useManageShufflePeriods_SelectAllLazyQuery>;
export type ManageShufflePeriods_SelectAllQueryResult = Apollo.QueryResult<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>;
export const SendEmail_GetAllGroupsDocument = gql`
    query SendEmail_GetAllGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    enabled
    name
  }
}
    `;

/**
 * __useSendEmail_GetAllGroupsQuery__
 *
 * To run a query within a React component, call `useSendEmail_GetAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendEmail_GetAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendEmail_GetAllGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSendEmail_GetAllGroupsQuery(baseOptions: Apollo.QueryHookOptions<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>(SendEmail_GetAllGroupsDocument, options);
      }
export function useSendEmail_GetAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>(SendEmail_GetAllGroupsDocument, options);
        }
export type SendEmail_GetAllGroupsQueryHookResult = ReturnType<typeof useSendEmail_GetAllGroupsQuery>;
export type SendEmail_GetAllGroupsLazyQueryHookResult = ReturnType<typeof useSendEmail_GetAllGroupsLazyQuery>;
export type SendEmail_GetAllGroupsQueryResult = Apollo.QueryResult<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>;
export const AddEventPeople_SelectItemPeopleDocument = gql`
    query AddEventPeople_SelectItemPeople($itemIds: [uuid!]!) {
  content_ItemProgramPerson(where: {itemId: {_in: $itemIds}}) {
    ...AddEventPeople_ItemPerson
  }
}
    ${AddEventPeople_ItemPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectItemPeopleQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectItemPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectItemPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectItemPeopleQuery({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useAddEventPeople_SelectItemPeopleQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>(AddEventPeople_SelectItemPeopleDocument, options);
      }
export function useAddEventPeople_SelectItemPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>(AddEventPeople_SelectItemPeopleDocument, options);
        }
export type AddEventPeople_SelectItemPeopleQueryHookResult = ReturnType<typeof useAddEventPeople_SelectItemPeopleQuery>;
export type AddEventPeople_SelectItemPeopleLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectItemPeopleLazyQuery>;
export type AddEventPeople_SelectItemPeopleQueryResult = Apollo.QueryResult<AddEventPeople_SelectItemPeopleQuery, AddEventPeople_SelectItemPeopleQueryVariables>;
export const AddEventPeople_SelectProgramPeopleDocument = gql`
    query AddEventPeople_SelectProgramPeople($conferenceId: uuid!) {
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_ProgramPerson
  }
}
    ${AddEventPeople_ProgramPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectProgramPeopleQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectProgramPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectProgramPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectProgramPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectProgramPeopleQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>(AddEventPeople_SelectProgramPeopleDocument, options);
      }
export function useAddEventPeople_SelectProgramPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>(AddEventPeople_SelectProgramPeopleDocument, options);
        }
export type AddEventPeople_SelectProgramPeopleQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeopleQuery>;
export type AddEventPeople_SelectProgramPeopleLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeopleLazyQuery>;
export type AddEventPeople_SelectProgramPeopleQueryResult = Apollo.QueryResult<AddEventPeople_SelectProgramPeopleQuery, AddEventPeople_SelectProgramPeopleQueryVariables>;
export const AddEventPeople_SelectRegistrantsDocument = gql`
    query AddEventPeople_SelectRegistrants($conferenceId: uuid!) {
  registrant_Registrant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_Registrant
  }
}
    ${AddEventPeople_RegistrantFragmentDoc}`;

/**
 * __useAddEventPeople_SelectRegistrantsQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectRegistrantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectRegistrantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectRegistrantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectRegistrantsQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>(AddEventPeople_SelectRegistrantsDocument, options);
      }
export function useAddEventPeople_SelectRegistrantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>(AddEventPeople_SelectRegistrantsDocument, options);
        }
export type AddEventPeople_SelectRegistrantsQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrantsQuery>;
export type AddEventPeople_SelectRegistrantsLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrantsLazyQuery>;
export type AddEventPeople_SelectRegistrantsQueryResult = Apollo.QueryResult<AddEventPeople_SelectRegistrantsQuery, AddEventPeople_SelectRegistrantsQueryVariables>;
export const AddEventPeople_SelectProgramPeople_ByRegistrantDocument = gql`
    query AddEventPeople_SelectProgramPeople_ByRegistrant($registrantIds: [uuid!]!) {
  collection_ProgramPerson(where: {registrantId: {_in: $registrantIds}}) {
    ...AddEventPeople_ProgramPerson
  }
}
    ${AddEventPeople_ProgramPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectProgramPeople_ByRegistrantQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectProgramPeople_ByRegistrantQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectProgramPeople_ByRegistrantQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectProgramPeople_ByRegistrantQuery({
 *   variables: {
 *      registrantIds: // value for 'registrantIds'
 *   },
 * });
 */
export function useAddEventPeople_SelectProgramPeople_ByRegistrantQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>(AddEventPeople_SelectProgramPeople_ByRegistrantDocument, options);
      }
export function useAddEventPeople_SelectProgramPeople_ByRegistrantLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>(AddEventPeople_SelectProgramPeople_ByRegistrantDocument, options);
        }
export type AddEventPeople_SelectProgramPeople_ByRegistrantQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeople_ByRegistrantQuery>;
export type AddEventPeople_SelectProgramPeople_ByRegistrantLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectProgramPeople_ByRegistrantLazyQuery>;
export type AddEventPeople_SelectProgramPeople_ByRegistrantQueryResult = Apollo.QueryResult<AddEventPeople_SelectProgramPeople_ByRegistrantQuery, AddEventPeople_SelectProgramPeople_ByRegistrantQueryVariables>;
export const AddEventPeople_SelectGroupsDocument = gql`
    query AddEventPeople_SelectGroups($conferenceId: uuid!) {
  permissions_Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_Group
  }
}
    ${AddEventPeople_GroupFragmentDoc}`;

/**
 * __useAddEventPeople_SelectGroupsQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectGroupsQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>(AddEventPeople_SelectGroupsDocument, options);
      }
export function useAddEventPeople_SelectGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>(AddEventPeople_SelectGroupsDocument, options);
        }
export type AddEventPeople_SelectGroupsQueryHookResult = ReturnType<typeof useAddEventPeople_SelectGroupsQuery>;
export type AddEventPeople_SelectGroupsLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectGroupsLazyQuery>;
export type AddEventPeople_SelectGroupsQueryResult = Apollo.QueryResult<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>;
export const AddEventPeople_SelectRegistrants_ByGroupDocument = gql`
    query AddEventPeople_SelectRegistrants_ByGroup($groupId: uuid!) {
  registrant_Registrant(where: {groupRegistrants: {groupId: {_eq: $groupId}}}) {
    ...AddEventPeople_Registrant
  }
}
    ${AddEventPeople_RegistrantFragmentDoc}`;

/**
 * __useAddEventPeople_SelectRegistrants_ByGroupQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectRegistrants_ByGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectRegistrants_ByGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectRegistrants_ByGroupQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useAddEventPeople_SelectRegistrants_ByGroupQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>(AddEventPeople_SelectRegistrants_ByGroupDocument, options);
      }
export function useAddEventPeople_SelectRegistrants_ByGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>(AddEventPeople_SelectRegistrants_ByGroupDocument, options);
        }
export type AddEventPeople_SelectRegistrants_ByGroupQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrants_ByGroupQuery>;
export type AddEventPeople_SelectRegistrants_ByGroupLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectRegistrants_ByGroupLazyQuery>;
export type AddEventPeople_SelectRegistrants_ByGroupQueryResult = Apollo.QueryResult<AddEventPeople_SelectRegistrants_ByGroupQuery, AddEventPeople_SelectRegistrants_ByGroupQueryVariables>;
export const AddEventPeople_InsertProgramPeopleDocument = gql`
    mutation AddEventPeople_InsertProgramPeople($objects: [collection_ProgramPerson_insert_input!]!) {
  insert_collection_ProgramPerson(objects: $objects) {
    returning {
      ...AddEventPeople_ProgramPerson
    }
  }
}
    ${AddEventPeople_ProgramPersonFragmentDoc}`;
export type AddEventPeople_InsertProgramPeopleMutationFn = Apollo.MutationFunction<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>;

/**
 * __useAddEventPeople_InsertProgramPeopleMutation__
 *
 * To run a mutation, you first call `useAddEventPeople_InsertProgramPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_InsertProgramPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addEventPeopleInsertProgramPeopleMutation, { data, loading, error }] = useAddEventPeople_InsertProgramPeopleMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useAddEventPeople_InsertProgramPeopleMutation(baseOptions?: Apollo.MutationHookOptions<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>(AddEventPeople_InsertProgramPeopleDocument, options);
      }
export type AddEventPeople_InsertProgramPeopleMutationHookResult = ReturnType<typeof useAddEventPeople_InsertProgramPeopleMutation>;
export type AddEventPeople_InsertProgramPeopleMutationResult = Apollo.MutationResult<AddEventPeople_InsertProgramPeopleMutation>;
export type AddEventPeople_InsertProgramPeopleMutationOptions = Apollo.BaseMutationOptions<AddEventPeople_InsertProgramPeopleMutation, AddEventPeople_InsertProgramPeopleMutationVariables>;
export const AddEventPeople_InsertEventPeopleDocument = gql`
    mutation AddEventPeople_InsertEventPeople($objects: [schedule_EventProgramPerson_insert_input!]!) {
  insert_schedule_EventProgramPerson(objects: $objects) {
    returning {
      ...EventProgramPersonInfo
    }
  }
}
    ${EventProgramPersonInfoFragmentDoc}`;
export type AddEventPeople_InsertEventPeopleMutationFn = Apollo.MutationFunction<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>;

/**
 * __useAddEventPeople_InsertEventPeopleMutation__
 *
 * To run a mutation, you first call `useAddEventPeople_InsertEventPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_InsertEventPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addEventPeopleInsertEventPeopleMutation, { data, loading, error }] = useAddEventPeople_InsertEventPeopleMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useAddEventPeople_InsertEventPeopleMutation(baseOptions?: Apollo.MutationHookOptions<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>(AddEventPeople_InsertEventPeopleDocument, options);
      }
export type AddEventPeople_InsertEventPeopleMutationHookResult = ReturnType<typeof useAddEventPeople_InsertEventPeopleMutation>;
export type AddEventPeople_InsertEventPeopleMutationResult = Apollo.MutationResult<AddEventPeople_InsertEventPeopleMutation>;
export type AddEventPeople_InsertEventPeopleMutationOptions = Apollo.BaseMutationOptions<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>;
export const InsertEventProgramPersonDocument = gql`
    mutation InsertEventProgramPerson($newEventProgramPerson: schedule_EventProgramPerson_insert_input!) {
  insert_schedule_EventProgramPerson_one(
    object: $newEventProgramPerson
    on_conflict: {constraint: EventProgramPerson_eventId_personId_roleName_key, update_columns: []}
  ) {
    ...EventProgramPersonInfo
  }
}
    ${EventProgramPersonInfoFragmentDoc}`;
export type InsertEventProgramPersonMutationFn = Apollo.MutationFunction<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>;

/**
 * __useInsertEventProgramPersonMutation__
 *
 * To run a mutation, you first call `useInsertEventProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventProgramPersonMutation, { data, loading, error }] = useInsertEventProgramPersonMutation({
 *   variables: {
 *      newEventProgramPerson: // value for 'newEventProgramPerson'
 *   },
 * });
 */
export function useInsertEventProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>(InsertEventProgramPersonDocument, options);
      }
export type InsertEventProgramPersonMutationHookResult = ReturnType<typeof useInsertEventProgramPersonMutation>;
export type InsertEventProgramPersonMutationResult = Apollo.MutationResult<InsertEventProgramPersonMutation>;
export type InsertEventProgramPersonMutationOptions = Apollo.BaseMutationOptions<InsertEventProgramPersonMutation, InsertEventProgramPersonMutationVariables>;
export const DeleteEventProgramPersonsDocument = gql`
    mutation DeleteEventProgramPersons($deleteEventPeopleIds: [uuid!]!) {
  delete_schedule_EventProgramPerson(where: {id: {_in: $deleteEventPeopleIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventProgramPersonsMutationFn = Apollo.MutationFunction<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>;

/**
 * __useDeleteEventProgramPersonsMutation__
 *
 * To run a mutation, you first call `useDeleteEventProgramPersonsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventProgramPersonsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventProgramPersonsMutation, { data, loading, error }] = useDeleteEventProgramPersonsMutation({
 *   variables: {
 *      deleteEventPeopleIds: // value for 'deleteEventPeopleIds'
 *   },
 * });
 */
export function useDeleteEventProgramPersonsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>(DeleteEventProgramPersonsDocument, options);
      }
export type DeleteEventProgramPersonsMutationHookResult = ReturnType<typeof useDeleteEventProgramPersonsMutation>;
export type DeleteEventProgramPersonsMutationResult = Apollo.MutationResult<DeleteEventProgramPersonsMutation>;
export type DeleteEventProgramPersonsMutationOptions = Apollo.BaseMutationOptions<DeleteEventProgramPersonsMutation, DeleteEventProgramPersonsMutationVariables>;
export const UpdateEventProgramPersonDocument = gql`
    mutation UpdateEventProgramPerson($id: uuid!, $personId: uuid!, $roleName: schedule_EventProgramPersonRole_enum!) {
  update_schedule_EventProgramPerson_by_pk(
    pk_columns: {id: $id}
    _set: {personId: $personId, roleName: $roleName}
  ) {
    ...EventProgramPersonInfo
  }
}
    ${EventProgramPersonInfoFragmentDoc}`;
export type UpdateEventProgramPersonMutationFn = Apollo.MutationFunction<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>;

/**
 * __useUpdateEventProgramPersonMutation__
 *
 * To run a mutation, you first call `useUpdateEventProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventProgramPersonMutation, { data, loading, error }] = useUpdateEventProgramPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      personId: // value for 'personId'
 *      roleName: // value for 'roleName'
 *   },
 * });
 */
export function useUpdateEventProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>(UpdateEventProgramPersonDocument, options);
      }
export type UpdateEventProgramPersonMutationHookResult = ReturnType<typeof useUpdateEventProgramPersonMutation>;
export type UpdateEventProgramPersonMutationResult = Apollo.MutationResult<UpdateEventProgramPersonMutation>;
export type UpdateEventProgramPersonMutationOptions = Apollo.BaseMutationOptions<UpdateEventProgramPersonMutation, UpdateEventProgramPersonMutationVariables>;
export const SelectWholeScheduleDocument = gql`
    query SelectWholeSchedule($conferenceId: uuid!) {
  room_Room(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomInfo
  }
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {startTime: asc, endTime: asc}
  ) {
    ...EventInfo
  }
  conference_OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  collection_Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  collection_Exhibition(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ExhibitionInfo
  }
  content_Item(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ItemFullNestedInfo
  }
  collection_ProgramPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ProgramPersonInfo
  }
}
    ${RoomInfoFragmentDoc}
${EventInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${ExhibitionInfoFragmentDoc}
${ItemFullNestedInfoFragmentDoc}
${ProgramPersonInfoFragmentDoc}`;

/**
 * __useSelectWholeScheduleQuery__
 *
 * To run a query within a React component, call `useSelectWholeScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectWholeScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectWholeScheduleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectWholeScheduleQuery(baseOptions: Apollo.QueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, options);
      }
export function useSelectWholeScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, options);
        }
export type SelectWholeScheduleQueryHookResult = ReturnType<typeof useSelectWholeScheduleQuery>;
export type SelectWholeScheduleLazyQueryHookResult = ReturnType<typeof useSelectWholeScheduleLazyQuery>;
export type SelectWholeScheduleQueryResult = Apollo.QueryResult<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>;
export const InsertRoomsDocument = gql`
    mutation InsertRooms($newRooms: [room_Room_insert_input!]!) {
  insert_room_Room(objects: $newRooms) {
    returning {
      ...RoomInfo
    }
  }
}
    ${RoomInfoFragmentDoc}`;
export type InsertRoomsMutationFn = Apollo.MutationFunction<InsertRoomsMutation, InsertRoomsMutationVariables>;

/**
 * __useInsertRoomsMutation__
 *
 * To run a mutation, you first call `useInsertRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomsMutation, { data, loading, error }] = useInsertRoomsMutation({
 *   variables: {
 *      newRooms: // value for 'newRooms'
 *   },
 * });
 */
export function useInsertRoomsMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomsMutation, InsertRoomsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRoomsMutation, InsertRoomsMutationVariables>(InsertRoomsDocument, options);
      }
export type InsertRoomsMutationHookResult = ReturnType<typeof useInsertRoomsMutation>;
export type InsertRoomsMutationResult = Apollo.MutationResult<InsertRoomsMutation>;
export type InsertRoomsMutationOptions = Apollo.BaseMutationOptions<InsertRoomsMutation, InsertRoomsMutationVariables>;
export const DeleteRoomsDocument = gql`
    mutation DeleteRooms($deleteRoomIds: [uuid!]!) {
  delete_room_Room(where: {id: {_in: $deleteRoomIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteRoomsMutationFn = Apollo.MutationFunction<DeleteRoomsMutation, DeleteRoomsMutationVariables>;

/**
 * __useDeleteRoomsMutation__
 *
 * To run a mutation, you first call `useDeleteRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRoomsMutation, { data, loading, error }] = useDeleteRoomsMutation({
 *   variables: {
 *      deleteRoomIds: // value for 'deleteRoomIds'
 *   },
 * });
 */
export function useDeleteRoomsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRoomsMutation, DeleteRoomsMutationVariables>(DeleteRoomsDocument, options);
      }
export type DeleteRoomsMutationHookResult = ReturnType<typeof useDeleteRoomsMutation>;
export type DeleteRoomsMutationResult = Apollo.MutationResult<DeleteRoomsMutation>;
export type DeleteRoomsMutationOptions = Apollo.BaseMutationOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>;
export const UpdateRoomDocument = gql`
    mutation UpdateRoom($id: uuid!, $name: String!, $capacity: Int = null, $originatingDataId: uuid = null, $priority: Int!) {
  update_room_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, originatingDataId: $originatingDataId, priority: $priority}
  ) {
    ...RoomInfo
  }
}
    ${RoomInfoFragmentDoc}`;
export type UpdateRoomMutationFn = Apollo.MutationFunction<UpdateRoomMutation, UpdateRoomMutationVariables>;

/**
 * __useUpdateRoomMutation__
 *
 * To run a mutation, you first call `useUpdateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomMutation, { data, loading, error }] = useUpdateRoomMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      originatingDataId: // value for 'originatingDataId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateRoomMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomMutation, UpdateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoomMutation, UpdateRoomMutationVariables>(UpdateRoomDocument, options);
      }
export type UpdateRoomMutationHookResult = ReturnType<typeof useUpdateRoomMutation>;
export type UpdateRoomMutationResult = Apollo.MutationResult<UpdateRoomMutation>;
export type UpdateRoomMutationOptions = Apollo.BaseMutationOptions<UpdateRoomMutation, UpdateRoomMutationVariables>;
export const DeleteEventsDocument = gql`
    mutation DeleteEvents($deleteEventIds: [uuid!]!) {
  delete_schedule_Event(where: {id: {_in: $deleteEventIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventsMutationFn = Apollo.MutationFunction<DeleteEventsMutation, DeleteEventsMutationVariables>;

/**
 * __useDeleteEventsMutation__
 *
 * To run a mutation, you first call `useDeleteEventsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventsMutation, { data, loading, error }] = useDeleteEventsMutation({
 *   variables: {
 *      deleteEventIds: // value for 'deleteEventIds'
 *   },
 * });
 */
export function useDeleteEventsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventsMutation, DeleteEventsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventsMutation, DeleteEventsMutationVariables>(DeleteEventsDocument, options);
      }
export type DeleteEventsMutationHookResult = ReturnType<typeof useDeleteEventsMutation>;
export type DeleteEventsMutationResult = Apollo.MutationResult<DeleteEventsMutation>;
export type DeleteEventsMutationOptions = Apollo.BaseMutationOptions<DeleteEventsMutation, DeleteEventsMutationVariables>;
export const InsertEventDocument = gql`
    mutation InsertEvent($newEvent: schedule_Event_insert_input!) {
  insert_schedule_Event_one(object: $newEvent) {
    ...EventInfo
  }
}
    ${EventInfoFragmentDoc}`;
export type InsertEventMutationFn = Apollo.MutationFunction<InsertEventMutation, InsertEventMutationVariables>;

/**
 * __useInsertEventMutation__
 *
 * To run a mutation, you first call `useInsertEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventMutation, { data, loading, error }] = useInsertEventMutation({
 *   variables: {
 *      newEvent: // value for 'newEvent'
 *   },
 * });
 */
export function useInsertEventMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventMutation, InsertEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventMutation, InsertEventMutationVariables>(InsertEventDocument, options);
      }
export type InsertEventMutationHookResult = ReturnType<typeof useInsertEventMutation>;
export type InsertEventMutationResult = Apollo.MutationResult<InsertEventMutation>;
export type InsertEventMutationOptions = Apollo.BaseMutationOptions<InsertEventMutation, InsertEventMutationVariables>;
export const UpdateEventDocument = gql`
    mutation UpdateEvent($eventId: uuid!, $roomId: uuid!, $intendedRoomModeName: room_Mode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $itemId: uuid = null, $exhibitionId: uuid = null, $newEventTags: [schedule_EventTag_insert_input!]!, $deleteEventTagIds: [uuid!]!) {
  insert_schedule_EventTag(objects: $newEventTags) {
    returning {
      ...EventTagInfo
    }
  }
  update_schedule_Event_by_pk(
    pk_columns: {id: $eventId}
    _set: {roomId: $roomId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, itemId: $itemId, exhibitionId: $exhibitionId}
  ) {
    ...EventInfo
  }
  delete_schedule_EventTag(
    where: {eventId: {_eq: $eventId}, tagId: {_in: $deleteEventTagIds}}
  ) {
    returning {
      id
    }
  }
}
    ${EventTagInfoFragmentDoc}
${EventInfoFragmentDoc}`;
export type UpdateEventMutationFn = Apollo.MutationFunction<UpdateEventMutation, UpdateEventMutationVariables>;

/**
 * __useUpdateEventMutation__
 *
 * To run a mutation, you first call `useUpdateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventMutation, { data, loading, error }] = useUpdateEventMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      roomId: // value for 'roomId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      itemId: // value for 'itemId'
 *      exhibitionId: // value for 'exhibitionId'
 *      newEventTags: // value for 'newEventTags'
 *      deleteEventTagIds: // value for 'deleteEventTagIds'
 *   },
 * });
 */
export function useUpdateEventMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventMutation, UpdateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventMutation, UpdateEventMutationVariables>(UpdateEventDocument, options);
      }
export type UpdateEventMutationHookResult = ReturnType<typeof useUpdateEventMutation>;
export type UpdateEventMutationResult = Apollo.MutationResult<UpdateEventMutation>;
export type UpdateEventMutationOptions = Apollo.BaseMutationOptions<UpdateEventMutation, UpdateEventMutationVariables>;
export const UpdateShufflePeriodDocument = gql`
    mutation UpdateShufflePeriod($id: uuid!, $object: room_ShufflePeriod_set_input!) {
  update_room_ShufflePeriod_by_pk(pk_columns: {id: $id}, _set: $object) {
    id
    created_at
    updated_at
    conferenceId
    startAt
    endAt
    roomDurationMinutes
    targetRegistrantsPerRoom
    maxRegistrantsPerRoom
    waitRoomMaxDurationSeconds
    name
    organiserId
    algorithm
  }
}
    `;
export type UpdateShufflePeriodMutationFn = Apollo.MutationFunction<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>;

/**
 * __useUpdateShufflePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateShufflePeriodMutation, { data, loading, error }] = useUpdateShufflePeriodMutation({
 *   variables: {
 *      id: // value for 'id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function useUpdateShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>(UpdateShufflePeriodDocument, options);
      }
export type UpdateShufflePeriodMutationHookResult = ReturnType<typeof useUpdateShufflePeriodMutation>;
export type UpdateShufflePeriodMutationResult = Apollo.MutationResult<UpdateShufflePeriodMutation>;
export type UpdateShufflePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>;
export const InsertShufflePeriodDocument = gql`
    mutation InsertShufflePeriod($object: room_ShufflePeriod_insert_input!) {
  insert_room_ShufflePeriod_one(object: $object) {
    id
    created_at
    updated_at
    conferenceId
    startAt
    endAt
    roomDurationMinutes
    targetRegistrantsPerRoom
    maxRegistrantsPerRoom
    waitRoomMaxDurationSeconds
    name
    organiserId
    algorithm
  }
}
    `;
export type InsertShufflePeriodMutationFn = Apollo.MutationFunction<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>;

/**
 * __useInsertShufflePeriodMutation__
 *
 * To run a mutation, you first call `useInsertShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertShufflePeriodMutation, { data, loading, error }] = useInsertShufflePeriodMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>(InsertShufflePeriodDocument, options);
      }
export type InsertShufflePeriodMutationHookResult = ReturnType<typeof useInsertShufflePeriodMutation>;
export type InsertShufflePeriodMutationResult = Apollo.MutationResult<InsertShufflePeriodMutation>;
export type InsertShufflePeriodMutationOptions = Apollo.BaseMutationOptions<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>;
export const DeleteShufflePeriodDocument = gql`
    mutation DeleteShufflePeriod($id: uuid!) {
  delete_room_ShufflePeriod_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteShufflePeriodMutationFn = Apollo.MutationFunction<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>;

/**
 * __useDeleteShufflePeriodMutation__
 *
 * To run a mutation, you first call `useDeleteShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteShufflePeriodMutation, { data, loading, error }] = useDeleteShufflePeriodMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>(DeleteShufflePeriodDocument, options);
      }
export type DeleteShufflePeriodMutationHookResult = ReturnType<typeof useDeleteShufflePeriodMutation>;
export type DeleteShufflePeriodMutationResult = Apollo.MutationResult<DeleteShufflePeriodMutation>;
export type DeleteShufflePeriodMutationOptions = Apollo.BaseMutationOptions<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>;
export const AddSponsorContentMenu_CreateElementDocument = gql`
    mutation AddSponsorContentMenu_CreateElement($object: content_Element_insert_input!) {
  insert_content_Element_one(object: $object) {
    id
  }
}
    `;
export type AddSponsorContentMenu_CreateElementMutationFn = Apollo.MutationFunction<AddSponsorContentMenu_CreateElementMutation, AddSponsorContentMenu_CreateElementMutationVariables>;

/**
 * __useAddSponsorContentMenu_CreateElementMutation__
 *
 * To run a mutation, you first call `useAddSponsorContentMenu_CreateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddSponsorContentMenu_CreateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addSponsorContentMenuCreateElementMutation, { data, loading, error }] = useAddSponsorContentMenu_CreateElementMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useAddSponsorContentMenu_CreateElementMutation(baseOptions?: Apollo.MutationHookOptions<AddSponsorContentMenu_CreateElementMutation, AddSponsorContentMenu_CreateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddSponsorContentMenu_CreateElementMutation, AddSponsorContentMenu_CreateElementMutationVariables>(AddSponsorContentMenu_CreateElementDocument, options);
      }
export type AddSponsorContentMenu_CreateElementMutationHookResult = ReturnType<typeof useAddSponsorContentMenu_CreateElementMutation>;
export type AddSponsorContentMenu_CreateElementMutationResult = Apollo.MutationResult<AddSponsorContentMenu_CreateElementMutation>;
export type AddSponsorContentMenu_CreateElementMutationOptions = Apollo.BaseMutationOptions<AddSponsorContentMenu_CreateElementMutation, AddSponsorContentMenu_CreateElementMutationVariables>;
export const EditableSponsorsTable_GetAllSponsorsDocument = gql`
    query EditableSponsorsTable_GetAllSponsors($conferenceId: uuid!) {
  content_Item(
    where: {typeName: {_eq: SPONSOR}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...EditableSponsorsTable_ItemInfo
  }
}
    ${EditableSponsorsTable_ItemInfoFragmentDoc}`;

/**
 * __useEditableSponsorsTable_GetAllSponsorsQuery__
 *
 * To run a query within a React component, call `useEditableSponsorsTable_GetAllSponsorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_GetAllSponsorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEditableSponsorsTable_GetAllSponsorsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useEditableSponsorsTable_GetAllSponsorsQuery(baseOptions: Apollo.QueryHookOptions<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>(EditableSponsorsTable_GetAllSponsorsDocument, options);
      }
export function useEditableSponsorsTable_GetAllSponsorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>(EditableSponsorsTable_GetAllSponsorsDocument, options);
        }
export type EditableSponsorsTable_GetAllSponsorsQueryHookResult = ReturnType<typeof useEditableSponsorsTable_GetAllSponsorsQuery>;
export type EditableSponsorsTable_GetAllSponsorsLazyQueryHookResult = ReturnType<typeof useEditableSponsorsTable_GetAllSponsorsLazyQuery>;
export type EditableSponsorsTable_GetAllSponsorsQueryResult = Apollo.QueryResult<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>;
export const EditableSponsorsTable_InsertSponsorDocument = gql`
    mutation EditableSponsorsTable_InsertSponsor($item: content_Item_insert_input!) {
  insert_content_Item_one(object: $item) {
    ...EditableSponsorsTable_ItemInfo
  }
}
    ${EditableSponsorsTable_ItemInfoFragmentDoc}`;
export type EditableSponsorsTable_InsertSponsorMutationFn = Apollo.MutationFunction<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>;

/**
 * __useEditableSponsorsTable_InsertSponsorMutation__
 *
 * To run a mutation, you first call `useEditableSponsorsTable_InsertSponsorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_InsertSponsorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editableSponsorsTableInsertSponsorMutation, { data, loading, error }] = useEditableSponsorsTable_InsertSponsorMutation({
 *   variables: {
 *      item: // value for 'item'
 *   },
 * });
 */
export function useEditableSponsorsTable_InsertSponsorMutation(baseOptions?: Apollo.MutationHookOptions<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>(EditableSponsorsTable_InsertSponsorDocument, options);
      }
export type EditableSponsorsTable_InsertSponsorMutationHookResult = ReturnType<typeof useEditableSponsorsTable_InsertSponsorMutation>;
export type EditableSponsorsTable_InsertSponsorMutationResult = Apollo.MutationResult<EditableSponsorsTable_InsertSponsorMutation>;
export type EditableSponsorsTable_InsertSponsorMutationOptions = Apollo.BaseMutationOptions<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>;
export const EditableSponsorsTable_UpdateSponsorDocument = gql`
    mutation EditableSponsorsTable_UpdateSponsor($itemId: uuid!, $object: content_Item_set_input!) {
  update_content_Item_by_pk(pk_columns: {id: $itemId}, _set: $object) {
    id
  }
}
    `;
export type EditableSponsorsTable_UpdateSponsorMutationFn = Apollo.MutationFunction<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>;

/**
 * __useEditableSponsorsTable_UpdateSponsorMutation__
 *
 * To run a mutation, you first call `useEditableSponsorsTable_UpdateSponsorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_UpdateSponsorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editableSponsorsTableUpdateSponsorMutation, { data, loading, error }] = useEditableSponsorsTable_UpdateSponsorMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      object: // value for 'object'
 *   },
 * });
 */
export function useEditableSponsorsTable_UpdateSponsorMutation(baseOptions?: Apollo.MutationHookOptions<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>(EditableSponsorsTable_UpdateSponsorDocument, options);
      }
export type EditableSponsorsTable_UpdateSponsorMutationHookResult = ReturnType<typeof useEditableSponsorsTable_UpdateSponsorMutation>;
export type EditableSponsorsTable_UpdateSponsorMutationResult = Apollo.MutationResult<EditableSponsorsTable_UpdateSponsorMutation>;
export type EditableSponsorsTable_UpdateSponsorMutationOptions = Apollo.BaseMutationOptions<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>;
export const EditableSponsorsTable_DeleteSponsorDocument = gql`
    mutation EditableSponsorsTable_DeleteSponsor($itemIds: [uuid!]!) {
  delete_content_Item(where: {id: {_in: $itemIds}}) {
    returning {
      id
    }
  }
}
    `;
export type EditableSponsorsTable_DeleteSponsorMutationFn = Apollo.MutationFunction<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>;

/**
 * __useEditableSponsorsTable_DeleteSponsorMutation__
 *
 * To run a mutation, you first call `useEditableSponsorsTable_DeleteSponsorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_DeleteSponsorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editableSponsorsTableDeleteSponsorMutation, { data, loading, error }] = useEditableSponsorsTable_DeleteSponsorMutation({
 *   variables: {
 *      itemIds: // value for 'itemIds'
 *   },
 * });
 */
export function useEditableSponsorsTable_DeleteSponsorMutation(baseOptions?: Apollo.MutationHookOptions<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>(EditableSponsorsTable_DeleteSponsorDocument, options);
      }
export type EditableSponsorsTable_DeleteSponsorMutationHookResult = ReturnType<typeof useEditableSponsorsTable_DeleteSponsorMutation>;
export type EditableSponsorsTable_DeleteSponsorMutationResult = Apollo.MutationResult<EditableSponsorsTable_DeleteSponsorMutation>;
export type EditableSponsorsTable_DeleteSponsorMutationOptions = Apollo.BaseMutationOptions<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>;
export const SponsorSecondaryEditor_GetSponsorSecondaryInfoDocument = gql`
    query SponsorSecondaryEditor_GetSponsorSecondaryInfo($itemId: uuid!) {
  content_Element(where: {itemId: {_eq: $itemId}}) {
    ...SponsorSecondaryEditor_Element
  }
  content_ItemProgramPerson(where: {itemId: {_eq: $itemId}}) {
    ...SponsorSecondaryEditor_ItemProgramPerson
  }
}
    ${SponsorSecondaryEditor_ElementFragmentDoc}
${SponsorSecondaryEditor_ItemProgramPersonFragmentDoc}`;

/**
 * __useSponsorSecondaryEditor_GetSponsorSecondaryInfoQuery__
 *
 * To run a query within a React component, call `useSponsorSecondaryEditor_GetSponsorSecondaryInfoQuery` and pass it any options that fit your needs.
 * When your component renders, `useSponsorSecondaryEditor_GetSponsorSecondaryInfoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSponsorSecondaryEditor_GetSponsorSecondaryInfoQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useSponsorSecondaryEditor_GetSponsorSecondaryInfoQuery(baseOptions: Apollo.QueryHookOptions<SponsorSecondaryEditor_GetSponsorSecondaryInfoQuery, SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SponsorSecondaryEditor_GetSponsorSecondaryInfoQuery, SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryVariables>(SponsorSecondaryEditor_GetSponsorSecondaryInfoDocument, options);
      }
export function useSponsorSecondaryEditor_GetSponsorSecondaryInfoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SponsorSecondaryEditor_GetSponsorSecondaryInfoQuery, SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SponsorSecondaryEditor_GetSponsorSecondaryInfoQuery, SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryVariables>(SponsorSecondaryEditor_GetSponsorSecondaryInfoDocument, options);
        }
export type SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryHookResult = ReturnType<typeof useSponsorSecondaryEditor_GetSponsorSecondaryInfoQuery>;
export type SponsorSecondaryEditor_GetSponsorSecondaryInfoLazyQueryHookResult = ReturnType<typeof useSponsorSecondaryEditor_GetSponsorSecondaryInfoLazyQuery>;
export type SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryResult = Apollo.QueryResult<SponsorSecondaryEditor_GetSponsorSecondaryInfoQuery, SponsorSecondaryEditor_GetSponsorSecondaryInfoQueryVariables>;
export const SponsorSecondaryEditor_SelectProgramPeopleDocument = gql`
    query SponsorSecondaryEditor_SelectProgramPeople($conferenceId: uuid!) {
  collection_ProgramPerson(
    where: {conferenceId: {_eq: $conferenceId}, registrantId: {_is_null: false}}
  ) {
    ...SponsorSecondaryEditor_ProgramPerson
  }
}
    ${SponsorSecondaryEditor_ProgramPersonFragmentDoc}`;

/**
 * __useSponsorSecondaryEditor_SelectProgramPeopleQuery__
 *
 * To run a query within a React component, call `useSponsorSecondaryEditor_SelectProgramPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useSponsorSecondaryEditor_SelectProgramPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSponsorSecondaryEditor_SelectProgramPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSponsorSecondaryEditor_SelectProgramPeopleQuery(baseOptions: Apollo.QueryHookOptions<SponsorSecondaryEditor_SelectProgramPeopleQuery, SponsorSecondaryEditor_SelectProgramPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SponsorSecondaryEditor_SelectProgramPeopleQuery, SponsorSecondaryEditor_SelectProgramPeopleQueryVariables>(SponsorSecondaryEditor_SelectProgramPeopleDocument, options);
      }
export function useSponsorSecondaryEditor_SelectProgramPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SponsorSecondaryEditor_SelectProgramPeopleQuery, SponsorSecondaryEditor_SelectProgramPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SponsorSecondaryEditor_SelectProgramPeopleQuery, SponsorSecondaryEditor_SelectProgramPeopleQueryVariables>(SponsorSecondaryEditor_SelectProgramPeopleDocument, options);
        }
export type SponsorSecondaryEditor_SelectProgramPeopleQueryHookResult = ReturnType<typeof useSponsorSecondaryEditor_SelectProgramPeopleQuery>;
export type SponsorSecondaryEditor_SelectProgramPeopleLazyQueryHookResult = ReturnType<typeof useSponsorSecondaryEditor_SelectProgramPeopleLazyQuery>;
export type SponsorSecondaryEditor_SelectProgramPeopleQueryResult = Apollo.QueryResult<SponsorSecondaryEditor_SelectProgramPeopleQuery, SponsorSecondaryEditor_SelectProgramPeopleQueryVariables>;
export const SponsorSecondaryEditor_InsertItemProgramPersonDocument = gql`
    mutation SponsorSecondaryEditor_InsertItemProgramPerson($conferenceId: uuid!, $personId: uuid!, $itemId: uuid!) {
  insert_content_ItemProgramPerson_one(
    object: {conferenceId: $conferenceId, personId: $personId, itemId: $itemId, priority: 1, roleName: "AUTHOR"}
  ) {
    ...SponsorSecondaryEditor_ItemProgramPerson
  }
}
    ${SponsorSecondaryEditor_ItemProgramPersonFragmentDoc}`;
export type SponsorSecondaryEditor_InsertItemProgramPersonMutationFn = Apollo.MutationFunction<SponsorSecondaryEditor_InsertItemProgramPersonMutation, SponsorSecondaryEditor_InsertItemProgramPersonMutationVariables>;

/**
 * __useSponsorSecondaryEditor_InsertItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useSponsorSecondaryEditor_InsertItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorSecondaryEditor_InsertItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorSecondaryEditorInsertItemProgramPersonMutation, { data, loading, error }] = useSponsorSecondaryEditor_InsertItemProgramPersonMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      personId: // value for 'personId'
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useSponsorSecondaryEditor_InsertItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<SponsorSecondaryEditor_InsertItemProgramPersonMutation, SponsorSecondaryEditor_InsertItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorSecondaryEditor_InsertItemProgramPersonMutation, SponsorSecondaryEditor_InsertItemProgramPersonMutationVariables>(SponsorSecondaryEditor_InsertItemProgramPersonDocument, options);
      }
export type SponsorSecondaryEditor_InsertItemProgramPersonMutationHookResult = ReturnType<typeof useSponsorSecondaryEditor_InsertItemProgramPersonMutation>;
export type SponsorSecondaryEditor_InsertItemProgramPersonMutationResult = Apollo.MutationResult<SponsorSecondaryEditor_InsertItemProgramPersonMutation>;
export type SponsorSecondaryEditor_InsertItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<SponsorSecondaryEditor_InsertItemProgramPersonMutation, SponsorSecondaryEditor_InsertItemProgramPersonMutationVariables>;
export const SponsorSecondaryEditor_DeleteItemProgramPersonDocument = gql`
    mutation SponsorSecondaryEditor_DeleteItemProgramPerson($itemPersonId: uuid!) {
  delete_content_ItemProgramPerson_by_pk(id: $itemPersonId) {
    id
  }
}
    `;
export type SponsorSecondaryEditor_DeleteItemProgramPersonMutationFn = Apollo.MutationFunction<SponsorSecondaryEditor_DeleteItemProgramPersonMutation, SponsorSecondaryEditor_DeleteItemProgramPersonMutationVariables>;

/**
 * __useSponsorSecondaryEditor_DeleteItemProgramPersonMutation__
 *
 * To run a mutation, you first call `useSponsorSecondaryEditor_DeleteItemProgramPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorSecondaryEditor_DeleteItemProgramPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorSecondaryEditorDeleteItemProgramPersonMutation, { data, loading, error }] = useSponsorSecondaryEditor_DeleteItemProgramPersonMutation({
 *   variables: {
 *      itemPersonId: // value for 'itemPersonId'
 *   },
 * });
 */
export function useSponsorSecondaryEditor_DeleteItemProgramPersonMutation(baseOptions?: Apollo.MutationHookOptions<SponsorSecondaryEditor_DeleteItemProgramPersonMutation, SponsorSecondaryEditor_DeleteItemProgramPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorSecondaryEditor_DeleteItemProgramPersonMutation, SponsorSecondaryEditor_DeleteItemProgramPersonMutationVariables>(SponsorSecondaryEditor_DeleteItemProgramPersonDocument, options);
      }
export type SponsorSecondaryEditor_DeleteItemProgramPersonMutationHookResult = ReturnType<typeof useSponsorSecondaryEditor_DeleteItemProgramPersonMutation>;
export type SponsorSecondaryEditor_DeleteItemProgramPersonMutationResult = Apollo.MutationResult<SponsorSecondaryEditor_DeleteItemProgramPersonMutation>;
export type SponsorSecondaryEditor_DeleteItemProgramPersonMutationOptions = Apollo.BaseMutationOptions<SponsorSecondaryEditor_DeleteItemProgramPersonMutation, SponsorSecondaryEditor_DeleteItemProgramPersonMutationVariables>;
export const SponsorElement_DeleteElementDocument = gql`
    mutation SponsorElement_DeleteElement($elementId: uuid!) {
  delete_content_Element_by_pk(id: $elementId) {
    id
  }
}
    `;
export type SponsorElement_DeleteElementMutationFn = Apollo.MutationFunction<SponsorElement_DeleteElementMutation, SponsorElement_DeleteElementMutationVariables>;

/**
 * __useSponsorElement_DeleteElementMutation__
 *
 * To run a mutation, you first call `useSponsorElement_DeleteElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorElement_DeleteElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorElementDeleteElementMutation, { data, loading, error }] = useSponsorElement_DeleteElementMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *   },
 * });
 */
export function useSponsorElement_DeleteElementMutation(baseOptions?: Apollo.MutationHookOptions<SponsorElement_DeleteElementMutation, SponsorElement_DeleteElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorElement_DeleteElementMutation, SponsorElement_DeleteElementMutationVariables>(SponsorElement_DeleteElementDocument, options);
      }
export type SponsorElement_DeleteElementMutationHookResult = ReturnType<typeof useSponsorElement_DeleteElementMutation>;
export type SponsorElement_DeleteElementMutationResult = Apollo.MutationResult<SponsorElement_DeleteElementMutation>;
export type SponsorElement_DeleteElementMutationOptions = Apollo.BaseMutationOptions<SponsorElement_DeleteElementMutation, SponsorElement_DeleteElementMutationVariables>;
export const SponsorElement_SetElementIsHiddenDocument = gql`
    mutation SponsorElement_SetElementIsHidden($elementId: uuid!, $isHidden: Boolean!) {
  update_content_Element_by_pk(
    pk_columns: {id: $elementId}
    _set: {isHidden: $isHidden}
  ) {
    id
  }
}
    `;
export type SponsorElement_SetElementIsHiddenMutationFn = Apollo.MutationFunction<SponsorElement_SetElementIsHiddenMutation, SponsorElement_SetElementIsHiddenMutationVariables>;

/**
 * __useSponsorElement_SetElementIsHiddenMutation__
 *
 * To run a mutation, you first call `useSponsorElement_SetElementIsHiddenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorElement_SetElementIsHiddenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorElementSetElementIsHiddenMutation, { data, loading, error }] = useSponsorElement_SetElementIsHiddenMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *      isHidden: // value for 'isHidden'
 *   },
 * });
 */
export function useSponsorElement_SetElementIsHiddenMutation(baseOptions?: Apollo.MutationHookOptions<SponsorElement_SetElementIsHiddenMutation, SponsorElement_SetElementIsHiddenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorElement_SetElementIsHiddenMutation, SponsorElement_SetElementIsHiddenMutationVariables>(SponsorElement_SetElementIsHiddenDocument, options);
      }
export type SponsorElement_SetElementIsHiddenMutationHookResult = ReturnType<typeof useSponsorElement_SetElementIsHiddenMutation>;
export type SponsorElement_SetElementIsHiddenMutationResult = Apollo.MutationResult<SponsorElement_SetElementIsHiddenMutation>;
export type SponsorElement_SetElementIsHiddenMutationOptions = Apollo.BaseMutationOptions<SponsorElement_SetElementIsHiddenMutation, SponsorElement_SetElementIsHiddenMutationVariables>;
export const SponsorElementInner_UpdateElementDocument = gql`
    mutation SponsorElementInner_UpdateElement($elementId: uuid!, $element: content_Element_set_input!) {
  update_content_Element_by_pk(pk_columns: {id: $elementId}, _set: $element) {
    id
  }
}
    `;
export type SponsorElementInner_UpdateElementMutationFn = Apollo.MutationFunction<SponsorElementInner_UpdateElementMutation, SponsorElementInner_UpdateElementMutationVariables>;

/**
 * __useSponsorElementInner_UpdateElementMutation__
 *
 * To run a mutation, you first call `useSponsorElementInner_UpdateElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorElementInner_UpdateElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorElementInnerUpdateElementMutation, { data, loading, error }] = useSponsorElementInner_UpdateElementMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *      element: // value for 'element'
 *   },
 * });
 */
export function useSponsorElementInner_UpdateElementMutation(baseOptions?: Apollo.MutationHookOptions<SponsorElementInner_UpdateElementMutation, SponsorElementInner_UpdateElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorElementInner_UpdateElementMutation, SponsorElementInner_UpdateElementMutationVariables>(SponsorElementInner_UpdateElementDocument, options);
      }
export type SponsorElementInner_UpdateElementMutationHookResult = ReturnType<typeof useSponsorElementInner_UpdateElementMutation>;
export type SponsorElementInner_UpdateElementMutationResult = Apollo.MutationResult<SponsorElementInner_UpdateElementMutation>;
export type SponsorElementInner_UpdateElementMutationOptions = Apollo.BaseMutationOptions<SponsorElementInner_UpdateElementMutation, SponsorElementInner_UpdateElementMutationVariables>;
export const ConferenceTakenDocument = gql`
    query ConferenceTaken($name: String!, $shortName: String!, $slug: String!) {
  conference_Conference(
    where: {_or: [{name: {_eq: $name}}, {shortName: {_eq: $shortName}}, {slug: {_eq: $slug}}]}
  ) {
    id
    name
    shortName
    slug
  }
}
    `;

/**
 * __useConferenceTakenQuery__
 *
 * To run a query within a React component, call `useConferenceTakenQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceTakenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceTakenQuery({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceTakenQuery(baseOptions: Apollo.QueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, options);
      }
export function useConferenceTakenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, options);
        }
export type ConferenceTakenQueryHookResult = ReturnType<typeof useConferenceTakenQuery>;
export type ConferenceTakenLazyQueryHookResult = ReturnType<typeof useConferenceTakenLazyQuery>;
export type ConferenceTakenQueryResult = Apollo.QueryResult<ConferenceTakenQuery, ConferenceTakenQueryVariables>;
export const CreateConferenceDocument = gql`
    mutation CreateConference($name: String!, $shortName: String!, $slug: String!, $demoCode: uuid!) {
  insert_conference_Conference(
    objects: [{name: $name, shortName: $shortName, slug: $slug, demoCodeId: $demoCode}]
  ) {
    returning {
      id
      slug
    }
  }
  update_conference_DemoCode(
    where: {id: {_eq: $demoCode}}
    _set: {note: "Code has been used."}
  ) {
    affected_rows
  }
}
    `;
export type CreateConferenceMutationFn = Apollo.MutationFunction<CreateConferenceMutation, CreateConferenceMutationVariables>;

/**
 * __useCreateConferenceMutation__
 *
 * To run a mutation, you first call `useCreateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferenceMutation, { data, loading, error }] = useCreateConferenceMutation({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *      demoCode: // value for 'demoCode'
 *   },
 * });
 */
export function useCreateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferenceMutation, CreateConferenceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConferenceMutation, CreateConferenceMutationVariables>(CreateConferenceDocument, options);
      }
export type CreateConferenceMutationHookResult = ReturnType<typeof useCreateConferenceMutation>;
export type CreateConferenceMutationResult = Apollo.MutationResult<CreateConferenceMutation>;
export type CreateConferenceMutationOptions = Apollo.BaseMutationOptions<CreateConferenceMutation, CreateConferenceMutationVariables>;
export const CreateNewConferenceMetaStructureDocument = gql`
    mutation CreateNewConferenceMetaStructure($conferenceId: uuid!, $registrantDisplayName: String!, $userId: String!, $abstractData: jsonb!, $itemListData: jsonb!) {
  insert_registrant_Registrant(
    objects: [{displayName: $registrantDisplayName, userId: $userId, conferenceId: $conferenceId, groupRegistrants: {data: {group: {data: {conferenceId: $conferenceId, includeUnauthenticated: false, name: "Organisers", groupRoles: {data: {role: {data: {conferenceId: $conferenceId, name: "Organiser", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_NAME}, {permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_MANAGE_ROLES}, {permissionName: CONFERENCE_MANAGE_GROUPS}, {permissionName: CONFERENCE_MANAGE_CONTENT}, {permissionName: CONFERENCE_MANAGE_SCHEDULE}, {permissionName: CONFERENCE_MANAGE_SHUFFLE}]}}}}}}}}}}]
  ) {
    affected_rows
  }
  insert_permissions_Group(
    objects: [{conferenceId: $conferenceId, enabled: false, name: "Registrants", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Registrant", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Public", includeUnauthenticated: true, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Public", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Registrars", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Registrar", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Moderators", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Moderator", rolePermissions: {data: [{permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Social Chairs", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Social Chair", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_SHUFFLE}]}}}}]}}]
  ) {
    returning {
      id
      conferenceId
      name
      enabled
      groupRoles {
        id
        roleId
        groupId
        role {
          id
          name
          conferenceId
          rolePermissions {
            id
            roleId
            permissionName
          }
        }
      }
    }
  }
  insert_content_Item(
    objects: {conferenceId: $conferenceId, typeName: LANDING_PAGE, elements: {data: [{conferenceId: $conferenceId, typeName: ABSTRACT, data: $abstractData, isHidden: false, layoutData: null, name: "Welcome text"}, {conferenceId: $conferenceId, typeName: CONTENT_GROUP_LIST, data: $itemListData, isHidden: false, layoutData: null, name: "Content group list"}]}, shortTitle: "Landing", title: "Landing page"}
  ) {
    returning {
      ...ItemData
    }
  }
}
    ${ItemDataFragmentDoc}`;
export type CreateNewConferenceMetaStructureMutationFn = Apollo.MutationFunction<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;

/**
 * __useCreateNewConferenceMetaStructureMutation__
 *
 * To run a mutation, you first call `useCreateNewConferenceMetaStructureMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNewConferenceMetaStructureMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNewConferenceMetaStructureMutation, { data, loading, error }] = useCreateNewConferenceMetaStructureMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantDisplayName: // value for 'registrantDisplayName'
 *      userId: // value for 'userId'
 *      abstractData: // value for 'abstractData'
 *      itemListData: // value for 'itemListData'
 *   },
 * });
 */
export function useCreateNewConferenceMetaStructureMutation(baseOptions?: Apollo.MutationHookOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>(CreateNewConferenceMetaStructureDocument, options);
      }
export type CreateNewConferenceMetaStructureMutationHookResult = ReturnType<typeof useCreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationResult = Apollo.MutationResult<CreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationOptions = Apollo.BaseMutationOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;
export const RegistrantsByIdDocument = gql`
    query RegistrantsById($conferenceId: uuid!, $registrantIds: [uuid!]!) {
  registrant_Registrant(
    where: {id: {_in: $registrantIds}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useRegistrantsByIdQuery__
 *
 * To run a query within a React component, call `useRegistrantsByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantsByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantsByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      registrantIds: // value for 'registrantIds'
 *   },
 * });
 */
export function useRegistrantsByIdQuery(baseOptions: Apollo.QueryHookOptions<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>(RegistrantsByIdDocument, options);
      }
export function useRegistrantsByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>(RegistrantsByIdDocument, options);
        }
export type RegistrantsByIdQueryHookResult = ReturnType<typeof useRegistrantsByIdQuery>;
export type RegistrantsByIdLazyQueryHookResult = ReturnType<typeof useRegistrantsByIdLazyQuery>;
export type RegistrantsByIdQueryResult = Apollo.QueryResult<RegistrantsByIdQuery, RegistrantsByIdQueryVariables>;
export const RegistrantsByUserIdDocument = gql`
    query RegistrantsByUserId($conferenceId: uuid!, $userIds: [String!]!) {
  registrant_Registrant(
    where: {userId: {_in: $userIds}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...RegistrantData
  }
}
    ${RegistrantDataFragmentDoc}`;

/**
 * __useRegistrantsByUserIdQuery__
 *
 * To run a query within a React component, call `useRegistrantsByUserIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useRegistrantsByUserIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRegistrantsByUserIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useRegistrantsByUserIdQuery(baseOptions: Apollo.QueryHookOptions<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>(RegistrantsByUserIdDocument, options);
      }
export function useRegistrantsByUserIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>(RegistrantsByUserIdDocument, options);
        }
export type RegistrantsByUserIdQueryHookResult = ReturnType<typeof useRegistrantsByUserIdQuery>;
export type RegistrantsByUserIdLazyQueryHookResult = ReturnType<typeof useRegistrantsByUserIdLazyQuery>;
export type RegistrantsByUserIdQueryResult = Apollo.QueryResult<RegistrantsByUserIdQuery, RegistrantsByUserIdQueryVariables>;
export const ConferenceBySlug_WithUserDocument = gql`
    query ConferenceBySlug_WithUser($slug: String!, $userId: String!) {
  conference_Conference(where: {slug: {_eq: $slug}}) {
    ...PublicConferenceInfo
    ...AuthdConferenceInfo
  }
}
    ${PublicConferenceInfoFragmentDoc}
${AuthdConferenceInfoFragmentDoc}`;

/**
 * __useConferenceBySlug_WithUserQuery__
 *
 * To run a query within a React component, call `useConferenceBySlug_WithUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceBySlug_WithUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceBySlug_WithUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useConferenceBySlug_WithUserQuery(baseOptions: Apollo.QueryHookOptions<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>(ConferenceBySlug_WithUserDocument, options);
      }
export function useConferenceBySlug_WithUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>(ConferenceBySlug_WithUserDocument, options);
        }
export type ConferenceBySlug_WithUserQueryHookResult = ReturnType<typeof useConferenceBySlug_WithUserQuery>;
export type ConferenceBySlug_WithUserLazyQueryHookResult = ReturnType<typeof useConferenceBySlug_WithUserLazyQuery>;
export type ConferenceBySlug_WithUserQueryResult = Apollo.QueryResult<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>;
export const ConferenceBySlug_WithoutUserDocument = gql`
    query ConferenceBySlug_WithoutUser($slug: String!) {
  conference_Conference(where: {slug: {_eq: $slug}}) {
    ...PublicConferenceInfo
  }
}
    ${PublicConferenceInfoFragmentDoc}`;

/**
 * __useConferenceBySlug_WithoutUserQuery__
 *
 * To run a query within a React component, call `useConferenceBySlug_WithoutUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceBySlug_WithoutUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceBySlug_WithoutUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceBySlug_WithoutUserQuery(baseOptions: Apollo.QueryHookOptions<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>(ConferenceBySlug_WithoutUserDocument, options);
      }
export function useConferenceBySlug_WithoutUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>(ConferenceBySlug_WithoutUserDocument, options);
        }
export type ConferenceBySlug_WithoutUserQueryHookResult = ReturnType<typeof useConferenceBySlug_WithoutUserQuery>;
export type ConferenceBySlug_WithoutUserLazyQueryHookResult = ReturnType<typeof useConferenceBySlug_WithoutUserLazyQuery>;
export type ConferenceBySlug_WithoutUserQueryResult = Apollo.QueryResult<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>;
export const UpdateSubtitlesDocument = gql`
    mutation UpdateSubtitles($elementId: String!, $magicToken: String!, $subtitleText: String!) {
  updateSubtitles(
    elementId: $elementId
    magicToken: $magicToken
    subtitleText: $subtitleText
  ) {
    message
    success
  }
}
    `;
export type UpdateSubtitlesMutationFn = Apollo.MutationFunction<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;

/**
 * __useUpdateSubtitlesMutation__
 *
 * To run a mutation, you first call `useUpdateSubtitlesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubtitlesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubtitlesMutation, { data, loading, error }] = useUpdateSubtitlesMutation({
 *   variables: {
 *      elementId: // value for 'elementId'
 *      magicToken: // value for 'magicToken'
 *      subtitleText: // value for 'subtitleText'
 *   },
 * });
 */
export function useUpdateSubtitlesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>(UpdateSubtitlesDocument, options);
      }
export type UpdateSubtitlesMutationHookResult = ReturnType<typeof useUpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationResult = Apollo.MutationResult<UpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationOptions = Apollo.BaseMutationOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;
export const GetElementDocument = gql`
    query GetElement($magicToken: String!) {
  content_ElementByAccessToken(where: {accessToken: {_eq: $magicToken}}) {
    typeName
    data
    layoutData
    name
    id
    itemTitle
  }
}
    `;

/**
 * __useGetElementQuery__
 *
 * To run a query within a React component, call `useGetElementQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetElementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetElementQuery({
 *   variables: {
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useGetElementQuery(baseOptions: Apollo.QueryHookOptions<GetElementQuery, GetElementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetElementQuery, GetElementQueryVariables>(GetElementDocument, options);
      }
export function useGetElementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetElementQuery, GetElementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetElementQuery, GetElementQueryVariables>(GetElementDocument, options);
        }
export type GetElementQueryHookResult = ReturnType<typeof useGetElementQuery>;
export type GetElementLazyQueryHookResult = ReturnType<typeof useGetElementLazyQuery>;
export type GetElementQueryResult = Apollo.QueryResult<GetElementQuery, GetElementQueryVariables>;
export const SelectUploadableItemDocument = gql`
    query SelectUploadableItem($uploadableId: uuid!) {
  content_UploadableElement(where: {id: {_eq: $uploadableId}}) {
    ...UploadableItemFields
  }
}
    ${UploadableItemFieldsFragmentDoc}`;

/**
 * __useSelectUploadableItemQuery__
 *
 * To run a query within a React component, call `useSelectUploadableItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectUploadableItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectUploadableItemQuery({
 *   variables: {
 *      uploadableId: // value for 'uploadableId'
 *   },
 * });
 */
export function useSelectUploadableItemQuery(baseOptions: Apollo.QueryHookOptions<SelectUploadableItemQuery, SelectUploadableItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectUploadableItemQuery, SelectUploadableItemQueryVariables>(SelectUploadableItemDocument, options);
      }
export function useSelectUploadableItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectUploadableItemQuery, SelectUploadableItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectUploadableItemQuery, SelectUploadableItemQueryVariables>(SelectUploadableItemDocument, options);
        }
export type SelectUploadableItemQueryHookResult = ReturnType<typeof useSelectUploadableItemQuery>;
export type SelectUploadableItemLazyQueryHookResult = ReturnType<typeof useSelectUploadableItemLazyQuery>;
export type SelectUploadableItemQueryResult = Apollo.QueryResult<SelectUploadableItemQuery, SelectUploadableItemQueryVariables>;
export const SubmitUploadableElementDocument = gql`
    mutation submitUploadableElement($elementData: jsonb!, $magicToken: String!) {
  submitUploadableElement(data: $elementData, magicToken: $magicToken) {
    message
    success
  }
}
    `;
export type SubmitUploadableElementMutationFn = Apollo.MutationFunction<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>;

/**
 * __useSubmitUploadableElementMutation__
 *
 * To run a mutation, you first call `useSubmitUploadableElementMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitUploadableElementMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitUploadableElementMutation, { data, loading, error }] = useSubmitUploadableElementMutation({
 *   variables: {
 *      elementData: // value for 'elementData'
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useSubmitUploadableElementMutation(baseOptions?: Apollo.MutationHookOptions<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>(SubmitUploadableElementDocument, options);
      }
export type SubmitUploadableElementMutationHookResult = ReturnType<typeof useSubmitUploadableElementMutation>;
export type SubmitUploadableElementMutationResult = Apollo.MutationResult<SubmitUploadableElementMutation>;
export type SubmitUploadableElementMutationOptions = Apollo.BaseMutationOptions<SubmitUploadableElementMutation, SubmitUploadableElementMutationVariables>;
export const GetUploadAgreementDocument = gql`
    query GetUploadAgreement($magicToken: String!) {
  getUploadAgreement(magicToken: $magicToken) {
    agreementText
  }
}
    `;

/**
 * __useGetUploadAgreementQuery__
 *
 * To run a query within a React component, call `useGetUploadAgreementQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUploadAgreementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUploadAgreementQuery({
 *   variables: {
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useGetUploadAgreementQuery(baseOptions: Apollo.QueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, options);
      }
export function useGetUploadAgreementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, options);
        }
export type GetUploadAgreementQueryHookResult = ReturnType<typeof useGetUploadAgreementQuery>;
export type GetUploadAgreementLazyQueryHookResult = ReturnType<typeof useGetUploadAgreementLazyQuery>;
export type GetUploadAgreementQueryResult = Apollo.QueryResult<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>;
export const GetForceUserRefreshConfigDocument = gql`
    query GetForceUserRefreshConfig($conferenceId: uuid!) {
  conference_Configuration(
    where: {conferenceId: {_eq: $conferenceId}, key: {_eq: "CLOWDR_APP_VERSION"}}
  ) {
    id
    conferenceId
    key
    value
  }
}
    `;

/**
 * __useGetForceUserRefreshConfigQuery__
 *
 * To run a query within a React component, call `useGetForceUserRefreshConfigQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetForceUserRefreshConfigQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetForceUserRefreshConfigQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetForceUserRefreshConfigQuery(baseOptions: Apollo.QueryHookOptions<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>(GetForceUserRefreshConfigDocument, options);
      }
export function useGetForceUserRefreshConfigLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>(GetForceUserRefreshConfigDocument, options);
        }
export type GetForceUserRefreshConfigQueryHookResult = ReturnType<typeof useGetForceUserRefreshConfigQuery>;
export type GetForceUserRefreshConfigLazyQueryHookResult = ReturnType<typeof useGetForceUserRefreshConfigLazyQuery>;
export type GetForceUserRefreshConfigQueryResult = Apollo.QueryResult<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>;
export const GoogleOAuth_SubmitGoogleOAuthCodeDocument = gql`
    mutation GoogleOAuth_SubmitGoogleOAuthCode($code: String!, $state: String!) {
  submitGoogleOAuthCode(code: $code, state: $state) {
    message
    success
  }
}
    `;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationFn = Apollo.MutationFunction<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>;

/**
 * __useGoogleOAuth_SubmitGoogleOAuthCodeMutation__
 *
 * To run a mutation, you first call `useGoogleOAuth_SubmitGoogleOAuthCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleOAuth_SubmitGoogleOAuthCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleOAuthSubmitGoogleOAuthCodeMutation, { data, loading, error }] = useGoogleOAuth_SubmitGoogleOAuthCodeMutation({
 *   variables: {
 *      code: // value for 'code'
 *      state: // value for 'state'
 *   },
 * });
 */
export function useGoogleOAuth_SubmitGoogleOAuthCodeMutation(baseOptions?: Apollo.MutationHookOptions<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>(GoogleOAuth_SubmitGoogleOAuthCodeDocument, options);
      }
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationHookResult = ReturnType<typeof useGoogleOAuth_SubmitGoogleOAuthCodeMutation>;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationResult = Apollo.MutationResult<GoogleOAuth_SubmitGoogleOAuthCodeMutation>;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationOptions = Apollo.BaseMutationOptions<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>;
export const SelectInvitationForAcceptDocument = gql`
    query SelectInvitationForAccept($inviteCode: uuid!) {
  registrant_Invitation(where: {inviteCode: {_eq: $inviteCode}}) {
    id
    invitedEmailAddress
  }
}
    `;

/**
 * __useSelectInvitationForAcceptQuery__
 *
 * To run a query within a React component, call `useSelectInvitationForAcceptQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInvitationForAcceptQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInvitationForAcceptQuery({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSelectInvitationForAcceptQuery(baseOptions: Apollo.QueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, options);
      }
export function useSelectInvitationForAcceptLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, options);
        }
export type SelectInvitationForAcceptQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptQuery>;
export type SelectInvitationForAcceptLazyQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptLazyQuery>;
export type SelectInvitationForAcceptQueryResult = Apollo.QueryResult<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>;
export const Invitation_ConfirmCurrentDocument = gql`
    mutation Invitation_ConfirmCurrent($inviteCode: uuid!) {
  invitationConfirmCurrent(inviteCode: $inviteCode) {
    confSlug
    ok
  }
}
    `;
export type Invitation_ConfirmCurrentMutationFn = Apollo.MutationFunction<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;

/**
 * __useInvitation_ConfirmCurrentMutation__
 *
 * To run a mutation, you first call `useInvitation_ConfirmCurrentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvitation_ConfirmCurrentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invitationConfirmCurrentMutation, { data, loading, error }] = useInvitation_ConfirmCurrentMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useInvitation_ConfirmCurrentMutation(baseOptions?: Apollo.MutationHookOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>(Invitation_ConfirmCurrentDocument, options);
      }
export type Invitation_ConfirmCurrentMutationHookResult = ReturnType<typeof useInvitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationResult = Apollo.MutationResult<Invitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationOptions = Apollo.BaseMutationOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;
export const Invitation_ConfirmWithCodeDocument = gql`
    mutation Invitation_ConfirmWithCode($inviteCode: uuid!, $confirmationCode: String!) {
  invitationConfirmWithCode(
    inviteInput: {inviteCode: $inviteCode, confirmationCode: $confirmationCode}
  ) {
    confSlug
    ok
  }
}
    `;
export type Invitation_ConfirmWithCodeMutationFn = Apollo.MutationFunction<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>;

/**
 * __useInvitation_ConfirmWithCodeMutation__
 *
 * To run a mutation, you first call `useInvitation_ConfirmWithCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvitation_ConfirmWithCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invitationConfirmWithCodeMutation, { data, loading, error }] = useInvitation_ConfirmWithCodeMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *      confirmationCode: // value for 'confirmationCode'
 *   },
 * });
 */
export function useInvitation_ConfirmWithCodeMutation(baseOptions?: Apollo.MutationHookOptions<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>(Invitation_ConfirmWithCodeDocument, options);
      }
export type Invitation_ConfirmWithCodeMutationHookResult = ReturnType<typeof useInvitation_ConfirmWithCodeMutation>;
export type Invitation_ConfirmWithCodeMutationResult = Apollo.MutationResult<Invitation_ConfirmWithCodeMutation>;
export type Invitation_ConfirmWithCodeMutationOptions = Apollo.BaseMutationOptions<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>;
export const SendInitialConfirmationEmailDocument = gql`
    mutation SendInitialConfirmationEmail($inviteCode: uuid!) {
  invitationConfirmSendInitialEmail(inviteInput: {inviteCode: $inviteCode}) {
    sent
  }
}
    `;
export type SendInitialConfirmationEmailMutationFn = Apollo.MutationFunction<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>;

/**
 * __useSendInitialConfirmationEmailMutation__
 *
 * To run a mutation, you first call `useSendInitialConfirmationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendInitialConfirmationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendInitialConfirmationEmailMutation, { data, loading, error }] = useSendInitialConfirmationEmailMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSendInitialConfirmationEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>(SendInitialConfirmationEmailDocument, options);
      }
export type SendInitialConfirmationEmailMutationHookResult = ReturnType<typeof useSendInitialConfirmationEmailMutation>;
export type SendInitialConfirmationEmailMutationResult = Apollo.MutationResult<SendInitialConfirmationEmailMutation>;
export type SendInitialConfirmationEmailMutationOptions = Apollo.BaseMutationOptions<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>;
export const SendRepeatConfirmationEmailDocument = gql`
    mutation SendRepeatConfirmationEmail($inviteCode: uuid!) {
  invitationConfirmSendRepeatEmail(inviteInput: {inviteCode: $inviteCode}) {
    sent
  }
}
    `;
export type SendRepeatConfirmationEmailMutationFn = Apollo.MutationFunction<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>;

/**
 * __useSendRepeatConfirmationEmailMutation__
 *
 * To run a mutation, you first call `useSendRepeatConfirmationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendRepeatConfirmationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendRepeatConfirmationEmailMutation, { data, loading, error }] = useSendRepeatConfirmationEmailMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSendRepeatConfirmationEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>(SendRepeatConfirmationEmailDocument, options);
      }
export type SendRepeatConfirmationEmailMutationHookResult = ReturnType<typeof useSendRepeatConfirmationEmailMutation>;
export type SendRepeatConfirmationEmailMutationResult = Apollo.MutationResult<SendRepeatConfirmationEmailMutation>;
export type SendRepeatConfirmationEmailMutationOptions = Apollo.BaseMutationOptions<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>;
export const MenuScheduleDocument = gql`
    query MenuSchedule($now: timestamptz!, $inOneHour: timestamptz!, $conferenceId: uuid!) {
  schedule_Event(
    where: {startTime: {_lte: $inOneHour}, endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, room: {}}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuScheduleQuery__
 *
 * To run a query within a React component, call `useMenuScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuScheduleQuery({
 *   variables: {
 *      now: // value for 'now'
 *      inOneHour: // value for 'inOneHour'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMenuScheduleQuery(baseOptions: Apollo.QueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, options);
      }
export function useMenuScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, options);
        }
export type MenuScheduleQueryHookResult = ReturnType<typeof useMenuScheduleQuery>;
export type MenuScheduleLazyQueryHookResult = ReturnType<typeof useMenuScheduleLazyQuery>;
export type MenuScheduleQueryResult = Apollo.QueryResult<MenuScheduleQuery, MenuScheduleQueryVariables>;
export const MenuSchedule_SearchEventsDocument = gql`
    query MenuSchedule_SearchEvents($conferenceId: uuid!, $search: String!) {
  schedule_Event(
    where: {conferenceId: {_eq: $conferenceId}, room: {}, _or: [{name: {_ilike: $search}}, {item: {_or: [{title: {_ilike: $search}}, {itemPeople: {person: {_or: [{name: {_ilike: $search}}, {affiliation: {_ilike: $search}}]}}}]}}, {eventPeople: {person: {_or: [{name: {_ilike: $search}}, {affiliation: {_ilike: $search}}]}}}, {eventTags: {tag: {name: {_ilike: $search}}}}]}
    limit: 10
    order_by: {startTime: asc}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuSchedule_SearchEventsQuery__
 *
 * To run a query within a React component, call `useMenuSchedule_SearchEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuSchedule_SearchEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuSchedule_SearchEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useMenuSchedule_SearchEventsQuery(baseOptions: Apollo.QueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, options);
      }
export function useMenuSchedule_SearchEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, options);
        }
export type MenuSchedule_SearchEventsQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsQuery>;
export type MenuSchedule_SearchEventsLazyQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsLazyQuery>;
export type MenuSchedule_SearchEventsQueryResult = Apollo.QueryResult<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>;
export const MainMenuSponsors_GetSponsorsDocument = gql`
    query MainMenuSponsors_GetSponsors($conferenceId: uuid!) {
  content_Item(
    where: {conferenceId: {_eq: $conferenceId}, typeName: {_eq: SPONSOR}}
    order_by: {title: asc}
  ) {
    ...MainMenuSponsors_ItemData
  }
}
    ${MainMenuSponsors_ItemDataFragmentDoc}`;

/**
 * __useMainMenuSponsors_GetSponsorsQuery__
 *
 * To run a query within a React component, call `useMainMenuSponsors_GetSponsorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMainMenuSponsors_GetSponsorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMainMenuSponsors_GetSponsorsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMainMenuSponsors_GetSponsorsQuery(baseOptions: Apollo.QueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, options);
      }
export function useMainMenuSponsors_GetSponsorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, options);
        }
export type MainMenuSponsors_GetSponsorsQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsQuery>;
export type MainMenuSponsors_GetSponsorsLazyQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsLazyQuery>;
export type MainMenuSponsors_GetSponsorsQueryResult = Apollo.QueryResult<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>;
export const CreateDmDocument = gql`
    mutation CreateDm($registrantIds: [uuid]!, $conferenceId: uuid!) {
  createRoomDm(registrantIds: $registrantIds, conferenceId: $conferenceId) {
    message
    roomId
    chatId
  }
}
    `;
export type CreateDmMutationFn = Apollo.MutationFunction<CreateDmMutation, CreateDmMutationVariables>;

/**
 * __useCreateDmMutation__
 *
 * To run a mutation, you first call `useCreateDmMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDmMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDmMutation, { data, loading, error }] = useCreateDmMutation({
 *   variables: {
 *      registrantIds: // value for 'registrantIds'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateDmMutation(baseOptions?: Apollo.MutationHookOptions<CreateDmMutation, CreateDmMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDmMutation, CreateDmMutationVariables>(CreateDmDocument, options);
      }
export type CreateDmMutationHookResult = ReturnType<typeof useCreateDmMutation>;
export type CreateDmMutationResult = Apollo.MutationResult<CreateDmMutation>;
export type CreateDmMutationOptions = Apollo.BaseMutationOptions<CreateDmMutation, CreateDmMutationVariables>;
export const GetRoomChatIdDocument = gql`
    query GetRoomChatId($roomId: uuid!) {
  room_Room_by_pk(id: $roomId) {
    id
    chatId
    name
  }
}
    `;

/**
 * __useGetRoomChatIdQuery__
 *
 * To run a query within a React component, call `useGetRoomChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomChatIdQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomChatIdQuery(baseOptions: Apollo.QueryHookOptions<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>(GetRoomChatIdDocument, options);
      }
export function useGetRoomChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>(GetRoomChatIdDocument, options);
        }
export type GetRoomChatIdQueryHookResult = ReturnType<typeof useGetRoomChatIdQuery>;
export type GetRoomChatIdLazyQueryHookResult = ReturnType<typeof useGetRoomChatIdLazyQuery>;
export type GetRoomChatIdQueryResult = Apollo.QueryResult<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>;
export const GetItemChatIdDocument = gql`
    query GetItemChatId($itemId: uuid!) {
  content_Item_by_pk(id: $itemId) {
    id
    title
    chatId
  }
}
    `;

/**
 * __useGetItemChatIdQuery__
 *
 * To run a query within a React component, call `useGetItemChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetItemChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetItemChatIdQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useGetItemChatIdQuery(baseOptions: Apollo.QueryHookOptions<GetItemChatIdQuery, GetItemChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetItemChatIdQuery, GetItemChatIdQueryVariables>(GetItemChatIdDocument, options);
      }
export function useGetItemChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetItemChatIdQuery, GetItemChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetItemChatIdQuery, GetItemChatIdQueryVariables>(GetItemChatIdDocument, options);
        }
export type GetItemChatIdQueryHookResult = ReturnType<typeof useGetItemChatIdQuery>;
export type GetItemChatIdLazyQueryHookResult = ReturnType<typeof useGetItemChatIdLazyQuery>;
export type GetItemChatIdQueryResult = Apollo.QueryResult<GetItemChatIdQuery, GetItemChatIdQueryVariables>;
export const GetVapidPublicKeyDocument = gql`
    query GetVAPIDPublicKey {
  vapidPublicKey {
    key
  }
}
    `;

/**
 * __useGetVapidPublicKeyQuery__
 *
 * To run a query within a React component, call `useGetVapidPublicKeyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVapidPublicKeyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVapidPublicKeyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetVapidPublicKeyQuery(baseOptions?: Apollo.QueryHookOptions<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>(GetVapidPublicKeyDocument, options);
      }
export function useGetVapidPublicKeyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>(GetVapidPublicKeyDocument, options);
        }
export type GetVapidPublicKeyQueryHookResult = ReturnType<typeof useGetVapidPublicKeyQuery>;
export type GetVapidPublicKeyLazyQueryHookResult = ReturnType<typeof useGetVapidPublicKeyLazyQuery>;
export type GetVapidPublicKeyQueryResult = Apollo.QueryResult<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>;
export const UpsertPushNotificationSubscriptionDocument = gql`
    mutation UpsertPushNotificationSubscription($object: PushNotificationSubscription_insert_input!) {
  insert_PushNotificationSubscription_one(
    object: $object
    on_conflict: {constraint: PushNotificationSubscription_pkey, update_columns: [auth, endpoint, p256dh]}
  ) {
    endpoint
  }
}
    `;
export type UpsertPushNotificationSubscriptionMutationFn = Apollo.MutationFunction<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>;

/**
 * __useUpsertPushNotificationSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpsertPushNotificationSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertPushNotificationSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertPushNotificationSubscriptionMutation, { data, loading, error }] = useUpsertPushNotificationSubscriptionMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useUpsertPushNotificationSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>(UpsertPushNotificationSubscriptionDocument, options);
      }
export type UpsertPushNotificationSubscriptionMutationHookResult = ReturnType<typeof useUpsertPushNotificationSubscriptionMutation>;
export type UpsertPushNotificationSubscriptionMutationResult = Apollo.MutationResult<UpsertPushNotificationSubscriptionMutation>;
export type UpsertPushNotificationSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>;
export const DeletePushNotificationSubscriptionDocument = gql`
    mutation DeletePushNotificationSubscription($endpoint: String!) {
  delete_PushNotificationSubscription(where: {endpoint: {_eq: $endpoint}}) {
    affected_rows
  }
}
    `;
export type DeletePushNotificationSubscriptionMutationFn = Apollo.MutationFunction<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>;

/**
 * __useDeletePushNotificationSubscriptionMutation__
 *
 * To run a mutation, you first call `useDeletePushNotificationSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePushNotificationSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePushNotificationSubscriptionMutation, { data, loading, error }] = useDeletePushNotificationSubscriptionMutation({
 *   variables: {
 *      endpoint: // value for 'endpoint'
 *   },
 * });
 */
export function useDeletePushNotificationSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>(DeletePushNotificationSubscriptionDocument, options);
      }
export type DeletePushNotificationSubscriptionMutationHookResult = ReturnType<typeof useDeletePushNotificationSubscriptionMutation>;
export type DeletePushNotificationSubscriptionMutationResult = Apollo.MutationResult<DeletePushNotificationSubscriptionMutation>;
export type DeletePushNotificationSubscriptionMutationOptions = Apollo.BaseMutationOptions<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>;
export const GetRoomMembersDocument = gql`
    query GetRoomMembers($roomId: uuid!) {
  room_RoomPerson(where: {roomId: {_eq: $roomId}}) {
    ...RoomMember
  }
}
    ${RoomMemberFragmentDoc}`;

/**
 * __useGetRoomMembersQuery__
 *
 * To run a query within a React component, call `useGetRoomMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomMembersQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomMembersQuery(baseOptions: Apollo.QueryHookOptions<GetRoomMembersQuery, GetRoomMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomMembersQuery, GetRoomMembersQueryVariables>(GetRoomMembersDocument, options);
      }
export function useGetRoomMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomMembersQuery, GetRoomMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomMembersQuery, GetRoomMembersQueryVariables>(GetRoomMembersDocument, options);
        }
export type GetRoomMembersQueryHookResult = ReturnType<typeof useGetRoomMembersQuery>;
export type GetRoomMembersLazyQueryHookResult = ReturnType<typeof useGetRoomMembersLazyQuery>;
export type GetRoomMembersQueryResult = Apollo.QueryResult<GetRoomMembersQuery, GetRoomMembersQueryVariables>;
export const GetRoomParticipantsDocument = gql`
    subscription GetRoomParticipants($conferenceId: uuid!, $roomId: uuid!) {
  room_Participant(
    where: {conferenceId: {_eq: $conferenceId}, roomId: {_eq: $roomId}}
  ) {
    ...RoomParticipantDetails
  }
}
    ${RoomParticipantDetailsFragmentDoc}`;

/**
 * __useGetRoomParticipantsSubscription__
 *
 * To run a query within a React component, call `useGetRoomParticipantsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomParticipantsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomParticipantsSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomParticipantsSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetRoomParticipantsSubscription, GetRoomParticipantsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetRoomParticipantsSubscription, GetRoomParticipantsSubscriptionVariables>(GetRoomParticipantsDocument, options);
      }
export type GetRoomParticipantsSubscriptionHookResult = ReturnType<typeof useGetRoomParticipantsSubscription>;
export type GetRoomParticipantsSubscriptionResult = Apollo.SubscriptionResult<GetRoomParticipantsSubscription>;
export const GetAllRoomParticipantsDocument = gql`
    query GetAllRoomParticipants($conferenceId: uuid!) {
  room_Participant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomParticipantDetails
  }
}
    ${RoomParticipantDetailsFragmentDoc}`;

/**
 * __useGetAllRoomParticipantsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetAllRoomParticipantsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, options);
      }
export function useGetAllRoomParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, options);
        }
export type GetAllRoomParticipantsQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsQuery>;
export type GetAllRoomParticipantsLazyQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsLazyQuery>;
export type GetAllRoomParticipantsQueryResult = Apollo.QueryResult<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>;
export const MyShuffleQueueEntryDocument = gql`
    subscription MyShuffleQueueEntry($id: bigint!) {
  room_ShuffleQueueEntry_by_pk(id: $id) {
    ...SubdShuffleQueueEntryData
  }
}
    ${SubdShuffleQueueEntryDataFragmentDoc}`;

/**
 * __useMyShuffleQueueEntrySubscription__
 *
 * To run a query within a React component, call `useMyShuffleQueueEntrySubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyShuffleQueueEntrySubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyShuffleQueueEntrySubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMyShuffleQueueEntrySubscription(baseOptions: Apollo.SubscriptionHookOptions<MyShuffleQueueEntrySubscription, MyShuffleQueueEntrySubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<MyShuffleQueueEntrySubscription, MyShuffleQueueEntrySubscriptionVariables>(MyShuffleQueueEntryDocument, options);
      }
export type MyShuffleQueueEntrySubscriptionHookResult = ReturnType<typeof useMyShuffleQueueEntrySubscription>;
export type MyShuffleQueueEntrySubscriptionResult = Apollo.SubscriptionResult<MyShuffleQueueEntrySubscription>;
export const GetShuffleRoomDocument = gql`
    query GetShuffleRoom($id: bigint!) {
  room_ShuffleRoom_by_pk(id: $id) {
    id
    roomId
  }
}
    `;

/**
 * __useGetShuffleRoomQuery__
 *
 * To run a query within a React component, call `useGetShuffleRoomQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShuffleRoomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShuffleRoomQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetShuffleRoomQuery(baseOptions: Apollo.QueryHookOptions<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>(GetShuffleRoomDocument, options);
      }
export function useGetShuffleRoomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>(GetShuffleRoomDocument, options);
        }
export type GetShuffleRoomQueryHookResult = ReturnType<typeof useGetShuffleRoomQuery>;
export type GetShuffleRoomLazyQueryHookResult = ReturnType<typeof useGetShuffleRoomLazyQuery>;
export type GetShuffleRoomQueryResult = Apollo.QueryResult<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>;
export const ShufflePeriodsDocument = gql`
    query ShufflePeriods($conferenceId: uuid!, $end: timestamptz!) {
  room_ShufflePeriod(
    where: {conferenceId: {_eq: $conferenceId}, endAt: {_gte: $end}}
  ) {
    ...ShufflePeriodData
  }
}
    ${ShufflePeriodDataFragmentDoc}`;

/**
 * __useShufflePeriodsQuery__
 *
 * To run a query within a React component, call `useShufflePeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useShufflePeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useShufflePeriodsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      end: // value for 'end'
 *   },
 * });
 */
export function useShufflePeriodsQuery(baseOptions: Apollo.QueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, options);
      }
export function useShufflePeriodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, options);
        }
export type ShufflePeriodsQueryHookResult = ReturnType<typeof useShufflePeriodsQuery>;
export type ShufflePeriodsLazyQueryHookResult = ReturnType<typeof useShufflePeriodsLazyQuery>;
export type ShufflePeriodsQueryResult = Apollo.QueryResult<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>;
export const JoinShuffleQueueDocument = gql`
    mutation JoinShuffleQueue($shufflePeriodId: uuid!, $registrantId: uuid!) {
  insert_room_ShuffleQueueEntry_one(
    object: {registrantId: $registrantId, shufflePeriodId: $shufflePeriodId}
  ) {
    ...PrefetchShuffleQueueEntryData
  }
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export type JoinShuffleQueueMutationFn = Apollo.MutationFunction<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;

/**
 * __useJoinShuffleQueueMutation__
 *
 * To run a mutation, you first call `useJoinShuffleQueueMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinShuffleQueueMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinShuffleQueueMutation, { data, loading, error }] = useJoinShuffleQueueMutation({
 *   variables: {
 *      shufflePeriodId: // value for 'shufflePeriodId'
 *      registrantId: // value for 'registrantId'
 *   },
 * });
 */
export function useJoinShuffleQueueMutation(baseOptions?: Apollo.MutationHookOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>(JoinShuffleQueueDocument, options);
      }
export type JoinShuffleQueueMutationHookResult = ReturnType<typeof useJoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationResult = Apollo.MutationResult<JoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationOptions = Apollo.BaseMutationOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;
export const GetShuffleRoomsParticipantsCountDocument = gql`
    query GetShuffleRoomsParticipantsCount($conferenceId: uuid!) {
  room_Participant_aggregate(
    where: {conferenceId: {_eq: $conferenceId}, room: {shuffleRooms: {isEnded: {_eq: false}}}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetShuffleRoomsParticipantsCountQuery__
 *
 * To run a query within a React component, call `useGetShuffleRoomsParticipantsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShuffleRoomsParticipantsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShuffleRoomsParticipantsCountQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetShuffleRoomsParticipantsCountQuery(baseOptions: Apollo.QueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, options);
      }
export function useGetShuffleRoomsParticipantsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, options);
        }
export type GetShuffleRoomsParticipantsCountQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountQuery>;
export type GetShuffleRoomsParticipantsCountLazyQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountLazyQuery>;
export type GetShuffleRoomsParticipantsCountQueryResult = Apollo.QueryResult<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>;
export const SelectCurrentUserDocument = gql`
    query SelectCurrentUser($userId: String!) {
  User_by_pk(id: $userId) {
    ...UserInfo
  }
}
    ${UserInfoFragmentDoc}`;

/**
 * __useSelectCurrentUserQuery__
 *
 * To run a query within a React component, call `useSelectCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectCurrentUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSelectCurrentUserQuery(baseOptions: Apollo.QueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, options);
      }
export function useSelectCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, options);
        }
export type SelectCurrentUserQueryHookResult = ReturnType<typeof useSelectCurrentUserQuery>;
export type SelectCurrentUserLazyQueryHookResult = ReturnType<typeof useSelectCurrentUserLazyQuery>;
export type SelectCurrentUserQueryResult = Apollo.QueryResult<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>;
export const TermsConfigsDocument = gql`
    query TermsConfigs {
  hostOrganisationName: system_Configuration_by_pk(key: HOST_ORGANISATION_NAME) {
    key
    value
    updated_at
  }
  termsTimestamp: system_Configuration_by_pk(key: TERMS_LATEST_REVISION_TIMESTAMP) {
    key
    value
    updated_at
  }
  termsURL: system_Configuration_by_pk(key: TERMS_URL) {
    key
    value
    updated_at
  }
  ppTimestamp: system_Configuration_by_pk(
    key: PRIVACY_POLICY_LATEST_REVISION_TIMESTAMP
  ) {
    key
    value
    updated_at
  }
  ppURL: system_Configuration_by_pk(key: PRIVACY_POLICY_URL) {
    key
    value
    updated_at
  }
  cookiesTimestamp: system_Configuration_by_pk(
    key: COOKIE_POLICY_LATEST_REVISION_TIMESTAMP
  ) {
    key
    value
    updated_at
  }
  cookiesURL: system_Configuration_by_pk(key: COOKIE_POLICY_URL) {
    key
    value
    updated_at
  }
}
    `;

/**
 * __useTermsConfigsQuery__
 *
 * To run a query within a React component, call `useTermsConfigsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTermsConfigsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTermsConfigsQuery({
 *   variables: {
 *   },
 * });
 */
export function useTermsConfigsQuery(baseOptions?: Apollo.QueryHookOptions<TermsConfigsQuery, TermsConfigsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TermsConfigsQuery, TermsConfigsQueryVariables>(TermsConfigsDocument, options);
      }
export function useTermsConfigsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TermsConfigsQuery, TermsConfigsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TermsConfigsQuery, TermsConfigsQueryVariables>(TermsConfigsDocument, options);
        }
export type TermsConfigsQueryHookResult = ReturnType<typeof useTermsConfigsQuery>;
export type TermsConfigsLazyQueryHookResult = ReturnType<typeof useTermsConfigsLazyQuery>;
export type TermsConfigsQueryResult = Apollo.QueryResult<TermsConfigsQuery, TermsConfigsQueryVariables>;
export const AgreeToTermsDocument = gql`
    mutation AgreeToTerms($userId: String!, $at: timestamptz!) {
  update_User_by_pk(
    pk_columns: {id: $userId}
    _set: {acceptedTermsAt: $at, acceptedPrivacyPolicyAt: $at}
  ) {
    id
    acceptedTermsAt
    acceptedPrivacyPolicyAt
  }
}
    `;
export type AgreeToTermsMutationFn = Apollo.MutationFunction<AgreeToTermsMutation, AgreeToTermsMutationVariables>;

/**
 * __useAgreeToTermsMutation__
 *
 * To run a mutation, you first call `useAgreeToTermsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAgreeToTermsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [agreeToTermsMutation, { data, loading, error }] = useAgreeToTermsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      at: // value for 'at'
 *   },
 * });
 */
export function useAgreeToTermsMutation(baseOptions?: Apollo.MutationHookOptions<AgreeToTermsMutation, AgreeToTermsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AgreeToTermsMutation, AgreeToTermsMutationVariables>(AgreeToTermsDocument, options);
      }
export type AgreeToTermsMutationHookResult = ReturnType<typeof useAgreeToTermsMutation>;
export type AgreeToTermsMutationResult = Apollo.MutationResult<AgreeToTermsMutation>;
export type AgreeToTermsMutationOptions = Apollo.BaseMutationOptions<AgreeToTermsMutation, AgreeToTermsMutationVariables>;