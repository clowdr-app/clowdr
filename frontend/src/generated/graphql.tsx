import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions =  {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  json: any;
  jsonb: any;
  timestamptz: any;
  uuid: any;
};

/** columns and relationships of "Attendee" */
export type Attendee = {
  readonly __typename?: 'Attendee';
  /** An array relationship */
  readonly badges: ReadonlyArray<AttendeeProfileBadges>;
  /** An aggregated array relationship */
  readonly badges_aggregate: AttendeeProfileBadges_Aggregate;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentPeople: ReadonlyArray<ContentPerson>;
  /** An aggregated array relationship */
  readonly contentPeople_aggregate: ContentPerson_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly displayName: Scalars['String'];
  /** An array relationship */
  readonly groupAttendees: ReadonlyArray<GroupAttendee>;
  /** An aggregated array relationship */
  readonly groupAttendees_aggregate: GroupAttendee_Aggregate;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Invitation>;
  /** A computed field, executes function "hasbeeninvited" */
  readonly inviteSent?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly profile?: Maybe<AttendeeProfile>;
  /** An array relationship */
  readonly roomParticipants: ReadonlyArray<RoomParticipant>;
  /** An aggregated array relationship */
  readonly roomParticipants_aggregate: RoomParticipant_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};


/** columns and relationships of "Attendee" */
export type AttendeeBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfileBadges_Order_By>>;
  where?: Maybe<AttendeeProfileBadges_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfileBadges_Order_By>>;
  where?: Maybe<AttendeeProfileBadges_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeContentPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeContentPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeGroupAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeGroupAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeRoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** columns and relationships of "Attendee" */
export type AttendeeRoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};

/** columns and relationships of "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount = {
  readonly __typename?: 'AttendeeGoogleAccount';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly googleAccountEmail: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly tokenData: Scalars['jsonb'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};


/** columns and relationships of "AttendeeGoogleAccount" */
export type AttendeeGoogleAccountTokenDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "AttendeeGoogleAccount" */
export type AttendeeGoogleAccountYouTubeDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Aggregate = {
  readonly __typename?: 'AttendeeGoogleAccount_aggregate';
  readonly aggregate?: Maybe<AttendeeGoogleAccount_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<AttendeeGoogleAccount>;
};

/** aggregate fields of "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Aggregate_Fields = {
  readonly __typename?: 'AttendeeGoogleAccount_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<AttendeeGoogleAccount_Max_Fields>;
  readonly min?: Maybe<AttendeeGoogleAccount_Min_Fields>;
};


/** aggregate fields of "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<AttendeeGoogleAccount_Max_Order_By>;
  readonly min?: Maybe<AttendeeGoogleAccount_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AttendeeGoogleAccount_Append_Input = {
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<AttendeeGoogleAccount_Insert_Input>;
  readonly on_conflict?: Maybe<AttendeeGoogleAccount_On_Conflict>;
};

/** Boolean expression to filter rows from the table "AttendeeGoogleAccount". All fields are combined with a logical 'AND'. */
export type AttendeeGoogleAccount_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<AttendeeGoogleAccount_Bool_Exp>>>;
  readonly _not?: Maybe<AttendeeGoogleAccount_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<AttendeeGoogleAccount_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly googleAccountEmail?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly tokenData?: Maybe<Jsonb_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly youTubeData?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "AttendeeGoogleAccount" */
export enum AttendeeGoogleAccount_Constraint {
  /** unique or primary key constraint */
  AttendeeGoogleAccountAttendeeIdGoogleAccountEmailKey = 'AttendeeGoogleAccount_attendeeId_googleAccountEmail_key',
  /** unique or primary key constraint */
  AttendeeGoogleAccountPkey = 'AttendeeGoogleAccount_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AttendeeGoogleAccount_Delete_At_Path_Input = {
  readonly tokenData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly youTubeData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AttendeeGoogleAccount_Delete_Elem_Input = {
  readonly tokenData?: Maybe<Scalars['Int']>;
  readonly youTubeData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AttendeeGoogleAccount_Delete_Key_Input = {
  readonly tokenData?: Maybe<Scalars['String']>;
  readonly youTubeData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type AttendeeGoogleAccount_Max_Fields = {
  readonly __typename?: 'AttendeeGoogleAccount_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly googleAccountEmail?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type AttendeeGoogleAccount_Min_Fields = {
  readonly __typename?: 'AttendeeGoogleAccount_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly googleAccountEmail?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Mutation_Response = {
  readonly __typename?: 'AttendeeGoogleAccount_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<AttendeeGoogleAccount>;
};

/** input type for inserting object relation for remote table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Obj_Rel_Insert_Input = {
  readonly data: AttendeeGoogleAccount_Insert_Input;
  readonly on_conflict?: Maybe<AttendeeGoogleAccount_On_Conflict>;
};

/** on conflict condition type for table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_On_Conflict = {
  readonly constraint: AttendeeGoogleAccount_Constraint;
  readonly update_columns: ReadonlyArray<AttendeeGoogleAccount_Update_Column>;
  readonly where?: Maybe<AttendeeGoogleAccount_Bool_Exp>;
};

/** ordering options when selecting data from "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly googleAccountEmail?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tokenData?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly youTubeData?: Maybe<Order_By>;
};

/** primary key columns input for table: "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AttendeeGoogleAccount_Prepend_Input = {
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "AttendeeGoogleAccount" */
export enum AttendeeGoogleAccount_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GoogleAccountEmail = 'googleAccountEmail',
  /** column name */
  Id = 'id',
  /** column name */
  TokenData = 'tokenData',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  YouTubeData = 'youTubeData'
}

/** input type for updating data in table "AttendeeGoogleAccount" */
export type AttendeeGoogleAccount_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly googleAccountEmail?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tokenData?: Maybe<Scalars['jsonb']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly youTubeData?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "AttendeeGoogleAccount" */
export enum AttendeeGoogleAccount_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GoogleAccountEmail = 'googleAccountEmail',
  /** column name */
  Id = 'id',
  /** column name */
  TokenData = 'tokenData',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  YouTubeData = 'youTubeData'
}

/** columns and relationships of "AttendeeProfile" */
export type AttendeeProfile = {
  readonly __typename?: 'AttendeeProfile';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at: Scalars['timestamptz'];
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited: Scalars['Boolean'];
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
  readonly website?: Maybe<Scalars['String']>;
};


/** columns and relationships of "AttendeeProfile" */
export type AttendeeProfileBadgesArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "AttendeeProfile" */
export type AttendeeProfilePronounsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "AttendeeProfileBadges" */
export type AttendeeProfileBadges = {
  readonly __typename?: 'AttendeeProfileBadges';
  /** An object relationship */
  readonly attendee?: Maybe<Attendee>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregated selection of "AttendeeProfileBadges" */
export type AttendeeProfileBadges_Aggregate = {
  readonly __typename?: 'AttendeeProfileBadges_aggregate';
  readonly aggregate?: Maybe<AttendeeProfileBadges_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<AttendeeProfileBadges>;
};

/** aggregate fields of "AttendeeProfileBadges" */
export type AttendeeProfileBadges_Aggregate_Fields = {
  readonly __typename?: 'AttendeeProfileBadges_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<AttendeeProfileBadges_Max_Fields>;
  readonly min?: Maybe<AttendeeProfileBadges_Min_Fields>;
};


/** aggregate fields of "AttendeeProfileBadges" */
export type AttendeeProfileBadges_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<AttendeeProfileBadges_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "AttendeeProfileBadges" */
export type AttendeeProfileBadges_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<AttendeeProfileBadges_Max_Order_By>;
  readonly min?: Maybe<AttendeeProfileBadges_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "AttendeeProfileBadges". All fields are combined with a logical 'AND'. */
export type AttendeeProfileBadges_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<AttendeeProfileBadges_Bool_Exp>>>;
  readonly _not?: Maybe<AttendeeProfileBadges_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<AttendeeProfileBadges_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type AttendeeProfileBadges_Max_Fields = {
  readonly __typename?: 'AttendeeProfileBadges_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "AttendeeProfileBadges" */
export type AttendeeProfileBadges_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type AttendeeProfileBadges_Min_Fields = {
  readonly __typename?: 'AttendeeProfileBadges_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly colour?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "AttendeeProfileBadges" */
export type AttendeeProfileBadges_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** ordering options when selecting data from "AttendeeProfileBadges" */
export type AttendeeProfileBadges_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly colour?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** select columns of table "AttendeeProfileBadges" */
export enum AttendeeProfileBadges_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  Colour = 'colour',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "AttendeeProfile" */
export type AttendeeProfile_Aggregate = {
  readonly __typename?: 'AttendeeProfile_aggregate';
  readonly aggregate?: Maybe<AttendeeProfile_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<AttendeeProfile>;
};

/** aggregate fields of "AttendeeProfile" */
export type AttendeeProfile_Aggregate_Fields = {
  readonly __typename?: 'AttendeeProfile_aggregate_fields';
  readonly avg?: Maybe<AttendeeProfile_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<AttendeeProfile_Max_Fields>;
  readonly min?: Maybe<AttendeeProfile_Min_Fields>;
  readonly stddev?: Maybe<AttendeeProfile_Stddev_Fields>;
  readonly stddev_pop?: Maybe<AttendeeProfile_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<AttendeeProfile_Stddev_Samp_Fields>;
  readonly sum?: Maybe<AttendeeProfile_Sum_Fields>;
  readonly var_pop?: Maybe<AttendeeProfile_Var_Pop_Fields>;
  readonly var_samp?: Maybe<AttendeeProfile_Var_Samp_Fields>;
  readonly variance?: Maybe<AttendeeProfile_Variance_Fields>;
};


/** aggregate fields of "AttendeeProfile" */
export type AttendeeProfile_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "AttendeeProfile" */
export type AttendeeProfile_Aggregate_Order_By = {
  readonly avg?: Maybe<AttendeeProfile_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<AttendeeProfile_Max_Order_By>;
  readonly min?: Maybe<AttendeeProfile_Min_Order_By>;
  readonly stddev?: Maybe<AttendeeProfile_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<AttendeeProfile_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<AttendeeProfile_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<AttendeeProfile_Sum_Order_By>;
  readonly var_pop?: Maybe<AttendeeProfile_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<AttendeeProfile_Var_Samp_Order_By>;
  readonly variance?: Maybe<AttendeeProfile_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type AttendeeProfile_Append_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "AttendeeProfile" */
export type AttendeeProfile_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<AttendeeProfile_Insert_Input>;
  readonly on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};

/** aggregate avg on columns */
export type AttendeeProfile_Avg_Fields = {
  readonly __typename?: 'AttendeeProfile_avg_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Avg_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "AttendeeProfile". All fields are combined with a logical 'AND'. */
export type AttendeeProfile_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<AttendeeProfile_Bool_Exp>>>;
  readonly _not?: Maybe<AttendeeProfile_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<AttendeeProfile_Bool_Exp>>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly affiliationURL?: Maybe<String_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly badges?: Maybe<Jsonb_Comparison_Exp>;
  readonly bio?: Maybe<String_Comparison_Exp>;
  readonly country?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly github?: Maybe<String_Comparison_Exp>;
  readonly hasBeenEdited?: Maybe<Boolean_Comparison_Exp>;
  readonly photoS3BucketName?: Maybe<String_Comparison_Exp>;
  readonly photoS3BucketRegion?: Maybe<String_Comparison_Exp>;
  readonly photoS3ObjectName?: Maybe<String_Comparison_Exp>;
  readonly photoURL_350x350?: Maybe<String_Comparison_Exp>;
  readonly photoURL_50x50?: Maybe<String_Comparison_Exp>;
  readonly pronouns?: Maybe<Jsonb_Comparison_Exp>;
  readonly realName?: Maybe<String_Comparison_Exp>;
  readonly timezoneUTCOffset?: Maybe<Float_Comparison_Exp>;
  readonly twitter?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly website?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "AttendeeProfile" */
export enum AttendeeProfile_Constraint {
  /** unique or primary key constraint */
  AttendeeProfileAttendeeIdKey = 'AttendeeProfile_attendeeId_key',
  /** unique or primary key constraint */
  AttendeeProfilePkey = 'AttendeeProfile_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type AttendeeProfile_Delete_At_Path_Input = {
  readonly badges?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly pronouns?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type AttendeeProfile_Delete_Elem_Input = {
  readonly badges?: Maybe<Scalars['Int']>;
  readonly pronouns?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type AttendeeProfile_Delete_Key_Input = {
  readonly badges?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "AttendeeProfile" */
export type AttendeeProfile_Inc_Input = {
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** input type for inserting data into table "AttendeeProfile" */
export type AttendeeProfile_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type AttendeeProfile_Max_Fields = {
  readonly __typename?: 'AttendeeProfile_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Max_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly realName?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type AttendeeProfile_Min_Fields = {
  readonly __typename?: 'AttendeeProfile_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Min_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly realName?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** response of any mutation on the table "AttendeeProfile" */
export type AttendeeProfile_Mutation_Response = {
  readonly __typename?: 'AttendeeProfile_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<AttendeeProfile>;
};

/** input type for inserting object relation for remote table "AttendeeProfile" */
export type AttendeeProfile_Obj_Rel_Insert_Input = {
  readonly data: AttendeeProfile_Insert_Input;
  readonly on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};

/** on conflict condition type for table "AttendeeProfile" */
export type AttendeeProfile_On_Conflict = {
  readonly constraint: AttendeeProfile_Constraint;
  readonly update_columns: ReadonlyArray<AttendeeProfile_Update_Column>;
  readonly where?: Maybe<AttendeeProfile_Bool_Exp>;
};

/** ordering options when selecting data from "AttendeeProfile" */
export type AttendeeProfile_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly affiliationURL?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly badges?: Maybe<Order_By>;
  readonly bio?: Maybe<Order_By>;
  readonly country?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly github?: Maybe<Order_By>;
  readonly hasBeenEdited?: Maybe<Order_By>;
  readonly photoS3BucketName?: Maybe<Order_By>;
  readonly photoS3BucketRegion?: Maybe<Order_By>;
  readonly photoS3ObjectName?: Maybe<Order_By>;
  readonly photoURL_350x350?: Maybe<Order_By>;
  readonly photoURL_50x50?: Maybe<Order_By>;
  readonly pronouns?: Maybe<Order_By>;
  readonly realName?: Maybe<Order_By>;
  readonly timezoneUTCOffset?: Maybe<Order_By>;
  readonly twitter?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly website?: Maybe<Order_By>;
};

/** primary key columns input for table: "AttendeeProfile" */
export type AttendeeProfile_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type AttendeeProfile_Prepend_Input = {
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "AttendeeProfile" */
export enum AttendeeProfile_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RealName = 'realName',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** input type for updating data in table "AttendeeProfile" */
export type AttendeeProfile_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly affiliationURL?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly badges?: Maybe<Scalars['jsonb']>;
  readonly bio?: Maybe<Scalars['String']>;
  readonly country?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly github?: Maybe<Scalars['String']>;
  readonly hasBeenEdited?: Maybe<Scalars['Boolean']>;
  readonly photoS3BucketName?: Maybe<Scalars['String']>;
  readonly photoS3BucketRegion?: Maybe<Scalars['String']>;
  readonly photoS3ObjectName?: Maybe<Scalars['String']>;
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
  readonly pronouns?: Maybe<Scalars['jsonb']>;
  readonly realName?: Maybe<Scalars['String']>;
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
  readonly twitter?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly website?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type AttendeeProfile_Stddev_Fields = {
  readonly __typename?: 'AttendeeProfile_stddev_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Stddev_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type AttendeeProfile_Stddev_Pop_Fields = {
  readonly __typename?: 'AttendeeProfile_stddev_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Stddev_Pop_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type AttendeeProfile_Stddev_Samp_Fields = {
  readonly __typename?: 'AttendeeProfile_stddev_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Stddev_Samp_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type AttendeeProfile_Sum_Fields = {
  readonly __typename?: 'AttendeeProfile_sum_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by sum() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Sum_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** update columns of table "AttendeeProfile" */
export enum AttendeeProfile_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AffiliationUrl = 'affiliationURL',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  Badges = 'badges',
  /** column name */
  Bio = 'bio',
  /** column name */
  Country = 'country',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Github = 'github',
  /** column name */
  HasBeenEdited = 'hasBeenEdited',
  /** column name */
  PhotoS3BucketName = 'photoS3BucketName',
  /** column name */
  PhotoS3BucketRegion = 'photoS3BucketRegion',
  /** column name */
  PhotoS3ObjectName = 'photoS3ObjectName',
  /** column name */
  PhotoUrl_350x350 = 'photoURL_350x350',
  /** column name */
  PhotoUrl_50x50 = 'photoURL_50x50',
  /** column name */
  Pronouns = 'pronouns',
  /** column name */
  RealName = 'realName',
  /** column name */
  TimezoneUtcOffset = 'timezoneUTCOffset',
  /** column name */
  Twitter = 'twitter',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Website = 'website'
}

/** aggregate var_pop on columns */
export type AttendeeProfile_Var_Pop_Fields = {
  readonly __typename?: 'AttendeeProfile_var_pop_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Var_Pop_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type AttendeeProfile_Var_Samp_Fields = {
  readonly __typename?: 'AttendeeProfile_var_samp_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Var_Samp_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type AttendeeProfile_Variance_Fields = {
  readonly __typename?: 'AttendeeProfile_variance_fields';
  readonly timezoneUTCOffset?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "AttendeeProfile" */
export type AttendeeProfile_Variance_Order_By = {
  readonly timezoneUTCOffset?: Maybe<Order_By>;
};

/** aggregated selection of "Attendee" */
export type Attendee_Aggregate = {
  readonly __typename?: 'Attendee_aggregate';
  readonly aggregate?: Maybe<Attendee_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Attendee>;
};

/** aggregate fields of "Attendee" */
export type Attendee_Aggregate_Fields = {
  readonly __typename?: 'Attendee_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Attendee_Max_Fields>;
  readonly min?: Maybe<Attendee_Min_Fields>;
};


/** aggregate fields of "Attendee" */
export type Attendee_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Attendee" */
export type Attendee_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Attendee_Max_Order_By>;
  readonly min?: Maybe<Attendee_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Attendee" */
export type Attendee_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Attendee_Insert_Input>;
  readonly on_conflict?: Maybe<Attendee_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Attendee". All fields are combined with a logical 'AND'. */
export type Attendee_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Attendee_Bool_Exp>>>;
  readonly _not?: Maybe<Attendee_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Attendee_Bool_Exp>>>;
  readonly badges?: Maybe<AttendeeProfileBadges_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentPeople?: Maybe<ContentPerson_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly displayName?: Maybe<String_Comparison_Exp>;
  readonly groupAttendees?: Maybe<GroupAttendee_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Invitation_Bool_Exp>;
  readonly profile?: Maybe<AttendeeProfile_Bool_Exp>;
  readonly roomParticipants?: Maybe<RoomParticipant_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Attendee" */
export enum Attendee_Constraint {
  /** unique or primary key constraint */
  AttendeeConferenceIdUserIdKey = 'Attendee_conferenceId_userId_key',
  /** unique or primary key constraint */
  AttendeePkey = 'Attendee_pkey'
}

/** input type for inserting data into table "Attendee" */
export type Attendee_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentPeople?: Maybe<ContentPerson_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly groupAttendees?: Maybe<GroupAttendee_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Invitation_Obj_Rel_Insert_Input>;
  readonly profile?: Maybe<AttendeeProfile_Obj_Rel_Insert_Input>;
  readonly roomParticipants?: Maybe<RoomParticipant_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Attendee_Max_Fields = {
  readonly __typename?: 'Attendee_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Attendee" */
export type Attendee_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Attendee_Min_Fields = {
  readonly __typename?: 'Attendee_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Attendee" */
export type Attendee_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "Attendee" */
export type Attendee_Mutation_Response = {
  readonly __typename?: 'Attendee_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Attendee>;
};

/** input type for inserting object relation for remote table "Attendee" */
export type Attendee_Obj_Rel_Insert_Input = {
  readonly data: Attendee_Insert_Input;
  readonly on_conflict?: Maybe<Attendee_On_Conflict>;
};

/** on conflict condition type for table "Attendee" */
export type Attendee_On_Conflict = {
  readonly constraint: Attendee_Constraint;
  readonly update_columns: ReadonlyArray<Attendee_Update_Column>;
  readonly where?: Maybe<Attendee_Bool_Exp>;
};

/** ordering options when selecting data from "Attendee" */
export type Attendee_Order_By = {
  readonly badges_aggregate?: Maybe<AttendeeProfileBadges_Aggregate_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentPeople_aggregate?: Maybe<ContentPerson_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly displayName?: Maybe<Order_By>;
  readonly groupAttendees_aggregate?: Maybe<GroupAttendee_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Invitation_Order_By>;
  readonly profile?: Maybe<AttendeeProfile_Order_By>;
  readonly roomParticipants_aggregate?: Maybe<RoomParticipant_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "Attendee" */
export type Attendee_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Attendee" */
export enum Attendee_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "Attendee" */
export type Attendee_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly displayName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "Attendee" */
export enum Attendee_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DisplayName = 'displayName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** expression to compare columns of type Boolean. All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Boolean']>;
  readonly _gt?: Maybe<Scalars['Boolean']>;
  readonly _gte?: Maybe<Scalars['Boolean']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Boolean']>;
  readonly _lte?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Scalars['Boolean']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Boolean']>>;
};

/** columns and relationships of "Broadcast" */
export type Broadcast = {
  readonly __typename?: 'Broadcast';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly to: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Broadcast" */
export type BroadcastDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItem = {
  readonly __typename?: 'BroadcastContentItem';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentItem?: Maybe<ContentItem>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event?: Maybe<Event>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly executedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** An aggregated array relationship */
  readonly executedTransitions_aggregate: ExecutedTransitions_Aggregate;
  /** An array relationship */
  readonly fallbackForTransitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly fallbackForTransitions_aggregate: Transitions_Aggregate;
  readonly id: Scalars['uuid'];
  readonly input: Scalars['jsonb'];
  /** An object relationship */
  readonly inputType: InputType;
  readonly inputTypeName: InputType_Enum;
  /** An array relationship */
  readonly transitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly transitions_aggregate: Transitions_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemFallbackForTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemFallbackForTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemInputArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "BroadcastContentItem" */
export type BroadcastContentItemTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};

/** aggregated selection of "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate = {
  readonly __typename?: 'BroadcastContentItem_aggregate';
  readonly aggregate?: Maybe<BroadcastContentItem_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<BroadcastContentItem>;
};

/** aggregate fields of "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate_Fields = {
  readonly __typename?: 'BroadcastContentItem_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<BroadcastContentItem_Max_Fields>;
  readonly min?: Maybe<BroadcastContentItem_Min_Fields>;
};


/** aggregate fields of "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "BroadcastContentItem" */
export type BroadcastContentItem_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<BroadcastContentItem_Max_Order_By>;
  readonly min?: Maybe<BroadcastContentItem_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type BroadcastContentItem_Append_Input = {
  readonly input?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "BroadcastContentItem" */
export type BroadcastContentItem_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<BroadcastContentItem_Insert_Input>;
  readonly on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};

/** Boolean expression to filter rows from the table "BroadcastContentItem". All fields are combined with a logical 'AND'. */
export type BroadcastContentItem_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<BroadcastContentItem_Bool_Exp>>>;
  readonly _not?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<BroadcastContentItem_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly fallbackForTransitions?: Maybe<Transitions_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly input?: Maybe<Jsonb_Comparison_Exp>;
  readonly inputType?: Maybe<InputType_Bool_Exp>;
  readonly inputTypeName?: Maybe<InputType_Enum_Comparison_Exp>;
  readonly transitions?: Maybe<Transitions_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "BroadcastContentItem" */
export enum BroadcastContentItem_Constraint {
  /** unique or primary key constraint */
  BroadcastContentItemContentItemIdKey = 'BroadcastContentItem_contentItemId_key',
  /** unique or primary key constraint */
  BroadcastContentItemEventIdKey = 'BroadcastContentItem_eventId_key',
  /** unique or primary key constraint */
  BroadcastContentItemPkey = 'BroadcastContentItem_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type BroadcastContentItem_Delete_At_Path_Input = {
  readonly input?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type BroadcastContentItem_Delete_Elem_Input = {
  readonly input?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type BroadcastContentItem_Delete_Key_Input = {
  readonly input?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "BroadcastContentItem" */
export type BroadcastContentItem_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Arr_Rel_Insert_Input>;
  readonly fallbackForTransitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly input?: Maybe<Scalars['jsonb']>;
  readonly inputType?: Maybe<InputType_Obj_Rel_Insert_Input>;
  readonly inputTypeName?: Maybe<InputType_Enum>;
  readonly transitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type BroadcastContentItem_Max_Fields = {
  readonly __typename?: 'BroadcastContentItem_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "BroadcastContentItem" */
export type BroadcastContentItem_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type BroadcastContentItem_Min_Fields = {
  readonly __typename?: 'BroadcastContentItem_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "BroadcastContentItem" */
export type BroadcastContentItem_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "BroadcastContentItem" */
export type BroadcastContentItem_Mutation_Response = {
  readonly __typename?: 'BroadcastContentItem_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<BroadcastContentItem>;
};

/** input type for inserting object relation for remote table "BroadcastContentItem" */
export type BroadcastContentItem_Obj_Rel_Insert_Input = {
  readonly data: BroadcastContentItem_Insert_Input;
  readonly on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};

/** on conflict condition type for table "BroadcastContentItem" */
export type BroadcastContentItem_On_Conflict = {
  readonly constraint: BroadcastContentItem_Constraint;
  readonly update_columns: ReadonlyArray<BroadcastContentItem_Update_Column>;
  readonly where?: Maybe<BroadcastContentItem_Bool_Exp>;
};

/** ordering options when selecting data from "BroadcastContentItem" */
export type BroadcastContentItem_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly executedTransitions_aggregate?: Maybe<ExecutedTransitions_Aggregate_Order_By>;
  readonly fallbackForTransitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly input?: Maybe<Order_By>;
  readonly inputType?: Maybe<InputType_Order_By>;
  readonly inputTypeName?: Maybe<Order_By>;
  readonly transitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "BroadcastContentItem" */
export type BroadcastContentItem_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type BroadcastContentItem_Prepend_Input = {
  readonly input?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "BroadcastContentItem" */
export enum BroadcastContentItem_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  InputTypeName = 'inputTypeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "BroadcastContentItem" */
export type BroadcastContentItem_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly input?: Maybe<Scalars['jsonb']>;
  readonly inputTypeName?: Maybe<InputType_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "BroadcastContentItem" */
export enum BroadcastContentItem_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  Input = 'input',
  /** column name */
  InputTypeName = 'inputTypeName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Broadcast" */
export type Broadcast_Aggregate = {
  readonly __typename?: 'Broadcast_aggregate';
  readonly aggregate?: Maybe<Broadcast_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Broadcast>;
};

/** aggregate fields of "Broadcast" */
export type Broadcast_Aggregate_Fields = {
  readonly __typename?: 'Broadcast_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Broadcast_Max_Fields>;
  readonly min?: Maybe<Broadcast_Min_Fields>;
};


/** aggregate fields of "Broadcast" */
export type Broadcast_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Broadcast" */
export type Broadcast_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Broadcast_Max_Order_By>;
  readonly min?: Maybe<Broadcast_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Broadcast_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "Broadcast" */
export type Broadcast_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Broadcast_Insert_Input>;
  readonly on_conflict?: Maybe<Broadcast_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Broadcast". All fields are combined with a logical 'AND'. */
export type Broadcast_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Broadcast_Bool_Exp>>>;
  readonly _not?: Maybe<Broadcast_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Broadcast_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly to?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Broadcast" */
export enum Broadcast_Constraint {
  /** unique or primary key constraint */
  BroadcastPkey = 'Broadcast_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Broadcast_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Broadcast_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Broadcast_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "Broadcast" */
export type Broadcast_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Broadcast_Max_Fields = {
  readonly __typename?: 'Broadcast_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Broadcast" */
export type Broadcast_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly to?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Broadcast_Min_Fields = {
  readonly __typename?: 'Broadcast_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Broadcast" */
export type Broadcast_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly to?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Broadcast" */
export type Broadcast_Mutation_Response = {
  readonly __typename?: 'Broadcast_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Broadcast>;
};

/** input type for inserting object relation for remote table "Broadcast" */
export type Broadcast_Obj_Rel_Insert_Input = {
  readonly data: Broadcast_Insert_Input;
  readonly on_conflict?: Maybe<Broadcast_On_Conflict>;
};

/** on conflict condition type for table "Broadcast" */
export type Broadcast_On_Conflict = {
  readonly constraint: Broadcast_Constraint;
  readonly update_columns: ReadonlyArray<Broadcast_Update_Column>;
  readonly where?: Maybe<Broadcast_Bool_Exp>;
};

/** ordering options when selecting data from "Broadcast" */
export type Broadcast_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly to?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Broadcast" */
export type Broadcast_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Broadcast_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "Broadcast" */
export enum Broadcast_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Broadcast" */
export type Broadcast_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly to?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Broadcast" */
export enum Broadcast_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  To = 'to',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ChatRemoteToken = {
  readonly __typename?: 'ChatRemoteToken';
  readonly expiry: Scalars['Int'];
  readonly jwt: Scalars['String'];
};

/** columns and relationships of "Conference" */
export type Conference = {
  readonly __typename?: 'Conference';
  /** An array relationship */
  readonly attendees: ReadonlyArray<Attendee>;
  /** An aggregated array relationship */
  readonly attendees_aggregate: Attendee_Aggregate;
  /** An array relationship */
  readonly chats: ReadonlyArray<Chat_Chat>;
  /** An aggregated array relationship */
  readonly chats_aggregate: Chat_Chat_Aggregate;
  /** An array relationship */
  readonly configurations: ReadonlyArray<ConferenceConfiguration>;
  /** An aggregated array relationship */
  readonly configurations_aggregate: ConferenceConfiguration_Aggregate;
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroup_Aggregate;
  /** An array relationship */
  readonly contentPeople: ReadonlyArray<ContentPerson>;
  /** An aggregated array relationship */
  readonly contentPeople_aggregate: ContentPerson_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly createdBy: Scalars['String'];
  /** An object relationship */
  readonly creator: User;
  /** An object relationship */
  readonly demoCode: ConferenceDemoCode;
  readonly demoCodeId: Scalars['uuid'];
  /** An array relationship */
  readonly groups: ReadonlyArray<Group>;
  /** An aggregated array relationship */
  readonly groups_aggregate: Group_Aggregate;
  /** An array relationship */
  readonly hallways: ReadonlyArray<Hallway>;
  /** An aggregated array relationship */
  readonly hallways_aggregate: Hallway_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly originatingDatas: ReadonlyArray<OriginatingData>;
  /** An aggregated array relationship */
  readonly originatingDatas_aggregate: OriginatingData_Aggregate;
  /** An array relationship */
  readonly publicPermissions: ReadonlyArray<FlatUnauthPermission>;
  /** An aggregated array relationship */
  readonly publicPermissions_aggregate: FlatUnauthPermission_Aggregate;
  /** An array relationship */
  readonly roles: ReadonlyArray<Role>;
  /** An aggregated array relationship */
  readonly roles_aggregate: Role_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
  readonly shortName: Scalars['String'];
  /** An array relationship */
  readonly shufflePeriods: ReadonlyArray<Room_ShufflePeriod>;
  /** An aggregated array relationship */
  readonly shufflePeriods_aggregate: Room_ShufflePeriod_Aggregate;
  readonly slug: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Tag>;
  /** An aggregated array relationship */
  readonly tags_aggregate: Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly userPermissions: ReadonlyArray<FlatUserPermission>;
  /** An aggregated array relationship */
  readonly userPermissions_aggregate: FlatUserPermission_Aggregate;
};


/** columns and relationships of "Conference" */
export type ConferenceAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceChatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceChats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceConfigurationsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceConfigurations_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceContentPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceHallwaysArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceHallways_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceOriginatingDatasArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceOriginatingDatas_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferencePublicPermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferencePublicPermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceShufflePeriodsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceShufflePeriods_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceUserPermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** columns and relationships of "Conference" */
export type ConferenceUserPermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};

/** columns and relationships of "ConferenceConfiguration" */
export type ConferenceConfiguration = {
  readonly __typename?: 'ConferenceConfiguration';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly key: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly value: Scalars['jsonb'];
};


/** columns and relationships of "ConferenceConfiguration" */
export type ConferenceConfigurationValueArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate = {
  readonly __typename?: 'ConferenceConfiguration_aggregate';
  readonly aggregate?: Maybe<ConferenceConfiguration_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ConferenceConfiguration>;
};

/** aggregate fields of "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate_Fields = {
  readonly __typename?: 'ConferenceConfiguration_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ConferenceConfiguration_Max_Fields>;
  readonly min?: Maybe<ConferenceConfiguration_Min_Fields>;
};


/** aggregate fields of "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ConferenceConfiguration" */
export type ConferenceConfiguration_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ConferenceConfiguration_Max_Order_By>;
  readonly min?: Maybe<ConferenceConfiguration_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ConferenceConfiguration_Append_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "ConferenceConfiguration" */
export type ConferenceConfiguration_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ConferenceConfiguration_Insert_Input>;
  readonly on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ConferenceConfiguration". All fields are combined with a logical 'AND'. */
export type ConferenceConfiguration_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ConferenceConfiguration_Bool_Exp>>>;
  readonly _not?: Maybe<ConferenceConfiguration_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ConferenceConfiguration_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly key?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly value?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "ConferenceConfiguration" */
export enum ConferenceConfiguration_Constraint {
  /** unique or primary key constraint */
  ConferenceConfigurationConferenceIdKeyKey = 'ConferenceConfiguration_conferenceId_key_key',
  /** unique or primary key constraint */
  ConferenceConfigurationPkey = 'ConferenceConfiguration_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ConferenceConfiguration_Delete_At_Path_Input = {
  readonly value?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ConferenceConfiguration_Delete_Elem_Input = {
  readonly value?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ConferenceConfiguration_Delete_Key_Input = {
  readonly value?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "ConferenceConfiguration" */
export type ConferenceConfiguration_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type ConferenceConfiguration_Max_Fields = {
  readonly __typename?: 'ConferenceConfiguration_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ConferenceConfiguration" */
export type ConferenceConfiguration_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ConferenceConfiguration_Min_Fields = {
  readonly __typename?: 'ConferenceConfiguration_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ConferenceConfiguration" */
export type ConferenceConfiguration_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ConferenceConfiguration" */
export type ConferenceConfiguration_Mutation_Response = {
  readonly __typename?: 'ConferenceConfiguration_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ConferenceConfiguration>;
};

/** input type for inserting object relation for remote table "ConferenceConfiguration" */
export type ConferenceConfiguration_Obj_Rel_Insert_Input = {
  readonly data: ConferenceConfiguration_Insert_Input;
  readonly on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};

/** on conflict condition type for table "ConferenceConfiguration" */
export type ConferenceConfiguration_On_Conflict = {
  readonly constraint: ConferenceConfiguration_Constraint;
  readonly update_columns: ReadonlyArray<ConferenceConfiguration_Update_Column>;
  readonly where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};

/** ordering options when selecting data from "ConferenceConfiguration" */
export type ConferenceConfiguration_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly value?: Maybe<Order_By>;
};

/** primary key columns input for table: "ConferenceConfiguration" */
export type ConferenceConfiguration_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ConferenceConfiguration_Prepend_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "ConferenceConfiguration" */
export enum ConferenceConfiguration_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "ConferenceConfiguration" */
export type ConferenceConfiguration_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly key?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "ConferenceConfiguration" */
export enum ConferenceConfiguration_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  Value = 'value'
}

/** columns and relationships of "ConferenceDemoCode" */
export type ConferenceDemoCode = {
  readonly __typename?: 'ConferenceDemoCode';
  /** An object relationship */
  readonly conference?: Maybe<Conference>;
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly usedBy?: Maybe<User>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate = {
  readonly __typename?: 'ConferenceDemoCode_aggregate';
  readonly aggregate?: Maybe<ConferenceDemoCode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ConferenceDemoCode>;
};

/** aggregate fields of "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate_Fields = {
  readonly __typename?: 'ConferenceDemoCode_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ConferenceDemoCode_Max_Fields>;
  readonly min?: Maybe<ConferenceDemoCode_Min_Fields>;
};


/** aggregate fields of "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ConferenceDemoCode" */
export type ConferenceDemoCode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ConferenceDemoCode_Max_Order_By>;
  readonly min?: Maybe<ConferenceDemoCode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ConferenceDemoCode" */
export type ConferenceDemoCode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ConferenceDemoCode_Insert_Input>;
  readonly on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ConferenceDemoCode". All fields are combined with a logical 'AND'. */
export type ConferenceDemoCode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ConferenceDemoCode_Bool_Exp>>>;
  readonly _not?: Maybe<ConferenceDemoCode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ConferenceDemoCode_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly note?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly usedBy?: Maybe<User_Bool_Exp>;
  readonly usedById?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ConferenceDemoCode" */
export enum ConferenceDemoCode_Constraint {
  /** unique or primary key constraint */
  ConferenceDemoCodesPkey = 'ConferenceDemoCodes_pkey'
}

/** input type for inserting data into table "ConferenceDemoCode" */
export type ConferenceDemoCode_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedBy?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ConferenceDemoCode_Max_Fields = {
  readonly __typename?: 'ConferenceDemoCode_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ConferenceDemoCode" */
export type ConferenceDemoCode_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ConferenceDemoCode_Min_Fields = {
  readonly __typename?: 'ConferenceDemoCode_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ConferenceDemoCode" */
export type ConferenceDemoCode_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** response of any mutation on the table "ConferenceDemoCode" */
export type ConferenceDemoCode_Mutation_Response = {
  readonly __typename?: 'ConferenceDemoCode_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ConferenceDemoCode>;
};

/** input type for inserting object relation for remote table "ConferenceDemoCode" */
export type ConferenceDemoCode_Obj_Rel_Insert_Input = {
  readonly data: ConferenceDemoCode_Insert_Input;
  readonly on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};

/** on conflict condition type for table "ConferenceDemoCode" */
export type ConferenceDemoCode_On_Conflict = {
  readonly constraint: ConferenceDemoCode_Constraint;
  readonly update_columns: ReadonlyArray<ConferenceDemoCode_Update_Column>;
  readonly where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};

/** ordering options when selecting data from "ConferenceDemoCode" */
export type ConferenceDemoCode_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly note?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly usedBy?: Maybe<User_Order_By>;
  readonly usedById?: Maybe<Order_By>;
};

/** primary key columns input for table: "ConferenceDemoCode" */
export type ConferenceDemoCode_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ConferenceDemoCode" */
export enum ConferenceDemoCode_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** input type for updating data in table "ConferenceDemoCode" */
export type ConferenceDemoCode_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly note?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly usedById?: Maybe<Scalars['String']>;
};

/** update columns of table "ConferenceDemoCode" */
export enum ConferenceDemoCode_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Note = 'note',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UsedById = 'usedById'
}

/** columns and relationships of "ConferencePrepareJob" */
export type ConferencePrepareJob = {
  readonly __typename?: 'ConferencePrepareJob';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly videoRenderJobs: ReadonlyArray<VideoRenderJob>;
  /** An aggregated array relationship */
  readonly videoRenderJobs_aggregate: VideoRenderJob_Aggregate;
};


/** columns and relationships of "ConferencePrepareJob" */
export type ConferencePrepareJobVideoRenderJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** columns and relationships of "ConferencePrepareJob" */
export type ConferencePrepareJobVideoRenderJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};

/** aggregated selection of "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate = {
  readonly __typename?: 'ConferencePrepareJob_aggregate';
  readonly aggregate?: Maybe<ConferencePrepareJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ConferencePrepareJob>;
};

/** aggregate fields of "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate_Fields = {
  readonly __typename?: 'ConferencePrepareJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ConferencePrepareJob_Max_Fields>;
  readonly min?: Maybe<ConferencePrepareJob_Min_Fields>;
};


/** aggregate fields of "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ConferencePrepareJob" */
export type ConferencePrepareJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ConferencePrepareJob_Max_Order_By>;
  readonly min?: Maybe<ConferencePrepareJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ConferencePrepareJob" */
export type ConferencePrepareJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ConferencePrepareJob_Insert_Input>;
  readonly on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ConferencePrepareJob". All fields are combined with a logical 'AND'. */
export type ConferencePrepareJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ConferencePrepareJob_Bool_Exp>>>;
  readonly _not?: Maybe<ConferencePrepareJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ConferencePrepareJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoRenderJobs?: Maybe<VideoRenderJob_Bool_Exp>;
};

/** unique or primary key constraints on table "ConferencePrepareJob" */
export enum ConferencePrepareJob_Constraint {
  /** unique or primary key constraint */
  ConferencePrepareJobPkey = 'ConferencePrepareJob_pkey'
}

/** input type for inserting data into table "ConferencePrepareJob" */
export type ConferencePrepareJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoRenderJobs?: Maybe<VideoRenderJob_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type ConferencePrepareJob_Max_Fields = {
  readonly __typename?: 'ConferencePrepareJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ConferencePrepareJob" */
export type ConferencePrepareJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ConferencePrepareJob_Min_Fields = {
  readonly __typename?: 'ConferencePrepareJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ConferencePrepareJob" */
export type ConferencePrepareJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ConferencePrepareJob" */
export type ConferencePrepareJob_Mutation_Response = {
  readonly __typename?: 'ConferencePrepareJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ConferencePrepareJob>;
};

/** input type for inserting object relation for remote table "ConferencePrepareJob" */
export type ConferencePrepareJob_Obj_Rel_Insert_Input = {
  readonly data: ConferencePrepareJob_Insert_Input;
  readonly on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};

/** on conflict condition type for table "ConferencePrepareJob" */
export type ConferencePrepareJob_On_Conflict = {
  readonly constraint: ConferencePrepareJob_Constraint;
  readonly update_columns: ReadonlyArray<ConferencePrepareJob_Update_Column>;
  readonly where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};

/** ordering options when selecting data from "ConferencePrepareJob" */
export type ConferencePrepareJob_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoRenderJobs_aggregate?: Maybe<VideoRenderJob_Aggregate_Order_By>;
};

/** primary key columns input for table: "ConferencePrepareJob" */
export type ConferencePrepareJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ConferencePrepareJob" */
export enum ConferencePrepareJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ConferencePrepareJob" */
export type ConferencePrepareJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ConferencePrepareJob" */
export enum ConferencePrepareJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ConferencePrepareOutput = {
  readonly __typename?: 'ConferencePrepareOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

/** aggregated selection of "Conference" */
export type Conference_Aggregate = {
  readonly __typename?: 'Conference_aggregate';
  readonly aggregate?: Maybe<Conference_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Conference>;
};

/** aggregate fields of "Conference" */
export type Conference_Aggregate_Fields = {
  readonly __typename?: 'Conference_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Conference_Max_Fields>;
  readonly min?: Maybe<Conference_Min_Fields>;
};


/** aggregate fields of "Conference" */
export type Conference_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Conference" */
export type Conference_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Conference_Max_Order_By>;
  readonly min?: Maybe<Conference_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Conference" */
export type Conference_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Conference_Insert_Input>;
  readonly on_conflict?: Maybe<Conference_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Conference". All fields are combined with a logical 'AND'. */
export type Conference_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Conference_Bool_Exp>>>;
  readonly _not?: Maybe<Conference_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Conference_Bool_Exp>>>;
  readonly attendees?: Maybe<Attendee_Bool_Exp>;
  readonly chats?: Maybe<Chat_Chat_Bool_Exp>;
  readonly configurations?: Maybe<ConferenceConfiguration_Bool_Exp>;
  readonly contentGroups?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentPeople?: Maybe<ContentPerson_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly createdBy?: Maybe<String_Comparison_Exp>;
  readonly creator?: Maybe<User_Bool_Exp>;
  readonly demoCode?: Maybe<ConferenceDemoCode_Bool_Exp>;
  readonly demoCodeId?: Maybe<Uuid_Comparison_Exp>;
  readonly groups?: Maybe<Group_Bool_Exp>;
  readonly hallways?: Maybe<Hallway_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingDatas?: Maybe<OriginatingData_Bool_Exp>;
  readonly publicPermissions?: Maybe<FlatUnauthPermission_Bool_Exp>;
  readonly roles?: Maybe<Role_Bool_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
  readonly shortName?: Maybe<String_Comparison_Exp>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly userPermissions?: Maybe<FlatUserPermission_Bool_Exp>;
};

/** unique or primary key constraints on table "Conference" */
export enum Conference_Constraint {
  /** unique or primary key constraint */
  ConferenceDemoCodeIdKey = 'Conference_demoCodeId_key',
  /** unique or primary key constraint */
  ConferenceNameKey = 'Conference_name_key',
  /** unique or primary key constraint */
  ConferencePkey = 'Conference_pkey',
  /** unique or primary key constraint */
  ConferenceShortNameKey = 'Conference_shortName_key',
  /** unique or primary key constraint */
  ConferenceSlugKey = 'Conference_slug_key'
}

/** input type for inserting data into table "Conference" */
export type Conference_Insert_Input = {
  readonly attendees?: Maybe<Attendee_Arr_Rel_Insert_Input>;
  readonly chats?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly configurations?: Maybe<ConferenceConfiguration_Arr_Rel_Insert_Input>;
  readonly contentGroups?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly contentPeople?: Maybe<ContentPerson_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly creator?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly demoCode?: Maybe<ConferenceDemoCode_Obj_Rel_Insert_Input>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly groups?: Maybe<Group_Arr_Rel_Insert_Input>;
  readonly hallways?: Maybe<Hallway_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDatas?: Maybe<OriginatingData_Arr_Rel_Insert_Input>;
  readonly roles?: Maybe<Role_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly shufflePeriods?: Maybe<Room_ShufflePeriod_Arr_Rel_Insert_Input>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Conference_Max_Fields = {
  readonly __typename?: 'Conference_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Conference" */
export type Conference_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Conference_Min_Fields = {
  readonly __typename?: 'Conference_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Conference" */
export type Conference_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Conference" */
export type Conference_Mutation_Response = {
  readonly __typename?: 'Conference_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Conference>;
};

/** input type for inserting object relation for remote table "Conference" */
export type Conference_Obj_Rel_Insert_Input = {
  readonly data: Conference_Insert_Input;
  readonly on_conflict?: Maybe<Conference_On_Conflict>;
};

/** on conflict condition type for table "Conference" */
export type Conference_On_Conflict = {
  readonly constraint: Conference_Constraint;
  readonly update_columns: ReadonlyArray<Conference_Update_Column>;
  readonly where?: Maybe<Conference_Bool_Exp>;
};

/** ordering options when selecting data from "Conference" */
export type Conference_Order_By = {
  readonly attendees_aggregate?: Maybe<Attendee_Aggregate_Order_By>;
  readonly chats_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly configurations_aggregate?: Maybe<ConferenceConfiguration_Aggregate_Order_By>;
  readonly contentGroups_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly contentPeople_aggregate?: Maybe<ContentPerson_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly createdBy?: Maybe<Order_By>;
  readonly creator?: Maybe<User_Order_By>;
  readonly demoCode?: Maybe<ConferenceDemoCode_Order_By>;
  readonly demoCodeId?: Maybe<Order_By>;
  readonly groups_aggregate?: Maybe<Group_Aggregate_Order_By>;
  readonly hallways_aggregate?: Maybe<Hallway_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDatas_aggregate?: Maybe<OriginatingData_Aggregate_Order_By>;
  readonly publicPermissions_aggregate?: Maybe<FlatUnauthPermission_Aggregate_Order_By>;
  readonly roles_aggregate?: Maybe<Role_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly shortName?: Maybe<Order_By>;
  readonly shufflePeriods_aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userPermissions_aggregate?: Maybe<FlatUserPermission_Aggregate_Order_By>;
};

/** primary key columns input for table: "Conference" */
export type Conference_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Conference" */
export enum Conference_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Conference" */
export type Conference_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly createdBy?: Maybe<Scalars['String']>;
  readonly demoCodeId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly shortName?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Conference" */
export enum Conference_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DemoCodeId = 'demoCodeId',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShortName = 'shortName',
  /** column name */
  Slug = 'slug',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type ConfirmInvitationInput = {
  readonly confirmationCode: Scalars['String'];
  readonly inviteCode: Scalars['uuid'];
};

export type ConfirmInvitationOutput = {
  readonly __typename?: 'ConfirmInvitationOutput';
  readonly confSlug?: Maybe<Scalars['String']>;
  readonly ok: Scalars['String'];
};

/** columns and relationships of "ContentGroup" */
export type ContentGroup = {
  readonly __typename?: 'ContentGroup';
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroupTags: ReadonlyArray<ContentGroupTag>;
  /** An aggregated array relationship */
  readonly contentGroupTags_aggregate: ContentGroupTag_Aggregate;
  /** An object relationship */
  readonly contentGroupType: ContentGroupType;
  readonly contentGroupTypeName: ContentGroupType_Enum;
  /** An array relationship */
  readonly contentItems: ReadonlyArray<ContentItem>;
  /** An aggregated array relationship */
  readonly contentItems_aggregate: ContentItem_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  /** An array relationship */
  readonly hallways: ReadonlyArray<ContentGroupHallway>;
  /** An aggregated array relationship */
  readonly hallways_aggregate: ContentGroupHallway_Aggregate;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly people: ReadonlyArray<ContentGroupPerson>;
  /** An aggregated array relationship */
  readonly people_aggregate: ContentGroupPerson_Aggregate;
  /** An array relationship */
  readonly requiredContentItems: ReadonlyArray<RequiredContentItem>;
  /** An aggregated array relationship */
  readonly requiredContentItems_aggregate: RequiredContentItem_Aggregate;
  /** An object relationship */
  readonly room?: Maybe<Room>;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
  readonly shortTitle?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly stats?: Maybe<Analytics_ContentGroupStats>;
  readonly title: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentGroupTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentGroupTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupHallwaysArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupHallways_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRequiredContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRequiredContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "ContentGroup" */
export type ContentGroupRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};

/** columns and relationships of "ContentGroupHallway" */
export type ContentGroupHallway = {
  readonly __typename?: 'ContentGroupHallway';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly groupId: Scalars['uuid'];
  /** An object relationship */
  readonly hallway: Hallway;
  readonly hallwayId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "ContentGroupHallway" */
export type ContentGroupHallwayLayoutArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate = {
  readonly __typename?: 'ContentGroupHallway_aggregate';
  readonly aggregate?: Maybe<ContentGroupHallway_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupHallway>;
};

/** aggregate fields of "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupHallway_aggregate_fields';
  readonly avg?: Maybe<ContentGroupHallway_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupHallway_Max_Fields>;
  readonly min?: Maybe<ContentGroupHallway_Min_Fields>;
  readonly stddev?: Maybe<ContentGroupHallway_Stddev_Fields>;
  readonly stddev_pop?: Maybe<ContentGroupHallway_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<ContentGroupHallway_Stddev_Samp_Fields>;
  readonly sum?: Maybe<ContentGroupHallway_Sum_Fields>;
  readonly var_pop?: Maybe<ContentGroupHallway_Var_Pop_Fields>;
  readonly var_samp?: Maybe<ContentGroupHallway_Var_Samp_Fields>;
  readonly variance?: Maybe<ContentGroupHallway_Variance_Fields>;
};


/** aggregate fields of "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupHallway" */
export type ContentGroupHallway_Aggregate_Order_By = {
  readonly avg?: Maybe<ContentGroupHallway_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupHallway_Max_Order_By>;
  readonly min?: Maybe<ContentGroupHallway_Min_Order_By>;
  readonly stddev?: Maybe<ContentGroupHallway_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<ContentGroupHallway_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<ContentGroupHallway_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<ContentGroupHallway_Sum_Order_By>;
  readonly var_pop?: Maybe<ContentGroupHallway_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<ContentGroupHallway_Var_Samp_Order_By>;
  readonly variance?: Maybe<ContentGroupHallway_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ContentGroupHallway_Append_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "ContentGroupHallway" */
export type ContentGroupHallway_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupHallway_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};

/** aggregate avg on columns */
export type ContentGroupHallway_Avg_Fields = {
  readonly __typename?: 'ContentGroupHallway_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ContentGroupHallway". All fields are combined with a logical 'AND'. */
export type ContentGroupHallway_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupHallway_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupHallway_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupHallway_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly hallway?: Maybe<Hallway_Bool_Exp>;
  readonly hallwayId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly layout?: Maybe<Jsonb_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupHallway" */
export enum ContentGroupHallway_Constraint {
  /** unique or primary key constraint */
  ContentGroupHallwayPkey = 'ContentGroupHallway_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ContentGroupHallway_Delete_At_Path_Input = {
  readonly layout?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ContentGroupHallway_Delete_Elem_Input = {
  readonly layout?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ContentGroupHallway_Delete_Key_Input = {
  readonly layout?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "ContentGroupHallway" */
export type ContentGroupHallway_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "ContentGroupHallway" */
export type ContentGroupHallway_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallway?: Maybe<Hallway_Obj_Rel_Insert_Input>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type ContentGroupHallway_Max_Fields = {
  readonly __typename?: 'ContentGroupHallway_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupHallway_Min_Fields = {
  readonly __typename?: 'ContentGroupHallway_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupHallway" */
export type ContentGroupHallway_Mutation_Response = {
  readonly __typename?: 'ContentGroupHallway_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupHallway>;
};

/** input type for inserting object relation for remote table "ContentGroupHallway" */
export type ContentGroupHallway_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupHallway_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupHallway" */
export type ContentGroupHallway_On_Conflict = {
  readonly constraint: ContentGroupHallway_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupHallway_Update_Column>;
  readonly where?: Maybe<ContentGroupHallway_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupHallway" */
export type ContentGroupHallway_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly hallway?: Maybe<Hallway_Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly layout?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupHallway" */
export type ContentGroupHallway_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ContentGroupHallway_Prepend_Input = {
  readonly layout?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "ContentGroupHallway" */
export enum ContentGroupHallway_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  HallwayId = 'hallwayId',
  /** column name */
  Id = 'id',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** input type for updating data in table "ContentGroupHallway" */
export type ContentGroupHallway_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layout?: Maybe<Scalars['jsonb']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type ContentGroupHallway_Stddev_Fields = {
  readonly __typename?: 'ContentGroupHallway_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ContentGroupHallway_Stddev_Pop_Fields = {
  readonly __typename?: 'ContentGroupHallway_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ContentGroupHallway_Stddev_Samp_Fields = {
  readonly __typename?: 'ContentGroupHallway_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type ContentGroupHallway_Sum_Fields = {
  readonly __typename?: 'ContentGroupHallway_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "ContentGroupHallway" */
export enum ContentGroupHallway_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  HallwayId = 'hallwayId',
  /** column name */
  Id = 'id',
  /** column name */
  Layout = 'layout',
  /** column name */
  Priority = 'priority'
}

/** aggregate var_pop on columns */
export type ContentGroupHallway_Var_Pop_Fields = {
  readonly __typename?: 'ContentGroupHallway_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ContentGroupHallway_Var_Samp_Fields = {
  readonly __typename?: 'ContentGroupHallway_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type ContentGroupHallway_Variance_Fields = {
  readonly __typename?: 'ContentGroupHallway_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ContentGroupHallway" */
export type ContentGroupHallway_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "ContentGroupPerson" */
export type ContentGroupPerson = {
  readonly __typename?: 'ContentGroupPerson';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly group: ContentGroup;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly person: ContentPerson;
  readonly personId: Scalars['uuid'];
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName: Scalars['String'];
};

/** aggregated selection of "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate = {
  readonly __typename?: 'ContentGroupPerson_aggregate';
  readonly aggregate?: Maybe<ContentGroupPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupPerson>;
};

/** aggregate fields of "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupPerson_aggregate_fields';
  readonly avg?: Maybe<ContentGroupPerson_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupPerson_Max_Fields>;
  readonly min?: Maybe<ContentGroupPerson_Min_Fields>;
  readonly stddev?: Maybe<ContentGroupPerson_Stddev_Fields>;
  readonly stddev_pop?: Maybe<ContentGroupPerson_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<ContentGroupPerson_Stddev_Samp_Fields>;
  readonly sum?: Maybe<ContentGroupPerson_Sum_Fields>;
  readonly var_pop?: Maybe<ContentGroupPerson_Var_Pop_Fields>;
  readonly var_samp?: Maybe<ContentGroupPerson_Var_Samp_Fields>;
  readonly variance?: Maybe<ContentGroupPerson_Variance_Fields>;
};


/** aggregate fields of "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupPerson" */
export type ContentGroupPerson_Aggregate_Order_By = {
  readonly avg?: Maybe<ContentGroupPerson_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupPerson_Max_Order_By>;
  readonly min?: Maybe<ContentGroupPerson_Min_Order_By>;
  readonly stddev?: Maybe<ContentGroupPerson_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<ContentGroupPerson_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<ContentGroupPerson_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<ContentGroupPerson_Sum_Order_By>;
  readonly var_pop?: Maybe<ContentGroupPerson_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<ContentGroupPerson_Var_Samp_Order_By>;
  readonly variance?: Maybe<ContentGroupPerson_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroupPerson" */
export type ContentGroupPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupPerson_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};

/** aggregate avg on columns */
export type ContentGroupPerson_Avg_Fields = {
  readonly __typename?: 'ContentGroupPerson_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ContentGroupPerson". All fields are combined with a logical 'AND'. */
export type ContentGroupPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupPerson_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupPerson_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly group?: Maybe<ContentGroup_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<ContentPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly roleName?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupPerson" */
export enum ContentGroupPerson_Constraint {
  /** unique or primary key constraint */
  ContentItemPersonPkey = 'ContentItemPerson_pkey',
  /** unique or primary key constraint */
  ContentItemPersonRoleNamePersonIdGroupIdKey = 'ContentItemPerson_roleName_personId_groupId_key'
}

/** input type for incrementing integer column in table "ContentGroupPerson" */
export type ContentGroupPerson_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "ContentGroupPerson" */
export type ContentGroupPerson_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly group?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<ContentPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ContentGroupPerson_Max_Fields = {
  readonly __typename?: 'ContentGroupPerson_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupPerson_Min_Fields = {
  readonly __typename?: 'ContentGroupPerson_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupPerson" */
export type ContentGroupPerson_Mutation_Response = {
  readonly __typename?: 'ContentGroupPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupPerson>;
};

/** input type for inserting object relation for remote table "ContentGroupPerson" */
export type ContentGroupPerson_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupPerson_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupPerson" */
export type ContentGroupPerson_On_Conflict = {
  readonly constraint: ContentGroupPerson_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupPerson_Update_Column>;
  readonly where?: Maybe<ContentGroupPerson_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupPerson" */
export type ContentGroupPerson_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly group?: Maybe<ContentGroup_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly person?: Maybe<ContentPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupPerson" */
export type ContentGroupPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentGroupPerson" */
export enum ContentGroupPerson_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** input type for updating data in table "ContentGroupPerson" */
export type ContentGroupPerson_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly roleName?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type ContentGroupPerson_Stddev_Fields = {
  readonly __typename?: 'ContentGroupPerson_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ContentGroupPerson_Stddev_Pop_Fields = {
  readonly __typename?: 'ContentGroupPerson_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ContentGroupPerson_Stddev_Samp_Fields = {
  readonly __typename?: 'ContentGroupPerson_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type ContentGroupPerson_Sum_Fields = {
  readonly __typename?: 'ContentGroupPerson_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "ContentGroupPerson" */
export enum ContentGroupPerson_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  Priority = 'priority',
  /** column name */
  RoleName = 'roleName'
}

/** aggregate var_pop on columns */
export type ContentGroupPerson_Var_Pop_Fields = {
  readonly __typename?: 'ContentGroupPerson_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ContentGroupPerson_Var_Samp_Fields = {
  readonly __typename?: 'ContentGroupPerson_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type ContentGroupPerson_Variance_Fields = {
  readonly __typename?: 'ContentGroupPerson_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ContentGroupPerson" */
export type ContentGroupPerson_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "ContentGroupTag" */
export type ContentGroupTag = {
  readonly __typename?: 'ContentGroupTag';
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly contentGroupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "ContentGroupTag" */
export type ContentGroupTag_Aggregate = {
  readonly __typename?: 'ContentGroupTag_aggregate';
  readonly aggregate?: Maybe<ContentGroupTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupTag>;
};

/** aggregate fields of "ContentGroupTag" */
export type ContentGroupTag_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupTag_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupTag_Max_Fields>;
  readonly min?: Maybe<ContentGroupTag_Min_Fields>;
};


/** aggregate fields of "ContentGroupTag" */
export type ContentGroupTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupTag" */
export type ContentGroupTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupTag_Max_Order_By>;
  readonly min?: Maybe<ContentGroupTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroupTag" */
export type ContentGroupTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupTag_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentGroupTag". All fields are combined with a logical 'AND'. */
export type ContentGroupTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupTag_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupTag_Bool_Exp>>>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupTag" */
export enum ContentGroupTag_Constraint {
  /** unique or primary key constraint */
  ContentGroupTagContentGroupIdTagIdKey = 'ContentGroupTag_contentGroupId_tagId_key',
  /** unique or primary key constraint */
  ContentGroupTagPkey = 'ContentGroupTag_pkey'
}

/** input type for inserting data into table "ContentGroupTag" */
export type ContentGroupTag_Insert_Input = {
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type ContentGroupTag_Max_Fields = {
  readonly __typename?: 'ContentGroupTag_max_fields';
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "ContentGroupTag" */
export type ContentGroupTag_Max_Order_By = {
  readonly contentGroupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupTag_Min_Fields = {
  readonly __typename?: 'ContentGroupTag_min_fields';
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "ContentGroupTag" */
export type ContentGroupTag_Min_Order_By = {
  readonly contentGroupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupTag" */
export type ContentGroupTag_Mutation_Response = {
  readonly __typename?: 'ContentGroupTag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupTag>;
};

/** input type for inserting object relation for remote table "ContentGroupTag" */
export type ContentGroupTag_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupTag_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupTag" */
export type ContentGroupTag_On_Conflict = {
  readonly constraint: ContentGroupTag_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupTag_Update_Column>;
  readonly where?: Maybe<ContentGroupTag_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupTag" */
export type ContentGroupTag_Order_By = {
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tag?: Maybe<Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupTag" */
export type ContentGroupTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentGroupTag" */
export enum ContentGroupTag_Select_Column {
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "ContentGroupTag" */
export type ContentGroupTag_Set_Input = {
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "ContentGroupTag" */
export enum ContentGroupTag_Update_Column {
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** columns and relationships of "ContentGroupType" */
export type ContentGroupType = {
  readonly __typename?: 'ContentGroupType';
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroup_Aggregate;
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};


/** columns and relationships of "ContentGroupType" */
export type ContentGroupTypeContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "ContentGroupType" */
export type ContentGroupTypeContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};

/** aggregated selection of "ContentGroupType" */
export type ContentGroupType_Aggregate = {
  readonly __typename?: 'ContentGroupType_aggregate';
  readonly aggregate?: Maybe<ContentGroupType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroupType>;
};

/** aggregate fields of "ContentGroupType" */
export type ContentGroupType_Aggregate_Fields = {
  readonly __typename?: 'ContentGroupType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroupType_Max_Fields>;
  readonly min?: Maybe<ContentGroupType_Min_Fields>;
};


/** aggregate fields of "ContentGroupType" */
export type ContentGroupType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroupType" */
export type ContentGroupType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroupType_Max_Order_By>;
  readonly min?: Maybe<ContentGroupType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroupType" */
export type ContentGroupType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroupType_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentGroupType". All fields are combined with a logical 'AND'. */
export type ContentGroupType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroupType_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroupType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroupType_Bool_Exp>>>;
  readonly contentGroups?: Maybe<ContentGroup_Bool_Exp>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroupType" */
export enum ContentGroupType_Constraint {
  /** unique or primary key constraint */
  ContentGroupTypePkey = 'ContentGroupType_pkey'
}

export enum ContentGroupType_Enum {
  /** A demonstration. */
  Demonstration = 'DEMONSTRATION',
  /** A keynote. */
  Keynote = 'KEYNOTE',
  /** Conference main landing page. */
  LandingPage = 'LANDING_PAGE',
  /** A generic group type - use sparingly. */
  Other = 'OTHER',
  /** A paper. */
  Paper = 'PAPER',
  /** A poster. */
  Poster = 'POSTER',
  /** A presentation. */
  Presentation = 'PRESENTATION',
  /** A Q&A covering the whole session. */
  SessionQAndA = 'SESSION_Q_AND_A',
  /** A scheduled social. */
  Social = 'SOCIAL',
  /** A sponsor. */
  Sponsor = 'SPONSOR',
  /** A symposium. */
  Symposium = 'SYMPOSIUM',
  /** A tutorial. */
  Tutorial = 'TUTORIAL',
  /** A workshop. */
  Workshop = 'WORKSHOP'
}

/** expression to compare columns of type ContentGroupType_enum. All fields are combined with logical 'AND'. */
export type ContentGroupType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<ContentGroupType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<ContentGroupType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<ContentGroupType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<ContentGroupType_Enum>>;
};

/** input type for inserting data into table "ContentGroupType" */
export type ContentGroupType_Insert_Input = {
  readonly contentGroups?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type ContentGroupType_Max_Fields = {
  readonly __typename?: 'ContentGroupType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ContentGroupType" */
export type ContentGroupType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroupType_Min_Fields = {
  readonly __typename?: 'ContentGroupType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ContentGroupType" */
export type ContentGroupType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroupType" */
export type ContentGroupType_Mutation_Response = {
  readonly __typename?: 'ContentGroupType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroupType>;
};

/** input type for inserting object relation for remote table "ContentGroupType" */
export type ContentGroupType_Obj_Rel_Insert_Input = {
  readonly data: ContentGroupType_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};

/** on conflict condition type for table "ContentGroupType" */
export type ContentGroupType_On_Conflict = {
  readonly constraint: ContentGroupType_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroupType_Update_Column>;
  readonly where?: Maybe<ContentGroupType_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroupType" */
export type ContentGroupType_Order_By = {
  readonly contentGroups_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroupType" */
export type ContentGroupType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "ContentGroupType" */
export enum ContentGroupType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "ContentGroupType" */
export type ContentGroupType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "ContentGroupType" */
export enum ContentGroupType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "ContentGroup" */
export type ContentGroup_Aggregate = {
  readonly __typename?: 'ContentGroup_aggregate';
  readonly aggregate?: Maybe<ContentGroup_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentGroup>;
};

/** aggregate fields of "ContentGroup" */
export type ContentGroup_Aggregate_Fields = {
  readonly __typename?: 'ContentGroup_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentGroup_Max_Fields>;
  readonly min?: Maybe<ContentGroup_Min_Fields>;
};


/** aggregate fields of "ContentGroup" */
export type ContentGroup_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentGroup" */
export type ContentGroup_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentGroup_Max_Order_By>;
  readonly min?: Maybe<ContentGroup_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentGroup" */
export type ContentGroup_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentGroup_Insert_Input>;
  readonly on_conflict?: Maybe<ContentGroup_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentGroup". All fields are combined with a logical 'AND'. */
export type ContentGroup_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentGroup_Bool_Exp>>>;
  readonly _not?: Maybe<ContentGroup_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentGroup_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Bool_Exp>;
  readonly contentGroupType?: Maybe<ContentGroupType_Bool_Exp>;
  readonly contentGroupTypeName?: Maybe<ContentGroupType_Enum_Comparison_Exp>;
  readonly contentItems?: Maybe<ContentItem_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly hallways?: Maybe<ContentGroupHallway_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly people?: Maybe<ContentGroupPerson_Bool_Exp>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
  readonly shortTitle?: Maybe<String_Comparison_Exp>;
  readonly stats?: Maybe<Analytics_ContentGroupStats_Bool_Exp>;
  readonly title?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentGroup" */
export enum ContentGroup_Constraint {
  /** unique or primary key constraint */
  ContentGroupPkey = 'ContentGroup_pkey'
}

/** input type for inserting data into table "ContentGroup" */
export type ContentGroup_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Arr_Rel_Insert_Input>;
  readonly contentGroupType?: Maybe<ContentGroupType_Obj_Rel_Insert_Input>;
  readonly contentGroupTypeName?: Maybe<ContentGroupType_Enum>;
  readonly contentItems?: Maybe<ContentItem_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly hallways?: Maybe<ContentGroupHallway_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly people?: Maybe<ContentGroupPerson_Arr_Rel_Insert_Input>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Arr_Rel_Insert_Input>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly stats?: Maybe<Analytics_ContentGroupStats_Obj_Rel_Insert_Input>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type ContentGroup_Max_Fields = {
  readonly __typename?: 'ContentGroup_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ContentGroup" */
export type ContentGroup_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentGroup_Min_Fields = {
  readonly __typename?: 'ContentGroup_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ContentGroup" */
export type ContentGroup_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentGroup" */
export type ContentGroup_Mutation_Response = {
  readonly __typename?: 'ContentGroup_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentGroup>;
};

/** input type for inserting object relation for remote table "ContentGroup" */
export type ContentGroup_Obj_Rel_Insert_Input = {
  readonly data: ContentGroup_Insert_Input;
  readonly on_conflict?: Maybe<ContentGroup_On_Conflict>;
};

/** on conflict condition type for table "ContentGroup" */
export type ContentGroup_On_Conflict = {
  readonly constraint: ContentGroup_Constraint;
  readonly update_columns: ReadonlyArray<ContentGroup_Update_Column>;
  readonly where?: Maybe<ContentGroup_Bool_Exp>;
};

/** ordering options when selecting data from "ContentGroup" */
export type ContentGroup_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupTags_aggregate?: Maybe<ContentGroupTag_Aggregate_Order_By>;
  readonly contentGroupType?: Maybe<ContentGroupType_Order_By>;
  readonly contentGroupTypeName?: Maybe<Order_By>;
  readonly contentItems_aggregate?: Maybe<ContentItem_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly hallways_aggregate?: Maybe<ContentGroupHallway_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly people_aggregate?: Maybe<ContentGroupPerson_Aggregate_Order_By>;
  readonly requiredContentItems_aggregate?: Maybe<RequiredContentItem_Aggregate_Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly shortTitle?: Maybe<Order_By>;
  readonly stats?: Maybe<Analytics_ContentGroupStats_Order_By>;
  readonly title?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentGroup" */
export type ContentGroup_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentGroup" */
export enum ContentGroup_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupTypeName = 'contentGroupTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ContentGroup" */
export type ContentGroup_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupTypeName?: Maybe<ContentGroupType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly shortTitle?: Maybe<Scalars['String']>;
  readonly title?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ContentGroup" */
export enum ContentGroup_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupTypeName = 'contentGroupTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  ShortTitle = 'shortTitle',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "ContentItem" */
export type ContentItem = {
  readonly __typename?: 'ContentItem';
  /** An object relationship */
  readonly broadcastContentItem?: Maybe<BroadcastContentItem>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly contentGroupId: Scalars['uuid'];
  /** An object relationship */
  readonly contentType: ContentType;
  readonly contentTypeName: ContentType_Enum;
  readonly createdAt: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly requiredContentItem?: Maybe<RequiredContentItem>;
  /** An object relationship */
  readonly stats?: Maybe<Analytics_ContentItemStats>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly youTubeUploads: ReadonlyArray<YouTubeUpload>;
  /** An aggregated array relationship */
  readonly youTubeUploads_aggregate: YouTubeUpload_Aggregate;
};


/** columns and relationships of "ContentItem" */
export type ContentItemDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "ContentItem" */
export type ContentItemLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "ContentItem" */
export type ContentItemYouTubeUploadsArgs = {
  distinct_on?: Maybe<ReadonlyArray<YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<YouTubeUpload_Order_By>>;
  where?: Maybe<YouTubeUpload_Bool_Exp>;
};


/** columns and relationships of "ContentItem" */
export type ContentItemYouTubeUploads_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<YouTubeUpload_Order_By>>;
  where?: Maybe<YouTubeUpload_Bool_Exp>;
};

/** aggregated selection of "ContentItem" */
export type ContentItem_Aggregate = {
  readonly __typename?: 'ContentItem_aggregate';
  readonly aggregate?: Maybe<ContentItem_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentItem>;
};

/** aggregate fields of "ContentItem" */
export type ContentItem_Aggregate_Fields = {
  readonly __typename?: 'ContentItem_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentItem_Max_Fields>;
  readonly min?: Maybe<ContentItem_Min_Fields>;
};


/** aggregate fields of "ContentItem" */
export type ContentItem_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentItem" */
export type ContentItem_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentItem_Max_Order_By>;
  readonly min?: Maybe<ContentItem_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type ContentItem_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "ContentItem" */
export type ContentItem_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentItem_Insert_Input>;
  readonly on_conflict?: Maybe<ContentItem_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentItem". All fields are combined with a logical 'AND'. */
export type ContentItem_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentItem_Bool_Exp>>>;
  readonly _not?: Maybe<ContentItem_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentItem_Bool_Exp>>>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentType?: Maybe<ContentType_Bool_Exp>;
  readonly contentTypeName?: Maybe<ContentType_Enum_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly requiredContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly stats?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly youTubeUploads?: Maybe<YouTubeUpload_Bool_Exp>;
};

/** unique or primary key constraints on table "ContentItem" */
export enum ContentItem_Constraint {
  /** unique or primary key constraint */
  ContentItemPkey = 'ContentItem_pkey',
  /** unique or primary key constraint */
  ContentItemRequiredContentIdKey = 'ContentItem_requiredContentId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type ContentItem_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
  readonly layoutData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type ContentItem_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type ContentItem_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "ContentItem" */
export type ContentItem_Insert_Input = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentType?: Maybe<ContentType_Obj_Rel_Insert_Input>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Obj_Rel_Insert_Input>;
  readonly stats?: Maybe<Analytics_ContentItemStats_Obj_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly youTubeUploads?: Maybe<YouTubeUpload_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type ContentItem_Max_Fields = {
  readonly __typename?: 'ContentItem_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ContentItem" */
export type ContentItem_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly requiredContentId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentItem_Min_Fields = {
  readonly __typename?: 'ContentItem_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ContentItem" */
export type ContentItem_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly requiredContentId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentItem" */
export type ContentItem_Mutation_Response = {
  readonly __typename?: 'ContentItem_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentItem>;
};

/** input type for inserting object relation for remote table "ContentItem" */
export type ContentItem_Obj_Rel_Insert_Input = {
  readonly data: ContentItem_Insert_Input;
  readonly on_conflict?: Maybe<ContentItem_On_Conflict>;
};

/** on conflict condition type for table "ContentItem" */
export type ContentItem_On_Conflict = {
  readonly constraint: ContentItem_Constraint;
  readonly update_columns: ReadonlyArray<ContentItem_Update_Column>;
  readonly where?: Maybe<ContentItem_Bool_Exp>;
};

/** ordering options when selecting data from "ContentItem" */
export type ContentItem_Order_By = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly contentType?: Maybe<ContentType_Order_By>;
  readonly contentTypeName?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly requiredContentId?: Maybe<Order_By>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Order_By>;
  readonly stats?: Maybe<Analytics_ContentItemStats_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly youTubeUploads_aggregate?: Maybe<YouTubeUpload_Aggregate_Order_By>;
};

/** primary key columns input for table: "ContentItem" */
export type ContentItem_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type ContentItem_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "ContentItem" */
export enum ContentItem_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RequiredContentId = 'requiredContentId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ContentItem" */
export type ContentItem_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly requiredContentId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ContentItem" */
export enum ContentItem_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RequiredContentId = 'requiredContentId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "ContentPerson" */
export type ContentPerson = {
  readonly __typename?: 'ContentPerson';
  readonly affiliation?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly attendee?: Maybe<Attendee>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentItemPeople: ReadonlyArray<ContentGroupPerson>;
  /** An aggregated array relationship */
  readonly contentItemPeople_aggregate: ContentGroupPerson_Aggregate;
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<EventPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: EventPerson_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};


/** columns and relationships of "ContentPerson" */
export type ContentPersonContentItemPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** columns and relationships of "ContentPerson" */
export type ContentPersonContentItemPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** columns and relationships of "ContentPerson" */
export type ContentPersonEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "ContentPerson" */
export type ContentPersonEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};

/** aggregated selection of "ContentPerson" */
export type ContentPerson_Aggregate = {
  readonly __typename?: 'ContentPerson_aggregate';
  readonly aggregate?: Maybe<ContentPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentPerson>;
};

/** aggregate fields of "ContentPerson" */
export type ContentPerson_Aggregate_Fields = {
  readonly __typename?: 'ContentPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentPerson_Max_Fields>;
  readonly min?: Maybe<ContentPerson_Min_Fields>;
};


/** aggregate fields of "ContentPerson" */
export type ContentPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentPerson" */
export type ContentPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentPerson_Max_Order_By>;
  readonly min?: Maybe<ContentPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentPerson" */
export type ContentPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentPerson_Insert_Input>;
  readonly on_conflict?: Maybe<ContentPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentPerson". All fields are combined with a logical 'AND'. */
export type ContentPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentPerson_Bool_Exp>>>;
  readonly _not?: Maybe<ContentPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentPerson_Bool_Exp>>>;
  readonly affiliation?: Maybe<String_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItemPeople?: Maybe<ContentGroupPerson_Bool_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<EventPerson_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "ContentPerson" */
export enum ContentPerson_Constraint {
  /** unique or primary key constraint */
  ContentPersonConferenceIdNameAffiliationKey = 'ContentPerson_conferenceId_name_affiliation_key',
  /** unique or primary key constraint */
  ContentPersonPkey = 'ContentPerson_pkey'
}

/** input type for inserting data into table "ContentPerson" */
export type ContentPerson_Insert_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemPeople?: Maybe<ContentGroupPerson_Arr_Rel_Insert_Input>;
  readonly email?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<EventPerson_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type ContentPerson_Max_Fields = {
  readonly __typename?: 'ContentPerson_max_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "ContentPerson" */
export type ContentPerson_Max_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentPerson_Min_Fields = {
  readonly __typename?: 'ContentPerson_min_fields';
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "ContentPerson" */
export type ContentPerson_Min_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentPerson" */
export type ContentPerson_Mutation_Response = {
  readonly __typename?: 'ContentPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentPerson>;
};

/** input type for inserting object relation for remote table "ContentPerson" */
export type ContentPerson_Obj_Rel_Insert_Input = {
  readonly data: ContentPerson_Insert_Input;
  readonly on_conflict?: Maybe<ContentPerson_On_Conflict>;
};

/** on conflict condition type for table "ContentPerson" */
export type ContentPerson_On_Conflict = {
  readonly constraint: ContentPerson_Constraint;
  readonly update_columns: ReadonlyArray<ContentPerson_Update_Column>;
  readonly where?: Maybe<ContentPerson_Bool_Exp>;
};

/** ordering options when selecting data from "ContentPerson" */
export type ContentPerson_Order_By = {
  readonly affiliation?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemPeople_aggregate?: Maybe<ContentGroupPerson_Aggregate_Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<EventPerson_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
};

/** primary key columns input for table: "ContentPerson" */
export type ContentPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ContentPerson" */
export enum ContentPerson_Select_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId'
}

/** input type for updating data in table "ContentPerson" */
export type ContentPerson_Set_Input = {
  readonly affiliation?: Maybe<Scalars['String']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "ContentPerson" */
export enum ContentPerson_Update_Column {
  /** column name */
  Affiliation = 'affiliation',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId'
}

/** columns and relationships of "ContentType" */
export type ContentType = {
  readonly __typename?: 'ContentType';
  /** An array relationship */
  readonly contentItems: ReadonlyArray<ContentItem>;
  /** An aggregated array relationship */
  readonly contentItems_aggregate: ContentItem_Aggregate;
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly requiredContentItems: ReadonlyArray<RequiredContentItem>;
  /** An aggregated array relationship */
  readonly requiredContentItems_aggregate: RequiredContentItem_Aggregate;
};


/** columns and relationships of "ContentType" */
export type ContentTypeContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentType" */
export type ContentTypeContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentType" */
export type ContentTypeRequiredContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "ContentType" */
export type ContentTypeRequiredContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};

/** aggregated selection of "ContentType" */
export type ContentType_Aggregate = {
  readonly __typename?: 'ContentType_aggregate';
  readonly aggregate?: Maybe<ContentType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ContentType>;
};

/** aggregate fields of "ContentType" */
export type ContentType_Aggregate_Fields = {
  readonly __typename?: 'ContentType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ContentType_Max_Fields>;
  readonly min?: Maybe<ContentType_Min_Fields>;
};


/** aggregate fields of "ContentType" */
export type ContentType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ContentType" */
export type ContentType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ContentType_Max_Order_By>;
  readonly min?: Maybe<ContentType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ContentType" */
export type ContentType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ContentType_Insert_Input>;
  readonly on_conflict?: Maybe<ContentType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ContentType". All fields are combined with a logical 'AND'. */
export type ContentType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ContentType_Bool_Exp>>>;
  readonly _not?: Maybe<ContentType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ContentType_Bool_Exp>>>;
  readonly contentItems?: Maybe<ContentItem_Bool_Exp>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Bool_Exp>;
};

/** unique or primary key constraints on table "ContentType" */
export enum ContentType_Constraint {
  /** unique or primary key constraint */
  ContentTypePkey = 'ContentType_pkey'
}

export enum ContentType_Enum {
  /** Abstract Markdown text. */
  Abstract = 'ABSTRACT',
  /** List of content groups in the system. */
  ContentGroupList = 'CONTENT_GROUP_LIST',
  /** File for an image (stored by Clowdr). */
  ImageFile = 'IMAGE_FILE',
  /** URL to an image (embedded in Clowdr UI). */
  ImageUrl = 'IMAGE_URL',
  /** A generic URL. */
  Link = 'LINK',
  /** A URL for a link button. */
  LinkButton = 'LINK_BUTTON',
  /** File for a paper (stored by Clowdr). */
  PaperFile = 'PAPER_FILE',
  /** Link for a paper (preview is not embedded in Clowdr UI). */
  PaperLink = 'PAPER_LINK',
  /** URL to a paper (preview may be embedded in Clowdr UI e.g. PDF JS viewer). */
  PaperUrl = 'PAPER_URL',
  /** File for a poster image (stored by Clowdr). */
  PosterFile = 'POSTER_FILE',
  /** URL to a poster image (embedded in Clowdr UI). */
  PosterUrl = 'POSTER_URL',
  /** General-purpose Markdown text. */
  Text = 'TEXT',
  /** Video file to be broadcast. */
  VideoBroadcast = 'VIDEO_BROADCAST',
  /** Video file for counting down to a transition in a broadcast. */
  VideoCountdown = 'VIDEO_COUNTDOWN',
  /** File for a video (stored by Clowdr). */
  VideoFile = 'VIDEO_FILE',
  /** Video file for filler loop between events/during breaks in a broadcast. */
  VideoFiller = 'VIDEO_FILLER',
  /** Link to a video (video is not embedded in Clowdr UI). */
  VideoLink = 'VIDEO_LINK',
  /** Video file to be published in advance of the conference. */
  VideoPrepublish = 'VIDEO_PREPUBLISH',
  /** Video file for sponsors filler loop between events/during breaks in a broadcast. */
  VideoSponsorsFiller = 'VIDEO_SPONSORS_FILLER',
  /** Video file for titles introducing an event during a broadcast. */
  VideoTitles = 'VIDEO_TITLES',
  /** URL for a video (video is embedded in Clowdr UI). */
  VideoUrl = 'VIDEO_URL',
  /** Schedule view for the whole conference. */
  WholeSchedule = 'WHOLE_SCHEDULE',
  /** Data for a Zoom meeting. */
  Zoom = 'ZOOM'
}

/** expression to compare columns of type ContentType_enum. All fields are combined with logical 'AND'. */
export type ContentType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<ContentType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<ContentType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<ContentType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<ContentType_Enum>>;
};

/** input type for inserting data into table "ContentType" */
export type ContentType_Insert_Input = {
  readonly contentItems?: Maybe<ContentItem_Arr_Rel_Insert_Input>;
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type ContentType_Max_Fields = {
  readonly __typename?: 'ContentType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "ContentType" */
export type ContentType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ContentType_Min_Fields = {
  readonly __typename?: 'ContentType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "ContentType" */
export type ContentType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "ContentType" */
export type ContentType_Mutation_Response = {
  readonly __typename?: 'ContentType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ContentType>;
};

/** input type for inserting object relation for remote table "ContentType" */
export type ContentType_Obj_Rel_Insert_Input = {
  readonly data: ContentType_Insert_Input;
  readonly on_conflict?: Maybe<ContentType_On_Conflict>;
};

/** on conflict condition type for table "ContentType" */
export type ContentType_On_Conflict = {
  readonly constraint: ContentType_Constraint;
  readonly update_columns: ReadonlyArray<ContentType_Update_Column>;
  readonly where?: Maybe<ContentType_Bool_Exp>;
};

/** ordering options when selecting data from "ContentType" */
export type ContentType_Order_By = {
  readonly contentItems_aggregate?: Maybe<ContentItem_Aggregate_Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItems_aggregate?: Maybe<RequiredContentItem_Aggregate_Order_By>;
};

/** primary key columns input for table: "ContentType" */
export type ContentType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "ContentType" */
export enum ContentType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "ContentType" */
export type ContentType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "ContentType" */
export enum ContentType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

export type CreateContentGroupRoomOutput = {
  readonly __typename?: 'CreateContentGroupRoomOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room>;
  readonly roomId?: Maybe<Scalars['String']>;
};

export type CreateRoomDmOutput = {
  readonly __typename?: 'CreateRoomDmOutput';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

export type EchoInput = {
  readonly message: Scalars['String'];
};

export type EchoOutput = {
  readonly __typename?: 'EchoOutput';
  readonly message: Scalars['String'];
};

/** columns and relationships of "Email" */
export type Email = {
  readonly __typename?: 'Email';
  readonly createdAt: Scalars['timestamptz'];
  readonly emailAddress: Scalars['String'];
  readonly htmlContents: Scalars['String'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly invitation?: Maybe<Invitation>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents: Scalars['String'];
  readonly reason: Scalars['String'];
  readonly retriesCount: Scalars['Int'];
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregated selection of "Email" */
export type Email_Aggregate = {
  readonly __typename?: 'Email_aggregate';
  readonly aggregate?: Maybe<Email_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Email>;
};

/** aggregate fields of "Email" */
export type Email_Aggregate_Fields = {
  readonly __typename?: 'Email_aggregate_fields';
  readonly avg?: Maybe<Email_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Email_Max_Fields>;
  readonly min?: Maybe<Email_Min_Fields>;
  readonly stddev?: Maybe<Email_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Email_Sum_Fields>;
  readonly var_pop?: Maybe<Email_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Email_Var_Samp_Fields>;
  readonly variance?: Maybe<Email_Variance_Fields>;
};


/** aggregate fields of "Email" */
export type Email_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Email_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Email" */
export type Email_Aggregate_Order_By = {
  readonly avg?: Maybe<Email_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Email_Max_Order_By>;
  readonly min?: Maybe<Email_Min_Order_By>;
  readonly stddev?: Maybe<Email_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Email_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Email_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Email_Sum_Order_By>;
  readonly var_pop?: Maybe<Email_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Email_Var_Samp_Order_By>;
  readonly variance?: Maybe<Email_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Email" */
export type Email_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Email_Insert_Input>;
  readonly on_conflict?: Maybe<Email_On_Conflict>;
};

/** aggregate avg on columns */
export type Email_Avg_Fields = {
  readonly __typename?: 'Email_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Email" */
export type Email_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Email". All fields are combined with a logical 'AND'. */
export type Email_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Email_Bool_Exp>>>;
  readonly _not?: Maybe<Email_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Email_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emailAddress?: Maybe<String_Comparison_Exp>;
  readonly htmlContents?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly invitation?: Maybe<Invitation_Bool_Exp>;
  readonly invitationId?: Maybe<Uuid_Comparison_Exp>;
  readonly plainTextContents?: Maybe<String_Comparison_Exp>;
  readonly reason?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly sentAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly subject?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "Email" */
export enum Email_Constraint {
  /** unique or primary key constraint */
  EmailPkey = 'Email_pkey'
}

/** input type for incrementing integer column in table "Email" */
export type Email_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Email" */
export type Email_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitation?: Maybe<Invitation_Obj_Rel_Insert_Input>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Email_Max_Fields = {
  readonly __typename?: 'Email_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Email" */
export type Email_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Email_Min_Fields = {
  readonly __typename?: 'Email_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Email" */
export type Email_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "Email" */
export type Email_Mutation_Response = {
  readonly __typename?: 'Email_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Email>;
};

/** input type for inserting object relation for remote table "Email" */
export type Email_Obj_Rel_Insert_Input = {
  readonly data: Email_Insert_Input;
  readonly on_conflict?: Maybe<Email_On_Conflict>;
};

/** on conflict condition type for table "Email" */
export type Email_On_Conflict = {
  readonly constraint: Email_Constraint;
  readonly update_columns: ReadonlyArray<Email_Update_Column>;
  readonly where?: Maybe<Email_Bool_Exp>;
};

/** ordering options when selecting data from "Email" */
export type Email_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly emailAddress?: Maybe<Order_By>;
  readonly htmlContents?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitation?: Maybe<Invitation_Order_By>;
  readonly invitationId?: Maybe<Order_By>;
  readonly plainTextContents?: Maybe<Order_By>;
  readonly reason?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly sentAt?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "Email" */
export type Email_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Email" */
export enum Email_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "Email" */
export type Email_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emailAddress?: Maybe<Scalars['String']>;
  readonly htmlContents?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly invitationId?: Maybe<Scalars['uuid']>;
  readonly plainTextContents?: Maybe<Scalars['String']>;
  readonly reason?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly sentAt?: Maybe<Scalars['timestamptz']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Email_Stddev_Fields = {
  readonly __typename?: 'Email_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Email" */
export type Email_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Email_Stddev_Pop_Fields = {
  readonly __typename?: 'Email_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Email" */
export type Email_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Email_Stddev_Samp_Fields = {
  readonly __typename?: 'Email_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Email" */
export type Email_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Email_Sum_Fields = {
  readonly __typename?: 'Email_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Email" */
export type Email_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "Email" */
export enum Email_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EmailAddress = 'emailAddress',
  /** column name */
  HtmlContents = 'htmlContents',
  /** column name */
  Id = 'id',
  /** column name */
  InvitationId = 'invitationId',
  /** column name */
  PlainTextContents = 'plainTextContents',
  /** column name */
  Reason = 'reason',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  SentAt = 'sentAt',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** aggregate var_pop on columns */
export type Email_Var_Pop_Fields = {
  readonly __typename?: 'Email_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Email" */
export type Email_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Email_Var_Samp_Fields = {
  readonly __typename?: 'Email_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Email" */
export type Email_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Email_Variance_Fields = {
  readonly __typename?: 'Email_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Email" */
export type Email_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** columns and relationships of "Event" */
export type Event = {
  readonly __typename?: 'Event';
  /** An object relationship */
  readonly broadcastContentItem?: Maybe<BroadcastContentItem>;
  /** An array relationship */
  readonly broadcasts: ReadonlyArray<Broadcast>;
  /** An aggregated array relationship */
  readonly broadcasts_aggregate: Broadcast_Aggregate;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup?: Maybe<ContentGroup>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  readonly durationSeconds: Scalars['Int'];
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<EventPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: EventPerson_Aggregate;
  /** An array relationship */
  readonly eventTags: ReadonlyArray<EventTag>;
  /** An aggregated array relationship */
  readonly eventTags_aggregate: EventTag_Aggregate;
  /** An object relationship */
  readonly eventVonageSession?: Maybe<EventVonageSession>;
  /** An array relationship */
  readonly executedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** An aggregated array relationship */
  readonly executedTransitions_aggregate: ExecutedTransitions_Aggregate;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['uuid'];
  readonly intendedRoomModeName: RoomMode_Enum;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly roomMode: RoomMode;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime: Scalars['timestamptz'];
  /** An array relationship */
  readonly transitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly transitions_aggregate: Transitions_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Event" */
export type EventBroadcastsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventBroadcasts_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "Event" */
export type EventTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};

/**
 * Current streams in event Vonage sessions.
 *
 *
 * columns and relationships of "EventParticipantStream"
 */
export type EventParticipantStream = {
  readonly __typename?: 'EventParticipantStream';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId: Scalars['String'];
  readonly vonageStreamId: Scalars['String'];
  readonly vonageStreamType: Scalars['String'];
};

/** aggregated selection of "EventParticipantStream" */
export type EventParticipantStream_Aggregate = {
  readonly __typename?: 'EventParticipantStream_aggregate';
  readonly aggregate?: Maybe<EventParticipantStream_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventParticipantStream>;
};

/** aggregate fields of "EventParticipantStream" */
export type EventParticipantStream_Aggregate_Fields = {
  readonly __typename?: 'EventParticipantStream_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventParticipantStream_Max_Fields>;
  readonly min?: Maybe<EventParticipantStream_Min_Fields>;
};


/** aggregate fields of "EventParticipantStream" */
export type EventParticipantStream_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventParticipantStream" */
export type EventParticipantStream_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventParticipantStream_Max_Order_By>;
  readonly min?: Maybe<EventParticipantStream_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventParticipantStream" */
export type EventParticipantStream_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventParticipantStream_Insert_Input>;
  readonly on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventParticipantStream". All fields are combined with a logical 'AND'. */
export type EventParticipantStream_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventParticipantStream_Bool_Exp>>>;
  readonly _not?: Maybe<EventParticipantStream_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventParticipantStream_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamId?: Maybe<String_Comparison_Exp>;
  readonly vonageStreamType?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventParticipantStream" */
export enum EventParticipantStream_Constraint {
  /** unique or primary key constraint */
  EventParticipantStreamEventIdAttendeeIdVonageStreamIdKey = 'EventParticipantStream_eventId_attendeeId_vonageStreamId_key',
  /** unique or primary key constraint */
  EventParticipantStreamPkey = 'EventParticipantStream_pkey'
}

/** input type for inserting data into table "EventParticipantStream" */
export type EventParticipantStream_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventParticipantStream_Max_Fields = {
  readonly __typename?: 'EventParticipantStream_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "EventParticipantStream" */
export type EventParticipantStream_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventParticipantStream_Min_Fields = {
  readonly __typename?: 'EventParticipantStream_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "EventParticipantStream" */
export type EventParticipantStream_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventParticipantStream" */
export type EventParticipantStream_Mutation_Response = {
  readonly __typename?: 'EventParticipantStream_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventParticipantStream>;
};

/** input type for inserting object relation for remote table "EventParticipantStream" */
export type EventParticipantStream_Obj_Rel_Insert_Input = {
  readonly data: EventParticipantStream_Insert_Input;
  readonly on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};

/** on conflict condition type for table "EventParticipantStream" */
export type EventParticipantStream_On_Conflict = {
  readonly constraint: EventParticipantStream_Constraint;
  readonly update_columns: ReadonlyArray<EventParticipantStream_Update_Column>;
  readonly where?: Maybe<EventParticipantStream_Bool_Exp>;
};

/** ordering options when selecting data from "EventParticipantStream" */
export type EventParticipantStream_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
  readonly vonageStreamId?: Maybe<Order_By>;
  readonly vonageStreamType?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventParticipantStream" */
export type EventParticipantStream_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventParticipantStream" */
export enum EventParticipantStream_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** input type for updating data in table "EventParticipantStream" */
export type EventParticipantStream_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
  readonly vonageStreamId?: Maybe<Scalars['String']>;
  readonly vonageStreamType?: Maybe<Scalars['String']>;
};

/** update columns of table "EventParticipantStream" */
export enum EventParticipantStream_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId',
  /** column name */
  VonageStreamId = 'vonageStreamId',
  /** column name */
  VonageStreamType = 'vonageStreamType'
}

/** columns and relationships of "EventPerson" */
export type EventPerson = {
  readonly __typename?: 'EventPerson';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  /** An object relationship */
  readonly eventPersonRole: EventPersonRole;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly person: ContentPerson;
  readonly personId: Scalars['uuid'];
  readonly roleName: EventPersonRole_Enum;
  readonly updatedAt: Scalars['timestamptz'];
};

/** columns and relationships of "EventPersonRole" */
export type EventPersonRole = {
  readonly __typename?: 'EventPersonRole';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly eventPeople: ReadonlyArray<EventPerson>;
  /** An aggregated array relationship */
  readonly eventPeople_aggregate: EventPerson_Aggregate;
  readonly name: Scalars['String'];
};


/** columns and relationships of "EventPersonRole" */
export type EventPersonRoleEventPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** columns and relationships of "EventPersonRole" */
export type EventPersonRoleEventPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};

/** aggregated selection of "EventPersonRole" */
export type EventPersonRole_Aggregate = {
  readonly __typename?: 'EventPersonRole_aggregate';
  readonly aggregate?: Maybe<EventPersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventPersonRole>;
};

/** aggregate fields of "EventPersonRole" */
export type EventPersonRole_Aggregate_Fields = {
  readonly __typename?: 'EventPersonRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventPersonRole_Max_Fields>;
  readonly min?: Maybe<EventPersonRole_Min_Fields>;
};


/** aggregate fields of "EventPersonRole" */
export type EventPersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventPersonRole" */
export type EventPersonRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventPersonRole_Max_Order_By>;
  readonly min?: Maybe<EventPersonRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventPersonRole" */
export type EventPersonRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventPersonRole_Insert_Input>;
  readonly on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventPersonRole". All fields are combined with a logical 'AND'. */
export type EventPersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventPersonRole_Bool_Exp>>>;
  readonly _not?: Maybe<EventPersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventPersonRole_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly eventPeople?: Maybe<EventPerson_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventPersonRole" */
export enum EventPersonRole_Constraint {
  /** unique or primary key constraint */
  EventPersonRolePkey = 'EventPersonRole_pkey'
}

export enum EventPersonRole_Enum {
  /** Chair/moderator of the event */
  Chair = 'CHAIR',
  /** Viewer who has been given access to the event (e.g. to ask a question). */
  Participant = 'PARTICIPANT',
  /** A presenter. */
  Presenter = 'PRESENTER'
}

/** expression to compare columns of type EventPersonRole_enum. All fields are combined with logical 'AND'. */
export type EventPersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<EventPersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<EventPersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<EventPersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<EventPersonRole_Enum>>;
};

/** input type for inserting data into table "EventPersonRole" */
export type EventPersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly eventPeople?: Maybe<EventPerson_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type EventPersonRole_Max_Fields = {
  readonly __typename?: 'EventPersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "EventPersonRole" */
export type EventPersonRole_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventPersonRole_Min_Fields = {
  readonly __typename?: 'EventPersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "EventPersonRole" */
export type EventPersonRole_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventPersonRole" */
export type EventPersonRole_Mutation_Response = {
  readonly __typename?: 'EventPersonRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventPersonRole>;
};

/** input type for inserting object relation for remote table "EventPersonRole" */
export type EventPersonRole_Obj_Rel_Insert_Input = {
  readonly data: EventPersonRole_Insert_Input;
  readonly on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};

/** on conflict condition type for table "EventPersonRole" */
export type EventPersonRole_On_Conflict = {
  readonly constraint: EventPersonRole_Constraint;
  readonly update_columns: ReadonlyArray<EventPersonRole_Update_Column>;
  readonly where?: Maybe<EventPersonRole_Bool_Exp>;
};

/** ordering options when selecting data from "EventPersonRole" */
export type EventPersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<EventPerson_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventPersonRole" */
export type EventPersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "EventPersonRole" */
export enum EventPersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "EventPersonRole" */
export type EventPersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "EventPersonRole" */
export enum EventPersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "EventPerson" */
export type EventPerson_Aggregate = {
  readonly __typename?: 'EventPerson_aggregate';
  readonly aggregate?: Maybe<EventPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventPerson>;
};

/** aggregate fields of "EventPerson" */
export type EventPerson_Aggregate_Fields = {
  readonly __typename?: 'EventPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventPerson_Max_Fields>;
  readonly min?: Maybe<EventPerson_Min_Fields>;
};


/** aggregate fields of "EventPerson" */
export type EventPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventPerson" */
export type EventPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventPerson_Max_Order_By>;
  readonly min?: Maybe<EventPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventPerson" */
export type EventPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventPerson_Insert_Input>;
  readonly on_conflict?: Maybe<EventPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventPerson". All fields are combined with a logical 'AND'. */
export type EventPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventPerson_Bool_Exp>>>;
  readonly _not?: Maybe<EventPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventPerson_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly person?: Maybe<ContentPerson_Bool_Exp>;
  readonly personId?: Maybe<Uuid_Comparison_Exp>;
  readonly roleName?: Maybe<EventPersonRole_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventPerson" */
export enum EventPerson_Constraint {
  /** unique or primary key constraint */
  EventPersonEventIdPersonIdRoleNameKey = 'EventPerson_eventId_personId_roleName_key',
  /** unique or primary key constraint */
  EventPersonPkey = 'EventPerson_pkey'
}

/** input type for inserting data into table "EventPerson" */
export type EventPerson_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Obj_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly person?: Maybe<ContentPerson_Obj_Rel_Insert_Input>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<EventPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventPerson_Max_Fields = {
  readonly __typename?: 'EventPerson_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "EventPerson" */
export type EventPerson_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventPerson_Min_Fields = {
  readonly __typename?: 'EventPerson_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "EventPerson" */
export type EventPerson_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventPerson" */
export type EventPerson_Mutation_Response = {
  readonly __typename?: 'EventPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventPerson>;
};

/** input type for inserting object relation for remote table "EventPerson" */
export type EventPerson_Obj_Rel_Insert_Input = {
  readonly data: EventPerson_Insert_Input;
  readonly on_conflict?: Maybe<EventPerson_On_Conflict>;
};

/** on conflict condition type for table "EventPerson" */
export type EventPerson_On_Conflict = {
  readonly constraint: EventPerson_Constraint;
  readonly update_columns: ReadonlyArray<EventPerson_Update_Column>;
  readonly where?: Maybe<EventPerson_Bool_Exp>;
};

/** ordering options when selecting data from "EventPerson" */
export type EventPerson_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly person?: Maybe<ContentPerson_Order_By>;
  readonly personId?: Maybe<Order_By>;
  readonly roleName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventPerson" */
export type EventPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventPerson" */
export enum EventPerson_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "EventPerson" */
export type EventPerson_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly personId?: Maybe<Scalars['uuid']>;
  readonly roleName?: Maybe<EventPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "EventPerson" */
export enum EventPerson_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  PersonId = 'personId',
  /** column name */
  RoleName = 'roleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "EventRoomJoinRequest" */
export type EventRoomJoinRequest = {
  readonly __typename?: 'EventRoomJoinRequest';
  readonly approved: Scalars['Boolean'];
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  /** An object relationship */
  readonly eventPersonRole: EventPersonRole;
  readonly eventPersonRoleName: EventPersonRole_Enum;
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate = {
  readonly __typename?: 'EventRoomJoinRequest_aggregate';
  readonly aggregate?: Maybe<EventRoomJoinRequest_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventRoomJoinRequest>;
};

/** aggregate fields of "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate_Fields = {
  readonly __typename?: 'EventRoomJoinRequest_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventRoomJoinRequest_Max_Fields>;
  readonly min?: Maybe<EventRoomJoinRequest_Min_Fields>;
};


/** aggregate fields of "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventRoomJoinRequest_Max_Order_By>;
  readonly min?: Maybe<EventRoomJoinRequest_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventRoomJoinRequest_Insert_Input>;
  readonly on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventRoomJoinRequest". All fields are combined with a logical 'AND'. */
export type EventRoomJoinRequest_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventRoomJoinRequest_Bool_Exp>>>;
  readonly _not?: Maybe<EventRoomJoinRequest_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventRoomJoinRequest_Bool_Exp>>>;
  readonly approved?: Maybe<Boolean_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Bool_Exp>;
  readonly eventPersonRoleName?: Maybe<EventPersonRole_Enum_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventRoomJoinRequest" */
export enum EventRoomJoinRequest_Constraint {
  /** unique or primary key constraint */
  EventRoomJoinRequestEventIdAttendeeIdKey = 'EventRoomJoinRequest_eventId_attendeeId_key',
  /** unique or primary key constraint */
  EventRoomJoinRequestPkey = 'EventRoomJoinRequest_pkey'
}

/** input type for inserting data into table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Insert_Input = {
  readonly approved?: Maybe<Scalars['Boolean']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Obj_Rel_Insert_Input>;
  readonly eventPersonRoleName?: Maybe<EventPersonRole_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventRoomJoinRequest_Max_Fields = {
  readonly __typename?: 'EventRoomJoinRequest_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventRoomJoinRequest_Min_Fields = {
  readonly __typename?: 'EventRoomJoinRequest_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Mutation_Response = {
  readonly __typename?: 'EventRoomJoinRequest_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventRoomJoinRequest>;
};

/** input type for inserting object relation for remote table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Obj_Rel_Insert_Input = {
  readonly data: EventRoomJoinRequest_Insert_Input;
  readonly on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};

/** on conflict condition type for table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_On_Conflict = {
  readonly constraint: EventRoomJoinRequest_Constraint;
  readonly update_columns: ReadonlyArray<EventRoomJoinRequest_Update_Column>;
  readonly where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};

/** ordering options when selecting data from "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Order_By = {
  readonly approved?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly eventPersonRole?: Maybe<EventPersonRole_Order_By>;
  readonly eventPersonRoleName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventRoomJoinRequest" */
export enum EventRoomJoinRequest_Select_Column {
  /** column name */
  Approved = 'approved',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  EventPersonRoleName = 'eventPersonRoleName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "EventRoomJoinRequest" */
export type EventRoomJoinRequest_Set_Input = {
  readonly approved?: Maybe<Scalars['Boolean']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly eventPersonRoleName?: Maybe<EventPersonRole_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "EventRoomJoinRequest" */
export enum EventRoomJoinRequest_Update_Column {
  /** column name */
  Approved = 'approved',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  EventPersonRoleName = 'eventPersonRoleName',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "EventTag" */
export type EventTag = {
  readonly __typename?: 'EventTag';
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly tag: Tag;
  readonly tagId: Scalars['uuid'];
};

/** aggregated selection of "EventTag" */
export type EventTag_Aggregate = {
  readonly __typename?: 'EventTag_aggregate';
  readonly aggregate?: Maybe<EventTag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventTag>;
};

/** aggregate fields of "EventTag" */
export type EventTag_Aggregate_Fields = {
  readonly __typename?: 'EventTag_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventTag_Max_Fields>;
  readonly min?: Maybe<EventTag_Min_Fields>;
};


/** aggregate fields of "EventTag" */
export type EventTag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventTag" */
export type EventTag_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventTag_Max_Order_By>;
  readonly min?: Maybe<EventTag_Min_Order_By>;
};

/** input type for inserting array relation for remote table "EventTag" */
export type EventTag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventTag_Insert_Input>;
  readonly on_conflict?: Maybe<EventTag_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventTag". All fields are combined with a logical 'AND'. */
export type EventTag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventTag_Bool_Exp>>>;
  readonly _not?: Maybe<EventTag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventTag_Bool_Exp>>>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly tag?: Maybe<Tag_Bool_Exp>;
  readonly tagId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventTag" */
export enum EventTag_Constraint {
  /** unique or primary key constraint */
  EventTagPkey = 'EventTag_pkey',
  /** unique or primary key constraint */
  EventTagTagIdEventIdKey = 'EventTag_tagId_eventId_key'
}

/** input type for inserting data into table "EventTag" */
export type EventTag_Insert_Input = {
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tag?: Maybe<Tag_Obj_Rel_Insert_Input>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type EventTag_Max_Fields = {
  readonly __typename?: 'EventTag_max_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "EventTag" */
export type EventTag_Max_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventTag_Min_Fields = {
  readonly __typename?: 'EventTag_min_fields';
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "EventTag" */
export type EventTag_Min_Order_By = {
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventTag" */
export type EventTag_Mutation_Response = {
  readonly __typename?: 'EventTag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventTag>;
};

/** input type for inserting object relation for remote table "EventTag" */
export type EventTag_Obj_Rel_Insert_Input = {
  readonly data: EventTag_Insert_Input;
  readonly on_conflict?: Maybe<EventTag_On_Conflict>;
};

/** on conflict condition type for table "EventTag" */
export type EventTag_On_Conflict = {
  readonly constraint: EventTag_Constraint;
  readonly update_columns: ReadonlyArray<EventTag_Update_Column>;
  readonly where?: Maybe<EventTag_Bool_Exp>;
};

/** ordering options when selecting data from "EventTag" */
export type EventTag_Order_By = {
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly tag?: Maybe<Tag_Order_By>;
  readonly tagId?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventTag" */
export type EventTag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "EventTag" */
export enum EventTag_Select_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** input type for updating data in table "EventTag" */
export type EventTag_Set_Input = {
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly tagId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "EventTag" */
export enum EventTag_Update_Column {
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  TagId = 'tagId'
}

/** columns and relationships of "EventVonageSession" */
export type EventVonageSession = {
  readonly __typename?: 'EventVonageSession';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly sessionId: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "EventVonageSession" */
export type EventVonageSessionLayoutDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "EventVonageSession" */
export type EventVonageSession_Aggregate = {
  readonly __typename?: 'EventVonageSession_aggregate';
  readonly aggregate?: Maybe<EventVonageSession_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<EventVonageSession>;
};

/** aggregate fields of "EventVonageSession" */
export type EventVonageSession_Aggregate_Fields = {
  readonly __typename?: 'EventVonageSession_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<EventVonageSession_Max_Fields>;
  readonly min?: Maybe<EventVonageSession_Min_Fields>;
};


/** aggregate fields of "EventVonageSession" */
export type EventVonageSession_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "EventVonageSession" */
export type EventVonageSession_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<EventVonageSession_Max_Order_By>;
  readonly min?: Maybe<EventVonageSession_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type EventVonageSession_Append_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "EventVonageSession" */
export type EventVonageSession_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<EventVonageSession_Insert_Input>;
  readonly on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};

/** Boolean expression to filter rows from the table "EventVonageSession". All fields are combined with a logical 'AND'. */
export type EventVonageSession_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<EventVonageSession_Bool_Exp>>>;
  readonly _not?: Maybe<EventVonageSession_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<EventVonageSession_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly layoutData?: Maybe<Jsonb_Comparison_Exp>;
  readonly sessionId?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "EventVonageSession" */
export enum EventVonageSession_Constraint {
  /** unique or primary key constraint */
  EventVonageSessionEventIdKey = 'EventVonageSession_eventId_key',
  /** unique or primary key constraint */
  EventVonageSessionPkey = 'EventVonageSession_pkey',
  /** unique or primary key constraint */
  EventVonageSessionSessionIdKey = 'EventVonageSession_sessionId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type EventVonageSession_Delete_At_Path_Input = {
  readonly layoutData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type EventVonageSession_Delete_Elem_Input = {
  readonly layoutData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type EventVonageSession_Delete_Key_Input = {
  readonly layoutData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "EventVonageSession" */
export type EventVonageSession_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type EventVonageSession_Max_Fields = {
  readonly __typename?: 'EventVonageSession_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "EventVonageSession" */
export type EventVonageSession_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type EventVonageSession_Min_Fields = {
  readonly __typename?: 'EventVonageSession_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "EventVonageSession" */
export type EventVonageSession_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "EventVonageSession" */
export type EventVonageSession_Mutation_Response = {
  readonly __typename?: 'EventVonageSession_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<EventVonageSession>;
};

/** input type for inserting object relation for remote table "EventVonageSession" */
export type EventVonageSession_Obj_Rel_Insert_Input = {
  readonly data: EventVonageSession_Insert_Input;
  readonly on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};

/** on conflict condition type for table "EventVonageSession" */
export type EventVonageSession_On_Conflict = {
  readonly constraint: EventVonageSession_Constraint;
  readonly update_columns: ReadonlyArray<EventVonageSession_Update_Column>;
  readonly where?: Maybe<EventVonageSession_Bool_Exp>;
};

/** ordering options when selecting data from "EventVonageSession" */
export type EventVonageSession_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly layoutData?: Maybe<Order_By>;
  readonly sessionId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "EventVonageSession" */
export type EventVonageSession_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type EventVonageSession_Prepend_Input = {
  readonly layoutData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "EventVonageSession" */
export enum EventVonageSession_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "EventVonageSession" */
export type EventVonageSession_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly sessionId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "EventVonageSession" */
export enum EventVonageSession_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  LayoutData = 'layoutData',
  /** column name */
  SessionId = 'sessionId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Event" */
export type Event_Aggregate = {
  readonly __typename?: 'Event_aggregate';
  readonly aggregate?: Maybe<Event_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Event>;
};

/** aggregate fields of "Event" */
export type Event_Aggregate_Fields = {
  readonly __typename?: 'Event_aggregate_fields';
  readonly avg?: Maybe<Event_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Event_Max_Fields>;
  readonly min?: Maybe<Event_Min_Fields>;
  readonly stddev?: Maybe<Event_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Event_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Event_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Event_Sum_Fields>;
  readonly var_pop?: Maybe<Event_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Event_Var_Samp_Fields>;
  readonly variance?: Maybe<Event_Variance_Fields>;
};


/** aggregate fields of "Event" */
export type Event_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Event_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Event" */
export type Event_Aggregate_Order_By = {
  readonly avg?: Maybe<Event_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Event_Max_Order_By>;
  readonly min?: Maybe<Event_Min_Order_By>;
  readonly stddev?: Maybe<Event_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Event_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Event_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Event_Sum_Order_By>;
  readonly var_pop?: Maybe<Event_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Event_Var_Samp_Order_By>;
  readonly variance?: Maybe<Event_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Event" */
export type Event_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Event_Insert_Input>;
  readonly on_conflict?: Maybe<Event_On_Conflict>;
};

/** aggregate avg on columns */
export type Event_Avg_Fields = {
  readonly __typename?: 'Event_avg_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Event" */
export type Event_Avg_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Event". All fields are combined with a logical 'AND'. */
export type Event_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Event_Bool_Exp>>>;
  readonly _not?: Maybe<Event_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Event_Bool_Exp>>>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly broadcasts?: Maybe<Broadcast_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationSeconds?: Maybe<Int_Comparison_Exp>;
  readonly endTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventPeople?: Maybe<EventPerson_Bool_Exp>;
  readonly eventTags?: Maybe<EventTag_Bool_Exp>;
  readonly eventVonageSession?: Maybe<EventVonageSession_Bool_Exp>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly hallwayId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly intendedRoomModeName?: Maybe<RoomMode_Enum_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly roomMode?: Maybe<RoomMode_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly startTime?: Maybe<Timestamptz_Comparison_Exp>;
  readonly transitions?: Maybe<Transitions_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Event" */
export enum Event_Constraint {
  /** unique or primary key constraint */
  EventPkey = 'Event_pkey'
}

/** input type for incrementing integer column in table "Event" */
export type Event_Inc_Input = {
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Event" */
export type Event_Insert_Input = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly broadcasts?: Maybe<Broadcast_Arr_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly eventPeople?: Maybe<EventPerson_Arr_Rel_Insert_Input>;
  readonly eventTags?: Maybe<EventTag_Arr_Rel_Insert_Input>;
  readonly eventVonageSession?: Maybe<EventVonageSession_Obj_Rel_Insert_Input>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Arr_Rel_Insert_Input>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<RoomMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomMode?: Maybe<RoomMode_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly transitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Event_Max_Fields = {
  readonly __typename?: 'Event_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Event" */
export type Event_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Event_Min_Fields = {
  readonly __typename?: 'Event_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Event" */
export type Event_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Event" */
export type Event_Mutation_Response = {
  readonly __typename?: 'Event_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Event>;
};

/** input type for inserting object relation for remote table "Event" */
export type Event_Obj_Rel_Insert_Input = {
  readonly data: Event_Insert_Input;
  readonly on_conflict?: Maybe<Event_On_Conflict>;
};

/** on conflict condition type for table "Event" */
export type Event_On_Conflict = {
  readonly constraint: Event_Constraint;
  readonly update_columns: ReadonlyArray<Event_Update_Column>;
  readonly where?: Maybe<Event_Bool_Exp>;
};

/** ordering options when selecting data from "Event" */
export type Event_Order_By = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly broadcasts_aggregate?: Maybe<Broadcast_Aggregate_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly durationSeconds?: Maybe<Order_By>;
  readonly endTime?: Maybe<Order_By>;
  readonly eventPeople_aggregate?: Maybe<EventPerson_Aggregate_Order_By>;
  readonly eventTags_aggregate?: Maybe<EventTag_Aggregate_Order_By>;
  readonly eventVonageSession?: Maybe<EventVonageSession_Order_By>;
  readonly executedTransitions_aggregate?: Maybe<ExecutedTransitions_Aggregate_Order_By>;
  readonly hallwayId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly intendedRoomModeName?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly roomMode?: Maybe<RoomMode_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startTime?: Maybe<Order_By>;
  readonly transitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Event" */
export type Event_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Event" */
export enum Event_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  HallwayId = 'hallwayId',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Event" */
export type Event_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly durationSeconds?: Maybe<Scalars['Int']>;
  readonly endTime?: Maybe<Scalars['timestamptz']>;
  readonly hallwayId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly intendedRoomModeName?: Maybe<RoomMode_Enum>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startTime?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Event_Stddev_Fields = {
  readonly __typename?: 'Event_stddev_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Event" */
export type Event_Stddev_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Event_Stddev_Pop_Fields = {
  readonly __typename?: 'Event_stddev_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Event" */
export type Event_Stddev_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Event_Stddev_Samp_Fields = {
  readonly __typename?: 'Event_stddev_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Event" */
export type Event_Stddev_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Event_Sum_Fields = {
  readonly __typename?: 'Event_sum_fields';
  readonly durationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Event" */
export type Event_Sum_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** update columns of table "Event" */
export enum Event_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  DurationSeconds = 'durationSeconds',
  /** column name */
  EndTime = 'endTime',
  /** column name */
  HallwayId = 'hallwayId',
  /** column name */
  Id = 'id',
  /** column name */
  IntendedRoomModeName = 'intendedRoomModeName',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartTime = 'startTime',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Event_Var_Pop_Fields = {
  readonly __typename?: 'Event_var_pop_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Event" */
export type Event_Var_Pop_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Event_Var_Samp_Fields = {
  readonly __typename?: 'Event_var_samp_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Event" */
export type Event_Var_Samp_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Event_Variance_Fields = {
  readonly __typename?: 'Event_variance_fields';
  readonly durationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Event" */
export type Event_Variance_Order_By = {
  readonly durationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "ExecutedTransitions" */
export type ExecutedTransitions = {
  readonly __typename?: 'ExecutedTransitions';
  readonly broadcastContentId: Scalars['uuid'];
  /** An object relationship */
  readonly broadcastContentItem: BroadcastContentItem;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  readonly time: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate = {
  readonly __typename?: 'ExecutedTransitions_aggregate';
  readonly aggregate?: Maybe<ExecutedTransitions_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<ExecutedTransitions>;
};

/** aggregate fields of "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate_Fields = {
  readonly __typename?: 'ExecutedTransitions_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<ExecutedTransitions_Max_Fields>;
  readonly min?: Maybe<ExecutedTransitions_Min_Fields>;
};


/** aggregate fields of "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ExecutedTransitions" */
export type ExecutedTransitions_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<ExecutedTransitions_Max_Order_By>;
  readonly min?: Maybe<ExecutedTransitions_Min_Order_By>;
};

/** input type for inserting array relation for remote table "ExecutedTransitions" */
export type ExecutedTransitions_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<ExecutedTransitions_Insert_Input>;
  readonly on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};

/** Boolean expression to filter rows from the table "ExecutedTransitions". All fields are combined with a logical 'AND'. */
export type ExecutedTransitions_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<ExecutedTransitions_Bool_Exp>>>;
  readonly _not?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<ExecutedTransitions_Bool_Exp>>>;
  readonly broadcastContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly time?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "ExecutedTransitions" */
export enum ExecutedTransitions_Constraint {
  /** unique or primary key constraint */
  ExecutedTransitionsPkey = 'ExecutedTransitions_pkey'
}

/** input type for inserting data into table "ExecutedTransitions" */
export type ExecutedTransitions_Insert_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type ExecutedTransitions_Max_Fields = {
  readonly __typename?: 'ExecutedTransitions_max_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "ExecutedTransitions" */
export type ExecutedTransitions_Max_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type ExecutedTransitions_Min_Fields = {
  readonly __typename?: 'ExecutedTransitions_min_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "ExecutedTransitions" */
export type ExecutedTransitions_Min_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "ExecutedTransitions" */
export type ExecutedTransitions_Mutation_Response = {
  readonly __typename?: 'ExecutedTransitions_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<ExecutedTransitions>;
};

/** input type for inserting object relation for remote table "ExecutedTransitions" */
export type ExecutedTransitions_Obj_Rel_Insert_Input = {
  readonly data: ExecutedTransitions_Insert_Input;
  readonly on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};

/** on conflict condition type for table "ExecutedTransitions" */
export type ExecutedTransitions_On_Conflict = {
  readonly constraint: ExecutedTransitions_Constraint;
  readonly update_columns: ReadonlyArray<ExecutedTransitions_Update_Column>;
  readonly where?: Maybe<ExecutedTransitions_Bool_Exp>;
};

/** ordering options when selecting data from "ExecutedTransitions" */
export type ExecutedTransitions_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "ExecutedTransitions" */
export type ExecutedTransitions_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "ExecutedTransitions" */
export enum ExecutedTransitions_Select_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "ExecutedTransitions" */
export type ExecutedTransitions_Set_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "ExecutedTransitions" */
export enum ExecutedTransitions_Update_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "FlatUnauthPermission" */
export type FlatUnauthPermission = {
  readonly __typename?: 'FlatUnauthPermission';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate = {
  readonly __typename?: 'FlatUnauthPermission_aggregate';
  readonly aggregate?: Maybe<FlatUnauthPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUnauthPermission>;
};

/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUnauthPermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<FlatUnauthPermission_Max_Fields>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Fields>;
};


/** aggregate fields of "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUnauthPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUnauthPermission_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "FlatUnauthPermission". All fields are combined with a logical 'AND'. */
export type FlatUnauthPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<FlatUnauthPermission_Bool_Exp>>>;
  readonly _not?: Maybe<FlatUnauthPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<FlatUnauthPermission_Bool_Exp>>>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type FlatUnauthPermission_Max_Fields = {
  readonly __typename?: 'FlatUnauthPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUnauthPermission_Min_Fields = {
  readonly __typename?: 'FlatUnauthPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUnauthPermission" */
export type FlatUnauthPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** ordering options when selecting data from "FlatUnauthPermission" */
export type FlatUnauthPermission_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
};

/** select columns of table "FlatUnauthPermission" */
export enum FlatUnauthPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug'
}

/** columns and relationships of "FlatUserPermission" */
export type FlatUserPermission = {
  readonly __typename?: 'FlatUserPermission';
  /** An object relationship */
  readonly conference?: Maybe<Conference>;
  /** An object relationship */
  readonly permission?: Maybe<Permission>;
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly user?: Maybe<User>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** aggregated selection of "FlatUserPermission" */
export type FlatUserPermission_Aggregate = {
  readonly __typename?: 'FlatUserPermission_aggregate';
  readonly aggregate?: Maybe<FlatUserPermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<FlatUserPermission>;
};

/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Fields = {
  readonly __typename?: 'FlatUserPermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<FlatUserPermission_Max_Fields>;
  readonly min?: Maybe<FlatUserPermission_Min_Fields>;
};


/** aggregate fields of "FlatUserPermission" */
export type FlatUserPermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "FlatUserPermission" */
export type FlatUserPermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<FlatUserPermission_Max_Order_By>;
  readonly min?: Maybe<FlatUserPermission_Min_Order_By>;
};

/** Boolean expression to filter rows from the table "FlatUserPermission". All fields are combined with a logical 'AND'. */
export type FlatUserPermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<FlatUserPermission_Bool_Exp>>>;
  readonly _not?: Maybe<FlatUserPermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<FlatUserPermission_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly permission?: Maybe<Permission_Bool_Exp>;
  readonly permission_name?: Maybe<String_Comparison_Exp>;
  readonly slug?: Maybe<String_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly user_id?: Maybe<String_Comparison_Exp>;
};

/** aggregate max on columns */
export type FlatUserPermission_Max_Fields = {
  readonly __typename?: 'FlatUserPermission_max_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Max_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type FlatUserPermission_Min_Fields = {
  readonly __typename?: 'FlatUserPermission_min_fields';
  readonly permission_name?: Maybe<Scalars['String']>;
  readonly slug?: Maybe<Scalars['String']>;
  readonly user_id?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "FlatUserPermission" */
export type FlatUserPermission_Min_Order_By = {
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** ordering options when selecting data from "FlatUserPermission" */
export type FlatUserPermission_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly permission?: Maybe<Permission_Order_By>;
  readonly permission_name?: Maybe<Order_By>;
  readonly slug?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly user_id?: Maybe<Order_By>;
};

/** select columns of table "FlatUserPermission" */
export enum FlatUserPermission_Select_Column {
  /** column name */
  PermissionName = 'permission_name',
  /** column name */
  Slug = 'slug',
  /** column name */
  UserId = 'user_id'
}

/** expression to compare columns of type Float. All fields are combined with logical 'AND'. */
export type Float_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Float']>;
  readonly _gt?: Maybe<Scalars['Float']>;
  readonly _gte?: Maybe<Scalars['Float']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Float']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Float']>;
  readonly _lte?: Maybe<Scalars['Float']>;
  readonly _neq?: Maybe<Scalars['Float']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Float']>>;
};

export type GenerateChatRemoteServiceIdsOutput = {
  readonly __typename?: 'GenerateChatRemoteServiceIdsOutput';
  readonly error?: Maybe<Scalars['String']>;
};

export type GenerateChatRemoteUserIdsOutput = {
  readonly __typename?: 'GenerateChatRemoteUserIdsOutput';
  readonly error?: Maybe<Scalars['String']>;
};

export type GetContentItemOutput = {
  readonly __typename?: 'GetContentItemOutput';
  readonly contentGroupTitle: Scalars['String'];
  readonly contentTypeName: Scalars['String'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['String'];
  readonly layoutData?: Maybe<Scalars['jsonb']>;
  readonly name: Scalars['String'];
};

export type GetGoogleOAuthUrlOutput = {
  readonly __typename?: 'GetGoogleOAuthUrlOutput';
  readonly url: Scalars['String'];
};

export type GetUploadAgreementOutput = {
  readonly __typename?: 'GetUploadAgreementOutput';
  readonly agreementText?: Maybe<Scalars['String']>;
};

/** columns and relationships of "Group" */
export type Group = {
  readonly __typename?: 'Group';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly enabled: Scalars['Boolean'];
  /** An array relationship */
  readonly groupAttendees: ReadonlyArray<GroupAttendee>;
  /** An aggregated array relationship */
  readonly groupAttendees_aggregate: GroupAttendee_Aggregate;
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<GroupRole>;
  /** An aggregated array relationship */
  readonly groupRoles_aggregate: GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly includeUnauthenticated: Scalars['Boolean'];
  readonly name: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Group" */
export type GroupGroupAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Group" */
export type GroupGroupAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** columns and relationships of "Group" */
export type GroupGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** columns and relationships of "Group" */
export type GroupGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};

/** columns and relationships of "GroupAttendee" */
export type GroupAttendee = {
  readonly __typename?: 'GroupAttendee';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "GroupAttendee" */
export type GroupAttendee_Aggregate = {
  readonly __typename?: 'GroupAttendee_aggregate';
  readonly aggregate?: Maybe<GroupAttendee_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<GroupAttendee>;
};

/** aggregate fields of "GroupAttendee" */
export type GroupAttendee_Aggregate_Fields = {
  readonly __typename?: 'GroupAttendee_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<GroupAttendee_Max_Fields>;
  readonly min?: Maybe<GroupAttendee_Min_Fields>;
};


/** aggregate fields of "GroupAttendee" */
export type GroupAttendee_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "GroupAttendee" */
export type GroupAttendee_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<GroupAttendee_Max_Order_By>;
  readonly min?: Maybe<GroupAttendee_Min_Order_By>;
};

/** input type for inserting array relation for remote table "GroupAttendee" */
export type GroupAttendee_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<GroupAttendee_Insert_Input>;
  readonly on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};

/** Boolean expression to filter rows from the table "GroupAttendee". All fields are combined with a logical 'AND'. */
export type GroupAttendee_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<GroupAttendee_Bool_Exp>>>;
  readonly _not?: Maybe<GroupAttendee_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<GroupAttendee_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "GroupAttendee" */
export enum GroupAttendee_Constraint {
  /** unique or primary key constraint */
  GroupAttendeeGroupIdAttendeeIdKey = 'GroupAttendee_groupId_attendeeId_key',
  /** unique or primary key constraint */
  GroupAttendeePkey = 'GroupAttendee_pkey'
}

/** input type for inserting data into table "GroupAttendee" */
export type GroupAttendee_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type GroupAttendee_Max_Fields = {
  readonly __typename?: 'GroupAttendee_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "GroupAttendee" */
export type GroupAttendee_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type GroupAttendee_Min_Fields = {
  readonly __typename?: 'GroupAttendee_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "GroupAttendee" */
export type GroupAttendee_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "GroupAttendee" */
export type GroupAttendee_Mutation_Response = {
  readonly __typename?: 'GroupAttendee_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<GroupAttendee>;
};

/** input type for inserting object relation for remote table "GroupAttendee" */
export type GroupAttendee_Obj_Rel_Insert_Input = {
  readonly data: GroupAttendee_Insert_Input;
  readonly on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};

/** on conflict condition type for table "GroupAttendee" */
export type GroupAttendee_On_Conflict = {
  readonly constraint: GroupAttendee_Constraint;
  readonly update_columns: ReadonlyArray<GroupAttendee_Update_Column>;
  readonly where?: Maybe<GroupAttendee_Bool_Exp>;
};

/** ordering options when selecting data from "GroupAttendee" */
export type GroupAttendee_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "GroupAttendee" */
export type GroupAttendee_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "GroupAttendee" */
export enum GroupAttendee_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "GroupAttendee" */
export type GroupAttendee_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "GroupAttendee" */
export enum GroupAttendee_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "GroupRole" */
export type GroupRole = {
  readonly __typename?: 'GroupRole';
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly group: Group;
  readonly groupId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly role: Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "GroupRole" */
export type GroupRole_Aggregate = {
  readonly __typename?: 'GroupRole_aggregate';
  readonly aggregate?: Maybe<GroupRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<GroupRole>;
};

/** aggregate fields of "GroupRole" */
export type GroupRole_Aggregate_Fields = {
  readonly __typename?: 'GroupRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<GroupRole_Max_Fields>;
  readonly min?: Maybe<GroupRole_Min_Fields>;
};


/** aggregate fields of "GroupRole" */
export type GroupRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "GroupRole" */
export type GroupRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<GroupRole_Max_Order_By>;
  readonly min?: Maybe<GroupRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "GroupRole" */
export type GroupRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<GroupRole_Insert_Input>;
  readonly on_conflict?: Maybe<GroupRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "GroupRole". All fields are combined with a logical 'AND'. */
export type GroupRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<GroupRole_Bool_Exp>>>;
  readonly _not?: Maybe<GroupRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<GroupRole_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly group?: Maybe<Group_Bool_Exp>;
  readonly groupId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly role?: Maybe<Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "GroupRole" */
export enum GroupRole_Constraint {
  /** unique or primary key constraint */
  GroupRoleGroupIdRoleIdKey = 'GroupRole_groupId_roleId_key',
  /** unique or primary key constraint */
  GroupRolePkey = 'GroupRole_pkey'
}

/** input type for inserting data into table "GroupRole" */
export type GroupRole_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly group?: Maybe<Group_Obj_Rel_Insert_Input>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly role?: Maybe<Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type GroupRole_Max_Fields = {
  readonly __typename?: 'GroupRole_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "GroupRole" */
export type GroupRole_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type GroupRole_Min_Fields = {
  readonly __typename?: 'GroupRole_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "GroupRole" */
export type GroupRole_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "GroupRole" */
export type GroupRole_Mutation_Response = {
  readonly __typename?: 'GroupRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<GroupRole>;
};

/** input type for inserting object relation for remote table "GroupRole" */
export type GroupRole_Obj_Rel_Insert_Input = {
  readonly data: GroupRole_Insert_Input;
  readonly on_conflict?: Maybe<GroupRole_On_Conflict>;
};

/** on conflict condition type for table "GroupRole" */
export type GroupRole_On_Conflict = {
  readonly constraint: GroupRole_Constraint;
  readonly update_columns: ReadonlyArray<GroupRole_Update_Column>;
  readonly where?: Maybe<GroupRole_Bool_Exp>;
};

/** ordering options when selecting data from "GroupRole" */
export type GroupRole_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly group?: Maybe<Group_Order_By>;
  readonly groupId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly role?: Maybe<Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "GroupRole" */
export type GroupRole_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "GroupRole" */
export enum GroupRole_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "GroupRole" */
export type GroupRole_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "GroupRole" */
export enum GroupRole_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  GroupId = 'groupId',
  /** column name */
  Id = 'id',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Group" */
export type Group_Aggregate = {
  readonly __typename?: 'Group_aggregate';
  readonly aggregate?: Maybe<Group_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Group>;
};

/** aggregate fields of "Group" */
export type Group_Aggregate_Fields = {
  readonly __typename?: 'Group_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Group_Max_Fields>;
  readonly min?: Maybe<Group_Min_Fields>;
};


/** aggregate fields of "Group" */
export type Group_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Group_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Group" */
export type Group_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Group_Max_Order_By>;
  readonly min?: Maybe<Group_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Group" */
export type Group_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Group_Insert_Input>;
  readonly on_conflict?: Maybe<Group_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Group". All fields are combined with a logical 'AND'. */
export type Group_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Group_Bool_Exp>>>;
  readonly _not?: Maybe<Group_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Group_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly enabled?: Maybe<Boolean_Comparison_Exp>;
  readonly groupAttendees?: Maybe<GroupAttendee_Bool_Exp>;
  readonly groupRoles?: Maybe<GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly includeUnauthenticated?: Maybe<Boolean_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Group" */
export enum Group_Constraint {
  /** unique or primary key constraint */
  GroupConferenceIdNameKey = 'Group_conferenceId_name_key',
  /** unique or primary key constraint */
  GroupPkey = 'Group_pkey'
}

/** input type for inserting data into table "Group" */
export type Group_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly groupAttendees?: Maybe<GroupAttendee_Arr_Rel_Insert_Input>;
  readonly groupRoles?: Maybe<GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Group_Max_Fields = {
  readonly __typename?: 'Group_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Group" */
export type Group_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Group_Min_Fields = {
  readonly __typename?: 'Group_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Group" */
export type Group_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Group" */
export type Group_Mutation_Response = {
  readonly __typename?: 'Group_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Group>;
};

/** input type for inserting object relation for remote table "Group" */
export type Group_Obj_Rel_Insert_Input = {
  readonly data: Group_Insert_Input;
  readonly on_conflict?: Maybe<Group_On_Conflict>;
};

/** on conflict condition type for table "Group" */
export type Group_On_Conflict = {
  readonly constraint: Group_Constraint;
  readonly update_columns: ReadonlyArray<Group_Update_Column>;
  readonly where?: Maybe<Group_Bool_Exp>;
};

/** ordering options when selecting data from "Group" */
export type Group_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly enabled?: Maybe<Order_By>;
  readonly groupAttendees_aggregate?: Maybe<GroupAttendee_Aggregate_Order_By>;
  readonly groupRoles_aggregate?: Maybe<GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly includeUnauthenticated?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Group" */
export type Group_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Group" */
export enum Group_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Group" */
export type Group_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly enabled?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly includeUnauthenticated?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Group" */
export enum Group_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Enabled = 'enabled',
  /** column name */
  Id = 'id',
  /** column name */
  IncludeUnauthenticated = 'includeUnauthenticated',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "Hallway" */
export type Hallway = {
  readonly __typename?: 'Hallway';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroupHallway>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroupHallway_Aggregate;
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  readonly priority: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "Hallway" */
export type HallwayContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** columns and relationships of "Hallway" */
export type HallwayContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};

/** aggregated selection of "Hallway" */
export type Hallway_Aggregate = {
  readonly __typename?: 'Hallway_aggregate';
  readonly aggregate?: Maybe<Hallway_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Hallway>;
};

/** aggregate fields of "Hallway" */
export type Hallway_Aggregate_Fields = {
  readonly __typename?: 'Hallway_aggregate_fields';
  readonly avg?: Maybe<Hallway_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Hallway_Max_Fields>;
  readonly min?: Maybe<Hallway_Min_Fields>;
  readonly stddev?: Maybe<Hallway_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Hallway_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Hallway_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Hallway_Sum_Fields>;
  readonly var_pop?: Maybe<Hallway_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Hallway_Var_Samp_Fields>;
  readonly variance?: Maybe<Hallway_Variance_Fields>;
};


/** aggregate fields of "Hallway" */
export type Hallway_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Hallway" */
export type Hallway_Aggregate_Order_By = {
  readonly avg?: Maybe<Hallway_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Hallway_Max_Order_By>;
  readonly min?: Maybe<Hallway_Min_Order_By>;
  readonly stddev?: Maybe<Hallway_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Hallway_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Hallway_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Hallway_Sum_Order_By>;
  readonly var_pop?: Maybe<Hallway_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Hallway_Var_Samp_Order_By>;
  readonly variance?: Maybe<Hallway_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Hallway" */
export type Hallway_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Hallway_Insert_Input>;
  readonly on_conflict?: Maybe<Hallway_On_Conflict>;
};

/** aggregate avg on columns */
export type Hallway_Avg_Fields = {
  readonly __typename?: 'Hallway_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Hallway" */
export type Hallway_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Hallway". All fields are combined with a logical 'AND'. */
export type Hallway_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Hallway_Bool_Exp>>>;
  readonly _not?: Maybe<Hallway_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Hallway_Bool_Exp>>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroups?: Maybe<ContentGroupHallway_Bool_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Hallway" */
export enum Hallway_Constraint {
  /** unique or primary key constraint */
  HallwayNameConferenceIdKey = 'Hallway_name_conferenceId_key',
  /** unique or primary key constraint */
  HallwayPkey = 'Hallway_pkey'
}

/** input type for incrementing integer column in table "Hallway" */
export type Hallway_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Hallway" */
export type Hallway_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroups?: Maybe<ContentGroupHallway_Arr_Rel_Insert_Input>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Hallway_Max_Fields = {
  readonly __typename?: 'Hallway_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Hallway" */
export type Hallway_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Hallway_Min_Fields = {
  readonly __typename?: 'Hallway_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Hallway" */
export type Hallway_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "Hallway" */
export type Hallway_Mutation_Response = {
  readonly __typename?: 'Hallway_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Hallway>;
};

/** input type for inserting object relation for remote table "Hallway" */
export type Hallway_Obj_Rel_Insert_Input = {
  readonly data: Hallway_Insert_Input;
  readonly on_conflict?: Maybe<Hallway_On_Conflict>;
};

/** on conflict condition type for table "Hallway" */
export type Hallway_On_Conflict = {
  readonly constraint: Hallway_Constraint;
  readonly update_columns: ReadonlyArray<Hallway_Update_Column>;
  readonly where?: Maybe<Hallway_Bool_Exp>;
};

/** ordering options when selecting data from "Hallway" */
export type Hallway_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroups_aggregate?: Maybe<ContentGroupHallway_Aggregate_Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "Hallway" */
export type Hallway_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Hallway" */
export enum Hallway_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "Hallway" */
export type Hallway_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Hallway_Stddev_Fields = {
  readonly __typename?: 'Hallway_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Hallway" */
export type Hallway_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Hallway_Stddev_Pop_Fields = {
  readonly __typename?: 'Hallway_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Hallway" */
export type Hallway_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Hallway_Stddev_Samp_Fields = {
  readonly __typename?: 'Hallway_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Hallway" */
export type Hallway_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Hallway_Sum_Fields = {
  readonly __typename?: 'Hallway_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Hallway" */
export type Hallway_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "Hallway" */
export enum Hallway_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Hallway_Var_Pop_Fields = {
  readonly __typename?: 'Hallway_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Hallway" */
export type Hallway_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Hallway_Var_Samp_Fields = {
  readonly __typename?: 'Hallway_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Hallway" */
export type Hallway_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Hallway_Variance_Fields = {
  readonly __typename?: 'Hallway_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Hallway" */
export type Hallway_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "InputType" */
export type InputType = {
  readonly __typename?: 'InputType';
  /** An array relationship */
  readonly broadcastContentItems: ReadonlyArray<BroadcastContentItem>;
  /** An aggregated array relationship */
  readonly broadcastContentItems_aggregate: BroadcastContentItem_Aggregate;
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};


/** columns and relationships of "InputType" */
export type InputTypeBroadcastContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** columns and relationships of "InputType" */
export type InputTypeBroadcastContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};

/** aggregated selection of "InputType" */
export type InputType_Aggregate = {
  readonly __typename?: 'InputType_aggregate';
  readonly aggregate?: Maybe<InputType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<InputType>;
};

/** aggregate fields of "InputType" */
export type InputType_Aggregate_Fields = {
  readonly __typename?: 'InputType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<InputType_Max_Fields>;
  readonly min?: Maybe<InputType_Min_Fields>;
};


/** aggregate fields of "InputType" */
export type InputType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "InputType" */
export type InputType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<InputType_Max_Order_By>;
  readonly min?: Maybe<InputType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "InputType" */
export type InputType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<InputType_Insert_Input>;
  readonly on_conflict?: Maybe<InputType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "InputType". All fields are combined with a logical 'AND'. */
export type InputType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<InputType_Bool_Exp>>>;
  readonly _not?: Maybe<InputType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<InputType_Bool_Exp>>>;
  readonly broadcastContentItems?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "InputType" */
export enum InputType_Constraint {
  /** unique or primary key constraint */
  InputTypeNamePkey = 'InputTypeName_pkey'
}

export enum InputType_Enum {
  /** GIF image. */
  Gif = 'GIF',
  /** JPEG image (jay-peg). */
  Jpeg = 'JPEG',
  /** MP4 video file. */
  Mp4 = 'MP4',
  /** PNG image. */
  Png = 'PNG',
  /** RTMP stream in push mode. */
  RtmpPush = 'RTMP_PUSH',
  /** RTMP push from a Vonage Video API session. */
  VonageSession = 'VONAGE_SESSION'
}

/** expression to compare columns of type InputType_enum. All fields are combined with logical 'AND'. */
export type InputType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<InputType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<InputType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<InputType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<InputType_Enum>>;
};

/** input type for inserting data into table "InputType" */
export type InputType_Insert_Input = {
  readonly broadcastContentItems?: Maybe<BroadcastContentItem_Arr_Rel_Insert_Input>;
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type InputType_Max_Fields = {
  readonly __typename?: 'InputType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "InputType" */
export type InputType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type InputType_Min_Fields = {
  readonly __typename?: 'InputType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "InputType" */
export type InputType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "InputType" */
export type InputType_Mutation_Response = {
  readonly __typename?: 'InputType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<InputType>;
};

/** input type for inserting object relation for remote table "InputType" */
export type InputType_Obj_Rel_Insert_Input = {
  readonly data: InputType_Insert_Input;
  readonly on_conflict?: Maybe<InputType_On_Conflict>;
};

/** on conflict condition type for table "InputType" */
export type InputType_On_Conflict = {
  readonly constraint: InputType_Constraint;
  readonly update_columns: ReadonlyArray<InputType_Update_Column>;
  readonly where?: Maybe<InputType_Bool_Exp>;
};

/** ordering options when selecting data from "InputType" */
export type InputType_Order_By = {
  readonly broadcastContentItems_aggregate?: Maybe<BroadcastContentItem_Aggregate_Order_By>;
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "InputType" */
export type InputType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "InputType" */
export enum InputType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "InputType" */
export type InputType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "InputType" */
export enum InputType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** expression to compare columns of type Int. All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['Int']>;
  readonly _gt?: Maybe<Scalars['Int']>;
  readonly _gte?: Maybe<Scalars['Int']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['Int']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['Int']>;
  readonly _lte?: Maybe<Scalars['Int']>;
  readonly _neq?: Maybe<Scalars['Int']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['Int']>>;
};

/** columns and relationships of "Invitation" */
export type Invitation = {
  readonly __typename?: 'Invitation';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly conferenceId: Scalars['uuid'];
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregated array relationship */
  readonly emails_aggregate: Email_Aggregate;
  /** A computed field, executes function "invitationhash" */
  readonly hash?: Maybe<Scalars['String']>;
  readonly id: Scalars['uuid'];
  readonly inviteCode: Scalars['uuid'];
  readonly invitedEmailAddress: Scalars['String'];
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user?: Maybe<User>;
};


/** columns and relationships of "Invitation" */
export type InvitationEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "Invitation" */
export type InvitationEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};

export type InvitationConfirmationEmailInput = {
  readonly inviteCode: Scalars['uuid'];
};

export type InvitationConfirmationEmailOutput = {
  readonly __typename?: 'InvitationConfirmationEmailOutput';
  readonly sent: Scalars['Boolean'];
};

export type InvitationSendEmailResult = {
  readonly __typename?: 'InvitationSendEmailResult';
  readonly attendeeId: Scalars['String'];
  readonly sent: Scalars['Boolean'];
};

/** aggregated selection of "Invitation" */
export type Invitation_Aggregate = {
  readonly __typename?: 'Invitation_aggregate';
  readonly aggregate?: Maybe<Invitation_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Invitation>;
};

/** aggregate fields of "Invitation" */
export type Invitation_Aggregate_Fields = {
  readonly __typename?: 'Invitation_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Invitation_Max_Fields>;
  readonly min?: Maybe<Invitation_Min_Fields>;
};


/** aggregate fields of "Invitation" */
export type Invitation_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Invitation" */
export type Invitation_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Invitation_Max_Order_By>;
  readonly min?: Maybe<Invitation_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Invitation" */
export type Invitation_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Invitation_Insert_Input>;
  readonly on_conflict?: Maybe<Invitation_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Invitation". All fields are combined with a logical 'AND'. */
export type Invitation_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Invitation_Bool_Exp>>>;
  readonly _not?: Maybe<Invitation_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Invitation_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly confirmationCode?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly inviteCode?: Maybe<Uuid_Comparison_Exp>;
  readonly invitedEmailAddress?: Maybe<String_Comparison_Exp>;
  readonly linkToUserId?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
};

/** unique or primary key constraints on table "Invitation" */
export enum Invitation_Constraint {
  /** unique or primary key constraint */
  InivitationAttendeeIdKey = 'Inivitation_attendeeId_key',
  /** unique or primary key constraint */
  InivitationConfirmationCodeKey = 'Inivitation_confirmationCode_key',
  /** unique or primary key constraint */
  InivitationInviteCodeKey = 'Inivitation_inviteCode_key',
  /** unique or primary key constraint */
  InivitationPkey = 'Inivitation_pkey',
  /** unique or primary key constraint */
  InvitationInvitedEmailAddressConferenceIdKey = 'Invitation_invitedEmailAddress_conferenceId_key'
}

/** input type for inserting data into table "Invitation" */
export type Invitation_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Invitation_Max_Fields = {
  readonly __typename?: 'Invitation_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Invitation" */
export type Invitation_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Invitation_Min_Fields = {
  readonly __typename?: 'Invitation_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Invitation" */
export type Invitation_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Invitation" */
export type Invitation_Mutation_Response = {
  readonly __typename?: 'Invitation_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Invitation>;
};

/** input type for inserting object relation for remote table "Invitation" */
export type Invitation_Obj_Rel_Insert_Input = {
  readonly data: Invitation_Insert_Input;
  readonly on_conflict?: Maybe<Invitation_On_Conflict>;
};

/** on conflict condition type for table "Invitation" */
export type Invitation_On_Conflict = {
  readonly constraint: Invitation_Constraint;
  readonly update_columns: ReadonlyArray<Invitation_Update_Column>;
  readonly where?: Maybe<Invitation_Bool_Exp>;
};

/** ordering options when selecting data from "Invitation" */
export type Invitation_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly confirmationCode?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly inviteCode?: Maybe<Order_By>;
  readonly invitedEmailAddress?: Maybe<Order_By>;
  readonly linkToUserId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
};

/** primary key columns input for table: "Invitation" */
export type Invitation_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Invitation" */
export enum Invitation_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Invitation" */
export type Invitation_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly confirmationCode?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly inviteCode?: Maybe<Scalars['uuid']>;
  readonly invitedEmailAddress?: Maybe<Scalars['String']>;
  readonly linkToUserId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Invitation" */
export enum Invitation_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConfirmationCode = 'confirmationCode',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  InviteCode = 'inviteCode',
  /** column name */
  InvitedEmailAddress = 'invitedEmailAddress',
  /** column name */
  LinkToUserId = 'linkToUserId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "JobStatus" */
export type JobStatus = {
  readonly __typename?: 'JobStatus';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "JobStatus" */
export type JobStatus_Aggregate = {
  readonly __typename?: 'JobStatus_aggregate';
  readonly aggregate?: Maybe<JobStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<JobStatus>;
};

/** aggregate fields of "JobStatus" */
export type JobStatus_Aggregate_Fields = {
  readonly __typename?: 'JobStatus_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<JobStatus_Max_Fields>;
  readonly min?: Maybe<JobStatus_Min_Fields>;
};


/** aggregate fields of "JobStatus" */
export type JobStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "JobStatus" */
export type JobStatus_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<JobStatus_Max_Order_By>;
  readonly min?: Maybe<JobStatus_Min_Order_By>;
};

/** input type for inserting array relation for remote table "JobStatus" */
export type JobStatus_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<JobStatus_Insert_Input>;
  readonly on_conflict?: Maybe<JobStatus_On_Conflict>;
};

/** Boolean expression to filter rows from the table "JobStatus". All fields are combined with a logical 'AND'. */
export type JobStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<JobStatus_Bool_Exp>>>;
  readonly _not?: Maybe<JobStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<JobStatus_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "JobStatus" */
export enum JobStatus_Constraint {
  /** unique or primary key constraint */
  JobStatusPkey = 'JobStatus_pkey'
}

export enum JobStatus_Enum {
  /** Job completed successfully. */
  Completed = 'COMPLETED',
  /** Job is no longer valid. */
  Expired = 'EXPIRED',
  /** Job failed during execution. */
  Failed = 'FAILED',
  /** Job is currently in progress. */
  InProgress = 'IN_PROGRESS',
  /** Job has not yet started execution. */
  New = 'NEW'
}

/** expression to compare columns of type JobStatus_enum. All fields are combined with logical 'AND'. */
export type JobStatus_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<JobStatus_Enum>;
  readonly _in?: Maybe<ReadonlyArray<JobStatus_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<JobStatus_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<JobStatus_Enum>>;
};

/** input type for inserting data into table "JobStatus" */
export type JobStatus_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type JobStatus_Max_Fields = {
  readonly __typename?: 'JobStatus_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "JobStatus" */
export type JobStatus_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type JobStatus_Min_Fields = {
  readonly __typename?: 'JobStatus_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "JobStatus" */
export type JobStatus_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "JobStatus" */
export type JobStatus_Mutation_Response = {
  readonly __typename?: 'JobStatus_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<JobStatus>;
};

/** input type for inserting object relation for remote table "JobStatus" */
export type JobStatus_Obj_Rel_Insert_Input = {
  readonly data: JobStatus_Insert_Input;
  readonly on_conflict?: Maybe<JobStatus_On_Conflict>;
};

/** on conflict condition type for table "JobStatus" */
export type JobStatus_On_Conflict = {
  readonly constraint: JobStatus_Constraint;
  readonly update_columns: ReadonlyArray<JobStatus_Update_Column>;
  readonly where?: Maybe<JobStatus_Bool_Exp>;
};

/** ordering options when selecting data from "JobStatus" */
export type JobStatus_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "JobStatus" */
export type JobStatus_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "JobStatus" */
export enum JobStatus_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "JobStatus" */
export type JobStatus_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "JobStatus" */
export enum JobStatus_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

export type JoinEventVonageSessionOutput = {
  readonly __typename?: 'JoinEventVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
};

export type JoinRoomChimeSessionOutput = {
  readonly __typename?: 'JoinRoomChimeSessionOutput';
  readonly attendee?: Maybe<Scalars['jsonb']>;
  readonly meeting?: Maybe<Scalars['jsonb']>;
  readonly message?: Maybe<Scalars['String']>;
};

export type JoinRoomVonageSessionOutput = {
  readonly __typename?: 'JoinRoomVonageSessionOutput';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sessionId?: Maybe<Scalars['String']>;
};

/** columns and relationships of "MediaLiveChannel" */
export type MediaLiveChannel = {
  readonly __typename?: 'MediaLiveChannel';
  /** An object relationship */
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob>;
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId: Scalars['String'];
  readonly cloudFrontDomain: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly endpointUri: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly loopingMp4InputAttachmentName: Scalars['String'];
  readonly mediaLiveChannelId: Scalars['String'];
  readonly mediaPackageChannelId: Scalars['String'];
  readonly mp4InputAttachmentName: Scalars['String'];
  readonly mp4InputId: Scalars['String'];
  /** An object relationship */
  readonly room?: Maybe<Room>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpInputId: Scalars['String'];
  readonly rtmpInputUri: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageInputAttachmentName: Scalars['String'];
};

/** aggregated selection of "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate = {
  readonly __typename?: 'MediaLiveChannel_aggregate';
  readonly aggregate?: Maybe<MediaLiveChannel_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<MediaLiveChannel>;
};

/** aggregate fields of "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate_Fields = {
  readonly __typename?: 'MediaLiveChannel_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<MediaLiveChannel_Max_Fields>;
  readonly min?: Maybe<MediaLiveChannel_Min_Fields>;
};


/** aggregate fields of "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "MediaLiveChannel" */
export type MediaLiveChannel_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<MediaLiveChannel_Max_Order_By>;
  readonly min?: Maybe<MediaLiveChannel_Min_Order_By>;
};

/** input type for inserting array relation for remote table "MediaLiveChannel" */
export type MediaLiveChannel_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<MediaLiveChannel_Insert_Input>;
  readonly on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};

/** Boolean expression to filter rows from the table "MediaLiveChannel". All fields are combined with a logical 'AND'. */
export type MediaLiveChannel_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<MediaLiveChannel_Bool_Exp>>>;
  readonly _not?: Maybe<MediaLiveChannel_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<MediaLiveChannel_Bool_Exp>>>;
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly channelStackCreateJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly cloudFormationStackArn?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDistributionId?: Maybe<String_Comparison_Exp>;
  readonly cloudFrontDomain?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpointUri?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly loopingMp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mediaLiveChannelId?: Maybe<String_Comparison_Exp>;
  readonly mediaPackageChannelId?: Maybe<String_Comparison_Exp>;
  readonly mp4InputAttachmentName?: Maybe<String_Comparison_Exp>;
  readonly mp4InputId?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly rtmpInputId?: Maybe<String_Comparison_Exp>;
  readonly rtmpInputUri?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageInputAttachmentName?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "MediaLiveChannel" */
export enum MediaLiveChannel_Constraint {
  /** unique or primary key constraint */
  MediaLiveChannelPkey = 'MediaLiveChannel_pkey',
  /** unique or primary key constraint */
  MediaLiveChannelRoomIdKey = 'MediaLiveChannel_roomId_key'
}

/** input type for inserting data into table "MediaLiveChannel" */
export type MediaLiveChannel_Insert_Input = {
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Obj_Rel_Insert_Input>;
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type MediaLiveChannel_Max_Fields = {
  readonly __typename?: 'MediaLiveChannel_max_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "MediaLiveChannel" */
export type MediaLiveChannel_Max_Order_By = {
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpInputId?: Maybe<Order_By>;
  readonly rtmpInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageInputAttachmentName?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type MediaLiveChannel_Min_Fields = {
  readonly __typename?: 'MediaLiveChannel_min_fields';
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "MediaLiveChannel" */
export type MediaLiveChannel_Min_Order_By = {
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpInputId?: Maybe<Order_By>;
  readonly rtmpInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageInputAttachmentName?: Maybe<Order_By>;
};

/** response of any mutation on the table "MediaLiveChannel" */
export type MediaLiveChannel_Mutation_Response = {
  readonly __typename?: 'MediaLiveChannel_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<MediaLiveChannel>;
};

/** input type for inserting object relation for remote table "MediaLiveChannel" */
export type MediaLiveChannel_Obj_Rel_Insert_Input = {
  readonly data: MediaLiveChannel_Insert_Input;
  readonly on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};

/** on conflict condition type for table "MediaLiveChannel" */
export type MediaLiveChannel_On_Conflict = {
  readonly constraint: MediaLiveChannel_Constraint;
  readonly update_columns: ReadonlyArray<MediaLiveChannel_Update_Column>;
  readonly where?: Maybe<MediaLiveChannel_Bool_Exp>;
};

/** ordering options when selecting data from "MediaLiveChannel" */
export type MediaLiveChannel_Order_By = {
  readonly channelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Order_By>;
  readonly channelStackCreateJobId?: Maybe<Order_By>;
  readonly cloudFormationStackArn?: Maybe<Order_By>;
  readonly cloudFrontDistributionId?: Maybe<Order_By>;
  readonly cloudFrontDomain?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly endpointUri?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly loopingMp4InputAttachmentName?: Maybe<Order_By>;
  readonly mediaLiveChannelId?: Maybe<Order_By>;
  readonly mediaPackageChannelId?: Maybe<Order_By>;
  readonly mp4InputAttachmentName?: Maybe<Order_By>;
  readonly mp4InputId?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly rtmpInputId?: Maybe<Order_By>;
  readonly rtmpInputUri?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageInputAttachmentName?: Maybe<Order_By>;
};

/** primary key columns input for table: "MediaLiveChannel" */
export type MediaLiveChannel_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "MediaLiveChannel" */
export enum MediaLiveChannel_Select_Column {
  /** column name */
  ChannelStackCreateJobId = 'channelStackCreateJobId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RtmpInputId = 'rtmpInputId',
  /** column name */
  RtmpInputUri = 'rtmpInputUri',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageInputAttachmentName = 'vonageInputAttachmentName'
}

/** input type for updating data in table "MediaLiveChannel" */
export type MediaLiveChannel_Set_Input = {
  readonly channelStackCreateJobId?: Maybe<Scalars['uuid']>;
  readonly cloudFormationStackArn?: Maybe<Scalars['String']>;
  readonly cloudFrontDistributionId?: Maybe<Scalars['String']>;
  readonly cloudFrontDomain?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly endpointUri?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly loopingMp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mediaLiveChannelId?: Maybe<Scalars['String']>;
  readonly mediaPackageChannelId?: Maybe<Scalars['String']>;
  readonly mp4InputAttachmentName?: Maybe<Scalars['String']>;
  readonly mp4InputId?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly rtmpInputId?: Maybe<Scalars['String']>;
  readonly rtmpInputUri?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageInputAttachmentName?: Maybe<Scalars['String']>;
};

/** update columns of table "MediaLiveChannel" */
export enum MediaLiveChannel_Update_Column {
  /** column name */
  ChannelStackCreateJobId = 'channelStackCreateJobId',
  /** column name */
  CloudFormationStackArn = 'cloudFormationStackArn',
  /** column name */
  CloudFrontDistributionId = 'cloudFrontDistributionId',
  /** column name */
  CloudFrontDomain = 'cloudFrontDomain',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EndpointUri = 'endpointUri',
  /** column name */
  Id = 'id',
  /** column name */
  LoopingMp4InputAttachmentName = 'loopingMp4InputAttachmentName',
  /** column name */
  MediaLiveChannelId = 'mediaLiveChannelId',
  /** column name */
  MediaPackageChannelId = 'mediaPackageChannelId',
  /** column name */
  Mp4InputAttachmentName = 'mp4InputAttachmentName',
  /** column name */
  Mp4InputId = 'mp4InputId',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RtmpInputId = 'rtmpInputId',
  /** column name */
  RtmpInputUri = 'rtmpInputUri',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageInputAttachmentName = 'vonageInputAttachmentName'
}

/** columns and relationships of "OnlineStatus" */
export type OnlineStatus = {
  readonly __typename?: 'OnlineStatus';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly isIncognito: Scalars['Boolean'];
  readonly lastSeen: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly user: User;
  readonly userId: Scalars['String'];
};

/** aggregated selection of "OnlineStatus" */
export type OnlineStatus_Aggregate = {
  readonly __typename?: 'OnlineStatus_aggregate';
  readonly aggregate?: Maybe<OnlineStatus_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<OnlineStatus>;
};

/** aggregate fields of "OnlineStatus" */
export type OnlineStatus_Aggregate_Fields = {
  readonly __typename?: 'OnlineStatus_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<OnlineStatus_Max_Fields>;
  readonly min?: Maybe<OnlineStatus_Min_Fields>;
};


/** aggregate fields of "OnlineStatus" */
export type OnlineStatus_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "OnlineStatus" */
export type OnlineStatus_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<OnlineStatus_Max_Order_By>;
  readonly min?: Maybe<OnlineStatus_Min_Order_By>;
};

/** input type for inserting array relation for remote table "OnlineStatus" */
export type OnlineStatus_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<OnlineStatus_Insert_Input>;
  readonly on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};

/** Boolean expression to filter rows from the table "OnlineStatus". All fields are combined with a logical 'AND'. */
export type OnlineStatus_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<OnlineStatus_Bool_Exp>>>;
  readonly _not?: Maybe<OnlineStatus_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<OnlineStatus_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isIncognito?: Maybe<Boolean_Comparison_Exp>;
  readonly lastSeen?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "OnlineStatus" */
export enum OnlineStatus_Constraint {
  /** unique or primary key constraint */
  OnlineStatusPkey = 'OnlineStatus_pkey',
  /** unique or primary key constraint */
  OnlineStatusUserIdKey = 'OnlineStatus_userId_key'
}

/** input type for inserting data into table "OnlineStatus" */
export type OnlineStatus_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isIncognito?: Maybe<Scalars['Boolean']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type OnlineStatus_Max_Fields = {
  readonly __typename?: 'OnlineStatus_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "OnlineStatus" */
export type OnlineStatus_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastSeen?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type OnlineStatus_Min_Fields = {
  readonly __typename?: 'OnlineStatus_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "OnlineStatus" */
export type OnlineStatus_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastSeen?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "OnlineStatus" */
export type OnlineStatus_Mutation_Response = {
  readonly __typename?: 'OnlineStatus_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<OnlineStatus>;
};

/** input type for inserting object relation for remote table "OnlineStatus" */
export type OnlineStatus_Obj_Rel_Insert_Input = {
  readonly data: OnlineStatus_Insert_Input;
  readonly on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};

/** on conflict condition type for table "OnlineStatus" */
export type OnlineStatus_On_Conflict = {
  readonly constraint: OnlineStatus_Constraint;
  readonly update_columns: ReadonlyArray<OnlineStatus_Update_Column>;
  readonly where?: Maybe<OnlineStatus_Bool_Exp>;
};

/** ordering options when selecting data from "OnlineStatus" */
export type OnlineStatus_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isIncognito?: Maybe<Order_By>;
  readonly lastSeen?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "OnlineStatus" */
export type OnlineStatus_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "OnlineStatus" */
export enum OnlineStatus_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsIncognito = 'isIncognito',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "OnlineStatus" */
export type OnlineStatus_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isIncognito?: Maybe<Scalars['Boolean']>;
  readonly lastSeen?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "OnlineStatus" */
export enum OnlineStatus_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsIncognito = 'isIncognito',
  /** column name */
  LastSeen = 'lastSeen',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UserId = 'userId'
}

/** columns and relationships of "OriginatingData" */
export type OriginatingData = {
  readonly __typename?: 'OriginatingData';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroups: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroups_aggregate: ContentGroup_Aggregate;
  /** An array relationship */
  readonly contentItems: ReadonlyArray<ContentItem>;
  /** An aggregated array relationship */
  readonly contentItems_aggregate: ContentItem_Aggregate;
  /** An array relationship */
  readonly contentPeople: ReadonlyArray<ContentPerson>;
  /** An aggregated array relationship */
  readonly contentPeople_aggregate: ContentPerson_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly data?: Maybe<Scalars['jsonb']>;
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly requiredContentItems: ReadonlyArray<RequiredContentItem>;
  /** An aggregated array relationship */
  readonly requiredContentItems_aggregate: RequiredContentItem_Aggregate;
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
  readonly sourceId: Scalars['String'];
  /** An array relationship */
  readonly tags: ReadonlyArray<Tag>;
  /** An aggregated array relationship */
  readonly tags_aggregate: Tag_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentGroupsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentGroups_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataContentPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRequiredContentItemsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRequiredContentItems_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** columns and relationships of "OriginatingData" */
export type OriginatingDataTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};

/** aggregated selection of "OriginatingData" */
export type OriginatingData_Aggregate = {
  readonly __typename?: 'OriginatingData_aggregate';
  readonly aggregate?: Maybe<OriginatingData_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<OriginatingData>;
};

/** aggregate fields of "OriginatingData" */
export type OriginatingData_Aggregate_Fields = {
  readonly __typename?: 'OriginatingData_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<OriginatingData_Max_Fields>;
  readonly min?: Maybe<OriginatingData_Min_Fields>;
};


/** aggregate fields of "OriginatingData" */
export type OriginatingData_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "OriginatingData" */
export type OriginatingData_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<OriginatingData_Max_Order_By>;
  readonly min?: Maybe<OriginatingData_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type OriginatingData_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "OriginatingData" */
export type OriginatingData_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<OriginatingData_Insert_Input>;
  readonly on_conflict?: Maybe<OriginatingData_On_Conflict>;
};

/** Boolean expression to filter rows from the table "OriginatingData". All fields are combined with a logical 'AND'. */
export type OriginatingData_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<OriginatingData_Bool_Exp>>>;
  readonly _not?: Maybe<OriginatingData_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<OriginatingData_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroups?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentItems?: Maybe<ContentItem_Bool_Exp>;
  readonly contentPeople?: Maybe<ContentPerson_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
  readonly sourceId?: Maybe<String_Comparison_Exp>;
  readonly tags?: Maybe<Tag_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "OriginatingData" */
export enum OriginatingData_Constraint {
  /** unique or primary key constraint */
  OriginatingDataPkey = 'OriginatingData_pkey',
  /** unique or primary key constraint */
  OriginatingDataSourceIdConferenceIdKey = 'OriginatingData_sourceId_conferenceId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type OriginatingData_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type OriginatingData_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type OriginatingData_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "OriginatingData" */
export type OriginatingData_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroups?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly contentItems?: Maybe<ContentItem_Arr_Rel_Insert_Input>;
  readonly contentPeople?: Maybe<ContentPerson_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly requiredContentItems?: Maybe<RequiredContentItem_Arr_Rel_Insert_Input>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly tags?: Maybe<Tag_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type OriginatingData_Max_Fields = {
  readonly __typename?: 'OriginatingData_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "OriginatingData" */
export type OriginatingData_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type OriginatingData_Min_Fields = {
  readonly __typename?: 'OriginatingData_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "OriginatingData" */
export type OriginatingData_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "OriginatingData" */
export type OriginatingData_Mutation_Response = {
  readonly __typename?: 'OriginatingData_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<OriginatingData>;
};

/** input type for inserting object relation for remote table "OriginatingData" */
export type OriginatingData_Obj_Rel_Insert_Input = {
  readonly data: OriginatingData_Insert_Input;
  readonly on_conflict?: Maybe<OriginatingData_On_Conflict>;
};

/** on conflict condition type for table "OriginatingData" */
export type OriginatingData_On_Conflict = {
  readonly constraint: OriginatingData_Constraint;
  readonly update_columns: ReadonlyArray<OriginatingData_Update_Column>;
  readonly where?: Maybe<OriginatingData_Bool_Exp>;
};

/** ordering options when selecting data from "OriginatingData" */
export type OriginatingData_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroups_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly contentItems_aggregate?: Maybe<ContentItem_Aggregate_Order_By>;
  readonly contentPeople_aggregate?: Maybe<ContentPerson_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly requiredContentItems_aggregate?: Maybe<RequiredContentItem_Aggregate_Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly sourceId?: Maybe<Order_By>;
  readonly tags_aggregate?: Maybe<Tag_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "OriginatingData" */
export type OriginatingData_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type OriginatingData_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "OriginatingData" */
export enum OriginatingData_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "OriginatingData" */
export type OriginatingData_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly sourceId?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "OriginatingData" */
export enum OriginatingData_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "Permission" */
export type Permission = {
  readonly __typename?: 'Permission';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<RolePermission>;
  /** An aggregated array relationship */
  readonly rolePermissions_aggregate: RolePermission_Aggregate;
};


/** columns and relationships of "Permission" */
export type PermissionRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** columns and relationships of "Permission" */
export type PermissionRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};

/** aggregated selection of "Permission" */
export type Permission_Aggregate = {
  readonly __typename?: 'Permission_aggregate';
  readonly aggregate?: Maybe<Permission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Permission>;
};

/** aggregate fields of "Permission" */
export type Permission_Aggregate_Fields = {
  readonly __typename?: 'Permission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Permission_Max_Fields>;
  readonly min?: Maybe<Permission_Min_Fields>;
};


/** aggregate fields of "Permission" */
export type Permission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Permission" */
export type Permission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Permission_Max_Order_By>;
  readonly min?: Maybe<Permission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Permission" */
export type Permission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Permission_Insert_Input>;
  readonly on_conflict?: Maybe<Permission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Permission". All fields are combined with a logical 'AND'. */
export type Permission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Permission_Bool_Exp>>>;
  readonly _not?: Maybe<Permission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Permission_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<RolePermission_Bool_Exp>;
};

/** unique or primary key constraints on table "Permission" */
export enum Permission_Constraint {
  /** unique or primary key constraint */
  PermissionPkey = 'Permission_pkey'
}

export enum Permission_Enum {
  /** Manage (create/update/delete) conference attendees. */
  ConferenceManageAttendees = 'CONFERENCE_MANAGE_ATTENDEES',
  /** Manage Content tables. */
  ConferenceManageContent = 'CONFERENCE_MANAGE_CONTENT',
  /** Manage groups of a conference. */
  ConferenceManageGroups = 'CONFERENCE_MANAGE_GROUPS',
  /** Manage (update only) conference name, short name and slug. */
  ConferenceManageName = 'CONFERENCE_MANAGE_NAME',
  /** Manage roles of a conference. */
  ConferenceManageRoles = 'CONFERENCE_MANAGE_ROLES',
  /** Manage Schedule tables. */
  ConferenceManageSchedule = 'CONFERENCE_MANAGE_SCHEDULE',
  /** Manage shuffle periods. */
  ConferenceManageShuffle = 'CONFERENCE_MANAGE_SHUFFLE',
  /** Moderate (update only) conference attendees. */
  ConferenceModerateAttendees = 'CONFERENCE_MODERATE_ATTENDEES',
  /** View the conference. */
  ConferenceView = 'CONFERENCE_VIEW',
  /** View conference attendees. */
  ConferenceViewAttendees = 'CONFERENCE_VIEW_ATTENDEES'
}

/** expression to compare columns of type Permission_enum. All fields are combined with logical 'AND'. */
export type Permission_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Permission_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Permission_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Permission_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Permission_Enum>>;
};

/** input type for inserting data into table "Permission" */
export type Permission_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<RolePermission_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type Permission_Max_Fields = {
  readonly __typename?: 'Permission_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "Permission" */
export type Permission_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Permission_Min_Fields = {
  readonly __typename?: 'Permission_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "Permission" */
export type Permission_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "Permission" */
export type Permission_Mutation_Response = {
  readonly __typename?: 'Permission_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Permission>;
};

/** input type for inserting object relation for remote table "Permission" */
export type Permission_Obj_Rel_Insert_Input = {
  readonly data: Permission_Insert_Input;
  readonly on_conflict?: Maybe<Permission_On_Conflict>;
};

/** on conflict condition type for table "Permission" */
export type Permission_On_Conflict = {
  readonly constraint: Permission_Constraint;
  readonly update_columns: ReadonlyArray<Permission_Update_Column>;
  readonly where?: Maybe<Permission_Bool_Exp>;
};

/** ordering options when selecting data from "Permission" */
export type Permission_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<RolePermission_Aggregate_Order_By>;
};

/** primary key columns input for table: "Permission" */
export type Permission_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "Permission" */
export enum Permission_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "Permission" */
export type Permission_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "Permission" */
export enum Permission_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

export type PresenceFlushOutput = {
  readonly __typename?: 'PresenceFlushOutput';
  readonly ok?: Maybe<Scalars['String']>;
};

export type PresenceSummaryOutput = {
  readonly __typename?: 'PresenceSummaryOutput';
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs: Scalars['Int'];
  readonly total_unique_user_ids: Scalars['Int'];
};

export type ProfilePhotoUrlResponse = {
  readonly __typename?: 'ProfilePhotoURLResponse';
  readonly url: Scalars['String'];
};

export type ProtectedEchoOutput = {
  readonly __typename?: 'ProtectedEchoOutput';
  readonly message: Scalars['String'];
};

/** columns and relationships of "PushNotificationSubscription" */
export type PushNotificationSubscription = {
  readonly __typename?: 'PushNotificationSubscription';
  readonly auth: Scalars['String'];
  readonly created_at: Scalars['timestamptz'];
  readonly endpoint: Scalars['String'];
  readonly p256dh: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly user: User;
  readonly userId: Scalars['String'];
};

/** aggregated selection of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate = {
  readonly __typename?: 'PushNotificationSubscription_aggregate';
  readonly aggregate?: Maybe<PushNotificationSubscription_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<PushNotificationSubscription>;
};

/** aggregate fields of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_Fields = {
  readonly __typename?: 'PushNotificationSubscription_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<PushNotificationSubscription_Max_Fields>;
  readonly min?: Maybe<PushNotificationSubscription_Min_Fields>;
};


/** aggregate fields of "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<PushNotificationSubscription_Max_Order_By>;
  readonly min?: Maybe<PushNotificationSubscription_Min_Order_By>;
};

/** input type for inserting array relation for remote table "PushNotificationSubscription" */
export type PushNotificationSubscription_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<PushNotificationSubscription_Insert_Input>;
  readonly on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};

/** Boolean expression to filter rows from the table "PushNotificationSubscription". All fields are combined with a logical 'AND'. */
export type PushNotificationSubscription_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<PushNotificationSubscription_Bool_Exp>>>;
  readonly _not?: Maybe<PushNotificationSubscription_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<PushNotificationSubscription_Bool_Exp>>>;
  readonly auth?: Maybe<String_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endpoint?: Maybe<String_Comparison_Exp>;
  readonly p256dh?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly user?: Maybe<User_Bool_Exp>;
  readonly userId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Constraint {
  /** unique or primary key constraint */
  PushNotificationSubscriptionPkey = 'PushNotificationSubscription_pkey'
}

/** input type for inserting data into table "PushNotificationSubscription" */
export type PushNotificationSubscription_Insert_Input = {
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly user?: Maybe<User_Obj_Rel_Insert_Input>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type PushNotificationSubscription_Max_Fields = {
  readonly __typename?: 'PushNotificationSubscription_max_fields';
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Max_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type PushNotificationSubscription_Min_Fields = {
  readonly __typename?: 'PushNotificationSubscription_min_fields';
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "PushNotificationSubscription" */
export type PushNotificationSubscription_Min_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** response of any mutation on the table "PushNotificationSubscription" */
export type PushNotificationSubscription_Mutation_Response = {
  readonly __typename?: 'PushNotificationSubscription_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<PushNotificationSubscription>;
};

/** input type for inserting object relation for remote table "PushNotificationSubscription" */
export type PushNotificationSubscription_Obj_Rel_Insert_Input = {
  readonly data: PushNotificationSubscription_Insert_Input;
  readonly on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};

/** on conflict condition type for table "PushNotificationSubscription" */
export type PushNotificationSubscription_On_Conflict = {
  readonly constraint: PushNotificationSubscription_Constraint;
  readonly update_columns: ReadonlyArray<PushNotificationSubscription_Update_Column>;
  readonly where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};

/** ordering options when selecting data from "PushNotificationSubscription" */
export type PushNotificationSubscription_Order_By = {
  readonly auth?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endpoint?: Maybe<Order_By>;
  readonly p256dh?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly user?: Maybe<User_Order_By>;
  readonly userId?: Maybe<Order_By>;
};

/** primary key columns input for table: "PushNotificationSubscription" */
export type PushNotificationSubscription_Pk_Columns_Input = {
  readonly endpoint: Scalars['String'];
};

/** select columns of table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Select_Column {
  /** column name */
  Auth = 'auth',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  P256dh = 'p256dh',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "PushNotificationSubscription" */
export type PushNotificationSubscription_Set_Input = {
  readonly auth?: Maybe<Scalars['String']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endpoint?: Maybe<Scalars['String']>;
  readonly p256dh?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly userId?: Maybe<Scalars['String']>;
};

/** update columns of table "PushNotificationSubscription" */
export enum PushNotificationSubscription_Update_Column {
  /** column name */
  Auth = 'auth',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Endpoint = 'endpoint',
  /** column name */
  P256dh = 'p256dh',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'userId'
}

export type RefreshYouTubeDataOutput = {
  readonly __typename?: 'RefreshYouTubeDataOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

/** columns and relationships of "RequiredContentItem" */
export type RequiredContentItem = {
  readonly __typename?: 'RequiredContentItem';
  readonly accessToken?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly contentGroupId: Scalars['uuid'];
  /** A computed field, executes function "requireditem_content_group_title" */
  readonly contentGroupTitle?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly contentItem?: Maybe<ContentItem>;
  /** An object relationship */
  readonly contentType: ContentType;
  readonly contentTypeName: ContentType_Enum;
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly isHidden: Scalars['Boolean'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly uploaders: ReadonlyArray<Uploader>;
  /** An aggregated array relationship */
  readonly uploaders_aggregate: Uploader_Aggregate;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};


/** columns and relationships of "RequiredContentItem" */
export type RequiredContentItemUploadersArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** columns and relationships of "RequiredContentItem" */
export type RequiredContentItemUploaders_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};

/** aggregated selection of "RequiredContentItem" */
export type RequiredContentItem_Aggregate = {
  readonly __typename?: 'RequiredContentItem_aggregate';
  readonly aggregate?: Maybe<RequiredContentItem_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RequiredContentItem>;
};

/** aggregate fields of "RequiredContentItem" */
export type RequiredContentItem_Aggregate_Fields = {
  readonly __typename?: 'RequiredContentItem_aggregate_fields';
  readonly avg?: Maybe<RequiredContentItem_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RequiredContentItem_Max_Fields>;
  readonly min?: Maybe<RequiredContentItem_Min_Fields>;
  readonly stddev?: Maybe<RequiredContentItem_Stddev_Fields>;
  readonly stddev_pop?: Maybe<RequiredContentItem_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<RequiredContentItem_Stddev_Samp_Fields>;
  readonly sum?: Maybe<RequiredContentItem_Sum_Fields>;
  readonly var_pop?: Maybe<RequiredContentItem_Var_Pop_Fields>;
  readonly var_samp?: Maybe<RequiredContentItem_Var_Samp_Fields>;
  readonly variance?: Maybe<RequiredContentItem_Variance_Fields>;
};


/** aggregate fields of "RequiredContentItem" */
export type RequiredContentItem_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RequiredContentItem" */
export type RequiredContentItem_Aggregate_Order_By = {
  readonly avg?: Maybe<RequiredContentItem_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RequiredContentItem_Max_Order_By>;
  readonly min?: Maybe<RequiredContentItem_Min_Order_By>;
  readonly stddev?: Maybe<RequiredContentItem_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<RequiredContentItem_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<RequiredContentItem_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<RequiredContentItem_Sum_Order_By>;
  readonly var_pop?: Maybe<RequiredContentItem_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<RequiredContentItem_Var_Samp_Order_By>;
  readonly variance?: Maybe<RequiredContentItem_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "RequiredContentItem" */
export type RequiredContentItem_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RequiredContentItem_Insert_Input>;
  readonly on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};

/** aggregate avg on columns */
export type RequiredContentItem_Avg_Fields = {
  readonly __typename?: 'RequiredContentItem_avg_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Avg_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "RequiredContentItem". All fields are combined with a logical 'AND'. */
export type RequiredContentItem_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RequiredContentItem_Bool_Exp>>>;
  readonly _not?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RequiredContentItem_Bool_Exp>>>;
  readonly accessToken?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentType?: Maybe<ContentType_Bool_Exp>;
  readonly contentTypeName?: Maybe<ContentType_Enum_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly isHidden?: Maybe<Boolean_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploaders?: Maybe<Uploader_Bool_Exp>;
  readonly uploadsRemaining?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "RequiredContentItem" */
export enum RequiredContentItem_Constraint {
  /** unique or primary key constraint */
  RequiredContentItemPkey = 'RequiredContentItem_pkey'
}

/** input type for incrementing integer column in table "RequiredContentItem" */
export type RequiredContentItem_Inc_Input = {
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "RequiredContentItem" */
export type RequiredContentItem_Insert_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentType?: Maybe<ContentType_Obj_Rel_Insert_Input>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploaders?: Maybe<Uploader_Arr_Rel_Insert_Input>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type RequiredContentItem_Max_Fields = {
  readonly __typename?: 'RequiredContentItem_max_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Max_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RequiredContentItem_Min_Fields = {
  readonly __typename?: 'RequiredContentItem_min_fields';
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Min_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** response of any mutation on the table "RequiredContentItem" */
export type RequiredContentItem_Mutation_Response = {
  readonly __typename?: 'RequiredContentItem_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RequiredContentItem>;
};

/** input type for inserting object relation for remote table "RequiredContentItem" */
export type RequiredContentItem_Obj_Rel_Insert_Input = {
  readonly data: RequiredContentItem_Insert_Input;
  readonly on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};

/** on conflict condition type for table "RequiredContentItem" */
export type RequiredContentItem_On_Conflict = {
  readonly constraint: RequiredContentItem_Constraint;
  readonly update_columns: ReadonlyArray<RequiredContentItem_Update_Column>;
  readonly where?: Maybe<RequiredContentItem_Bool_Exp>;
};

/** ordering options when selecting data from "RequiredContentItem" */
export type RequiredContentItem_Order_By = {
  readonly accessToken?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentType?: Maybe<ContentType_Order_By>;
  readonly contentTypeName?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isHidden?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploaders_aggregate?: Maybe<Uploader_Aggregate_Order_By>;
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** primary key columns input for table: "RequiredContentItem" */
export type RequiredContentItem_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RequiredContentItem" */
export enum RequiredContentItem_Select_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** input type for updating data in table "RequiredContentItem" */
export type RequiredContentItem_Set_Input = {
  readonly accessToken?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly contentTypeName?: Maybe<ContentType_Enum>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly isHidden?: Maybe<Scalars['Boolean']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type RequiredContentItem_Stddev_Fields = {
  readonly __typename?: 'RequiredContentItem_stddev_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Stddev_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type RequiredContentItem_Stddev_Pop_Fields = {
  readonly __typename?: 'RequiredContentItem_stddev_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Stddev_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type RequiredContentItem_Stddev_Samp_Fields = {
  readonly __typename?: 'RequiredContentItem_stddev_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Stddev_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type RequiredContentItem_Sum_Fields = {
  readonly __typename?: 'RequiredContentItem_sum_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Sum_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** update columns of table "RequiredContentItem" */
export enum RequiredContentItem_Update_Column {
  /** column name */
  AccessToken = 'accessToken',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ContentTypeName = 'contentTypeName',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  IsHidden = 'isHidden',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadsRemaining = 'uploadsRemaining'
}

/** aggregate var_pop on columns */
export type RequiredContentItem_Var_Pop_Fields = {
  readonly __typename?: 'RequiredContentItem_var_pop_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Var_Pop_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type RequiredContentItem_Var_Samp_Fields = {
  readonly __typename?: 'RequiredContentItem_var_samp_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Var_Samp_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type RequiredContentItem_Variance_Fields = {
  readonly __typename?: 'RequiredContentItem_variance_fields';
  readonly uploadsRemaining?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "RequiredContentItem" */
export type RequiredContentItem_Variance_Order_By = {
  readonly uploadsRemaining?: Maybe<Order_By>;
};

/** columns and relationships of "Role" */
export type Role = {
  readonly __typename?: 'Role';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly groupRoles: ReadonlyArray<GroupRole>;
  /** An aggregated array relationship */
  readonly groupRoles_aggregate: GroupRole_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rolePermissions: ReadonlyArray<RolePermission>;
  /** An aggregated array relationship */
  readonly rolePermissions_aggregate: RolePermission_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Role" */
export type RoleGroupRolesArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** columns and relationships of "Role" */
export type RoleGroupRoles_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** columns and relationships of "Role" */
export type RoleRolePermissionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** columns and relationships of "Role" */
export type RoleRolePermissions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};

/** columns and relationships of "RolePermission" */
export type RolePermission = {
  readonly __typename?: 'RolePermission';
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly permission: Permission;
  readonly permissionName: Permission_Enum;
  /** An object relationship */
  readonly role: Role;
  readonly roleId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "RolePermission" */
export type RolePermission_Aggregate = {
  readonly __typename?: 'RolePermission_aggregate';
  readonly aggregate?: Maybe<RolePermission_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RolePermission>;
};

/** aggregate fields of "RolePermission" */
export type RolePermission_Aggregate_Fields = {
  readonly __typename?: 'RolePermission_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RolePermission_Max_Fields>;
  readonly min?: Maybe<RolePermission_Min_Fields>;
};


/** aggregate fields of "RolePermission" */
export type RolePermission_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RolePermission" */
export type RolePermission_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RolePermission_Max_Order_By>;
  readonly min?: Maybe<RolePermission_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RolePermission" */
export type RolePermission_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RolePermission_Insert_Input>;
  readonly on_conflict?: Maybe<RolePermission_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RolePermission". All fields are combined with a logical 'AND'. */
export type RolePermission_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RolePermission_Bool_Exp>>>;
  readonly _not?: Maybe<RolePermission_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RolePermission_Bool_Exp>>>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly permission?: Maybe<Permission_Bool_Exp>;
  readonly permissionName?: Maybe<Permission_Enum_Comparison_Exp>;
  readonly role?: Maybe<Role_Bool_Exp>;
  readonly roleId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "RolePermission" */
export enum RolePermission_Constraint {
  /** unique or primary key constraint */
  RolePermissionPkey = 'RolePermission_pkey',
  /** unique or primary key constraint */
  RolePermissionRoleIdPermissionKey = 'RolePermission_roleId_permission_key'
}

/** input type for inserting data into table "RolePermission" */
export type RolePermission_Insert_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permission?: Maybe<Permission_Obj_Rel_Insert_Input>;
  readonly permissionName?: Maybe<Permission_Enum>;
  readonly role?: Maybe<Role_Obj_Rel_Insert_Input>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type RolePermission_Max_Fields = {
  readonly __typename?: 'RolePermission_max_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "RolePermission" */
export type RolePermission_Max_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RolePermission_Min_Fields = {
  readonly __typename?: 'RolePermission_min_fields';
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "RolePermission" */
export type RolePermission_Min_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "RolePermission" */
export type RolePermission_Mutation_Response = {
  readonly __typename?: 'RolePermission_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RolePermission>;
};

/** input type for inserting object relation for remote table "RolePermission" */
export type RolePermission_Obj_Rel_Insert_Input = {
  readonly data: RolePermission_Insert_Input;
  readonly on_conflict?: Maybe<RolePermission_On_Conflict>;
};

/** on conflict condition type for table "RolePermission" */
export type RolePermission_On_Conflict = {
  readonly constraint: RolePermission_Constraint;
  readonly update_columns: ReadonlyArray<RolePermission_Update_Column>;
  readonly where?: Maybe<RolePermission_Bool_Exp>;
};

/** ordering options when selecting data from "RolePermission" */
export type RolePermission_Order_By = {
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly permission?: Maybe<Permission_Order_By>;
  readonly permissionName?: Maybe<Order_By>;
  readonly role?: Maybe<Role_Order_By>;
  readonly roleId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "RolePermission" */
export type RolePermission_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RolePermission" */
export enum RolePermission_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "RolePermission" */
export type RolePermission_Set_Input = {
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly permissionName?: Maybe<Permission_Enum>;
  readonly roleId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "RolePermission" */
export enum RolePermission_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  PermissionName = 'permissionName',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregated selection of "Role" */
export type Role_Aggregate = {
  readonly __typename?: 'Role_aggregate';
  readonly aggregate?: Maybe<Role_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Role>;
};

/** aggregate fields of "Role" */
export type Role_Aggregate_Fields = {
  readonly __typename?: 'Role_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Role_Max_Fields>;
  readonly min?: Maybe<Role_Min_Fields>;
};


/** aggregate fields of "Role" */
export type Role_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Role_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Role" */
export type Role_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Role_Max_Order_By>;
  readonly min?: Maybe<Role_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Role" */
export type Role_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Role_Insert_Input>;
  readonly on_conflict?: Maybe<Role_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Role". All fields are combined with a logical 'AND'. */
export type Role_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Role_Bool_Exp>>>;
  readonly _not?: Maybe<Role_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Role_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly groupRoles?: Maybe<GroupRole_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rolePermissions?: Maybe<RolePermission_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Role" */
export enum Role_Constraint {
  /** unique or primary key constraint */
  RoleConferenceNameKey = 'Role_conference_name_key',
  /** unique or primary key constraint */
  RolePkey = 'Role_pkey'
}

/** input type for inserting data into table "Role" */
export type Role_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly groupRoles?: Maybe<GroupRole_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rolePermissions?: Maybe<RolePermission_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Role_Max_Fields = {
  readonly __typename?: 'Role_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Role" */
export type Role_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Role_Min_Fields = {
  readonly __typename?: 'Role_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Role" */
export type Role_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Role" */
export type Role_Mutation_Response = {
  readonly __typename?: 'Role_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Role>;
};

/** input type for inserting object relation for remote table "Role" */
export type Role_Obj_Rel_Insert_Input = {
  readonly data: Role_Insert_Input;
  readonly on_conflict?: Maybe<Role_On_Conflict>;
};

/** on conflict condition type for table "Role" */
export type Role_On_Conflict = {
  readonly constraint: Role_Constraint;
  readonly update_columns: ReadonlyArray<Role_Update_Column>;
  readonly where?: Maybe<Role_Bool_Exp>;
};

/** ordering options when selecting data from "Role" */
export type Role_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly groupRoles_aggregate?: Maybe<GroupRole_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rolePermissions_aggregate?: Maybe<RolePermission_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Role" */
export type Role_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Role" */
export enum Role_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Role" */
export type Role_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Role" */
export enum Role_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "Room" */
export type Room = {
  readonly __typename?: 'Room';
  readonly capacity?: Maybe<Scalars['Int']>;
  /** An array relationship */
  readonly channelStackCreateJobs: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** An aggregated array relationship */
  readonly channelStackCreateJobs_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** An object relationship */
  readonly chat?: Maybe<Chat_Chat>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly currentMode: RoomMode;
  readonly currentModeName: RoomMode_Enum;
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  /** An array relationship */
  readonly executedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** An aggregated array relationship */
  readonly executedTransitions_aggregate: ExecutedTransitions_Aggregate;
  readonly id: Scalars['uuid'];
  /** A computed field, executes function "IsProgramRoom" */
  readonly isProgramRoom?: Maybe<Scalars['Boolean']>;
  /** An object relationship */
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel>;
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingContentGroup?: Maybe<ContentGroup>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly originatingEvent?: Maybe<Event>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly participants: ReadonlyArray<RoomParticipant>;
  /** An aggregated array relationship */
  readonly participants_aggregate: RoomParticipant_Aggregate;
  readonly priority: Scalars['Int'];
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly roomChimeMeeting?: Maybe<Room_RoomChimeMeeting>;
  /** An array relationship */
  readonly roomPeople: ReadonlyArray<RoomPerson>;
  /** An aggregated array relationship */
  readonly roomPeople_aggregate: RoomPerson_Aggregate;
  /** An object relationship */
  readonly roomPrivacy: RoomPrivacy;
  readonly roomPrivacyName: RoomPrivacy_Enum;
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregated array relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  /** An object relationship */
  readonly stats?: Maybe<Analytics_RoomStats>;
  /** An array relationship */
  readonly transitions: ReadonlyArray<Transitions>;
  /** An aggregated array relationship */
  readonly transitions_aggregate: Transitions_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
  readonly videoRoomBackendName?: Maybe<Room_VideoRoomBackend_Enum>;
};


/** columns and relationships of "Room" */
export type RoomChannelStackCreateJobsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomChannelStackCreateJobs_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomParticipantsArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomParticipants_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomRoomPeopleArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomRoomPeople_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** columns and relationships of "Room" */
export type RoomTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};

/** columns and relationships of "RoomMode" */
export type RoomMode = {
  readonly __typename?: 'RoomMode';
  readonly description: Scalars['String'];
  /** An array relationship */
  readonly events: ReadonlyArray<Event>;
  /** An aggregated array relationship */
  readonly events_aggregate: Event_Aggregate;
  readonly name: Scalars['String'];
  /** An array relationship */
  readonly rooms: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly rooms_aggregate: Room_Aggregate;
};


/** columns and relationships of "RoomMode" */
export type RoomModeEventsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "RoomMode" */
export type RoomModeEvents_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** columns and relationships of "RoomMode" */
export type RoomModeRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "RoomMode" */
export type RoomModeRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};

/** aggregated selection of "RoomMode" */
export type RoomMode_Aggregate = {
  readonly __typename?: 'RoomMode_aggregate';
  readonly aggregate?: Maybe<RoomMode_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomMode>;
};

/** aggregate fields of "RoomMode" */
export type RoomMode_Aggregate_Fields = {
  readonly __typename?: 'RoomMode_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomMode_Max_Fields>;
  readonly min?: Maybe<RoomMode_Min_Fields>;
};


/** aggregate fields of "RoomMode" */
export type RoomMode_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomMode" */
export type RoomMode_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomMode_Max_Order_By>;
  readonly min?: Maybe<RoomMode_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomMode" */
export type RoomMode_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomMode_Insert_Input>;
  readonly on_conflict?: Maybe<RoomMode_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomMode". All fields are combined with a logical 'AND'. */
export type RoomMode_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomMode_Bool_Exp>>>;
  readonly _not?: Maybe<RoomMode_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomMode_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly rooms?: Maybe<Room_Bool_Exp>;
};

/** unique or primary key constraints on table "RoomMode" */
export enum RoomMode_Constraint {
  /** unique or primary key constraint */
  RoomModePkey = 'RoomMode_pkey'
}

export enum RoomMode_Enum {
  /** Users may participate in the general video chat. */
  Breakout = 'BREAKOUT',
  /** An exhibition hall. */
  Exhibition = 'EXHIBITION',
  /** An empty room. */
  None = 'NONE',
  /** Pre-recorded content should be played out to attendees. The breakout and Q&A video chats may also be available to relevant users. */
  Prerecorded = 'PRERECORDED',
  /** A live presentation should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  Presentation = 'PRESENTATION',
  /** A live Q&A/discussion should be delivered in the Q&A video chat. The breakout video chat may also be available to relevant users. */
  QAndA = 'Q_AND_A',
  /** A shuffle queue. */
  Shuffle = 'SHUFFLE',
  /** An ordinary video from either a VIDEO_URL content element or a video uploaded to Clowdr. */
  VideoPlayer = 'VIDEO_PLAYER',
  /** Event is taking place in a Zoom room. */
  Zoom = 'ZOOM'
}

/** expression to compare columns of type RoomMode_enum. All fields are combined with logical 'AND'. */
export type RoomMode_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<RoomMode_Enum>;
  readonly _in?: Maybe<ReadonlyArray<RoomMode_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<RoomMode_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<RoomMode_Enum>>;
};

/** input type for inserting data into table "RoomMode" */
export type RoomMode_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly rooms?: Maybe<Room_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type RoomMode_Max_Fields = {
  readonly __typename?: 'RoomMode_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomMode" */
export type RoomMode_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomMode_Min_Fields = {
  readonly __typename?: 'RoomMode_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomMode" */
export type RoomMode_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomMode" */
export type RoomMode_Mutation_Response = {
  readonly __typename?: 'RoomMode_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomMode>;
};

/** input type for inserting object relation for remote table "RoomMode" */
export type RoomMode_Obj_Rel_Insert_Input = {
  readonly data: RoomMode_Insert_Input;
  readonly on_conflict?: Maybe<RoomMode_On_Conflict>;
};

/** on conflict condition type for table "RoomMode" */
export type RoomMode_On_Conflict = {
  readonly constraint: RoomMode_Constraint;
  readonly update_columns: ReadonlyArray<RoomMode_Update_Column>;
  readonly where?: Maybe<RoomMode_Bool_Exp>;
};

/** ordering options when selecting data from "RoomMode" */
export type RoomMode_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly rooms_aggregate?: Maybe<Room_Aggregate_Order_By>;
};

/** primary key columns input for table: "RoomMode" */
export type RoomMode_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "RoomMode" */
export enum RoomMode_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "RoomMode" */
export type RoomMode_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomMode" */
export enum RoomMode_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "RoomParticipant" */
export type RoomParticipant = {
  readonly __typename?: 'RoomParticipant';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly chimeAttendeeId?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** aggregated selection of "RoomParticipant" */
export type RoomParticipant_Aggregate = {
  readonly __typename?: 'RoomParticipant_aggregate';
  readonly aggregate?: Maybe<RoomParticipant_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomParticipant>;
};

/** aggregate fields of "RoomParticipant" */
export type RoomParticipant_Aggregate_Fields = {
  readonly __typename?: 'RoomParticipant_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomParticipant_Max_Fields>;
  readonly min?: Maybe<RoomParticipant_Min_Fields>;
};


/** aggregate fields of "RoomParticipant" */
export type RoomParticipant_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomParticipant" */
export type RoomParticipant_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomParticipant_Max_Order_By>;
  readonly min?: Maybe<RoomParticipant_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomParticipant" */
export type RoomParticipant_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomParticipant_Insert_Input>;
  readonly on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomParticipant". All fields are combined with a logical 'AND'. */
export type RoomParticipant_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomParticipant_Bool_Exp>>>;
  readonly _not?: Maybe<RoomParticipant_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomParticipant_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chimeAttendeeId?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vonageConnectionId?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomParticipant" */
export enum RoomParticipant_Constraint {
  /** unique or primary key constraint */
  RoomParticipantPkey = 'RoomParticipant_pkey',
  /** unique or primary key constraint */
  RoomParticipantRoomIdAttendeeIdKey = 'RoomParticipant_roomId_attendeeId_key'
}

/** input type for inserting data into table "RoomParticipant" */
export type RoomParticipant_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chimeAttendeeId?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type RoomParticipant_Max_Fields = {
  readonly __typename?: 'RoomParticipant_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chimeAttendeeId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomParticipant" */
export type RoomParticipant_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chimeAttendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomParticipant_Min_Fields = {
  readonly __typename?: 'RoomParticipant_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chimeAttendeeId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomParticipant" */
export type RoomParticipant_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chimeAttendeeId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomParticipant" */
export type RoomParticipant_Mutation_Response = {
  readonly __typename?: 'RoomParticipant_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomParticipant>;
};

/** input type for inserting object relation for remote table "RoomParticipant" */
export type RoomParticipant_Obj_Rel_Insert_Input = {
  readonly data: RoomParticipant_Insert_Input;
  readonly on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};

/** on conflict condition type for table "RoomParticipant" */
export type RoomParticipant_On_Conflict = {
  readonly constraint: RoomParticipant_Constraint;
  readonly update_columns: ReadonlyArray<RoomParticipant_Update_Column>;
  readonly where?: Maybe<RoomParticipant_Bool_Exp>;
};

/** ordering options when selecting data from "RoomParticipant" */
export type RoomParticipant_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chimeAttendeeId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vonageConnectionId?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomParticipant" */
export type RoomParticipant_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RoomParticipant" */
export enum RoomParticipant_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChimeAttendeeId = 'chimeAttendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** input type for updating data in table "RoomParticipant" */
export type RoomParticipant_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chimeAttendeeId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vonageConnectionId?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomParticipant" */
export enum RoomParticipant_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChimeAttendeeId = 'chimeAttendeeId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VonageConnectionId = 'vonageConnectionId'
}

/** columns and relationships of "RoomPerson" */
export type RoomPerson = {
  readonly __typename?: 'RoomPerson';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly roomPersonRole: RoomPersonRole;
  readonly roomPersonRoleName: RoomPersonRole_Enum;
  readonly updatedAt: Scalars['timestamptz'];
};

/** columns and relationships of "RoomPersonRole" */
export type RoomPersonRole = {
  readonly __typename?: 'RoomPersonRole';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "RoomPersonRole" */
export type RoomPersonRole_Aggregate = {
  readonly __typename?: 'RoomPersonRole_aggregate';
  readonly aggregate?: Maybe<RoomPersonRole_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomPersonRole>;
};

/** aggregate fields of "RoomPersonRole" */
export type RoomPersonRole_Aggregate_Fields = {
  readonly __typename?: 'RoomPersonRole_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomPersonRole_Max_Fields>;
  readonly min?: Maybe<RoomPersonRole_Min_Fields>;
};


/** aggregate fields of "RoomPersonRole" */
export type RoomPersonRole_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomPersonRole" */
export type RoomPersonRole_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomPersonRole_Max_Order_By>;
  readonly min?: Maybe<RoomPersonRole_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomPersonRole" */
export type RoomPersonRole_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomPersonRole_Insert_Input>;
  readonly on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomPersonRole". All fields are combined with a logical 'AND'. */
export type RoomPersonRole_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomPersonRole_Bool_Exp>>>;
  readonly _not?: Maybe<RoomPersonRole_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomPersonRole_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomPersonRole" */
export enum RoomPersonRole_Constraint {
  /** unique or primary key constraint */
  RoomPersonRolePkey = 'RoomPersonRole_pkey'
}

export enum RoomPersonRole_Enum {
  /** User has control over the room. */
  Admin = 'ADMIN',
  /** User can participate in the room. */
  Participant = 'PARTICIPANT'
}

/** expression to compare columns of type RoomPersonRole_enum. All fields are combined with logical 'AND'. */
export type RoomPersonRole_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<RoomPersonRole_Enum>;
  readonly _in?: Maybe<ReadonlyArray<RoomPersonRole_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<RoomPersonRole_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<RoomPersonRole_Enum>>;
};

/** input type for inserting data into table "RoomPersonRole" */
export type RoomPersonRole_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type RoomPersonRole_Max_Fields = {
  readonly __typename?: 'RoomPersonRole_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomPersonRole" */
export type RoomPersonRole_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomPersonRole_Min_Fields = {
  readonly __typename?: 'RoomPersonRole_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomPersonRole" */
export type RoomPersonRole_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomPersonRole" */
export type RoomPersonRole_Mutation_Response = {
  readonly __typename?: 'RoomPersonRole_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomPersonRole>;
};

/** input type for inserting object relation for remote table "RoomPersonRole" */
export type RoomPersonRole_Obj_Rel_Insert_Input = {
  readonly data: RoomPersonRole_Insert_Input;
  readonly on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};

/** on conflict condition type for table "RoomPersonRole" */
export type RoomPersonRole_On_Conflict = {
  readonly constraint: RoomPersonRole_Constraint;
  readonly update_columns: ReadonlyArray<RoomPersonRole_Update_Column>;
  readonly where?: Maybe<RoomPersonRole_Bool_Exp>;
};

/** ordering options when selecting data from "RoomPersonRole" */
export type RoomPersonRole_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomPersonRole" */
export type RoomPersonRole_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "RoomPersonRole" */
export enum RoomPersonRole_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "RoomPersonRole" */
export type RoomPersonRole_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomPersonRole" */
export enum RoomPersonRole_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "RoomPerson" */
export type RoomPerson_Aggregate = {
  readonly __typename?: 'RoomPerson_aggregate';
  readonly aggregate?: Maybe<RoomPerson_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomPerson>;
};

/** aggregate fields of "RoomPerson" */
export type RoomPerson_Aggregate_Fields = {
  readonly __typename?: 'RoomPerson_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomPerson_Max_Fields>;
  readonly min?: Maybe<RoomPerson_Min_Fields>;
};


/** aggregate fields of "RoomPerson" */
export type RoomPerson_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomPerson" */
export type RoomPerson_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomPerson_Max_Order_By>;
  readonly min?: Maybe<RoomPerson_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomPerson" */
export type RoomPerson_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomPerson_Insert_Input>;
  readonly on_conflict?: Maybe<RoomPerson_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomPerson". All fields are combined with a logical 'AND'. */
export type RoomPerson_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomPerson_Bool_Exp>>>;
  readonly _not?: Maybe<RoomPerson_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomPerson_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly roomPersonRole?: Maybe<RoomPersonRole_Bool_Exp>;
  readonly roomPersonRoleName?: Maybe<RoomPersonRole_Enum_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomPerson" */
export enum RoomPerson_Constraint {
  /** unique or primary key constraint */
  RoomPersonAttendeeIdRoomIdKey = 'RoomPerson_attendeeId_roomId_key',
  /** unique or primary key constraint */
  RoomPersonPkey = 'RoomPerson_pkey'
}

/** input type for inserting data into table "RoomPerson" */
export type RoomPerson_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomPersonRole?: Maybe<RoomPersonRole_Obj_Rel_Insert_Input>;
  readonly roomPersonRoleName?: Maybe<RoomPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type RoomPerson_Max_Fields = {
  readonly __typename?: 'RoomPerson_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "RoomPerson" */
export type RoomPerson_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomPerson_Min_Fields = {
  readonly __typename?: 'RoomPerson_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "RoomPerson" */
export type RoomPerson_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomPerson" */
export type RoomPerson_Mutation_Response = {
  readonly __typename?: 'RoomPerson_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomPerson>;
};

/** input type for inserting object relation for remote table "RoomPerson" */
export type RoomPerson_Obj_Rel_Insert_Input = {
  readonly data: RoomPerson_Insert_Input;
  readonly on_conflict?: Maybe<RoomPerson_On_Conflict>;
};

/** on conflict condition type for table "RoomPerson" */
export type RoomPerson_On_Conflict = {
  readonly constraint: RoomPerson_Constraint;
  readonly update_columns: ReadonlyArray<RoomPerson_Update_Column>;
  readonly where?: Maybe<RoomPerson_Bool_Exp>;
};

/** ordering options when selecting data from "RoomPerson" */
export type RoomPerson_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly roomPersonRole?: Maybe<RoomPersonRole_Order_By>;
  readonly roomPersonRoleName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomPerson" */
export type RoomPerson_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "RoomPerson" */
export enum RoomPerson_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RoomPersonRoleName = 'roomPersonRoleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "RoomPerson" */
export type RoomPerson_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly roomPersonRoleName?: Maybe<RoomPersonRole_Enum>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "RoomPerson" */
export enum RoomPerson_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  RoomPersonRoleName = 'roomPersonRoleName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "RoomPrivacy" */
export type RoomPrivacy = {
  readonly __typename?: 'RoomPrivacy';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "RoomPrivacy" */
export type RoomPrivacy_Aggregate = {
  readonly __typename?: 'RoomPrivacy_aggregate';
  readonly aggregate?: Maybe<RoomPrivacy_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<RoomPrivacy>;
};

/** aggregate fields of "RoomPrivacy" */
export type RoomPrivacy_Aggregate_Fields = {
  readonly __typename?: 'RoomPrivacy_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<RoomPrivacy_Max_Fields>;
  readonly min?: Maybe<RoomPrivacy_Min_Fields>;
};


/** aggregate fields of "RoomPrivacy" */
export type RoomPrivacy_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "RoomPrivacy" */
export type RoomPrivacy_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<RoomPrivacy_Max_Order_By>;
  readonly min?: Maybe<RoomPrivacy_Min_Order_By>;
};

/** input type for inserting array relation for remote table "RoomPrivacy" */
export type RoomPrivacy_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<RoomPrivacy_Insert_Input>;
  readonly on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};

/** Boolean expression to filter rows from the table "RoomPrivacy". All fields are combined with a logical 'AND'. */
export type RoomPrivacy_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<RoomPrivacy_Bool_Exp>>>;
  readonly _not?: Maybe<RoomPrivacy_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<RoomPrivacy_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "RoomPrivacy" */
export enum RoomPrivacy_Constraint {
  /** unique or primary key constraint */
  RoomPrivacyPkey = 'RoomPrivacy_pkey'
}

export enum RoomPrivacy_Enum {
  /** Room is a direct message between two attendees. No new attendees can be added. */
  Dm = 'DM',
  /** Room access is automatically controlled by the system. */
  Managed = 'MANAGED',
  /** Room is only visible to attendees who have been given access. New attendees can be added. */
  Private = 'PRIVATE',
  /** Room is visible to all attendees at the conference. */
  Public = 'PUBLIC'
}

/** expression to compare columns of type RoomPrivacy_enum. All fields are combined with logical 'AND'. */
export type RoomPrivacy_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<RoomPrivacy_Enum>;
  readonly _in?: Maybe<ReadonlyArray<RoomPrivacy_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<RoomPrivacy_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<RoomPrivacy_Enum>>;
};

/** input type for inserting data into table "RoomPrivacy" */
export type RoomPrivacy_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type RoomPrivacy_Max_Fields = {
  readonly __typename?: 'RoomPrivacy_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "RoomPrivacy" */
export type RoomPrivacy_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type RoomPrivacy_Min_Fields = {
  readonly __typename?: 'RoomPrivacy_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "RoomPrivacy" */
export type RoomPrivacy_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "RoomPrivacy" */
export type RoomPrivacy_Mutation_Response = {
  readonly __typename?: 'RoomPrivacy_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<RoomPrivacy>;
};

/** input type for inserting object relation for remote table "RoomPrivacy" */
export type RoomPrivacy_Obj_Rel_Insert_Input = {
  readonly data: RoomPrivacy_Insert_Input;
  readonly on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};

/** on conflict condition type for table "RoomPrivacy" */
export type RoomPrivacy_On_Conflict = {
  readonly constraint: RoomPrivacy_Constraint;
  readonly update_columns: ReadonlyArray<RoomPrivacy_Update_Column>;
  readonly where?: Maybe<RoomPrivacy_Bool_Exp>;
};

/** ordering options when selecting data from "RoomPrivacy" */
export type RoomPrivacy_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "RoomPrivacy" */
export type RoomPrivacy_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "RoomPrivacy" */
export enum RoomPrivacy_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "RoomPrivacy" */
export type RoomPrivacy_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "RoomPrivacy" */
export enum RoomPrivacy_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "Room" */
export type Room_Aggregate = {
  readonly __typename?: 'Room_aggregate';
  readonly aggregate?: Maybe<Room_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room>;
};

/** aggregate fields of "Room" */
export type Room_Aggregate_Fields = {
  readonly __typename?: 'Room_aggregate_fields';
  readonly avg?: Maybe<Room_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_Max_Fields>;
  readonly min?: Maybe<Room_Min_Fields>;
  readonly stddev?: Maybe<Room_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_Sum_Fields>;
  readonly var_pop?: Maybe<Room_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_Variance_Fields>;
};


/** aggregate fields of "Room" */
export type Room_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Room" */
export type Room_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_Max_Order_By>;
  readonly min?: Maybe<Room_Min_Order_By>;
  readonly stddev?: Maybe<Room_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Room" */
export type Room_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_Insert_Input>;
  readonly on_conflict?: Maybe<Room_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_Avg_Fields = {
  readonly __typename?: 'Room_avg_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Room" */
export type Room_Avg_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Room". All fields are combined with a logical 'AND'. */
export type Room_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_Bool_Exp>>>;
  readonly _not?: Maybe<Room_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_Bool_Exp>>>;
  readonly capacity?: Maybe<Int_Comparison_Exp>;
  readonly channelStackCreateJobs?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly currentMode?: Maybe<RoomMode_Bool_Exp>;
  readonly currentModeName?: Maybe<RoomMode_Enum_Comparison_Exp>;
  readonly events?: Maybe<Event_Bool_Exp>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel_Bool_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingContentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly originatingContentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly originatingEvent?: Maybe<Event_Bool_Exp>;
  readonly originatingEventId?: Maybe<Uuid_Comparison_Exp>;
  readonly participants?: Maybe<RoomParticipant_Bool_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly publicVonageSessionId?: Maybe<String_Comparison_Exp>;
  readonly roomChimeMeeting?: Maybe<Room_RoomChimeMeeting_Bool_Exp>;
  readonly roomPeople?: Maybe<RoomPerson_Bool_Exp>;
  readonly roomPrivacy?: Maybe<RoomPrivacy_Bool_Exp>;
  readonly roomPrivacyName?: Maybe<RoomPrivacy_Enum_Comparison_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly stats?: Maybe<Analytics_RoomStats_Bool_Exp>;
  readonly transitions?: Maybe<Transitions_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoRoomBackendName?: Maybe<Room_VideoRoomBackend_Enum_Comparison_Exp>;
};

/** unique or primary key constraints on table "Room" */
export enum Room_Constraint {
  /** unique or primary key constraint */
  RoomConferenceIdNameKey = 'Room_conferenceId_name_key',
  /** unique or primary key constraint */
  RoomOriginatingEventIdKey = 'Room_originatingEventId_key',
  /** unique or primary key constraint */
  RoomPkey = 'Room_pkey'
}

/** input type for incrementing integer column in table "Room" */
export type Room_Inc_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Room" */
export type Room_Insert_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly channelStackCreateJobs?: Maybe<Job_Queues_ChannelStackCreateJob_Arr_Rel_Insert_Input>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentMode?: Maybe<RoomMode_Obj_Rel_Insert_Input>;
  readonly currentModeName?: Maybe<RoomMode_Enum>;
  readonly events?: Maybe<Event_Arr_Rel_Insert_Input>;
  readonly executedTransitions?: Maybe<ExecutedTransitions_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel_Obj_Rel_Insert_Input>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEvent?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly participants?: Maybe<RoomParticipant_Arr_Rel_Insert_Input>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly roomChimeMeeting?: Maybe<Room_RoomChimeMeeting_Obj_Rel_Insert_Input>;
  readonly roomPeople?: Maybe<RoomPerson_Arr_Rel_Insert_Input>;
  readonly roomPrivacy?: Maybe<RoomPrivacy_Obj_Rel_Insert_Input>;
  readonly roomPrivacyName?: Maybe<RoomPrivacy_Enum>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly stats?: Maybe<Analytics_RoomStats_Obj_Rel_Insert_Input>;
  readonly transitions?: Maybe<Transitions_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoRoomBackendName?: Maybe<Room_VideoRoomBackend_Enum>;
};

/** aggregate max on columns */
export type Room_Max_Fields = {
  readonly __typename?: 'Room_max_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Room" */
export type Room_Max_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingContentGroupId?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_Min_Fields = {
  readonly __typename?: 'Room_min_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Room" */
export type Room_Min_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingContentGroupId?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "Room" */
export type Room_Mutation_Response = {
  readonly __typename?: 'Room_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room>;
};

/** input type for inserting object relation for remote table "Room" */
export type Room_Obj_Rel_Insert_Input = {
  readonly data: Room_Insert_Input;
  readonly on_conflict?: Maybe<Room_On_Conflict>;
};

/** on conflict condition type for table "Room" */
export type Room_On_Conflict = {
  readonly constraint: Room_Constraint;
  readonly update_columns: ReadonlyArray<Room_Update_Column>;
  readonly where?: Maybe<Room_Bool_Exp>;
};

/** ordering options when selecting data from "Room" */
export type Room_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly channelStackCreateJobs_aggregate?: Maybe<Job_Queues_ChannelStackCreateJob_Aggregate_Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly currentMode?: Maybe<RoomMode_Order_By>;
  readonly currentModeName?: Maybe<Order_By>;
  readonly events_aggregate?: Maybe<Event_Aggregate_Order_By>;
  readonly executedTransitions_aggregate?: Maybe<ExecutedTransitions_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaLiveChannel?: Maybe<MediaLiveChannel_Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingContentGroup?: Maybe<ContentGroup_Order_By>;
  readonly originatingContentGroupId?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly originatingEvent?: Maybe<Event_Order_By>;
  readonly originatingEventId?: Maybe<Order_By>;
  readonly participants_aggregate?: Maybe<RoomParticipant_Aggregate_Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly publicVonageSessionId?: Maybe<Order_By>;
  readonly roomChimeMeeting?: Maybe<Room_RoomChimeMeeting_Order_By>;
  readonly roomPeople_aggregate?: Maybe<RoomPerson_Aggregate_Order_By>;
  readonly roomPrivacy?: Maybe<RoomPrivacy_Order_By>;
  readonly roomPrivacyName?: Maybe<Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly stats?: Maybe<Analytics_RoomStats_Order_By>;
  readonly transitions_aggregate?: Maybe<Transitions_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly videoRoomBackendName?: Maybe<Order_By>;
};

/** primary key columns input for table: "Room" */
export type Room_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Room" */
export enum Room_Select_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingContentGroupId = 'originatingContentGroupId',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  RoomPrivacyName = 'roomPrivacyName',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VideoRoomBackendName = 'videoRoomBackendName'
}

/** input type for updating data in table "Room" */
export type Room_Set_Input = {
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly currentModeName?: Maybe<RoomMode_Enum>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingContentGroupId?: Maybe<Scalars['uuid']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly originatingEventId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly publicVonageSessionId?: Maybe<Scalars['String']>;
  readonly roomPrivacyName?: Maybe<RoomPrivacy_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly videoRoomBackendName?: Maybe<Room_VideoRoomBackend_Enum>;
};

/** aggregate stddev on columns */
export type Room_Stddev_Fields = {
  readonly __typename?: 'Room_stddev_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Room" */
export type Room_Stddev_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_Stddev_Pop_Fields = {
  readonly __typename?: 'Room_stddev_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Room" */
export type Room_Stddev_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_Stddev_Samp_Fields = {
  readonly __typename?: 'Room_stddev_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Room" */
export type Room_Stddev_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_Sum_Fields = {
  readonly __typename?: 'Room_sum_fields';
  readonly capacity?: Maybe<Scalars['Int']>;
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Room" */
export type Room_Sum_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "Room" */
export enum Room_Update_Column {
  /** column name */
  Capacity = 'capacity',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  CurrentModeName = 'currentModeName',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingContentGroupId = 'originatingContentGroupId',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  OriginatingEventId = 'originatingEventId',
  /** column name */
  Priority = 'priority',
  /** column name */
  PublicVonageSessionId = 'publicVonageSessionId',
  /** column name */
  RoomPrivacyName = 'roomPrivacyName',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  VideoRoomBackendName = 'videoRoomBackendName'
}

/** aggregate var_pop on columns */
export type Room_Var_Pop_Fields = {
  readonly __typename?: 'Room_var_pop_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Room" */
export type Room_Var_Pop_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_Var_Samp_Fields = {
  readonly __typename?: 'Room_var_samp_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Room" */
export type Room_Var_Samp_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_Variance_Fields = {
  readonly __typename?: 'Room_variance_fields';
  readonly capacity?: Maybe<Scalars['Float']>;
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Room" */
export type Room_Variance_Order_By = {
  readonly capacity?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
};

export type SampleInput = {
  readonly password: Scalars['String'];
  readonly username: Scalars['String'];
};

export type SampleOutput = {
  readonly __typename?: 'SampleOutput';
  readonly accessToken: Scalars['String'];
};

export type StopEventBroadcastOutput = {
  readonly __typename?: 'StopEventBroadcastOutput';
  readonly broadcastsStopped: Scalars['Int'];
};

/** expression to compare columns of type String. All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['String']>;
  readonly _gt?: Maybe<Scalars['String']>;
  readonly _gte?: Maybe<Scalars['String']>;
  readonly _ilike?: Maybe<Scalars['String']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _like?: Maybe<Scalars['String']>;
  readonly _lt?: Maybe<Scalars['String']>;
  readonly _lte?: Maybe<Scalars['String']>;
  readonly _neq?: Maybe<Scalars['String']>;
  readonly _nilike?: Maybe<Scalars['String']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _nlike?: Maybe<Scalars['String']>;
  readonly _nsimilar?: Maybe<Scalars['String']>;
  readonly _similar?: Maybe<Scalars['String']>;
};

export type SubmitContentItemInput = {
  readonly contentItemData: Scalars['jsonb'];
};

export type SubmitContentItemOutput = {
  readonly __typename?: 'SubmitContentItemOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

export type SubmitGoogleOAuthCodeOutput = {
  readonly __typename?: 'SubmitGoogleOAuthCodeOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type SubmitGoogleOAuthTokenOutput = {
  readonly __typename?: 'SubmitGoogleOAuthTokenOutput';
  readonly message?: Maybe<Scalars['String']>;
  readonly success: Scalars['Boolean'];
};

export type SubmitUpdatedSubtitlesInput = {
  readonly accessToken: Scalars['String'];
  readonly contentItemId: Scalars['String'];
  readonly subtitleText: Scalars['String'];
};

export type SubmitUpdatedSubtitlesOutput = {
  readonly __typename?: 'SubmitUpdatedSubtitlesOutput';
  readonly message: Scalars['String'];
  readonly success: Scalars['Boolean'];
};

/** columns and relationships of "Tag" */
export type Tag = {
  readonly __typename?: 'Tag';
  readonly colour: Scalars['String'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroupTags: ReadonlyArray<ContentGroupTag>;
  /** An aggregated array relationship */
  readonly contentGroupTags_aggregate: ContentGroupTag_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  /** An array relationship */
  readonly eventTags: ReadonlyArray<EventTag>;
  /** An aggregated array relationship */
  readonly eventTags_aggregate: EventTag_Aggregate;
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly originatingData?: Maybe<OriginatingData>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority: Scalars['Int'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "Tag" */
export type TagContentGroupTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "Tag" */
export type TagContentGroupTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** columns and relationships of "Tag" */
export type TagEventTagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** columns and relationships of "Tag" */
export type TagEventTags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};

/** aggregated selection of "Tag" */
export type Tag_Aggregate = {
  readonly __typename?: 'Tag_aggregate';
  readonly aggregate?: Maybe<Tag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Tag>;
};

/** aggregate fields of "Tag" */
export type Tag_Aggregate_Fields = {
  readonly __typename?: 'Tag_aggregate_fields';
  readonly avg?: Maybe<Tag_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Tag_Max_Fields>;
  readonly min?: Maybe<Tag_Min_Fields>;
  readonly stddev?: Maybe<Tag_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Tag_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Tag_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Tag_Sum_Fields>;
  readonly var_pop?: Maybe<Tag_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Tag_Var_Samp_Fields>;
  readonly variance?: Maybe<Tag_Variance_Fields>;
};


/** aggregate fields of "Tag" */
export type Tag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Tag" */
export type Tag_Aggregate_Order_By = {
  readonly avg?: Maybe<Tag_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Tag_Max_Order_By>;
  readonly min?: Maybe<Tag_Min_Order_By>;
  readonly stddev?: Maybe<Tag_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Tag_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Tag_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Tag_Sum_Order_By>;
  readonly var_pop?: Maybe<Tag_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Tag_Var_Samp_Order_By>;
  readonly variance?: Maybe<Tag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Tag" */
export type Tag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Tag_Insert_Input>;
  readonly on_conflict?: Maybe<Tag_On_Conflict>;
};

/** aggregate avg on columns */
export type Tag_Avg_Fields = {
  readonly __typename?: 'Tag_avg_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Tag" */
export type Tag_Avg_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Tag". All fields are combined with a logical 'AND'. */
export type Tag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Tag_Bool_Exp>>>;
  readonly _not?: Maybe<Tag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Tag_Bool_Exp>>>;
  readonly colour?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly eventTags?: Maybe<EventTag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly originatingData?: Maybe<OriginatingData_Bool_Exp>;
  readonly originatingDataId?: Maybe<Uuid_Comparison_Exp>;
  readonly priority?: Maybe<Int_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Tag" */
export enum Tag_Constraint {
  /** unique or primary key constraint */
  TagPkey = 'Tag_pkey'
}

/** input type for incrementing integer column in table "Tag" */
export type Tag_Inc_Input = {
  readonly priority?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Tag" */
export type Tag_Insert_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroupTags?: Maybe<ContentGroupTag_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventTags?: Maybe<EventTag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingData?: Maybe<OriginatingData_Obj_Rel_Insert_Input>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Tag_Max_Fields = {
  readonly __typename?: 'Tag_max_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Tag" */
export type Tag_Max_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Tag_Min_Fields = {
  readonly __typename?: 'Tag_min_fields';
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Tag" */
export type Tag_Min_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Tag" */
export type Tag_Mutation_Response = {
  readonly __typename?: 'Tag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Tag>;
};

/** input type for inserting object relation for remote table "Tag" */
export type Tag_Obj_Rel_Insert_Input = {
  readonly data: Tag_Insert_Input;
  readonly on_conflict?: Maybe<Tag_On_Conflict>;
};

/** on conflict condition type for table "Tag" */
export type Tag_On_Conflict = {
  readonly constraint: Tag_Constraint;
  readonly update_columns: ReadonlyArray<Tag_Update_Column>;
  readonly where?: Maybe<Tag_Bool_Exp>;
};

/** ordering options when selecting data from "Tag" */
export type Tag_Order_By = {
  readonly colour?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroupTags_aggregate?: Maybe<ContentGroupTag_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventTags_aggregate?: Maybe<EventTag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly originatingData?: Maybe<OriginatingData_Order_By>;
  readonly originatingDataId?: Maybe<Order_By>;
  readonly priority?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Tag" */
export type Tag_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Tag" */
export enum Tag_Select_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Tag" */
export type Tag_Set_Input = {
  readonly colour?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly originatingDataId?: Maybe<Scalars['uuid']>;
  readonly priority?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Tag_Stddev_Fields = {
  readonly __typename?: 'Tag_stddev_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Tag" */
export type Tag_Stddev_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Tag_Stddev_Pop_Fields = {
  readonly __typename?: 'Tag_stddev_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Tag" */
export type Tag_Stddev_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Tag_Stddev_Samp_Fields = {
  readonly __typename?: 'Tag_stddev_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Tag" */
export type Tag_Stddev_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Tag_Sum_Fields = {
  readonly __typename?: 'Tag_sum_fields';
  readonly priority?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Tag" */
export type Tag_Sum_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** update columns of table "Tag" */
export enum Tag_Update_Column {
  /** column name */
  Colour = 'colour',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OriginatingDataId = 'originatingDataId',
  /** column name */
  Priority = 'priority',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Tag_Var_Pop_Fields = {
  readonly __typename?: 'Tag_var_pop_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Tag" */
export type Tag_Var_Pop_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Tag_Var_Samp_Fields = {
  readonly __typename?: 'Tag_var_samp_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Tag" */
export type Tag_Var_Samp_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Tag_Variance_Fields = {
  readonly __typename?: 'Tag_variance_fields';
  readonly priority?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Tag" */
export type Tag_Variance_Order_By = {
  readonly priority?: Maybe<Order_By>;
};

/** columns and relationships of "TranscriptionJob" */
export type TranscriptionJob = {
  readonly __typename?: 'TranscriptionJob';
  readonly awsTranscribeJobName: Scalars['String'];
  readonly contentItemId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly languageCode: Scalars['String'];
  readonly transcriptionS3Url: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly videoS3Url: Scalars['String'];
};

/** aggregated selection of "TranscriptionJob" */
export type TranscriptionJob_Aggregate = {
  readonly __typename?: 'TranscriptionJob_aggregate';
  readonly aggregate?: Maybe<TranscriptionJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<TranscriptionJob>;
};

/** aggregate fields of "TranscriptionJob" */
export type TranscriptionJob_Aggregate_Fields = {
  readonly __typename?: 'TranscriptionJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<TranscriptionJob_Max_Fields>;
  readonly min?: Maybe<TranscriptionJob_Min_Fields>;
};


/** aggregate fields of "TranscriptionJob" */
export type TranscriptionJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "TranscriptionJob" */
export type TranscriptionJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<TranscriptionJob_Max_Order_By>;
  readonly min?: Maybe<TranscriptionJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "TranscriptionJob" */
export type TranscriptionJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<TranscriptionJob_Insert_Input>;
  readonly on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "TranscriptionJob". All fields are combined with a logical 'AND'. */
export type TranscriptionJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<TranscriptionJob_Bool_Exp>>>;
  readonly _not?: Maybe<TranscriptionJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<TranscriptionJob_Bool_Exp>>>;
  readonly awsTranscribeJobName?: Maybe<String_Comparison_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly languageCode?: Maybe<String_Comparison_Exp>;
  readonly transcriptionS3Url?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoS3Url?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "TranscriptionJob" */
export enum TranscriptionJob_Constraint {
  /** unique or primary key constraint */
  TranscriptionJobAwsTranscribeJobNameKey = 'TranscriptionJob_awsTranscribeJobName_key',
  /** unique or primary key constraint */
  TranscriptionJobPkey = 'TranscriptionJob_pkey'
}

/** input type for inserting data into table "TranscriptionJob" */
export type TranscriptionJob_Insert_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type TranscriptionJob_Max_Fields = {
  readonly __typename?: 'TranscriptionJob_max_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "TranscriptionJob" */
export type TranscriptionJob_Max_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type TranscriptionJob_Min_Fields = {
  readonly __typename?: 'TranscriptionJob_min_fields';
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "TranscriptionJob" */
export type TranscriptionJob_Min_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** response of any mutation on the table "TranscriptionJob" */
export type TranscriptionJob_Mutation_Response = {
  readonly __typename?: 'TranscriptionJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<TranscriptionJob>;
};

/** input type for inserting object relation for remote table "TranscriptionJob" */
export type TranscriptionJob_Obj_Rel_Insert_Input = {
  readonly data: TranscriptionJob_Insert_Input;
  readonly on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};

/** on conflict condition type for table "TranscriptionJob" */
export type TranscriptionJob_On_Conflict = {
  readonly constraint: TranscriptionJob_Constraint;
  readonly update_columns: ReadonlyArray<TranscriptionJob_Update_Column>;
  readonly where?: Maybe<TranscriptionJob_Bool_Exp>;
};

/** ordering options when selecting data from "TranscriptionJob" */
export type TranscriptionJob_Order_By = {
  readonly awsTranscribeJobName?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly languageCode?: Maybe<Order_By>;
  readonly transcriptionS3Url?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoS3Url?: Maybe<Order_By>;
};

/** primary key columns input for table: "TranscriptionJob" */
export type TranscriptionJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "TranscriptionJob" */
export enum TranscriptionJob_Select_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** input type for updating data in table "TranscriptionJob" */
export type TranscriptionJob_Set_Input = {
  readonly awsTranscribeJobName?: Maybe<Scalars['String']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly languageCode?: Maybe<Scalars['String']>;
  readonly transcriptionS3Url?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoS3Url?: Maybe<Scalars['String']>;
};

/** update columns of table "TranscriptionJob" */
export enum TranscriptionJob_Update_Column {
  /** column name */
  AwsTranscribeJobName = 'awsTranscribeJobName',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  LanguageCode = 'languageCode',
  /** column name */
  TranscriptionS3Url = 'transcriptionS3Url',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoS3Url = 'videoS3Url'
}

/** columns and relationships of "Transitions" */
export type Transitions = {
  readonly __typename?: 'Transitions';
  readonly broadcastContentId: Scalars['uuid'];
  /** An object relationship */
  readonly broadcastContentItem: BroadcastContentItem;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem>;
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  readonly time: Scalars['timestamptz'];
  readonly updatedAt: Scalars['timestamptz'];
};

/** aggregated selection of "Transitions" */
export type Transitions_Aggregate = {
  readonly __typename?: 'Transitions_aggregate';
  readonly aggregate?: Maybe<Transitions_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Transitions>;
};

/** aggregate fields of "Transitions" */
export type Transitions_Aggregate_Fields = {
  readonly __typename?: 'Transitions_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Transitions_Max_Fields>;
  readonly min?: Maybe<Transitions_Min_Fields>;
};


/** aggregate fields of "Transitions" */
export type Transitions_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Transitions" */
export type Transitions_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Transitions_Max_Order_By>;
  readonly min?: Maybe<Transitions_Min_Order_By>;
};

/** input type for inserting array relation for remote table "Transitions" */
export type Transitions_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Transitions_Insert_Input>;
  readonly on_conflict?: Maybe<Transitions_On_Conflict>;
};

/** Boolean expression to filter rows from the table "Transitions". All fields are combined with a logical 'AND'. */
export type Transitions_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Transitions_Bool_Exp>>>;
  readonly _not?: Maybe<Transitions_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Transitions_Bool_Exp>>>;
  readonly broadcastContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly fallbackBroadcastContentId?: Maybe<Uuid_Comparison_Exp>;
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly time?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Transitions" */
export enum Transitions_Constraint {
  /** unique or primary key constraint */
  TransitionsPkey = 'Transitions_pkey'
}

/** input type for inserting data into table "Transitions" */
export type Transitions_Insert_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Transitions_Max_Fields = {
  readonly __typename?: 'Transitions_max_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Transitions" */
export type Transitions_Max_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Transitions_Min_Fields = {
  readonly __typename?: 'Transitions_min_fields';
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Transitions" */
export type Transitions_Min_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Transitions" */
export type Transitions_Mutation_Response = {
  readonly __typename?: 'Transitions_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Transitions>;
};

/** input type for inserting object relation for remote table "Transitions" */
export type Transitions_Obj_Rel_Insert_Input = {
  readonly data: Transitions_Insert_Input;
  readonly on_conflict?: Maybe<Transitions_On_Conflict>;
};

/** on conflict condition type for table "Transitions" */
export type Transitions_On_Conflict = {
  readonly constraint: Transitions_Constraint;
  readonly update_columns: ReadonlyArray<Transitions_Update_Column>;
  readonly where?: Maybe<Transitions_Bool_Exp>;
};

/** ordering options when selecting data from "Transitions" */
export type Transitions_Order_By = {
  readonly broadcastContentId?: Maybe<Order_By>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentId?: Maybe<Order_By>;
  readonly fallbackBroadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly time?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Transitions" */
export type Transitions_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Transitions" */
export enum Transitions_Select_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  FallbackBroadcastContentId = 'fallbackBroadcastContentId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Transitions" */
export type Transitions_Set_Input = {
  readonly broadcastContentId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly fallbackBroadcastContentId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly time?: Maybe<Scalars['timestamptz']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "Transitions" */
export enum Transitions_Update_Column {
  /** column name */
  BroadcastContentId = 'broadcastContentId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  EventId = 'eventId',
  /** column name */
  FallbackBroadcastContentId = 'fallbackBroadcastContentId',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  Time = 'time',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type UpdateProfilePhotoResponse = {
  readonly __typename?: 'UpdateProfilePhotoResponse';
  readonly ok: Scalars['Boolean'];
  readonly photoURL_350x350?: Maybe<Scalars['String']>;
  readonly photoURL_50x50?: Maybe<Scalars['String']>;
};

/** columns and relationships of "Uploader" */
export type Uploader = {
  readonly __typename?: 'Uploader';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly email: Scalars['String'];
  readonly emailsSentCount: Scalars['Int'];
  readonly id: Scalars['uuid'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly requiredContentItem: RequiredContentItem;
  readonly requiredContentItemId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};

export type UploaderSendSubmissionRequestResult = {
  readonly __typename?: 'UploaderSendSubmissionRequestResult';
  readonly sent: Scalars['Boolean'];
  readonly uploaderId: Scalars['uuid'];
};

/** aggregated selection of "Uploader" */
export type Uploader_Aggregate = {
  readonly __typename?: 'Uploader_aggregate';
  readonly aggregate?: Maybe<Uploader_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Uploader>;
};

/** aggregate fields of "Uploader" */
export type Uploader_Aggregate_Fields = {
  readonly __typename?: 'Uploader_aggregate_fields';
  readonly avg?: Maybe<Uploader_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Uploader_Max_Fields>;
  readonly min?: Maybe<Uploader_Min_Fields>;
  readonly stddev?: Maybe<Uploader_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Uploader_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Uploader_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Uploader_Sum_Fields>;
  readonly var_pop?: Maybe<Uploader_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Uploader_Var_Samp_Fields>;
  readonly variance?: Maybe<Uploader_Variance_Fields>;
};


/** aggregate fields of "Uploader" */
export type Uploader_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "Uploader" */
export type Uploader_Aggregate_Order_By = {
  readonly avg?: Maybe<Uploader_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Uploader_Max_Order_By>;
  readonly min?: Maybe<Uploader_Min_Order_By>;
  readonly stddev?: Maybe<Uploader_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Uploader_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Uploader_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Uploader_Sum_Order_By>;
  readonly var_pop?: Maybe<Uploader_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Uploader_Var_Samp_Order_By>;
  readonly variance?: Maybe<Uploader_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "Uploader" */
export type Uploader_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Uploader_Insert_Input>;
  readonly on_conflict?: Maybe<Uploader_On_Conflict>;
};

/** aggregate avg on columns */
export type Uploader_Avg_Fields = {
  readonly __typename?: 'Uploader_avg_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "Uploader" */
export type Uploader_Avg_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "Uploader". All fields are combined with a logical 'AND'. */
export type Uploader_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Uploader_Bool_Exp>>>;
  readonly _not?: Maybe<Uploader_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Uploader_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emailsSentCount?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Bool_Exp>;
  readonly requiredContentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "Uploader" */
export enum Uploader_Constraint {
  /** unique or primary key constraint */
  UploaderEmailRequiredContentItemIdKey = 'Uploader_email_requiredContentItemId_key',
  /** unique or primary key constraint */
  UploaderPkey = 'Uploader_pkey'
}

/** input type for incrementing integer column in table "Uploader" */
export type Uploader_Inc_Input = {
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "Uploader" */
export type Uploader_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Obj_Rel_Insert_Input>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Uploader_Max_Fields = {
  readonly __typename?: 'Uploader_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "Uploader" */
export type Uploader_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItemId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Uploader_Min_Fields = {
  readonly __typename?: 'Uploader_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "Uploader" */
export type Uploader_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItemId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "Uploader" */
export type Uploader_Mutation_Response = {
  readonly __typename?: 'Uploader_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Uploader>;
};

/** input type for inserting object relation for remote table "Uploader" */
export type Uploader_Obj_Rel_Insert_Input = {
  readonly data: Uploader_Insert_Input;
  readonly on_conflict?: Maybe<Uploader_On_Conflict>;
};

/** on conflict condition type for table "Uploader" */
export type Uploader_On_Conflict = {
  readonly constraint: Uploader_Constraint;
  readonly update_columns: ReadonlyArray<Uploader_Update_Column>;
  readonly where?: Maybe<Uploader_Bool_Exp>;
};

/** ordering options when selecting data from "Uploader" */
export type Uploader_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emailsSentCount?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly requiredContentItem?: Maybe<RequiredContentItem_Order_By>;
  readonly requiredContentItemId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "Uploader" */
export type Uploader_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "Uploader" */
export enum Uploader_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RequiredContentItemId = 'requiredContentItemId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "Uploader" */
export type Uploader_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly requiredContentItemId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Uploader_Stddev_Fields = {
  readonly __typename?: 'Uploader_stddev_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "Uploader" */
export type Uploader_Stddev_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Uploader_Stddev_Pop_Fields = {
  readonly __typename?: 'Uploader_stddev_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "Uploader" */
export type Uploader_Stddev_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Uploader_Stddev_Samp_Fields = {
  readonly __typename?: 'Uploader_stddev_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "Uploader" */
export type Uploader_Stddev_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Uploader_Sum_Fields = {
  readonly __typename?: 'Uploader_sum_fields';
  readonly emailsSentCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "Uploader" */
export type Uploader_Sum_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** update columns of table "Uploader" */
export enum Uploader_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  EmailsSentCount = 'emailsSentCount',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  RequiredContentItemId = 'requiredContentItemId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** aggregate var_pop on columns */
export type Uploader_Var_Pop_Fields = {
  readonly __typename?: 'Uploader_var_pop_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "Uploader" */
export type Uploader_Var_Pop_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Uploader_Var_Samp_Fields = {
  readonly __typename?: 'Uploader_var_samp_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "Uploader" */
export type Uploader_Var_Samp_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Uploader_Variance_Fields = {
  readonly __typename?: 'Uploader_variance_fields';
  readonly emailsSentCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "Uploader" */
export type Uploader_Variance_Order_By = {
  readonly emailsSentCount?: Maybe<Order_By>;
};

/** columns and relationships of "User" */
export type User = {
  readonly __typename?: 'User';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  /** An array relationship */
  readonly attendees: ReadonlyArray<Attendee>;
  /** An aggregated array relationship */
  readonly attendees_aggregate: Attendee_Aggregate;
  /** An array relationship */
  readonly conferenceDemoCodes: ReadonlyArray<ConferenceDemoCode>;
  /** An aggregated array relationship */
  readonly conferenceDemoCodes_aggregate: ConferenceDemoCode_Aggregate;
  /** An array relationship */
  readonly conferencesCreated: ReadonlyArray<Conference>;
  /** An aggregated array relationship */
  readonly conferencesCreated_aggregate: Conference_Aggregate;
  readonly createdAt: Scalars['timestamptz'];
  readonly email?: Maybe<Scalars['String']>;
  /** An array relationship */
  readonly emails: ReadonlyArray<Email>;
  /** An aggregated array relationship */
  readonly emails_aggregate: Email_Aggregate;
  readonly firstName: Scalars['String'];
  readonly id: Scalars['String'];
  /** An array relationship */
  readonly invitationsPendingConfirmation: ReadonlyArray<Invitation>;
  /** An aggregated array relationship */
  readonly invitationsPendingConfirmation_aggregate: Invitation_Aggregate;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName: Scalars['String'];
  /** An object relationship */
  readonly onlineStatus?: Maybe<OnlineStatus>;
  /** An array relationship */
  readonly pushNotificationSubscriptions: ReadonlyArray<PushNotificationSubscription>;
  /** An aggregated array relationship */
  readonly pushNotificationSubscriptions_aggregate: PushNotificationSubscription_Aggregate;
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "User" */
export type UserAttendeesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserAttendees_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodesArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferenceDemoCodes_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreatedArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserConferencesCreated_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmailsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserEmails_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserInvitationsPendingConfirmation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserPushNotificationSubscriptionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** columns and relationships of "User" */
export type UserPushNotificationSubscriptions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};

/** aggregated selection of "User" */
export type User_Aggregate = {
  readonly __typename?: 'User_aggregate';
  readonly aggregate?: Maybe<User_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<User>;
};

/** aggregate fields of "User" */
export type User_Aggregate_Fields = {
  readonly __typename?: 'User_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<User_Max_Fields>;
  readonly min?: Maybe<User_Min_Fields>;
};


/** aggregate fields of "User" */
export type User_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<User_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "User" */
export type User_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<User_Max_Order_By>;
  readonly min?: Maybe<User_Min_Order_By>;
};

/** input type for inserting array relation for remote table "User" */
export type User_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<User_Insert_Input>;
  readonly on_conflict?: Maybe<User_On_Conflict>;
};

/** Boolean expression to filter rows from the table "User". All fields are combined with a logical 'AND'. */
export type User_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<User_Bool_Exp>>>;
  readonly _not?: Maybe<User_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<User_Bool_Exp>>>;
  readonly acceptedPrivacyPolicyAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly acceptedTermsAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly attendees?: Maybe<Attendee_Bool_Exp>;
  readonly conferenceDemoCodes?: Maybe<ConferenceDemoCode_Bool_Exp>;
  readonly conferencesCreated?: Maybe<Conference_Bool_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly email?: Maybe<String_Comparison_Exp>;
  readonly emails?: Maybe<Email_Bool_Exp>;
  readonly firstName?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<String_Comparison_Exp>;
  readonly invitationsPendingConfirmation?: Maybe<Invitation_Bool_Exp>;
  readonly lastLoggedInAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly lastName?: Maybe<String_Comparison_Exp>;
  readonly onlineStatus?: Maybe<OnlineStatus_Bool_Exp>;
  readonly pushNotificationSubscriptions?: Maybe<PushNotificationSubscription_Bool_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "User" */
export enum User_Constraint {
  /** unique or primary key constraint */
  UserEmailKey = 'user_email_key',
  /** unique or primary key constraint */
  UserPkey = 'user_pkey'
}

/** input type for inserting data into table "User" */
export type User_Insert_Input = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly attendees?: Maybe<Attendee_Arr_Rel_Insert_Input>;
  readonly conferenceDemoCodes?: Maybe<ConferenceDemoCode_Arr_Rel_Insert_Input>;
  readonly conferencesCreated?: Maybe<Conference_Arr_Rel_Insert_Input>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly emails?: Maybe<Email_Arr_Rel_Insert_Input>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly invitationsPendingConfirmation?: Maybe<Invitation_Arr_Rel_Insert_Input>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly onlineStatus?: Maybe<OnlineStatus_Obj_Rel_Insert_Input>;
  readonly pushNotificationSubscriptions?: Maybe<PushNotificationSubscription_Arr_Rel_Insert_Input>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type User_Max_Fields = {
  readonly __typename?: 'User_max_fields';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "User" */
export type User_Max_Order_By = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Order_By>;
  readonly acceptedTermsAt?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly firstName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastLoggedInAt?: Maybe<Order_By>;
  readonly lastName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type User_Min_Fields = {
  readonly __typename?: 'User_min_fields';
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "User" */
export type User_Min_Order_By = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Order_By>;
  readonly acceptedTermsAt?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly firstName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly lastLoggedInAt?: Maybe<Order_By>;
  readonly lastName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "User" */
export type User_Mutation_Response = {
  readonly __typename?: 'User_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<User>;
};

/** input type for inserting object relation for remote table "User" */
export type User_Obj_Rel_Insert_Input = {
  readonly data: User_Insert_Input;
  readonly on_conflict?: Maybe<User_On_Conflict>;
};

/** on conflict condition type for table "User" */
export type User_On_Conflict = {
  readonly constraint: User_Constraint;
  readonly update_columns: ReadonlyArray<User_Update_Column>;
  readonly where?: Maybe<User_Bool_Exp>;
};

/** ordering options when selecting data from "User" */
export type User_Order_By = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Order_By>;
  readonly acceptedTermsAt?: Maybe<Order_By>;
  readonly attendees_aggregate?: Maybe<Attendee_Aggregate_Order_By>;
  readonly conferenceDemoCodes_aggregate?: Maybe<ConferenceDemoCode_Aggregate_Order_By>;
  readonly conferencesCreated_aggregate?: Maybe<Conference_Aggregate_Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly email?: Maybe<Order_By>;
  readonly emails_aggregate?: Maybe<Email_Aggregate_Order_By>;
  readonly firstName?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly invitationsPendingConfirmation_aggregate?: Maybe<Invitation_Aggregate_Order_By>;
  readonly lastLoggedInAt?: Maybe<Order_By>;
  readonly lastName?: Maybe<Order_By>;
  readonly onlineStatus?: Maybe<OnlineStatus_Order_By>;
  readonly pushNotificationSubscriptions_aggregate?: Maybe<PushNotificationSubscription_Aggregate_Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "User" */
export type User_Pk_Columns_Input = {
  readonly id: Scalars['String'];
};

/** select columns of table "User" */
export enum User_Select_Column {
  /** column name */
  AcceptedPrivacyPolicyAt = 'acceptedPrivacyPolicyAt',
  /** column name */
  AcceptedTermsAt = 'acceptedTermsAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastLoggedInAt = 'lastLoggedInAt',
  /** column name */
  LastName = 'lastName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "User" */
export type User_Set_Input = {
  readonly acceptedPrivacyPolicyAt?: Maybe<Scalars['timestamptz']>;
  readonly acceptedTermsAt?: Maybe<Scalars['timestamptz']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly email?: Maybe<Scalars['String']>;
  readonly firstName?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['String']>;
  readonly lastLoggedInAt?: Maybe<Scalars['timestamptz']>;
  readonly lastName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "User" */
export enum User_Update_Column {
  /** column name */
  AcceptedPrivacyPolicyAt = 'acceptedPrivacyPolicyAt',
  /** column name */
  AcceptedTermsAt = 'acceptedTermsAt',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastLoggedInAt = 'lastLoggedInAt',
  /** column name */
  LastName = 'lastName',
  /** column name */
  UpdatedAt = 'updatedAt'
}

export type VapidPublicKeyOutput = {
  readonly __typename?: 'VAPIDPublicKeyOutput';
  readonly key: Scalars['String'];
};

/** columns and relationships of "VideoRenderJob" */
export type VideoRenderJob = {
  readonly __typename?: 'VideoRenderJob';
  /** An object relationship */
  readonly broadcastContentItem: BroadcastContentItem;
  readonly broadcastContentItemId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly conferencePrepareJob: ConferencePrepareJob;
  readonly conferencePrepareJobId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "VideoRenderJob" */
export type VideoRenderJobDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "VideoRenderJob" */
export type VideoRenderJob_Aggregate = {
  readonly __typename?: 'VideoRenderJob_aggregate';
  readonly aggregate?: Maybe<VideoRenderJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<VideoRenderJob>;
};

/** aggregate fields of "VideoRenderJob" */
export type VideoRenderJob_Aggregate_Fields = {
  readonly __typename?: 'VideoRenderJob_aggregate_fields';
  readonly avg?: Maybe<VideoRenderJob_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<VideoRenderJob_Max_Fields>;
  readonly min?: Maybe<VideoRenderJob_Min_Fields>;
  readonly stddev?: Maybe<VideoRenderJob_Stddev_Fields>;
  readonly stddev_pop?: Maybe<VideoRenderJob_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<VideoRenderJob_Stddev_Samp_Fields>;
  readonly sum?: Maybe<VideoRenderJob_Sum_Fields>;
  readonly var_pop?: Maybe<VideoRenderJob_Var_Pop_Fields>;
  readonly var_samp?: Maybe<VideoRenderJob_Var_Samp_Fields>;
  readonly variance?: Maybe<VideoRenderJob_Variance_Fields>;
};


/** aggregate fields of "VideoRenderJob" */
export type VideoRenderJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "VideoRenderJob" */
export type VideoRenderJob_Aggregate_Order_By = {
  readonly avg?: Maybe<VideoRenderJob_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<VideoRenderJob_Max_Order_By>;
  readonly min?: Maybe<VideoRenderJob_Min_Order_By>;
  readonly stddev?: Maybe<VideoRenderJob_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<VideoRenderJob_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<VideoRenderJob_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<VideoRenderJob_Sum_Order_By>;
  readonly var_pop?: Maybe<VideoRenderJob_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<VideoRenderJob_Var_Samp_Order_By>;
  readonly variance?: Maybe<VideoRenderJob_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type VideoRenderJob_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "VideoRenderJob" */
export type VideoRenderJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<VideoRenderJob_Insert_Input>;
  readonly on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};

/** aggregate avg on columns */
export type VideoRenderJob_Avg_Fields = {
  readonly __typename?: 'VideoRenderJob_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "VideoRenderJob". All fields are combined with a logical 'AND'. */
export type VideoRenderJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<VideoRenderJob_Bool_Exp>>>;
  readonly _not?: Maybe<VideoRenderJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<VideoRenderJob_Bool_Exp>>>;
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Bool_Exp>;
  readonly broadcastContentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly conferencePrepareJob?: Maybe<ConferencePrepareJob_Bool_Exp>;
  readonly conferencePrepareJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "VideoRenderJob" */
export enum VideoRenderJob_Constraint {
  /** unique or primary key constraint */
  VideoRenderJobPkey = 'VideoRenderJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type VideoRenderJob_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type VideoRenderJob_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type VideoRenderJob_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "VideoRenderJob" */
export type VideoRenderJob_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "VideoRenderJob" */
export type VideoRenderJob_Insert_Input = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Obj_Rel_Insert_Input>;
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJob?: Maybe<ConferencePrepareJob_Obj_Rel_Insert_Input>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type VideoRenderJob_Max_Fields = {
  readonly __typename?: 'VideoRenderJob_max_fields';
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Max_Order_By = {
  readonly broadcastContentItemId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type VideoRenderJob_Min_Fields = {
  readonly __typename?: 'VideoRenderJob_min_fields';
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Min_Order_By = {
  readonly broadcastContentItemId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "VideoRenderJob" */
export type VideoRenderJob_Mutation_Response = {
  readonly __typename?: 'VideoRenderJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<VideoRenderJob>;
};

/** input type for inserting object relation for remote table "VideoRenderJob" */
export type VideoRenderJob_Obj_Rel_Insert_Input = {
  readonly data: VideoRenderJob_Insert_Input;
  readonly on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};

/** on conflict condition type for table "VideoRenderJob" */
export type VideoRenderJob_On_Conflict = {
  readonly constraint: VideoRenderJob_Constraint;
  readonly update_columns: ReadonlyArray<VideoRenderJob_Update_Column>;
  readonly where?: Maybe<VideoRenderJob_Bool_Exp>;
};

/** ordering options when selecting data from "VideoRenderJob" */
export type VideoRenderJob_Order_By = {
  readonly broadcastContentItem?: Maybe<BroadcastContentItem_Order_By>;
  readonly broadcastContentItemId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly conferencePrepareJob?: Maybe<ConferencePrepareJob_Order_By>;
  readonly conferencePrepareJobId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "VideoRenderJob" */
export type VideoRenderJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type VideoRenderJob_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "VideoRenderJob" */
export enum VideoRenderJob_Select_Column {
  /** column name */
  BroadcastContentItemId = 'broadcastContentItemId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "VideoRenderJob" */
export type VideoRenderJob_Set_Input = {
  readonly broadcastContentItemId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly conferencePrepareJobId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type VideoRenderJob_Stddev_Fields = {
  readonly __typename?: 'VideoRenderJob_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type VideoRenderJob_Stddev_Pop_Fields = {
  readonly __typename?: 'VideoRenderJob_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type VideoRenderJob_Stddev_Samp_Fields = {
  readonly __typename?: 'VideoRenderJob_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type VideoRenderJob_Sum_Fields = {
  readonly __typename?: 'VideoRenderJob_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "VideoRenderJob" */
export enum VideoRenderJob_Update_Column {
  /** column name */
  BroadcastContentItemId = 'broadcastContentItemId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ConferencePrepareJobId = 'conferencePrepareJobId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type VideoRenderJob_Var_Pop_Fields = {
  readonly __typename?: 'VideoRenderJob_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type VideoRenderJob_Var_Samp_Fields = {
  readonly __typename?: 'VideoRenderJob_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type VideoRenderJob_Variance_Fields = {
  readonly __typename?: 'VideoRenderJob_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "VideoRenderJob" */
export type VideoRenderJob_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** columns and relationships of "YouTubeUpload" */
export type YouTubeUpload = {
  readonly __typename?: 'YouTubeUpload';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentItem?: Maybe<ContentItem>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId: Scalars['String'];
  readonly videoPrivacyStatus: Scalars['String'];
  readonly videoStatus: Scalars['String'];
  readonly videoTitle: Scalars['String'];
};

/** aggregated selection of "YouTubeUpload" */
export type YouTubeUpload_Aggregate = {
  readonly __typename?: 'YouTubeUpload_aggregate';
  readonly aggregate?: Maybe<YouTubeUpload_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<YouTubeUpload>;
};

/** aggregate fields of "YouTubeUpload" */
export type YouTubeUpload_Aggregate_Fields = {
  readonly __typename?: 'YouTubeUpload_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<YouTubeUpload_Max_Fields>;
  readonly min?: Maybe<YouTubeUpload_Min_Fields>;
};


/** aggregate fields of "YouTubeUpload" */
export type YouTubeUpload_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<YouTubeUpload_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "YouTubeUpload" */
export type YouTubeUpload_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<YouTubeUpload_Max_Order_By>;
  readonly min?: Maybe<YouTubeUpload_Min_Order_By>;
};

/** input type for inserting array relation for remote table "YouTubeUpload" */
export type YouTubeUpload_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<YouTubeUpload_Insert_Input>;
  readonly on_conflict?: Maybe<YouTubeUpload_On_Conflict>;
};

/** Boolean expression to filter rows from the table "YouTubeUpload". All fields are combined with a logical 'AND'. */
export type YouTubeUpload_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<YouTubeUpload_Bool_Exp>>>;
  readonly _not?: Maybe<YouTubeUpload_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<YouTubeUpload_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploadYouTubeVideoJobId?: Maybe<Uuid_Comparison_Exp>;
  readonly videoId?: Maybe<String_Comparison_Exp>;
  readonly videoPrivacyStatus?: Maybe<String_Comparison_Exp>;
  readonly videoStatus?: Maybe<String_Comparison_Exp>;
  readonly videoTitle?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "YouTubeUpload" */
export enum YouTubeUpload_Constraint {
  /** unique or primary key constraint */
  YouTubeUploadPkey = 'YouTubeUpload_pkey',
  /** unique or primary key constraint */
  YouTubeUploadVideoIdKey = 'YouTubeUpload_videoId_key'
}

/** input type for inserting data into table "YouTubeUpload" */
export type YouTubeUpload_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type YouTubeUpload_Max_Fields = {
  readonly __typename?: 'YouTubeUpload_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "YouTubeUpload" */
export type YouTubeUpload_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type YouTubeUpload_Min_Fields = {
  readonly __typename?: 'YouTubeUpload_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "YouTubeUpload" */
export type YouTubeUpload_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** response of any mutation on the table "YouTubeUpload" */
export type YouTubeUpload_Mutation_Response = {
  readonly __typename?: 'YouTubeUpload_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<YouTubeUpload>;
};

/** input type for inserting object relation for remote table "YouTubeUpload" */
export type YouTubeUpload_Obj_Rel_Insert_Input = {
  readonly data: YouTubeUpload_Insert_Input;
  readonly on_conflict?: Maybe<YouTubeUpload_On_Conflict>;
};

/** on conflict condition type for table "YouTubeUpload" */
export type YouTubeUpload_On_Conflict = {
  readonly constraint: YouTubeUpload_Constraint;
  readonly update_columns: ReadonlyArray<YouTubeUpload_Update_Column>;
  readonly where?: Maybe<YouTubeUpload_Bool_Exp>;
};

/** ordering options when selecting data from "YouTubeUpload" */
export type YouTubeUpload_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly uploadYouTubeVideoJobId?: Maybe<Order_By>;
  readonly videoId?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** primary key columns input for table: "YouTubeUpload" */
export type YouTubeUpload_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "YouTubeUpload" */
export enum YouTubeUpload_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadYouTubeVideoJobId = 'uploadYouTubeVideoJobId',
  /** column name */
  VideoId = 'videoId',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoStatus = 'videoStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** input type for updating data in table "YouTubeUpload" */
export type YouTubeUpload_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly uploadYouTubeVideoJobId?: Maybe<Scalars['uuid']>;
  readonly videoId?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** update columns of table "YouTubeUpload" */
export enum YouTubeUpload_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UploadYouTubeVideoJobId = 'uploadYouTubeVideoJobId',
  /** column name */
  VideoId = 'videoId',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoStatus = 'videoStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** columns and relationships of "analytics.AppStats" */
export type Analytics_AppStats = {
  readonly __typename?: 'analytics_AppStats';
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['Int'];
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs: Scalars['Int'];
  readonly total_unique_user_ids: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "analytics.AppStats" */
export type Analytics_AppStatsPagesArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate = {
  readonly __typename?: 'analytics_AppStats_aggregate';
  readonly aggregate?: Maybe<Analytics_AppStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_AppStats>;
};

/** aggregate fields of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_AppStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_AppStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_AppStats_Max_Fields>;
  readonly min?: Maybe<Analytics_AppStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_AppStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_AppStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_AppStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_AppStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_AppStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_AppStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_AppStats_Variance_Fields>;
};


/** aggregate fields of "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.AppStats" */
export type Analytics_AppStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_AppStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_AppStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_AppStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_AppStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_AppStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_AppStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_AppStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_AppStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_AppStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_AppStats_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Analytics_AppStats_Append_Input = {
  readonly pages?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "analytics.AppStats" */
export type Analytics_AppStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_AppStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_AppStats_Avg_Fields = {
  readonly __typename?: 'analytics_AppStats_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.AppStats". All fields are combined with a logical 'AND'. */
export type Analytics_AppStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_AppStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_AppStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_AppStats_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly pages?: Maybe<Jsonb_Comparison_Exp>;
  readonly total_unique_tabs?: Maybe<Int_Comparison_Exp>;
  readonly total_unique_user_ids?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.AppStats" */
export enum Analytics_AppStats_Constraint {
  /** unique or primary key constraint */
  AppStatsPkey = 'AppStats_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Analytics_AppStats_Delete_At_Path_Input = {
  readonly pages?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Analytics_AppStats_Delete_Elem_Input = {
  readonly pages?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Analytics_AppStats_Delete_Key_Input = {
  readonly pages?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "analytics.AppStats" */
export type Analytics_AppStats_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.AppStats" */
export type Analytics_AppStats_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Analytics_AppStats_Max_Fields = {
  readonly __typename?: 'analytics_AppStats_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_AppStats_Min_Fields = {
  readonly __typename?: 'analytics_AppStats_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.AppStats" */
export type Analytics_AppStats_Mutation_Response = {
  readonly __typename?: 'analytics_AppStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_AppStats>;
};

/** input type for inserting object relation for remote table "analytics.AppStats" */
export type Analytics_AppStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_AppStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.AppStats" */
export type Analytics_AppStats_On_Conflict = {
  readonly constraint: Analytics_AppStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_AppStats_Update_Column>;
  readonly where?: Maybe<Analytics_AppStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.AppStats" */
export type Analytics_AppStats_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly pages?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.AppStats" */
export type Analytics_AppStats_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Analytics_AppStats_Prepend_Input = {
  readonly pages?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "analytics.AppStats" */
export enum Analytics_AppStats_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pages = 'pages',
  /** column name */
  TotalUniqueTabs = 'total_unique_tabs',
  /** column name */
  TotalUniqueUserIds = 'total_unique_user_ids',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "analytics.AppStats" */
export type Analytics_AppStats_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly pages?: Maybe<Scalars['jsonb']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Analytics_AppStats_Stddev_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_AppStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_AppStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_AppStats_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_AppStats_Sum_Fields = {
  readonly __typename?: 'analytics_AppStats_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
  readonly total_unique_tabs?: Maybe<Scalars['Int']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** update columns of table "analytics.AppStats" */
export enum Analytics_AppStats_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Pages = 'pages',
  /** column name */
  TotalUniqueTabs = 'total_unique_tabs',
  /** column name */
  TotalUniqueUserIds = 'total_unique_user_ids',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Analytics_AppStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_AppStats_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_AppStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_AppStats_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_AppStats_Variance_Fields = {
  readonly __typename?: 'analytics_AppStats_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
  readonly total_unique_tabs?: Maybe<Scalars['Float']>;
  readonly total_unique_user_ids?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.AppStats" */
export type Analytics_AppStats_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
  readonly total_unique_tabs?: Maybe<Order_By>;
  readonly total_unique_user_ids?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats = {
  readonly __typename?: 'analytics_ContentGroupStats';
  /** An object relationship */
  readonly contentGroup: ContentGroup;
  readonly contentGroupId: Scalars['uuid'];
  readonly viewCount: Scalars['Int'];
};

/** aggregated selection of "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Aggregate = {
  readonly __typename?: 'analytics_ContentGroupStats_aggregate';
  readonly aggregate?: Maybe<Analytics_ContentGroupStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ContentGroupStats>;
};

/** aggregate fields of "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_ContentGroupStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_ContentGroupStats_Max_Fields>;
  readonly min?: Maybe<Analytics_ContentGroupStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ContentGroupStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ContentGroupStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ContentGroupStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ContentGroupStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ContentGroupStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ContentGroupStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ContentGroupStats_Variance_Fields>;
};


/** aggregate fields of "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_ContentGroupStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_ContentGroupStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_ContentGroupStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_ContentGroupStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_ContentGroupStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_ContentGroupStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_ContentGroupStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_ContentGroupStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_ContentGroupStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_ContentGroupStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_ContentGroupStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_ContentGroupStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_ContentGroupStats_Avg_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_avg_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Avg_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.ContentGroupStats". All fields are combined with a logical 'AND'. */
export type Analytics_ContentGroupStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_ContentGroupStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_ContentGroupStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_ContentGroupStats_Bool_Exp>>>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly contentGroupId?: Maybe<Uuid_Comparison_Exp>;
  readonly viewCount?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.ContentGroupStats" */
export enum Analytics_ContentGroupStats_Constraint {
  /** unique or primary key constraint */
  ContentGroupStatsPkey = 'ContentGroupStats_pkey'
}

/** input type for incrementing integer column in table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Inc_Input = {
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Insert_Input = {
  readonly contentGroup?: Maybe<ContentGroup_Obj_Rel_Insert_Input>;
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Analytics_ContentGroupStats_Max_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_max_fields';
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Max_Order_By = {
  readonly contentGroupId?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_ContentGroupStats_Min_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_min_fields';
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Min_Order_By = {
  readonly contentGroupId?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Mutation_Response = {
  readonly __typename?: 'analytics_ContentGroupStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_ContentGroupStats>;
};

/** input type for inserting object relation for remote table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_ContentGroupStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_ContentGroupStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_On_Conflict = {
  readonly constraint: Analytics_ContentGroupStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_ContentGroupStats_Update_Column>;
  readonly where?: Maybe<Analytics_ContentGroupStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Order_By = {
  readonly contentGroup?: Maybe<ContentGroup_Order_By>;
  readonly contentGroupId?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Pk_Columns_Input = {
  readonly contentGroupId: Scalars['uuid'];
};

/** select columns of table "analytics.ContentGroupStats" */
export enum Analytics_ContentGroupStats_Select_Column {
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ViewCount = 'viewCount'
}

/** input type for updating data in table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Set_Input = {
  readonly contentGroupId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Analytics_ContentGroupStats_Stddev_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_stddev_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Stddev_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ContentGroupStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_stddev_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Stddev_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ContentGroupStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_stddev_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Stddev_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_ContentGroupStats_Sum_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_sum_fields';
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Sum_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.ContentGroupStats" */
export enum Analytics_ContentGroupStats_Update_Column {
  /** column name */
  ContentGroupId = 'contentGroupId',
  /** column name */
  ViewCount = 'viewCount'
}

/** aggregate var_pop on columns */
export type Analytics_ContentGroupStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_var_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Var_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_ContentGroupStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_var_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Var_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_ContentGroupStats_Variance_Fields = {
  readonly __typename?: 'analytics_ContentGroupStats_variance_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.ContentGroupStats" */
export type Analytics_ContentGroupStats_Variance_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats = {
  readonly __typename?: 'analytics_ContentItemStats';
  /** An object relationship */
  readonly contentItem: ContentItem;
  readonly contentItemId: Scalars['uuid'];
  readonly viewCount: Scalars['Int'];
};

/** aggregated selection of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate = {
  readonly __typename?: 'analytics_ContentItemStats_aggregate';
  readonly aggregate?: Maybe<Analytics_ContentItemStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_ContentItemStats>;
};

/** aggregate fields of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_ContentItemStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_ContentItemStats_Max_Fields>;
  readonly min?: Maybe<Analytics_ContentItemStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_ContentItemStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_ContentItemStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_ContentItemStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_ContentItemStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_ContentItemStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_ContentItemStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_ContentItemStats_Variance_Fields>;
};


/** aggregate fields of "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_ContentItemStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_ContentItemStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_ContentItemStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_ContentItemStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_ContentItemStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_ContentItemStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_ContentItemStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_ContentItemStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_ContentItemStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_ContentItemStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_ContentItemStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_ContentItemStats_Avg_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_avg_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Avg_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.ContentItemStats". All fields are combined with a logical 'AND'. */
export type Analytics_ContentItemStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_ContentItemStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_ContentItemStats_Bool_Exp>>>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly viewCount?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Constraint {
  /** unique or primary key constraint */
  ContentItemStatsPkey = 'ContentItemStats_pkey'
}

/** input type for incrementing integer column in table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Inc_Input = {
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Insert_Input = {
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Analytics_ContentItemStats_Max_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_max_fields';
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Max_Order_By = {
  readonly contentItemId?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_ContentItemStats_Min_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_min_fields';
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Min_Order_By = {
  readonly contentItemId?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Mutation_Response = {
  readonly __typename?: 'analytics_ContentItemStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_ContentItemStats>;
};

/** input type for inserting object relation for remote table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_ContentItemStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_On_Conflict = {
  readonly constraint: Analytics_ContentItemStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_ContentItemStats_Update_Column>;
  readonly where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Order_By = {
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly viewCount?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Pk_Columns_Input = {
  readonly contentItemId: Scalars['uuid'];
};

/** select columns of table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Select_Column {
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  ViewCount = 'viewCount'
}

/** input type for updating data in table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Set_Input = {
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Analytics_ContentItemStats_Stddev_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_ContentItemStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_ContentItemStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_stddev_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Stddev_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_ContentItemStats_Sum_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_sum_fields';
  readonly viewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Sum_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.ContentItemStats" */
export enum Analytics_ContentItemStats_Update_Column {
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  ViewCount = 'viewCount'
}

/** aggregate var_pop on columns */
export type Analytics_ContentItemStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_var_pop_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Var_Pop_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_ContentItemStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_var_samp_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Var_Samp_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_ContentItemStats_Variance_Fields = {
  readonly __typename?: 'analytics_ContentItemStats_variance_fields';
  readonly viewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.ContentItemStats" */
export type Analytics_ContentItemStats_Variance_Order_By = {
  readonly viewCount?: Maybe<Order_By>;
};

/** columns and relationships of "analytics.RoomStats" */
export type Analytics_RoomStats = {
  readonly __typename?: 'analytics_RoomStats';
  readonly hlsViewCount: Scalars['Int'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
};

/** aggregated selection of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate = {
  readonly __typename?: 'analytics_RoomStats_aggregate';
  readonly aggregate?: Maybe<Analytics_RoomStats_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Analytics_RoomStats>;
};

/** aggregate fields of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_Fields = {
  readonly __typename?: 'analytics_RoomStats_aggregate_fields';
  readonly avg?: Maybe<Analytics_RoomStats_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Analytics_RoomStats_Max_Fields>;
  readonly min?: Maybe<Analytics_RoomStats_Min_Fields>;
  readonly stddev?: Maybe<Analytics_RoomStats_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Analytics_RoomStats_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Analytics_RoomStats_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Analytics_RoomStats_Sum_Fields>;
  readonly var_pop?: Maybe<Analytics_RoomStats_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Analytics_RoomStats_Var_Samp_Fields>;
  readonly variance?: Maybe<Analytics_RoomStats_Variance_Fields>;
};


/** aggregate fields of "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "analytics.RoomStats" */
export type Analytics_RoomStats_Aggregate_Order_By = {
  readonly avg?: Maybe<Analytics_RoomStats_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Analytics_RoomStats_Max_Order_By>;
  readonly min?: Maybe<Analytics_RoomStats_Min_Order_By>;
  readonly stddev?: Maybe<Analytics_RoomStats_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Analytics_RoomStats_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Analytics_RoomStats_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Analytics_RoomStats_Sum_Order_By>;
  readonly var_pop?: Maybe<Analytics_RoomStats_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Analytics_RoomStats_Var_Samp_Order_By>;
  readonly variance?: Maybe<Analytics_RoomStats_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "analytics.RoomStats" */
export type Analytics_RoomStats_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Analytics_RoomStats_Insert_Input>;
  readonly on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};

/** aggregate avg on columns */
export type Analytics_RoomStats_Avg_Fields = {
  readonly __typename?: 'analytics_RoomStats_avg_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Avg_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "analytics.RoomStats". All fields are combined with a logical 'AND'. */
export type Analytics_RoomStats_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Analytics_RoomStats_Bool_Exp>>>;
  readonly _not?: Maybe<Analytics_RoomStats_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Analytics_RoomStats_Bool_Exp>>>;
  readonly hlsViewCount?: Maybe<Int_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "analytics.RoomStats" */
export enum Analytics_RoomStats_Constraint {
  /** unique or primary key constraint */
  RoomStatsPkey = 'RoomStats_pkey'
}

/** input type for incrementing integer column in table "analytics.RoomStats" */
export type Analytics_RoomStats_Inc_Input = {
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "analytics.RoomStats" */
export type Analytics_RoomStats_Insert_Input = {
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Analytics_RoomStats_Max_Fields = {
  readonly __typename?: 'analytics_RoomStats_max_fields';
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Max_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Analytics_RoomStats_Min_Fields = {
  readonly __typename?: 'analytics_RoomStats_min_fields';
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Min_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
};

/** response of any mutation on the table "analytics.RoomStats" */
export type Analytics_RoomStats_Mutation_Response = {
  readonly __typename?: 'analytics_RoomStats_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Analytics_RoomStats>;
};

/** input type for inserting object relation for remote table "analytics.RoomStats" */
export type Analytics_RoomStats_Obj_Rel_Insert_Input = {
  readonly data: Analytics_RoomStats_Insert_Input;
  readonly on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};

/** on conflict condition type for table "analytics.RoomStats" */
export type Analytics_RoomStats_On_Conflict = {
  readonly constraint: Analytics_RoomStats_Constraint;
  readonly update_columns: ReadonlyArray<Analytics_RoomStats_Update_Column>;
  readonly where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};

/** ordering options when selecting data from "analytics.RoomStats" */
export type Analytics_RoomStats_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
};

/** primary key columns input for table: "analytics.RoomStats" */
export type Analytics_RoomStats_Pk_Columns_Input = {
  readonly roomId: Scalars['uuid'];
};

/** select columns of table "analytics.RoomStats" */
export enum Analytics_RoomStats_Select_Column {
  /** column name */
  HlsViewCount = 'hlsViewCount',
  /** column name */
  RoomId = 'roomId'
}

/** input type for updating data in table "analytics.RoomStats" */
export type Analytics_RoomStats_Set_Input = {
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
};

/** aggregate stddev on columns */
export type Analytics_RoomStats_Stddev_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Analytics_RoomStats_Stddev_Pop_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_pop_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Pop_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Analytics_RoomStats_Stddev_Samp_Fields = {
  readonly __typename?: 'analytics_RoomStats_stddev_samp_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Stddev_Samp_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Analytics_RoomStats_Sum_Fields = {
  readonly __typename?: 'analytics_RoomStats_sum_fields';
  readonly hlsViewCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Sum_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** update columns of table "analytics.RoomStats" */
export enum Analytics_RoomStats_Update_Column {
  /** column name */
  HlsViewCount = 'hlsViewCount',
  /** column name */
  RoomId = 'roomId'
}

/** aggregate var_pop on columns */
export type Analytics_RoomStats_Var_Pop_Fields = {
  readonly __typename?: 'analytics_RoomStats_var_pop_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Var_Pop_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Analytics_RoomStats_Var_Samp_Fields = {
  readonly __typename?: 'analytics_RoomStats_var_samp_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Var_Samp_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Analytics_RoomStats_Variance_Fields = {
  readonly __typename?: 'analytics_RoomStats_variance_fields';
  readonly hlsViewCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "analytics.RoomStats" */
export type Analytics_RoomStats_Variance_Order_By = {
  readonly hlsViewCount?: Maybe<Order_By>;
};


/** expression to compare columns of type bigint. All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['bigint']>;
  readonly _gt?: Maybe<Scalars['bigint']>;
  readonly _gte?: Maybe<Scalars['bigint']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['bigint']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['bigint']>;
  readonly _lte?: Maybe<Scalars['bigint']>;
  readonly _neq?: Maybe<Scalars['bigint']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['bigint']>>;
};

/** columns and relationships of "chat.Chat" */
export type Chat_Chat = {
  readonly __typename?: 'chat_Chat';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An array relationship */
  readonly contentGroup: ReadonlyArray<ContentGroup>;
  /** An aggregated array relationship */
  readonly contentGroup_aggregate: ContentGroup_Aggregate;
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly duplicateTo?: Maybe<Chat_Chat>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly duplicatesFrom: ReadonlyArray<Chat_Chat>;
  /** An aggregated array relationship */
  readonly duplicatesFrom_aggregate: Chat_Chat_Aggregate;
  readonly enableAutoPin: Scalars['Boolean'];
  readonly enableAutoSubscribe: Scalars['Boolean'];
  readonly enableMandatoryPin: Scalars['Boolean'];
  readonly enableMandatorySubscribe: Scalars['Boolean'];
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregated array relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['uuid'];
  /** An array relationship */
  readonly messages: ReadonlyArray<Chat_Message>;
  /** An aggregated array relationship */
  readonly messages_aggregate: Chat_Message_Aggregate;
  /** An array relationship */
  readonly pins: ReadonlyArray<Chat_Pin>;
  /** An aggregated array relationship */
  readonly pins_aggregate: Chat_Pin_Aggregate;
  /** An array relationship */
  readonly readUpToIndices: ReadonlyArray<Chat_ReadUpToIndex>;
  /** An aggregated array relationship */
  readonly readUpToIndices_aggregate: Chat_ReadUpToIndex_Aggregate;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins: Scalars['Boolean'];
  /** An array relationship */
  readonly room: ReadonlyArray<Room>;
  /** An aggregated array relationship */
  readonly room_aggregate: Room_Aggregate;
  /** An array relationship */
  readonly subscriptions: ReadonlyArray<Chat_Subscription>;
  /** An aggregated array relationship */
  readonly subscriptions_aggregate: Chat_Subscription_Aggregate;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatContentGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatContentGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFromArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatDuplicatesFrom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessagesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatMessages_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPinsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatPins_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndicesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatReadUpToIndices_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** columns and relationships of "chat.Chat" */
export type Chat_ChatSubscriptions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};

/** aggregated selection of "chat.Chat" */
export type Chat_Chat_Aggregate = {
  readonly __typename?: 'chat_Chat_aggregate';
  readonly aggregate?: Maybe<Chat_Chat_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Chat>;
};

/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_Fields = {
  readonly __typename?: 'chat_Chat_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Chat_Max_Fields>;
  readonly min?: Maybe<Chat_Chat_Min_Fields>;
};


/** aggregate fields of "chat.Chat" */
export type Chat_Chat_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Chat" */
export type Chat_Chat_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Chat_Max_Order_By>;
  readonly min?: Maybe<Chat_Chat_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Chat" */
export type Chat_Chat_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Chat_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Chat". All fields are combined with a logical 'AND'. */
export type Chat_Chat_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Chat_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Chat_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Chat_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentGroup?: Maybe<ContentGroup_Bool_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly duplicateTo?: Maybe<Chat_Chat_Bool_Exp>;
  readonly duplicateToId?: Maybe<Uuid_Comparison_Exp>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Bool_Exp>;
  readonly enableAutoPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableAutoSubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatoryPin?: Maybe<Boolean_Comparison_Exp>;
  readonly enableMandatorySubscribe?: Maybe<Boolean_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly messages?: Maybe<Chat_Message_Bool_Exp>;
  readonly pins?: Maybe<Chat_Pin_Bool_Exp>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly remoteServiceId?: Maybe<String_Comparison_Exp>;
  readonly restrictToAdmins?: Maybe<Boolean_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly subscriptions?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Chat" */
export enum Chat_Chat_Constraint {
  /** unique or primary key constraint */
  ChatPkey = 'Chat_pkey'
}

/** input type for inserting data into table "chat.Chat" */
export type Chat_Chat_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentGroup?: Maybe<ContentGroup_Arr_Rel_Insert_Input>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateTo?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly duplicatesFrom?: Maybe<Chat_Chat_Arr_Rel_Insert_Input>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly messages?: Maybe<Chat_Message_Arr_Rel_Insert_Input>;
  readonly pins?: Maybe<Chat_Pin_Arr_Rel_Insert_Input>;
  readonly readUpToIndices?: Maybe<Chat_ReadUpToIndex_Arr_Rel_Insert_Input>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly room?: Maybe<Room_Arr_Rel_Insert_Input>;
  readonly subscriptions?: Maybe<Chat_Subscription_Arr_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Chat_Max_Fields = {
  readonly __typename?: 'chat_Chat_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Chat" */
export type Chat_Chat_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Chat_Min_Fields = {
  readonly __typename?: 'chat_Chat_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Chat" */
export type Chat_Chat_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Chat" */
export type Chat_Chat_Mutation_Response = {
  readonly __typename?: 'chat_Chat_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Chat>;
};

/** input type for inserting object relation for remote table "chat.Chat" */
export type Chat_Chat_Obj_Rel_Insert_Input = {
  readonly data: Chat_Chat_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};

/** on conflict condition type for table "chat.Chat" */
export type Chat_Chat_On_Conflict = {
  readonly constraint: Chat_Chat_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Chat_Update_Column>;
  readonly where?: Maybe<Chat_Chat_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Chat" */
export type Chat_Chat_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentGroup_aggregate?: Maybe<ContentGroup_Aggregate_Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateTo?: Maybe<Chat_Chat_Order_By>;
  readonly duplicateToId?: Maybe<Order_By>;
  readonly duplicatesFrom_aggregate?: Maybe<Chat_Chat_Aggregate_Order_By>;
  readonly enableAutoPin?: Maybe<Order_By>;
  readonly enableAutoSubscribe?: Maybe<Order_By>;
  readonly enableMandatoryPin?: Maybe<Order_By>;
  readonly enableMandatorySubscribe?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messages_aggregate?: Maybe<Chat_Message_Aggregate_Order_By>;
  readonly pins_aggregate?: Maybe<Chat_Pin_Aggregate_Order_By>;
  readonly readUpToIndices_aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Order_By>;
  readonly remoteServiceId?: Maybe<Order_By>;
  readonly restrictToAdmins?: Maybe<Order_By>;
  readonly room_aggregate?: Maybe<Room_Aggregate_Order_By>;
  readonly subscriptions_aggregate?: Maybe<Chat_Subscription_Aggregate_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Chat" */
export type Chat_Chat_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "chat.Chat" */
export enum Chat_Chat_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RemoteServiceId = 'remoteServiceId',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Chat" */
export type Chat_Chat_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateToId?: Maybe<Scalars['uuid']>;
  readonly enableAutoPin?: Maybe<Scalars['Boolean']>;
  readonly enableAutoSubscribe?: Maybe<Scalars['Boolean']>;
  readonly enableMandatoryPin?: Maybe<Scalars['Boolean']>;
  readonly enableMandatorySubscribe?: Maybe<Scalars['Boolean']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly remoteServiceId?: Maybe<Scalars['String']>;
  readonly restrictToAdmins?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Chat" */
export enum Chat_Chat_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DuplicateToId = 'duplicateToId',
  /** column name */
  EnableAutoPin = 'enableAutoPin',
  /** column name */
  EnableAutoSubscribe = 'enableAutoSubscribe',
  /** column name */
  EnableMandatoryPin = 'enableMandatoryPin',
  /** column name */
  EnableMandatorySubscribe = 'enableMandatorySubscribe',
  /** column name */
  Id = 'id',
  /** column name */
  RemoteServiceId = 'remoteServiceId',
  /** column name */
  RestrictToAdmins = 'restrictToAdmins',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "chat.Flag" */
export type Chat_Flag = {
  readonly __typename?: 'chat_Flag';
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly discussionChat?: Maybe<Chat_Chat>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  /** An object relationship */
  readonly flaggedBy?: Maybe<Attendee>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id: Scalars['Int'];
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageSId: Scalars['uuid'];
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type: Chat_FlagType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};

/** columns and relationships of "chat.FlagType" */
export type Chat_FlagType = {
  readonly __typename?: 'chat_FlagType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.FlagType" */
export type Chat_FlagType_Aggregate = {
  readonly __typename?: 'chat_FlagType_aggregate';
  readonly aggregate?: Maybe<Chat_FlagType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_FlagType>;
};

/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_Fields = {
  readonly __typename?: 'chat_FlagType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_FlagType_Max_Fields>;
  readonly min?: Maybe<Chat_FlagType_Min_Fields>;
};


/** aggregate fields of "chat.FlagType" */
export type Chat_FlagType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.FlagType" */
export type Chat_FlagType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_FlagType_Max_Order_By>;
  readonly min?: Maybe<Chat_FlagType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.FlagType" */
export type Chat_FlagType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_FlagType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.FlagType". All fields are combined with a logical 'AND'. */
export type Chat_FlagType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_FlagType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_FlagType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_FlagType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.FlagType" */
export enum Chat_FlagType_Constraint {
  /** unique or primary key constraint */
  FlagTypePkey = 'FlagType_pkey'
}

export enum Chat_FlagType_Enum {
  /** It's abusive or harmful. */
  Abusive = 'Abusive',
  /** It contains false information and is intended to mislead readers. */
  Disinformation = 'Disinformation',
  /** It gives the wrong idea or impression. */
  Misleading = 'Misleading',
  /** It expresses intentions of self-harm or suicide. */
  RiskToLife = 'Risk_To_Life',
  /** It's spam, suspicious or annoying. */
  Spam = 'Spam'
}

/** expression to compare columns of type chat_FlagType_enum. All fields are combined with logical 'AND'. */
export type Chat_FlagType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_FlagType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_FlagType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_FlagType_Enum>>;
};

/** input type for inserting data into table "chat.FlagType" */
export type Chat_FlagType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_FlagType_Max_Fields = {
  readonly __typename?: 'chat_FlagType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.FlagType" */
export type Chat_FlagType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_FlagType_Min_Fields = {
  readonly __typename?: 'chat_FlagType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.FlagType" */
export type Chat_FlagType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.FlagType" */
export type Chat_FlagType_Mutation_Response = {
  readonly __typename?: 'chat_FlagType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_FlagType>;
};

/** input type for inserting object relation for remote table "chat.FlagType" */
export type Chat_FlagType_Obj_Rel_Insert_Input = {
  readonly data: Chat_FlagType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};

/** on conflict condition type for table "chat.FlagType" */
export type Chat_FlagType_On_Conflict = {
  readonly constraint: Chat_FlagType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_FlagType_Update_Column>;
  readonly where?: Maybe<Chat_FlagType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.FlagType" */
export type Chat_FlagType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.FlagType" */
export type Chat_FlagType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.FlagType" */
export enum Chat_FlagType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.FlagType" */
export type Chat_FlagType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.FlagType" */
export enum Chat_FlagType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Flag" */
export type Chat_Flag_Aggregate = {
  readonly __typename?: 'chat_Flag_aggregate';
  readonly aggregate?: Maybe<Chat_Flag_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Flag>;
};

/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_Fields = {
  readonly __typename?: 'chat_Flag_aggregate_fields';
  readonly avg?: Maybe<Chat_Flag_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Flag_Max_Fields>;
  readonly min?: Maybe<Chat_Flag_Min_Fields>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Flag_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Flag_Variance_Fields>;
};


/** aggregate fields of "chat.Flag" */
export type Chat_Flag_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Flag" */
export type Chat_Flag_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Flag_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Flag_Max_Order_By>;
  readonly min?: Maybe<Chat_Flag_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Flag_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Flag_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Flag_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Flag_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Flag_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Flag_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Flag_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Flag" */
export type Chat_Flag_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Flag_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Flag_Avg_Fields = {
  readonly __typename?: 'chat_Flag_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Flag" */
export type Chat_Flag_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Flag". All fields are combined with a logical 'AND'. */
export type Chat_Flag_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Flag_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Flag_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Flag_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly discussionChat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly discussionChatId?: Maybe<Uuid_Comparison_Exp>;
  readonly flaggedBy?: Maybe<Attendee_Bool_Exp>;
  readonly flaggedById?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly notes?: Maybe<String_Comparison_Exp>;
  readonly resolution?: Maybe<String_Comparison_Exp>;
  readonly resolved_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly type?: Maybe<Chat_FlagType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Flag" */
export enum Chat_Flag_Constraint {
  /** unique or primary key constraint */
  FlagMessageSIdFlaggedByIdTypeKey = 'Flag_messageSId_flaggedById_type_key',
  /** unique or primary key constraint */
  FlagPkey = 'Flag_pkey'
}

/** input type for incrementing integer column in table "chat.Flag" */
export type Chat_Flag_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Flag" */
export type Chat_Flag_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedBy?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Flag_Max_Fields = {
  readonly __typename?: 'chat_Flag_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Flag" */
export type Chat_Flag_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Flag_Min_Fields = {
  readonly __typename?: 'chat_Flag_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Flag" */
export type Chat_Flag_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Flag" */
export type Chat_Flag_Mutation_Response = {
  readonly __typename?: 'chat_Flag_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Flag>;
};

/** input type for inserting object relation for remote table "chat.Flag" */
export type Chat_Flag_Obj_Rel_Insert_Input = {
  readonly data: Chat_Flag_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};

/** on conflict condition type for table "chat.Flag" */
export type Chat_Flag_On_Conflict = {
  readonly constraint: Chat_Flag_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Flag_Update_Column>;
  readonly where?: Maybe<Chat_Flag_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Flag" */
export type Chat_Flag_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly discussionChat?: Maybe<Chat_Chat_Order_By>;
  readonly discussionChatId?: Maybe<Order_By>;
  readonly flaggedBy?: Maybe<Attendee_Order_By>;
  readonly flaggedById?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly notes?: Maybe<Order_By>;
  readonly resolution?: Maybe<Order_By>;
  readonly resolved_at?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Flag" */
export type Chat_Flag_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** select columns of table "chat.Flag" */
export enum Chat_Flag_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Flag" */
export type Chat_Flag_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly discussionChatId?: Maybe<Scalars['uuid']>;
  readonly flaggedById?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly notes?: Maybe<Scalars['String']>;
  readonly resolution?: Maybe<Scalars['String']>;
  readonly resolved_at?: Maybe<Scalars['timestamptz']>;
  readonly type?: Maybe<Chat_FlagType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Flag_Stddev_Fields = {
  readonly __typename?: 'chat_Flag_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Flag_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Flag_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Flag_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Flag_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Flag_Sum_Fields = {
  readonly __typename?: 'chat_Flag_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Flag" */
export type Chat_Flag_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "chat.Flag" */
export enum Chat_Flag_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DiscussionChatId = 'discussionChatId',
  /** column name */
  FlaggedById = 'flaggedById',
  /** column name */
  Id = 'id',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  Notes = 'notes',
  /** column name */
  Resolution = 'resolution',
  /** column name */
  ResolvedAt = 'resolved_at',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Flag_Var_Pop_Fields = {
  readonly __typename?: 'chat_Flag_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Flag_Var_Samp_Fields = {
  readonly __typename?: 'chat_Flag_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Flag" */
export type Chat_Flag_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Flag_Variance_Fields = {
  readonly __typename?: 'chat_Flag_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Flag" */
export type Chat_Flag_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_Message = {
  readonly __typename?: 'chat_Message';
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicateIncoming?: Maybe<Chat_Message>;
  /** An object relationship */
  readonly duplicateOutgoing?: Maybe<Chat_Message>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly flags: ReadonlyArray<Chat_Flag>;
  /** An aggregated array relationship */
  readonly flags_aggregate: Chat_Flag_Aggregate;
  readonly id: Scalars['Int'];
  readonly isPinned: Scalars['Boolean'];
  readonly message: Scalars['String'];
  /** An array relationship */
  readonly reactions: ReadonlyArray<Chat_Reaction>;
  /** An aggregated array relationship */
  readonly reactions_aggregate: Chat_Reaction_Aggregate;
  readonly sId: Scalars['uuid'];
  /** An object relationship */
  readonly sender?: Maybe<Attendee>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type: Chat_MessageType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageFlagsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageFlags_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageReactionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/**
 * Chat messages. The systemId field is unique and can be used to prevent duplicate inserts of things like event start/end markers.
 *
 *
 * columns and relationships of "chat.Message"
 */
export type Chat_MessageReactions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.MessageType" */
export type Chat_MessageType = {
  readonly __typename?: 'chat_MessageType';
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.MessageType" */
export type Chat_MessageType_Aggregate = {
  readonly __typename?: 'chat_MessageType_aggregate';
  readonly aggregate?: Maybe<Chat_MessageType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_MessageType>;
};

/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_Fields = {
  readonly __typename?: 'chat_MessageType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_MessageType_Max_Fields>;
  readonly min?: Maybe<Chat_MessageType_Min_Fields>;
};


/** aggregate fields of "chat.MessageType" */
export type Chat_MessageType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.MessageType" */
export type Chat_MessageType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_MessageType_Max_Order_By>;
  readonly min?: Maybe<Chat_MessageType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.MessageType" */
export type Chat_MessageType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_MessageType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.MessageType". All fields are combined with a logical 'AND'. */
export type Chat_MessageType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_MessageType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_MessageType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_MessageType_Bool_Exp>>>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.MessageType" */
export enum Chat_MessageType_Constraint {
  /** unique or primary key constraint */
  MessageTypePkey = 'MessageType_pkey'
}

export enum Chat_MessageType_Enum {
  Answer = 'ANSWER',
  DuplicationMarker = 'DUPLICATION_MARKER',
  Emote = 'EMOTE',
  Message = 'MESSAGE',
  Poll = 'POLL',
  PollResults = 'POLL_RESULTS',
  Question = 'QUESTION'
}

/** expression to compare columns of type chat_MessageType_enum. All fields are combined with logical 'AND'. */
export type Chat_MessageType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_MessageType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_MessageType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_MessageType_Enum>>;
};

/** input type for inserting data into table "chat.MessageType" */
export type Chat_MessageType_Insert_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_MessageType_Max_Fields = {
  readonly __typename?: 'chat_MessageType_max_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.MessageType" */
export type Chat_MessageType_Max_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_MessageType_Min_Fields = {
  readonly __typename?: 'chat_MessageType_min_fields';
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.MessageType" */
export type Chat_MessageType_Min_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.MessageType" */
export type Chat_MessageType_Mutation_Response = {
  readonly __typename?: 'chat_MessageType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_MessageType>;
};

/** input type for inserting object relation for remote table "chat.MessageType" */
export type Chat_MessageType_Obj_Rel_Insert_Input = {
  readonly data: Chat_MessageType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};

/** on conflict condition type for table "chat.MessageType" */
export type Chat_MessageType_On_Conflict = {
  readonly constraint: Chat_MessageType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_MessageType_Update_Column>;
  readonly where?: Maybe<Chat_MessageType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.MessageType" */
export type Chat_MessageType_Order_By = {
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.MessageType" */
export type Chat_MessageType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.MessageType" */
export enum Chat_MessageType_Select_Column {
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.MessageType" */
export type Chat_MessageType_Set_Input = {
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.MessageType" */
export enum Chat_MessageType_Update_Column {
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Message" */
export type Chat_Message_Aggregate = {
  readonly __typename?: 'chat_Message_aggregate';
  readonly aggregate?: Maybe<Chat_Message_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Message>;
};

/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_Fields = {
  readonly __typename?: 'chat_Message_aggregate_fields';
  readonly avg?: Maybe<Chat_Message_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Message_Max_Fields>;
  readonly min?: Maybe<Chat_Message_Min_Fields>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Chat_Message_Sum_Fields>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Fields>;
  readonly variance?: Maybe<Chat_Message_Variance_Fields>;
};


/** aggregate fields of "chat.Message" */
export type Chat_Message_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Message" */
export type Chat_Message_Aggregate_Order_By = {
  readonly avg?: Maybe<Chat_Message_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Message_Max_Order_By>;
  readonly min?: Maybe<Chat_Message_Min_Order_By>;
  readonly stddev?: Maybe<Chat_Message_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Chat_Message_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Chat_Message_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Chat_Message_Sum_Order_By>;
  readonly var_pop?: Maybe<Chat_Message_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Chat_Message_Var_Samp_Order_By>;
  readonly variance?: Maybe<Chat_Message_Variance_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Message" */
export type Chat_Message_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Message_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** aggregate avg on columns */
export type Chat_Message_Avg_Fields = {
  readonly __typename?: 'chat_Message_avg_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "chat.Message" */
export type Chat_Message_Avg_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "chat.Message". All fields are combined with a logical 'AND'. */
export type Chat_Message_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Message_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Message_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Message_Bool_Exp>>>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Bool_Exp>;
  readonly duplicatedMessageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly flags?: Maybe<Chat_Flag_Bool_Exp>;
  readonly id?: Maybe<Int_Comparison_Exp>;
  readonly isPinned?: Maybe<Boolean_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly reactions?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly sId?: Maybe<Uuid_Comparison_Exp>;
  readonly sender?: Maybe<Attendee_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly systemId?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_MessageType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Message" */
export enum Chat_Message_Constraint {
  /** unique or primary key constraint */
  MessageDuplicatedMessageSIdKey = 'Message_duplicatedMessageSId_key',
  /** unique or primary key constraint */
  MessagePkey = 'Message_pkey',
  /** unique or primary key constraint */
  MessageSIdChatIdKey = 'Message_sId_chatId_key',
  /** unique or primary key constraint */
  MessageSIdKey = 'Message_sId_key',
  /** unique or primary key constraint */
  MessageSystemIdKey = 'Message_systemId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Message_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Message_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Message_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for incrementing integer column in table "chat.Message" */
export type Chat_Message_Inc_Input = {
  readonly id?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "chat.Message" */
export type Chat_Message_Insert_Input = {
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly flags?: Maybe<Chat_Flag_Arr_Rel_Insert_Input>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly reactions?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly sender?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Message_Max_Fields = {
  readonly __typename?: 'chat_Message_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Message" */
export type Chat_Message_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Message_Min_Fields = {
  readonly __typename?: 'chat_Message_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Message" */
export type Chat_Message_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Message" */
export type Chat_Message_Mutation_Response = {
  readonly __typename?: 'chat_Message_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Message>;
};

/** input type for inserting object relation for remote table "chat.Message" */
export type Chat_Message_Obj_Rel_Insert_Input = {
  readonly data: Chat_Message_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Message_On_Conflict>;
};

/** on conflict condition type for table "chat.Message" */
export type Chat_Message_On_Conflict = {
  readonly constraint: Chat_Message_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Message_Update_Column>;
  readonly where?: Maybe<Chat_Message_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Message" */
export type Chat_Message_Order_By = {
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicateIncoming?: Maybe<Chat_Message_Order_By>;
  readonly duplicateOutgoing?: Maybe<Chat_Message_Order_By>;
  readonly duplicatedMessageSId?: Maybe<Order_By>;
  readonly flags_aggregate?: Maybe<Chat_Flag_Aggregate_Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isPinned?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly reactions_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly sender?: Maybe<Attendee_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly systemId?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Message" */
export type Chat_Message_Pk_Columns_Input = {
  readonly id: Scalars['Int'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Message_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Message" */
export enum Chat_Message_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageSId = 'duplicatedMessageSId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Message" */
export type Chat_Message_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicatedMessageSId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['Int']>;
  readonly isPinned?: Maybe<Scalars['Boolean']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly systemId?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_MessageType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Chat_Message_Stddev_Fields = {
  readonly __typename?: 'chat_Message_stddev_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Chat_Message_Stddev_Pop_Fields = {
  readonly __typename?: 'chat_Message_stddev_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Chat_Message_Stddev_Samp_Fields = {
  readonly __typename?: 'chat_Message_stddev_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "chat.Message" */
export type Chat_Message_Stddev_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Chat_Message_Sum_Fields = {
  readonly __typename?: 'chat_Message_sum_fields';
  readonly id?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "chat.Message" */
export type Chat_Message_Sum_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "chat.Message" */
export enum Chat_Message_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicatedMessageSId = 'duplicatedMessageSId',
  /** column name */
  Id = 'id',
  /** column name */
  IsPinned = 'isPinned',
  /** column name */
  Message = 'message',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  SystemId = 'systemId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Chat_Message_Var_Pop_Fields = {
  readonly __typename?: 'chat_Message_var_pop_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "chat.Message" */
export type Chat_Message_Var_Pop_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Chat_Message_Var_Samp_Fields = {
  readonly __typename?: 'chat_Message_var_samp_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "chat.Message" */
export type Chat_Message_Var_Samp_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Chat_Message_Variance_Fields = {
  readonly __typename?: 'chat_Message_variance_fields';
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "chat.Message" */
export type Chat_Message_Variance_Order_By = {
  readonly id?: Maybe<Order_By>;
};

/**
 * Pin a chat to the sidebar.
 *
 *
 * columns and relationships of "chat.Pin"
 */
export type Chat_Pin = {
  readonly __typename?: 'chat_Pin';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly wasManuallyPinned: Scalars['Boolean'];
};

/** aggregated selection of "chat.Pin" */
export type Chat_Pin_Aggregate = {
  readonly __typename?: 'chat_Pin_aggregate';
  readonly aggregate?: Maybe<Chat_Pin_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Pin>;
};

/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_Fields = {
  readonly __typename?: 'chat_Pin_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Pin_Max_Fields>;
  readonly min?: Maybe<Chat_Pin_Min_Fields>;
};


/** aggregate fields of "chat.Pin" */
export type Chat_Pin_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Pin" */
export type Chat_Pin_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Pin_Max_Order_By>;
  readonly min?: Maybe<Chat_Pin_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Pin" */
export type Chat_Pin_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Pin_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Pin". All fields are combined with a logical 'AND'. */
export type Chat_Pin_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Pin_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Pin_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Pin_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly wasManuallyPinned?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Pin" */
export enum Chat_Pin_Constraint {
  /** unique or primary key constraint */
  ChatPinPkey = 'ChatPin_pkey'
}

/** input type for inserting data into table "chat.Pin" */
export type Chat_Pin_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Pin_Max_Fields = {
  readonly __typename?: 'chat_Pin_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Pin" */
export type Chat_Pin_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Pin_Min_Fields = {
  readonly __typename?: 'chat_Pin_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Pin" */
export type Chat_Pin_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Pin" */
export type Chat_Pin_Mutation_Response = {
  readonly __typename?: 'chat_Pin_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Pin>;
};

/** input type for inserting object relation for remote table "chat.Pin" */
export type Chat_Pin_Obj_Rel_Insert_Input = {
  readonly data: Chat_Pin_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};

/** on conflict condition type for table "chat.Pin" */
export type Chat_Pin_On_Conflict = {
  readonly constraint: Chat_Pin_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Pin_Update_Column>;
  readonly where?: Maybe<Chat_Pin_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Pin" */
export type Chat_Pin_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly wasManuallyPinned?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Pin" */
export type Chat_Pin_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
  readonly chatId: Scalars['uuid'];
};

/** select columns of table "chat.Pin" */
export enum Chat_Pin_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** input type for updating data in table "chat.Pin" */
export type Chat_Pin_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallyPinned?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Pin" */
export enum Chat_Pin_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallyPinned = 'wasManuallyPinned'
}

/** columns and relationships of "chat.Reaction" */
export type Chat_Reaction = {
  readonly __typename?: 'chat_Reaction';
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  /** An object relationship */
  readonly duplicate?: Maybe<Chat_Reaction>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  /** An array relationship */
  readonly duplicates: ReadonlyArray<Chat_Reaction>;
  /** An aggregated array relationship */
  readonly duplicates_aggregate: Chat_Reaction_Aggregate;
  /** An object relationship */
  readonly message: Chat_Message;
  readonly messageSId: Scalars['uuid'];
  readonly sId: Scalars['uuid'];
  /** An object relationship */
  readonly sender: Attendee;
  readonly senderId: Scalars['uuid'];
  readonly symbol: Scalars['String'];
  readonly type: Chat_ReactionType_Enum;
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDataArgs = {
  path?: Maybe<Scalars['String']>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicatesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** columns and relationships of "chat.Reaction" */
export type Chat_ReactionDuplicates_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** columns and relationships of "chat.ReactionType" */
export type Chat_ReactionType = {
  readonly __typename?: 'chat_ReactionType';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate = {
  readonly __typename?: 'chat_ReactionType_aggregate';
  readonly aggregate?: Maybe<Chat_ReactionType_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReactionType>;
};

/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_Fields = {
  readonly __typename?: 'chat_ReactionType_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_ReactionType_Max_Fields>;
  readonly min?: Maybe<Chat_ReactionType_Min_Fields>;
};


/** aggregate fields of "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.ReactionType" */
export type Chat_ReactionType_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_ReactionType_Max_Order_By>;
  readonly min?: Maybe<Chat_ReactionType_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.ReactionType" */
export type Chat_ReactionType_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_ReactionType_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.ReactionType". All fields are combined with a logical 'AND'. */
export type Chat_ReactionType_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_ReactionType_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_ReactionType_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_ReactionType_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReactionType" */
export enum Chat_ReactionType_Constraint {
  /** unique or primary key constraint */
  ReactionTypePkey = 'ReactionType_pkey'
}

export enum Chat_ReactionType_Enum {
  /** Link to a message that answers the question. */
  Answer = 'ANSWER',
  /** A plain emoji reaction */
  Emoji = 'EMOJI',
  /** A vote in a poll */
  PollChoice = 'POLL_CHOICE',
  /** Stop accepting new responses to the poll */
  PollClosed = 'POLL_CLOSED',
  /** Make the poll results visible */
  PollComplete = 'POLL_COMPLETE'
}

/** expression to compare columns of type chat_ReactionType_enum. All fields are combined with logical 'AND'. */
export type Chat_ReactionType_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Chat_ReactionType_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Chat_ReactionType_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Chat_ReactionType_Enum>>;
};

/** input type for inserting data into table "chat.ReactionType" */
export type Chat_ReactionType_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Chat_ReactionType_Max_Fields = {
  readonly __typename?: 'chat_ReactionType_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "chat.ReactionType" */
export type Chat_ReactionType_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_ReactionType_Min_Fields = {
  readonly __typename?: 'chat_ReactionType_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "chat.ReactionType" */
export type Chat_ReactionType_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.ReactionType" */
export type Chat_ReactionType_Mutation_Response = {
  readonly __typename?: 'chat_ReactionType_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_ReactionType>;
};

/** input type for inserting object relation for remote table "chat.ReactionType" */
export type Chat_ReactionType_Obj_Rel_Insert_Input = {
  readonly data: Chat_ReactionType_Insert_Input;
  readonly on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};

/** on conflict condition type for table "chat.ReactionType" */
export type Chat_ReactionType_On_Conflict = {
  readonly constraint: Chat_ReactionType_Constraint;
  readonly update_columns: ReadonlyArray<Chat_ReactionType_Update_Column>;
  readonly where?: Maybe<Chat_ReactionType_Bool_Exp>;
};

/** ordering options when selecting data from "chat.ReactionType" */
export type Chat_ReactionType_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.ReactionType" */
export type Chat_ReactionType_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "chat.ReactionType" */
export type Chat_ReactionType_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "chat.ReactionType" */
export enum Chat_ReactionType_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "chat.Reaction" */
export type Chat_Reaction_Aggregate = {
  readonly __typename?: 'chat_Reaction_aggregate';
  readonly aggregate?: Maybe<Chat_Reaction_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Reaction>;
};

/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_Fields = {
  readonly __typename?: 'chat_Reaction_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Reaction_Max_Fields>;
  readonly min?: Maybe<Chat_Reaction_Min_Fields>;
};


/** aggregate fields of "chat.Reaction" */
export type Chat_Reaction_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Reaction" */
export type Chat_Reaction_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Reaction_Max_Order_By>;
  readonly min?: Maybe<Chat_Reaction_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "chat.Reaction" */
export type Chat_Reaction_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Reaction_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Reaction". All fields are combined with a logical 'AND'. */
export type Chat_Reaction_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Reaction_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Reaction_Bool_Exp>>>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly duplicate?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly duplicateSId?: Maybe<Uuid_Comparison_Exp>;
  readonly duplicates?: Maybe<Chat_Reaction_Bool_Exp>;
  readonly message?: Maybe<Chat_Message_Bool_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly sId?: Maybe<Uuid_Comparison_Exp>;
  readonly sender?: Maybe<Attendee_Bool_Exp>;
  readonly senderId?: Maybe<Uuid_Comparison_Exp>;
  readonly symbol?: Maybe<String_Comparison_Exp>;
  readonly type?: Maybe<Chat_ReactionType_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Reaction" */
export enum Chat_Reaction_Constraint {
  /** unique or primary key constraint */
  ReactionPkey = 'Reaction_pkey',
  /** unique or primary key constraint */
  ReactionSIdKey = 'Reaction_sId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Chat_Reaction_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Chat_Reaction_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Chat_Reaction_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "chat.Reaction" */
export type Chat_Reaction_Insert_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicate?: Maybe<Chat_Reaction_Obj_Rel_Insert_Input>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly duplicates?: Maybe<Chat_Reaction_Arr_Rel_Insert_Input>;
  readonly message?: Maybe<Chat_Message_Obj_Rel_Insert_Input>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly sender?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_Reaction_Max_Fields = {
  readonly __typename?: 'chat_Reaction_max_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Reaction" */
export type Chat_Reaction_Max_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Reaction_Min_Fields = {
  readonly __typename?: 'chat_Reaction_min_fields';
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Reaction" */
export type Chat_Reaction_Min_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Reaction" */
export type Chat_Reaction_Mutation_Response = {
  readonly __typename?: 'chat_Reaction_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Reaction>;
};

/** input type for inserting object relation for remote table "chat.Reaction" */
export type Chat_Reaction_Obj_Rel_Insert_Input = {
  readonly data: Chat_Reaction_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};

/** on conflict condition type for table "chat.Reaction" */
export type Chat_Reaction_On_Conflict = {
  readonly constraint: Chat_Reaction_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Reaction_Update_Column>;
  readonly where?: Maybe<Chat_Reaction_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Reaction" */
export type Chat_Reaction_Order_By = {
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly duplicate?: Maybe<Chat_Reaction_Order_By>;
  readonly duplicateSId?: Maybe<Order_By>;
  readonly duplicates_aggregate?: Maybe<Chat_Reaction_Aggregate_Order_By>;
  readonly message?: Maybe<Chat_Message_Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly sId?: Maybe<Order_By>;
  readonly sender?: Maybe<Attendee_Order_By>;
  readonly senderId?: Maybe<Order_By>;
  readonly symbol?: Maybe<Order_By>;
  readonly type?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Reaction" */
export type Chat_Reaction_Pk_Columns_Input = {
  readonly sId: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Chat_Reaction_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "chat.Reaction" */
export enum Chat_Reaction_Select_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateSId = 'duplicateSId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.Reaction" */
export type Chat_Reaction_Set_Input = {
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly duplicateSId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly sId?: Maybe<Scalars['uuid']>;
  readonly senderId?: Maybe<Scalars['uuid']>;
  readonly symbol?: Maybe<Scalars['String']>;
  readonly type?: Maybe<Chat_ReactionType_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.Reaction" */
export enum Chat_Reaction_Update_Column {
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  DuplicateSId = 'duplicateSId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  SId = 'sId',
  /** column name */
  SenderId = 'senderId',
  /** column name */
  Symbol = 'symbol',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex = {
  readonly __typename?: 'chat_ReadUpToIndex';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate';
  readonly aggregate?: Maybe<Chat_ReadUpToIndex_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Fields>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Fields>;
};


/** aggregate fields of "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_ReadUpToIndex_Max_Order_By>;
  readonly min?: Maybe<Chat_ReadUpToIndex_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.ReadUpToIndex". All fields are combined with a logical 'AND'. */
export type Chat_ReadUpToIndex_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_ReadUpToIndex_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_ReadUpToIndex_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly messageSId?: Maybe<Uuid_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Constraint {
  /** unique or primary key constraint */
  ReadUpToIndexPkey = 'ReadUpToIndex_pkey'
}

/** input type for inserting data into table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Chat_ReadUpToIndex_Max_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_ReadUpToIndex_Min_Fields = {
  readonly __typename?: 'chat_ReadUpToIndex_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Mutation_Response = {
  readonly __typename?: 'chat_ReadUpToIndex_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_ReadUpToIndex>;
};

/** input type for inserting object relation for remote table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Obj_Rel_Insert_Input = {
  readonly data: Chat_ReadUpToIndex_Insert_Input;
  readonly on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};

/** on conflict condition type for table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_On_Conflict = {
  readonly constraint: Chat_ReadUpToIndex_Constraint;
  readonly update_columns: ReadonlyArray<Chat_ReadUpToIndex_Update_Column>;
  readonly where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};

/** ordering options when selecting data from "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly messageSId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
  readonly chatId: Scalars['uuid'];
};

/** select columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "chat.ReadUpToIndex" */
export type Chat_ReadUpToIndex_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly messageSId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "chat.ReadUpToIndex" */
export enum Chat_ReadUpToIndex_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  MessageSId = 'messageSId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/**
 * Subscribe to chat notifications.
 *
 *
 * columns and relationships of "chat.Subscription"
 */
export type Chat_Subscription = {
  readonly __typename?: 'chat_Subscription';
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  /** An object relationship */
  readonly chat: Chat_Chat;
  readonly chatId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly wasManuallySubscribed: Scalars['Boolean'];
};

/** aggregated selection of "chat.Subscription" */
export type Chat_Subscription_Aggregate = {
  readonly __typename?: 'chat_Subscription_aggregate';
  readonly aggregate?: Maybe<Chat_Subscription_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Chat_Subscription>;
};

/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_Fields = {
  readonly __typename?: 'chat_Subscription_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Chat_Subscription_Max_Fields>;
  readonly min?: Maybe<Chat_Subscription_Min_Fields>;
};


/** aggregate fields of "chat.Subscription" */
export type Chat_Subscription_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "chat.Subscription" */
export type Chat_Subscription_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Chat_Subscription_Max_Order_By>;
  readonly min?: Maybe<Chat_Subscription_Min_Order_By>;
};

/** input type for inserting array relation for remote table "chat.Subscription" */
export type Chat_Subscription_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Chat_Subscription_Insert_Input>;
  readonly on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};

/** Boolean expression to filter rows from the table "chat.Subscription". All fields are combined with a logical 'AND'. */
export type Chat_Subscription_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Chat_Subscription_Bool_Exp>>>;
  readonly _not?: Maybe<Chat_Subscription_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Chat_Subscription_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly chat?: Maybe<Chat_Chat_Bool_Exp>;
  readonly chatId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly wasManuallySubscribed?: Maybe<Boolean_Comparison_Exp>;
};

/** unique or primary key constraints on table "chat.Subscription" */
export enum Chat_Subscription_Constraint {
  /** unique or primary key constraint */
  SubscriptionPkey = 'Subscription_pkey'
}

/** input type for inserting data into table "chat.Subscription" */
export type Chat_Subscription_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chat?: Maybe<Chat_Chat_Obj_Rel_Insert_Input>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** aggregate max on columns */
export type Chat_Subscription_Max_Fields = {
  readonly __typename?: 'chat_Subscription_max_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "chat.Subscription" */
export type Chat_Subscription_Max_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Chat_Subscription_Min_Fields = {
  readonly __typename?: 'chat_Subscription_min_fields';
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "chat.Subscription" */
export type Chat_Subscription_Min_Order_By = {
  readonly attendeeId?: Maybe<Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "chat.Subscription" */
export type Chat_Subscription_Mutation_Response = {
  readonly __typename?: 'chat_Subscription_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Chat_Subscription>;
};

/** input type for inserting object relation for remote table "chat.Subscription" */
export type Chat_Subscription_Obj_Rel_Insert_Input = {
  readonly data: Chat_Subscription_Insert_Input;
  readonly on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};

/** on conflict condition type for table "chat.Subscription" */
export type Chat_Subscription_On_Conflict = {
  readonly constraint: Chat_Subscription_Constraint;
  readonly update_columns: ReadonlyArray<Chat_Subscription_Update_Column>;
  readonly where?: Maybe<Chat_Subscription_Bool_Exp>;
};

/** ordering options when selecting data from "chat.Subscription" */
export type Chat_Subscription_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly chat?: Maybe<Chat_Chat_Order_By>;
  readonly chatId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly wasManuallySubscribed?: Maybe<Order_By>;
};

/** primary key columns input for table: "chat.Subscription" */
export type Chat_Subscription_Pk_Columns_Input = {
  readonly attendeeId: Scalars['uuid'];
  readonly chatId: Scalars['uuid'];
};

/** select columns of table "chat.Subscription" */
export enum Chat_Subscription_Select_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** input type for updating data in table "chat.Subscription" */
export type Chat_Subscription_Set_Input = {
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly chatId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly wasManuallySubscribed?: Maybe<Scalars['Boolean']>;
};

/** update columns of table "chat.Subscription" */
export enum Chat_Subscription_Update_Column {
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  ChatId = 'chatId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  WasManuallySubscribed = 'wasManuallySubscribed'
}

/** columns and relationships of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  readonly stackLogicalResourceId: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_ChannelStackCreateJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
};

/** aggregate fields of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_ChannelStackCreateJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_ChannelStackCreateJob_Min_Fields>;
};


/** aggregate fields of "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_ChannelStackCreateJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_ChannelStackCreateJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.ChannelStackCreateJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_ChannelStackCreateJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly stackLogicalResourceId?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Constraint {
  /** unique or primary key constraint */
  ChannelStackCreateJobPkey = 'ChannelStackCreateJob_pkey',
  /** unique or primary key constraint */
  ChannelStackCreateJobStackLogicalResourceIdKey = 'ChannelStackCreateJob_stackLogicalResourceId_key'
}

/** input type for inserting data into table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_ChannelStackCreateJob_Max_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_ChannelStackCreateJob_Min_Fields = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Mutation_Response = {
  readonly __typename?: 'job_queues_ChannelStackCreateJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
};

/** input type for inserting object relation for remote table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_ChannelStackCreateJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_On_Conflict = {
  readonly constraint: Job_Queues_ChannelStackCreateJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly stackLogicalResourceId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StackLogicalResourceId = 'stackLogicalResourceId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.ChannelStackCreateJob" */
export type Job_Queues_ChannelStackCreateJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly stackLogicalResourceId?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.ChannelStackCreateJob" */
export enum Job_Queues_ChannelStackCreateJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  StackLogicalResourceId = 'stackLogicalResourceId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob = {
  readonly __typename?: 'job_queues_CombineVideosJob';
  /** An object relationship */
  readonly attendee?: Maybe<Attendee>;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdByAttendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at: Scalars['timestamptz'];
  readonly data: Scalars['jsonb'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJobDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate = {
  readonly __typename?: 'job_queues_CombineVideosJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_CombineVideosJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_CombineVideosJob>;
};

/** aggregate fields of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_CombineVideosJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_CombineVideosJob_Min_Fields>;
};


/** aggregate fields of "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_CombineVideosJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_CombineVideosJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CombineVideosJob_Append_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_CombineVideosJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.CombineVideosJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_CombineVideosJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_CombineVideosJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_CombineVideosJob_Bool_Exp>>>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdByAttendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly data?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly mediaConvertJobId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly outputName?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Constraint {
  /** unique or primary key constraint */
  CombineVideosJobPkey = 'CombineVideosJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_CombineVideosJob_Delete_At_Path_Input = {
  readonly data?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_CombineVideosJob_Delete_Elem_Input = {
  readonly data?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_CombineVideosJob_Delete_Key_Input = {
  readonly data?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Insert_Input = {
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByAttendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_CombineVideosJob_Max_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByAttendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdByAttendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaConvertJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly outputName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_CombineVideosJob_Min_Fields = {
  readonly __typename?: 'job_queues_CombineVideosJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByAttendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdByAttendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaConvertJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly outputName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Mutation_Response = {
  readonly __typename?: 'job_queues_CombineVideosJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_CombineVideosJob>;
};

/** input type for inserting object relation for remote table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_CombineVideosJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_On_Conflict = {
  readonly constraint: Job_Queues_CombineVideosJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_CombineVideosJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Order_By = {
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdByAttendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly data?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaConvertJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly outputName?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CombineVideosJob_Prepend_Input = {
  readonly data?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedByAttendeeId = 'createdByAttendeeId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaConvertJobId = 'mediaConvertJobId',
  /** column name */
  Message = 'message',
  /** column name */
  OutputName = 'outputName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.CombineVideosJob" */
export type Job_Queues_CombineVideosJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdByAttendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly data?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly mediaConvertJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly outputName?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.CombineVideosJob" */
export enum Job_Queues_CombineVideosJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedByAttendeeId = 'createdByAttendeeId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Data = 'data',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaConvertJobId = 'mediaConvertJobId',
  /** column name */
  Message = 'message',
  /** column name */
  OutputName = 'outputName',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob = {
  readonly __typename?: 'job_queues_CustomEmailJob';
  readonly attendeeIds: Scalars['jsonb'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly htmlBody: Scalars['String'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly subject: Scalars['String'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJobAttendeeIdsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_CustomEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_CustomEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_CustomEmailJob>;
};

/** aggregate fields of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_CustomEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_CustomEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_CustomEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_CustomEmailJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CustomEmailJob_Append_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_CustomEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.CustomEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_CustomEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_CustomEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_CustomEmailJob_Bool_Exp>>>;
  readonly attendeeIds?: Maybe<Jsonb_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly htmlBody?: Maybe<String_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly subject?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Constraint {
  /** unique or primary key constraint */
  CustomEmailJobPkey = 'CustomEmailJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_CustomEmailJob_Delete_At_Path_Input = {
  readonly attendeeIds?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_CustomEmailJob_Delete_Elem_Input = {
  readonly attendeeIds?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_CustomEmailJob_Delete_Key_Input = {
  readonly attendeeIds?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Insert_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_CustomEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly htmlBody?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_CustomEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_CustomEmailJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly htmlBody?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_CustomEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_CustomEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_CustomEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_CustomEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_CustomEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Order_By = {
  readonly attendeeIds?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly htmlBody?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly subject?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_CustomEmailJob_Prepend_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Select_Column {
  /** column name */
  AttendeeIds = 'attendeeIds',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HtmlBody = 'htmlBody',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.CustomEmailJob" */
export type Job_Queues_CustomEmailJob_Set_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly htmlBody?: Maybe<Scalars['String']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly subject?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.CustomEmailJob" */
export enum Job_Queues_CustomEmailJob_Update_Column {
  /** column name */
  AttendeeIds = 'attendeeIds',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  HtmlBody = 'htmlBody',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  Subject = 'subject',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob = {
  readonly __typename?: 'job_queues_InvitationEmailJob';
  readonly attendeeIds: Scalars['jsonb'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly sendRepeat: Scalars['Boolean'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJobAttendeeIdsArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_InvitationEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_InvitationEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_InvitationEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_InvitationEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_InvitationEmailJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Append_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_InvitationEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.InvitationEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_InvitationEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>>>;
  readonly attendeeIds?: Maybe<Jsonb_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly sendRepeat?: Maybe<Boolean_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Constraint {
  /** unique or primary key constraint */
  InvitationEmailJobsPkey = 'InvitationEmailJobs_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_InvitationEmailJob_Delete_At_Path_Input = {
  readonly attendeeIds?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_InvitationEmailJob_Delete_Elem_Input = {
  readonly attendeeIds?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_InvitationEmailJob_Delete_Key_Input = {
  readonly attendeeIds?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Insert_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_InvitationEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_InvitationEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_InvitationEmailJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_InvitationEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_InvitationEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_InvitationEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_InvitationEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Order_By = {
  readonly attendeeIds?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly sendRepeat?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_InvitationEmailJob_Prepend_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Select_Column {
  /** column name */
  AttendeeIds = 'attendeeIds',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "job_queues.InvitationEmailJob" */
export type Job_Queues_InvitationEmailJob_Set_Input = {
  readonly attendeeIds?: Maybe<Scalars['jsonb']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly sendRepeat?: Maybe<Scalars['Boolean']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.InvitationEmailJob" */
export enum Job_Queues_InvitationEmailJob_Update_Column {
  /** column name */
  AttendeeIds = 'attendeeIds',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  SendRepeat = 'sendRepeat',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly event: Event;
  readonly eventId: Scalars['uuid'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_MediaPackageHarvestJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_MediaPackageHarvestJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_MediaPackageHarvestJob_Min_Fields>;
};


/** aggregate fields of "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_MediaPackageHarvestJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_MediaPackageHarvestJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.MediaPackageHarvestJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_MediaPackageHarvestJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly event?: Maybe<Event_Bool_Exp>;
  readonly eventId?: Maybe<Uuid_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly mediaPackageHarvestJobId?: Maybe<String_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Constraint {
  /** unique or primary key constraint */
  MediaPackageHarvestJobMediaPackageHarvestJobIdKey = 'MediaPackageHarvestJob_mediaPackageHarvestJobId_key',
  /** unique or primary key constraint */
  MediaPackageHarvestJobPkey = 'MediaPackageHarvestJob_pkey'
}

/** input type for inserting data into table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly event?: Maybe<Event_Obj_Rel_Insert_Input>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Job_Queues_MediaPackageHarvestJob_Max_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_MediaPackageHarvestJob_Min_Fields = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Mutation_Response = {
  readonly __typename?: 'job_queues_MediaPackageHarvestJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
};

/** input type for inserting object relation for remote table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_MediaPackageHarvestJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_On_Conflict = {
  readonly constraint: Job_Queues_MediaPackageHarvestJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly event?: Maybe<Event_Order_By>;
  readonly eventId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly mediaPackageHarvestJobId?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "job_queues.MediaPackageHarvestJob" */
export type Job_Queues_MediaPackageHarvestJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly eventId?: Maybe<Scalars['uuid']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly mediaPackageHarvestJobId?: Maybe<Scalars['String']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "job_queues.MediaPackageHarvestJob" */
export enum Job_Queues_MediaPackageHarvestJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EventId = 'eventId',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  MediaPackageHarvestJobId = 'mediaPackageHarvestJobId',
  /** column name */
  Message = 'message',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** columns and relationships of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob = {
  readonly __typename?: 'job_queues_PublishVideoJob';
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentItem: ContentItem;
  readonly contentItemId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly jobStatusName: Scalars['String'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_PublishVideoJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_PublishVideoJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_PublishVideoJob_Min_Fields>;
};


/** aggregate fields of "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_PublishVideoJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_PublishVideoJob_Min_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_PublishVideoJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.PublishVideoJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_PublishVideoJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_PublishVideoJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_PublishVideoJob_Bool_Exp>>>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatusName?: Maybe<String_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly vimeoVideoUrl?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Constraint {
  /** unique or primary key constraint */
  PublishVideoJobPkey = 'PublishVideoJob_pkey'
}

/** input type for inserting data into table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Insert_Input = {
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Job_Queues_PublishVideoJob_Max_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_PublishVideoJob_Min_Fields = {
  readonly __typename?: 'job_queues_PublishVideoJob_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Mutation_Response = {
  readonly __typename?: 'job_queues_PublishVideoJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_PublishVideoJob>;
};

/** input type for inserting object relation for remote table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_PublishVideoJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_On_Conflict = {
  readonly constraint: Job_Queues_PublishVideoJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_PublishVideoJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Order_By = {
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly vimeoVideoUrl?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Select_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** input type for updating data in table "job_queues.PublishVideoJob" */
export type Job_Queues_PublishVideoJob_Set_Input = {
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<Scalars['String']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly vimeoVideoUrl?: Maybe<Scalars['String']>;
};

/** update columns of table "job_queues.PublishVideoJob" */
export enum Job_Queues_PublishVideoJob_Update_Column {
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VimeoVideoUrl = 'vimeoVideoUrl'
}

/** columns and relationships of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob';
  readonly created_at: Scalars['timestamptz'];
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id: Scalars['uuid'];
  readonly processed: Scalars['Boolean'];
  readonly updated_at: Scalars['timestamptz'];
  /** An object relationship */
  readonly uploader: Uploader;
  readonly uploaderId: Scalars['uuid'];
};


/** columns and relationships of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJobEmailTemplateArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_SubmissionRequestEmailJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_SubmissionRequestEmailJob_Min_Fields>;
};


/** aggregate fields of "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_SubmissionRequestEmailJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_SubmissionRequestEmailJob_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_SubmissionRequestEmailJob_Append_Input = {
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};

/** Boolean expression to filter rows from the table "job_queues.SubmissionRequestEmailJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_SubmissionRequestEmailJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly emailTemplate?: Maybe<Jsonb_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly processed?: Maybe<Boolean_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly uploader?: Maybe<Uploader_Bool_Exp>;
  readonly uploaderId?: Maybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Constraint {
  /** unique or primary key constraint */
  SubmissionRequestEmailJobPkey = 'SubmissionRequestEmailJob_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input = {
  readonly emailTemplate?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input = {
  readonly emailTemplate?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input = {
  readonly emailTemplate?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploader?: Maybe<Uploader_Obj_Rel_Insert_Input>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** aggregate max on columns */
export type Job_Queues_SubmissionRequestEmailJob_Max_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** order by max() on columns of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_SubmissionRequestEmailJob_Min_Fields = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** order by min() on columns of table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Mutation_Response = {
  readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
};

/** input type for inserting object relation for remote table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_SubmissionRequestEmailJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_On_Conflict = {
  readonly constraint: Job_Queues_SubmissionRequestEmailJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly emailTemplate?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly processed?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly uploader?: Maybe<Uploader_Order_By>;
  readonly uploaderId?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Job_Queues_SubmissionRequestEmailJob_Prepend_Input = {
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailTemplate = 'emailTemplate',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}

/** input type for updating data in table "job_queues.SubmissionRequestEmailJob" */
export type Job_Queues_SubmissionRequestEmailJob_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly emailTemplate?: Maybe<Scalars['jsonb']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly processed?: Maybe<Scalars['Boolean']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly uploaderId?: Maybe<Scalars['uuid']>;
};

/** update columns of table "job_queues.SubmissionRequestEmailJob" */
export enum Job_Queues_SubmissionRequestEmailJob_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EmailTemplate = 'emailTemplate',
  /** column name */
  Id = 'id',
  /** column name */
  Processed = 'processed',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UploaderId = 'uploaderId'
}

/** columns and relationships of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob';
  /** An object relationship */
  readonly attendeeGoogleAccount: AttendeeGoogleAccount;
  readonly attendeeGoogleAccountId: Scalars['uuid'];
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  /** An object relationship */
  readonly contentItem: ContentItem;
  readonly contentItemId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly jobStatus: JobStatus;
  readonly jobStatusName: JobStatus_Enum;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly retriesCount: Scalars['Int'];
  readonly updatedAt: Scalars['timestamptz'];
  readonly videoDescription: Scalars['String'];
  readonly videoPrivacyStatus: Scalars['String'];
  readonly videoTitle: Scalars['String'];
};

/** aggregated selection of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_aggregate';
  readonly aggregate?: Maybe<Job_Queues_UploadYouTubeVideoJob_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
};

/** aggregate fields of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_aggregate_fields';
  readonly avg?: Maybe<Job_Queues_UploadYouTubeVideoJob_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Job_Queues_UploadYouTubeVideoJob_Max_Fields>;
  readonly min?: Maybe<Job_Queues_UploadYouTubeVideoJob_Min_Fields>;
  readonly stddev?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Job_Queues_UploadYouTubeVideoJob_Sum_Fields>;
  readonly var_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Samp_Fields>;
  readonly variance?: Maybe<Job_Queues_UploadYouTubeVideoJob_Variance_Fields>;
};


/** aggregate fields of "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Aggregate_Order_By = {
  readonly avg?: Maybe<Job_Queues_UploadYouTubeVideoJob_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Job_Queues_UploadYouTubeVideoJob_Max_Order_By>;
  readonly min?: Maybe<Job_Queues_UploadYouTubeVideoJob_Min_Order_By>;
  readonly stddev?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Job_Queues_UploadYouTubeVideoJob_Sum_Order_By>;
  readonly var_pop?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Job_Queues_UploadYouTubeVideoJob_Var_Samp_Order_By>;
  readonly variance?: Maybe<Job_Queues_UploadYouTubeVideoJob_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input>;
  readonly on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};

/** aggregate avg on columns */
export type Job_Queues_UploadYouTubeVideoJob_Avg_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_avg_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Avg_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "job_queues.UploadYouTubeVideoJob". All fields are combined with a logical 'AND'. */
export type Job_Queues_UploadYouTubeVideoJob_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>>>;
  readonly _not?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>>>;
  readonly attendeeGoogleAccount?: Maybe<AttendeeGoogleAccount_Bool_Exp>;
  readonly attendeeGoogleAccountId?: Maybe<Uuid_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly contentItem?: Maybe<ContentItem_Bool_Exp>;
  readonly contentItemId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly jobStatus?: Maybe<JobStatus_Bool_Exp>;
  readonly jobStatusName?: Maybe<JobStatus_Enum_Comparison_Exp>;
  readonly message?: Maybe<String_Comparison_Exp>;
  readonly playlistId?: Maybe<String_Comparison_Exp>;
  readonly retriesCount?: Maybe<Int_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly videoDescription?: Maybe<String_Comparison_Exp>;
  readonly videoPrivacyStatus?: Maybe<String_Comparison_Exp>;
  readonly videoTitle?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Constraint {
  /** unique or primary key constraint */
  UploadYouTubeVideoJobPkey = 'UploadYouTubeVideoJob_pkey'
}

/** input type for incrementing integer column in table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Inc_Input = {
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Insert_Input = {
  readonly attendeeGoogleAccount?: Maybe<AttendeeGoogleAccount_Obj_Rel_Insert_Input>;
  readonly attendeeGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItem?: Maybe<ContentItem_Obj_Rel_Insert_Input>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatus?: Maybe<JobStatus_Obj_Rel_Insert_Input>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Job_Queues_UploadYouTubeVideoJob_Max_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_max_fields';
  readonly attendeeGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Max_Order_By = {
  readonly attendeeGoogleAccountId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly playlistId?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoDescription?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Job_Queues_UploadYouTubeVideoJob_Min_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_min_fields';
  readonly attendeeGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Min_Order_By = {
  readonly attendeeGoogleAccountId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly playlistId?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoDescription?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** response of any mutation on the table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Mutation_Response = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
};

/** input type for inserting object relation for remote table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Obj_Rel_Insert_Input = {
  readonly data: Job_Queues_UploadYouTubeVideoJob_Insert_Input;
  readonly on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};

/** on conflict condition type for table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_On_Conflict = {
  readonly constraint: Job_Queues_UploadYouTubeVideoJob_Constraint;
  readonly update_columns: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Update_Column>;
  readonly where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};

/** ordering options when selecting data from "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Order_By = {
  readonly attendeeGoogleAccount?: Maybe<AttendeeGoogleAccount_Order_By>;
  readonly attendeeGoogleAccountId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly contentItem?: Maybe<ContentItem_Order_By>;
  readonly contentItemId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly jobStatus?: Maybe<JobStatus_Order_By>;
  readonly jobStatusName?: Maybe<Order_By>;
  readonly message?: Maybe<Order_By>;
  readonly playlistId?: Maybe<Order_By>;
  readonly retriesCount?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
  readonly videoDescription?: Maybe<Order_By>;
  readonly videoPrivacyStatus?: Maybe<Order_By>;
  readonly videoTitle?: Maybe<Order_By>;
};

/** primary key columns input for table: "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Select_Column {
  /** column name */
  AttendeeGoogleAccountId = 'attendeeGoogleAccountId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  PlaylistId = 'playlistId',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoDescription = 'videoDescription',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** input type for updating data in table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Set_Input = {
  readonly attendeeGoogleAccountId?: Maybe<Scalars['uuid']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly contentItemId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly jobStatusName?: Maybe<JobStatus_Enum>;
  readonly message?: Maybe<Scalars['String']>;
  readonly playlistId?: Maybe<Scalars['String']>;
  readonly retriesCount?: Maybe<Scalars['Int']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
  readonly videoDescription?: Maybe<Scalars['String']>;
  readonly videoPrivacyStatus?: Maybe<Scalars['String']>;
  readonly videoTitle?: Maybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_stddev_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Stddev_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Job_Queues_UploadYouTubeVideoJob_Sum_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_sum_fields';
  readonly retriesCount?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Sum_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** update columns of table "job_queues.UploadYouTubeVideoJob" */
export enum Job_Queues_UploadYouTubeVideoJob_Update_Column {
  /** column name */
  AttendeeGoogleAccountId = 'attendeeGoogleAccountId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  ContentItemId = 'contentItemId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  JobStatusName = 'jobStatusName',
  /** column name */
  Message = 'message',
  /** column name */
  PlaylistId = 'playlistId',
  /** column name */
  RetriesCount = 'retriesCount',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  VideoDescription = 'videoDescription',
  /** column name */
  VideoPrivacyStatus = 'videoPrivacyStatus',
  /** column name */
  VideoTitle = 'videoTitle'
}

/** aggregate var_pop on columns */
export type Job_Queues_UploadYouTubeVideoJob_Var_Pop_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_var_pop_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Var_Pop_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Job_Queues_UploadYouTubeVideoJob_Var_Samp_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_var_samp_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Var_Samp_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Job_Queues_UploadYouTubeVideoJob_Variance_Fields = {
  readonly __typename?: 'job_queues_UploadYouTubeVideoJob_variance_fields';
  readonly retriesCount?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "job_queues.UploadYouTubeVideoJob" */
export type Job_Queues_UploadYouTubeVideoJob_Variance_Order_By = {
  readonly retriesCount?: Maybe<Order_By>;
};


/** expression to compare columns of type json. All fields are combined with logical 'AND'. */
export type Json_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['json']>;
  readonly _gt?: Maybe<Scalars['json']>;
  readonly _gte?: Maybe<Scalars['json']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['json']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['json']>;
  readonly _lte?: Maybe<Scalars['json']>;
  readonly _neq?: Maybe<Scalars['json']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['json']>>;
};


/** expression to compare columns of type jsonb. All fields are combined with logical 'AND'. */
export type Jsonb_Comparison_Exp = {
  /** is the column contained in the given json value */
  readonly _contained_in?: Maybe<Scalars['jsonb']>;
  /** does the column contain the given json value at the top level */
  readonly _contains?: Maybe<Scalars['jsonb']>;
  readonly _eq?: Maybe<Scalars['jsonb']>;
  readonly _gt?: Maybe<Scalars['jsonb']>;
  readonly _gte?: Maybe<Scalars['jsonb']>;
  /** does the string exist as a top-level key in the column */
  readonly _has_key?: Maybe<Scalars['String']>;
  /** do all of these strings exist as top-level keys in the column */
  readonly _has_keys_all?: Maybe<ReadonlyArray<Scalars['String']>>;
  /** do any of these strings exist as top-level keys in the column */
  readonly _has_keys_any?: Maybe<ReadonlyArray<Scalars['String']>>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['jsonb']>;
  readonly _lte?: Maybe<Scalars['jsonb']>;
  readonly _neq?: Maybe<Scalars['jsonb']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['jsonb']>>;
};

/** mutation root */
export type Mutation_Root = {
  readonly __typename?: 'mutation_root';
  /** perform the action: "createContentGroupRoom" */
  readonly createContentGroupRoom?: Maybe<CreateContentGroupRoomOutput>;
  /** perform the action: "createRoomDm" */
  readonly createRoomDm?: Maybe<CreateRoomDmOutput>;
  /** delete data from the table: "Attendee" */
  readonly delete_Attendee?: Maybe<Attendee_Mutation_Response>;
  /** delete data from the table: "AttendeeGoogleAccount" */
  readonly delete_AttendeeGoogleAccount?: Maybe<AttendeeGoogleAccount_Mutation_Response>;
  /** delete single row from the table: "AttendeeGoogleAccount" */
  readonly delete_AttendeeGoogleAccount_by_pk?: Maybe<AttendeeGoogleAccount>;
  /** delete data from the table: "AttendeeProfile" */
  readonly delete_AttendeeProfile?: Maybe<AttendeeProfile_Mutation_Response>;
  /** delete single row from the table: "AttendeeProfile" */
  readonly delete_AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** delete single row from the table: "Attendee" */
  readonly delete_Attendee_by_pk?: Maybe<Attendee>;
  /** delete data from the table: "Broadcast" */
  readonly delete_Broadcast?: Maybe<Broadcast_Mutation_Response>;
  /** delete data from the table: "BroadcastContentItem" */
  readonly delete_BroadcastContentItem?: Maybe<BroadcastContentItem_Mutation_Response>;
  /** delete single row from the table: "BroadcastContentItem" */
  readonly delete_BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** delete single row from the table: "Broadcast" */
  readonly delete_Broadcast_by_pk?: Maybe<Broadcast>;
  /** delete data from the table: "Conference" */
  readonly delete_Conference?: Maybe<Conference_Mutation_Response>;
  /** delete data from the table: "ConferenceConfiguration" */
  readonly delete_ConferenceConfiguration?: Maybe<ConferenceConfiguration_Mutation_Response>;
  /** delete single row from the table: "ConferenceConfiguration" */
  readonly delete_ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** delete data from the table: "ConferenceDemoCode" */
  readonly delete_ConferenceDemoCode?: Maybe<ConferenceDemoCode_Mutation_Response>;
  /** delete single row from the table: "ConferenceDemoCode" */
  readonly delete_ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** delete data from the table: "ConferencePrepareJob" */
  readonly delete_ConferencePrepareJob?: Maybe<ConferencePrepareJob_Mutation_Response>;
  /** delete single row from the table: "ConferencePrepareJob" */
  readonly delete_ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** delete single row from the table: "Conference" */
  readonly delete_Conference_by_pk?: Maybe<Conference>;
  /** delete data from the table: "ContentGroup" */
  readonly delete_ContentGroup?: Maybe<ContentGroup_Mutation_Response>;
  /** delete data from the table: "ContentGroupHallway" */
  readonly delete_ContentGroupHallway?: Maybe<ContentGroupHallway_Mutation_Response>;
  /** delete single row from the table: "ContentGroupHallway" */
  readonly delete_ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** delete data from the table: "ContentGroupPerson" */
  readonly delete_ContentGroupPerson?: Maybe<ContentGroupPerson_Mutation_Response>;
  /** delete single row from the table: "ContentGroupPerson" */
  readonly delete_ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** delete data from the table: "ContentGroupTag" */
  readonly delete_ContentGroupTag?: Maybe<ContentGroupTag_Mutation_Response>;
  /** delete single row from the table: "ContentGroupTag" */
  readonly delete_ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** delete data from the table: "ContentGroupType" */
  readonly delete_ContentGroupType?: Maybe<ContentGroupType_Mutation_Response>;
  /** delete single row from the table: "ContentGroupType" */
  readonly delete_ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** delete single row from the table: "ContentGroup" */
  readonly delete_ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** delete data from the table: "ContentItem" */
  readonly delete_ContentItem?: Maybe<ContentItem_Mutation_Response>;
  /** delete single row from the table: "ContentItem" */
  readonly delete_ContentItem_by_pk?: Maybe<ContentItem>;
  /** delete data from the table: "ContentPerson" */
  readonly delete_ContentPerson?: Maybe<ContentPerson_Mutation_Response>;
  /** delete single row from the table: "ContentPerson" */
  readonly delete_ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** delete data from the table: "ContentType" */
  readonly delete_ContentType?: Maybe<ContentType_Mutation_Response>;
  /** delete single row from the table: "ContentType" */
  readonly delete_ContentType_by_pk?: Maybe<ContentType>;
  /** delete data from the table: "Email" */
  readonly delete_Email?: Maybe<Email_Mutation_Response>;
  /** delete single row from the table: "Email" */
  readonly delete_Email_by_pk?: Maybe<Email>;
  /** delete data from the table: "Event" */
  readonly delete_Event?: Maybe<Event_Mutation_Response>;
  /** delete data from the table: "EventParticipantStream" */
  readonly delete_EventParticipantStream?: Maybe<EventParticipantStream_Mutation_Response>;
  /** delete single row from the table: "EventParticipantStream" */
  readonly delete_EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** delete data from the table: "EventPerson" */
  readonly delete_EventPerson?: Maybe<EventPerson_Mutation_Response>;
  /** delete data from the table: "EventPersonRole" */
  readonly delete_EventPersonRole?: Maybe<EventPersonRole_Mutation_Response>;
  /** delete single row from the table: "EventPersonRole" */
  readonly delete_EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** delete single row from the table: "EventPerson" */
  readonly delete_EventPerson_by_pk?: Maybe<EventPerson>;
  /** delete data from the table: "EventRoomJoinRequest" */
  readonly delete_EventRoomJoinRequest?: Maybe<EventRoomJoinRequest_Mutation_Response>;
  /** delete single row from the table: "EventRoomJoinRequest" */
  readonly delete_EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** delete data from the table: "EventTag" */
  readonly delete_EventTag?: Maybe<EventTag_Mutation_Response>;
  /** delete single row from the table: "EventTag" */
  readonly delete_EventTag_by_pk?: Maybe<EventTag>;
  /** delete data from the table: "EventVonageSession" */
  readonly delete_EventVonageSession?: Maybe<EventVonageSession_Mutation_Response>;
  /** delete single row from the table: "EventVonageSession" */
  readonly delete_EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** delete single row from the table: "Event" */
  readonly delete_Event_by_pk?: Maybe<Event>;
  /** delete data from the table: "ExecutedTransitions" */
  readonly delete_ExecutedTransitions?: Maybe<ExecutedTransitions_Mutation_Response>;
  /** delete single row from the table: "ExecutedTransitions" */
  readonly delete_ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** delete data from the table: "Group" */
  readonly delete_Group?: Maybe<Group_Mutation_Response>;
  /** delete data from the table: "GroupAttendee" */
  readonly delete_GroupAttendee?: Maybe<GroupAttendee_Mutation_Response>;
  /** delete single row from the table: "GroupAttendee" */
  readonly delete_GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** delete data from the table: "GroupRole" */
  readonly delete_GroupRole?: Maybe<GroupRole_Mutation_Response>;
  /** delete single row from the table: "GroupRole" */
  readonly delete_GroupRole_by_pk?: Maybe<GroupRole>;
  /** delete single row from the table: "Group" */
  readonly delete_Group_by_pk?: Maybe<Group>;
  /** delete data from the table: "Hallway" */
  readonly delete_Hallway?: Maybe<Hallway_Mutation_Response>;
  /** delete single row from the table: "Hallway" */
  readonly delete_Hallway_by_pk?: Maybe<Hallway>;
  /** delete data from the table: "InputType" */
  readonly delete_InputType?: Maybe<InputType_Mutation_Response>;
  /** delete single row from the table: "InputType" */
  readonly delete_InputType_by_pk?: Maybe<InputType>;
  /** delete data from the table: "Invitation" */
  readonly delete_Invitation?: Maybe<Invitation_Mutation_Response>;
  /** delete single row from the table: "Invitation" */
  readonly delete_Invitation_by_pk?: Maybe<Invitation>;
  /** delete data from the table: "JobStatus" */
  readonly delete_JobStatus?: Maybe<JobStatus_Mutation_Response>;
  /** delete single row from the table: "JobStatus" */
  readonly delete_JobStatus_by_pk?: Maybe<JobStatus>;
  /** delete data from the table: "MediaLiveChannel" */
  readonly delete_MediaLiveChannel?: Maybe<MediaLiveChannel_Mutation_Response>;
  /** delete single row from the table: "MediaLiveChannel" */
  readonly delete_MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** delete data from the table: "OnlineStatus" */
  readonly delete_OnlineStatus?: Maybe<OnlineStatus_Mutation_Response>;
  /** delete single row from the table: "OnlineStatus" */
  readonly delete_OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** delete data from the table: "OriginatingData" */
  readonly delete_OriginatingData?: Maybe<OriginatingData_Mutation_Response>;
  /** delete single row from the table: "OriginatingData" */
  readonly delete_OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** delete data from the table: "Permission" */
  readonly delete_Permission?: Maybe<Permission_Mutation_Response>;
  /** delete single row from the table: "Permission" */
  readonly delete_Permission_by_pk?: Maybe<Permission>;
  /** delete data from the table: "PushNotificationSubscription" */
  readonly delete_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** delete single row from the table: "PushNotificationSubscription" */
  readonly delete_PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** delete data from the table: "RequiredContentItem" */
  readonly delete_RequiredContentItem?: Maybe<RequiredContentItem_Mutation_Response>;
  /** delete single row from the table: "RequiredContentItem" */
  readonly delete_RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** delete data from the table: "Role" */
  readonly delete_Role?: Maybe<Role_Mutation_Response>;
  /** delete data from the table: "RolePermission" */
  readonly delete_RolePermission?: Maybe<RolePermission_Mutation_Response>;
  /** delete single row from the table: "RolePermission" */
  readonly delete_RolePermission_by_pk?: Maybe<RolePermission>;
  /** delete single row from the table: "Role" */
  readonly delete_Role_by_pk?: Maybe<Role>;
  /** delete data from the table: "Room" */
  readonly delete_Room?: Maybe<Room_Mutation_Response>;
  /** delete data from the table: "RoomMode" */
  readonly delete_RoomMode?: Maybe<RoomMode_Mutation_Response>;
  /** delete single row from the table: "RoomMode" */
  readonly delete_RoomMode_by_pk?: Maybe<RoomMode>;
  /** delete data from the table: "RoomParticipant" */
  readonly delete_RoomParticipant?: Maybe<RoomParticipant_Mutation_Response>;
  /** delete single row from the table: "RoomParticipant" */
  readonly delete_RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** delete data from the table: "RoomPerson" */
  readonly delete_RoomPerson?: Maybe<RoomPerson_Mutation_Response>;
  /** delete data from the table: "RoomPersonRole" */
  readonly delete_RoomPersonRole?: Maybe<RoomPersonRole_Mutation_Response>;
  /** delete single row from the table: "RoomPersonRole" */
  readonly delete_RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** delete single row from the table: "RoomPerson" */
  readonly delete_RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** delete data from the table: "RoomPrivacy" */
  readonly delete_RoomPrivacy?: Maybe<RoomPrivacy_Mutation_Response>;
  /** delete single row from the table: "RoomPrivacy" */
  readonly delete_RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** delete single row from the table: "Room" */
  readonly delete_Room_by_pk?: Maybe<Room>;
  /** delete data from the table: "Tag" */
  readonly delete_Tag?: Maybe<Tag_Mutation_Response>;
  /** delete single row from the table: "Tag" */
  readonly delete_Tag_by_pk?: Maybe<Tag>;
  /** delete data from the table: "TranscriptionJob" */
  readonly delete_TranscriptionJob?: Maybe<TranscriptionJob_Mutation_Response>;
  /** delete single row from the table: "TranscriptionJob" */
  readonly delete_TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** delete data from the table: "Transitions" */
  readonly delete_Transitions?: Maybe<Transitions_Mutation_Response>;
  /** delete single row from the table: "Transitions" */
  readonly delete_Transitions_by_pk?: Maybe<Transitions>;
  /** delete data from the table: "Uploader" */
  readonly delete_Uploader?: Maybe<Uploader_Mutation_Response>;
  /** delete single row from the table: "Uploader" */
  readonly delete_Uploader_by_pk?: Maybe<Uploader>;
  /** delete data from the table: "User" */
  readonly delete_User?: Maybe<User_Mutation_Response>;
  /** delete single row from the table: "User" */
  readonly delete_User_by_pk?: Maybe<User>;
  /** delete data from the table: "VideoRenderJob" */
  readonly delete_VideoRenderJob?: Maybe<VideoRenderJob_Mutation_Response>;
  /** delete single row from the table: "VideoRenderJob" */
  readonly delete_VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** delete data from the table: "YouTubeUpload" */
  readonly delete_YouTubeUpload?: Maybe<YouTubeUpload_Mutation_Response>;
  /** delete single row from the table: "YouTubeUpload" */
  readonly delete_YouTubeUpload_by_pk?: Maybe<YouTubeUpload>;
  /** delete data from the table: "analytics.AppStats" */
  readonly delete_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** delete single row from the table: "analytics.AppStats" */
  readonly delete_analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** delete data from the table: "analytics.ContentGroupStats" */
  readonly delete_analytics_ContentGroupStats?: Maybe<Analytics_ContentGroupStats_Mutation_Response>;
  /** delete single row from the table: "analytics.ContentGroupStats" */
  readonly delete_analytics_ContentGroupStats_by_pk?: Maybe<Analytics_ContentGroupStats>;
  /** delete data from the table: "analytics.ContentItemStats" */
  readonly delete_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** delete single row from the table: "analytics.ContentItemStats" */
  readonly delete_analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** delete data from the table: "analytics.RoomStats" */
  readonly delete_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** delete single row from the table: "analytics.RoomStats" */
  readonly delete_analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** delete data from the table: "chat.Chat" */
  readonly delete_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** delete single row from the table: "chat.Chat" */
  readonly delete_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** delete data from the table: "chat.Flag" */
  readonly delete_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** delete data from the table: "chat.FlagType" */
  readonly delete_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** delete single row from the table: "chat.FlagType" */
  readonly delete_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** delete single row from the table: "chat.Flag" */
  readonly delete_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** delete data from the table: "chat.Message" */
  readonly delete_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** delete data from the table: "chat.MessageType" */
  readonly delete_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** delete single row from the table: "chat.MessageType" */
  readonly delete_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** delete single row from the table: "chat.Message" */
  readonly delete_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** delete data from the table: "chat.Pin" */
  readonly delete_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** delete single row from the table: "chat.Pin" */
  readonly delete_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** delete data from the table: "chat.Reaction" */
  readonly delete_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** delete data from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** delete single row from the table: "chat.ReactionType" */
  readonly delete_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** delete single row from the table: "chat.Reaction" */
  readonly delete_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** delete data from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** delete single row from the table: "chat.ReadUpToIndex" */
  readonly delete_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** delete data from the table: "chat.Subscription" */
  readonly delete_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** delete single row from the table: "chat.Subscription" */
  readonly delete_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** delete data from the table: "job_queues.ChannelStackCreateJob" */
  readonly delete_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.ChannelStackCreateJob" */
  readonly delete_job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** delete data from the table: "job_queues.CombineVideosJob" */
  readonly delete_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.CombineVideosJob" */
  readonly delete_job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** delete data from the table: "job_queues.CustomEmailJob" */
  readonly delete_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.CustomEmailJob" */
  readonly delete_job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** delete data from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.InvitationEmailJob" */
  readonly delete_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** delete data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.MediaPackageHarvestJob" */
  readonly delete_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** delete data from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.PublishVideoJob" */
  readonly delete_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** delete data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly delete_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** delete data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly delete_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** delete single row from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly delete_job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** delete data from the table: "room.RoomChimeMeeting" */
  readonly delete_room_RoomChimeMeeting?: Maybe<Room_RoomChimeMeeting_Mutation_Response>;
  /** delete single row from the table: "room.RoomChimeMeeting" */
  readonly delete_room_RoomChimeMeeting_by_pk?: Maybe<Room_RoomChimeMeeting>;
  /** delete data from the table: "room.ShuffleAlgorithm" */
  readonly delete_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleAlgorithm" */
  readonly delete_room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** delete data from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** delete single row from the table: "room.ShufflePeriod" */
  readonly delete_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** delete data from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleQueueEntry" */
  readonly delete_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** delete data from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** delete single row from the table: "room.ShuffleRoom" */
  readonly delete_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** delete data from the table: "room.VideoRoomBackend" */
  readonly delete_room_VideoRoomBackend?: Maybe<Room_VideoRoomBackend_Mutation_Response>;
  /** delete single row from the table: "room.VideoRoomBackend" */
  readonly delete_room_VideoRoomBackend_by_pk?: Maybe<Room_VideoRoomBackend>;
  /** delete data from the table: "system.Configuration" */
  readonly delete_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** delete data from the table: "system.ConfigurationKey" */
  readonly delete_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** delete single row from the table: "system.ConfigurationKey" */
  readonly delete_system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** delete single row from the table: "system.Configuration" */
  readonly delete_system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** perform the action: "getGoogleOAuthUrl" */
  readonly getGoogleOAuthUrl?: Maybe<GetGoogleOAuthUrlOutput>;
  /** insert data into the table: "Attendee" */
  readonly insert_Attendee?: Maybe<Attendee_Mutation_Response>;
  /** insert data into the table: "AttendeeGoogleAccount" */
  readonly insert_AttendeeGoogleAccount?: Maybe<AttendeeGoogleAccount_Mutation_Response>;
  /** insert a single row into the table: "AttendeeGoogleAccount" */
  readonly insert_AttendeeGoogleAccount_one?: Maybe<AttendeeGoogleAccount>;
  /** insert data into the table: "AttendeeProfile" */
  readonly insert_AttendeeProfile?: Maybe<AttendeeProfile_Mutation_Response>;
  /** insert a single row into the table: "AttendeeProfile" */
  readonly insert_AttendeeProfile_one?: Maybe<AttendeeProfile>;
  /** insert a single row into the table: "Attendee" */
  readonly insert_Attendee_one?: Maybe<Attendee>;
  /** insert data into the table: "Broadcast" */
  readonly insert_Broadcast?: Maybe<Broadcast_Mutation_Response>;
  /** insert data into the table: "BroadcastContentItem" */
  readonly insert_BroadcastContentItem?: Maybe<BroadcastContentItem_Mutation_Response>;
  /** insert a single row into the table: "BroadcastContentItem" */
  readonly insert_BroadcastContentItem_one?: Maybe<BroadcastContentItem>;
  /** insert a single row into the table: "Broadcast" */
  readonly insert_Broadcast_one?: Maybe<Broadcast>;
  /** insert data into the table: "Conference" */
  readonly insert_Conference?: Maybe<Conference_Mutation_Response>;
  /** insert data into the table: "ConferenceConfiguration" */
  readonly insert_ConferenceConfiguration?: Maybe<ConferenceConfiguration_Mutation_Response>;
  /** insert a single row into the table: "ConferenceConfiguration" */
  readonly insert_ConferenceConfiguration_one?: Maybe<ConferenceConfiguration>;
  /** insert data into the table: "ConferenceDemoCode" */
  readonly insert_ConferenceDemoCode?: Maybe<ConferenceDemoCode_Mutation_Response>;
  /** insert a single row into the table: "ConferenceDemoCode" */
  readonly insert_ConferenceDemoCode_one?: Maybe<ConferenceDemoCode>;
  /** insert data into the table: "ConferencePrepareJob" */
  readonly insert_ConferencePrepareJob?: Maybe<ConferencePrepareJob_Mutation_Response>;
  /** insert a single row into the table: "ConferencePrepareJob" */
  readonly insert_ConferencePrepareJob_one?: Maybe<ConferencePrepareJob>;
  /** insert a single row into the table: "Conference" */
  readonly insert_Conference_one?: Maybe<Conference>;
  /** insert data into the table: "ContentGroup" */
  readonly insert_ContentGroup?: Maybe<ContentGroup_Mutation_Response>;
  /** insert data into the table: "ContentGroupHallway" */
  readonly insert_ContentGroupHallway?: Maybe<ContentGroupHallway_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupHallway" */
  readonly insert_ContentGroupHallway_one?: Maybe<ContentGroupHallway>;
  /** insert data into the table: "ContentGroupPerson" */
  readonly insert_ContentGroupPerson?: Maybe<ContentGroupPerson_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupPerson" */
  readonly insert_ContentGroupPerson_one?: Maybe<ContentGroupPerson>;
  /** insert data into the table: "ContentGroupTag" */
  readonly insert_ContentGroupTag?: Maybe<ContentGroupTag_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupTag" */
  readonly insert_ContentGroupTag_one?: Maybe<ContentGroupTag>;
  /** insert data into the table: "ContentGroupType" */
  readonly insert_ContentGroupType?: Maybe<ContentGroupType_Mutation_Response>;
  /** insert a single row into the table: "ContentGroupType" */
  readonly insert_ContentGroupType_one?: Maybe<ContentGroupType>;
  /** insert a single row into the table: "ContentGroup" */
  readonly insert_ContentGroup_one?: Maybe<ContentGroup>;
  /** insert data into the table: "ContentItem" */
  readonly insert_ContentItem?: Maybe<ContentItem_Mutation_Response>;
  /** insert a single row into the table: "ContentItem" */
  readonly insert_ContentItem_one?: Maybe<ContentItem>;
  /** insert data into the table: "ContentPerson" */
  readonly insert_ContentPerson?: Maybe<ContentPerson_Mutation_Response>;
  /** insert a single row into the table: "ContentPerson" */
  readonly insert_ContentPerson_one?: Maybe<ContentPerson>;
  /** insert data into the table: "ContentType" */
  readonly insert_ContentType?: Maybe<ContentType_Mutation_Response>;
  /** insert a single row into the table: "ContentType" */
  readonly insert_ContentType_one?: Maybe<ContentType>;
  /** insert data into the table: "Email" */
  readonly insert_Email?: Maybe<Email_Mutation_Response>;
  /** insert a single row into the table: "Email" */
  readonly insert_Email_one?: Maybe<Email>;
  /** insert data into the table: "Event" */
  readonly insert_Event?: Maybe<Event_Mutation_Response>;
  /** insert data into the table: "EventParticipantStream" */
  readonly insert_EventParticipantStream?: Maybe<EventParticipantStream_Mutation_Response>;
  /** insert a single row into the table: "EventParticipantStream" */
  readonly insert_EventParticipantStream_one?: Maybe<EventParticipantStream>;
  /** insert data into the table: "EventPerson" */
  readonly insert_EventPerson?: Maybe<EventPerson_Mutation_Response>;
  /** insert data into the table: "EventPersonRole" */
  readonly insert_EventPersonRole?: Maybe<EventPersonRole_Mutation_Response>;
  /** insert a single row into the table: "EventPersonRole" */
  readonly insert_EventPersonRole_one?: Maybe<EventPersonRole>;
  /** insert a single row into the table: "EventPerson" */
  readonly insert_EventPerson_one?: Maybe<EventPerson>;
  /** insert data into the table: "EventRoomJoinRequest" */
  readonly insert_EventRoomJoinRequest?: Maybe<EventRoomJoinRequest_Mutation_Response>;
  /** insert a single row into the table: "EventRoomJoinRequest" */
  readonly insert_EventRoomJoinRequest_one?: Maybe<EventRoomJoinRequest>;
  /** insert data into the table: "EventTag" */
  readonly insert_EventTag?: Maybe<EventTag_Mutation_Response>;
  /** insert a single row into the table: "EventTag" */
  readonly insert_EventTag_one?: Maybe<EventTag>;
  /** insert data into the table: "EventVonageSession" */
  readonly insert_EventVonageSession?: Maybe<EventVonageSession_Mutation_Response>;
  /** insert a single row into the table: "EventVonageSession" */
  readonly insert_EventVonageSession_one?: Maybe<EventVonageSession>;
  /** insert a single row into the table: "Event" */
  readonly insert_Event_one?: Maybe<Event>;
  /** insert data into the table: "ExecutedTransitions" */
  readonly insert_ExecutedTransitions?: Maybe<ExecutedTransitions_Mutation_Response>;
  /** insert a single row into the table: "ExecutedTransitions" */
  readonly insert_ExecutedTransitions_one?: Maybe<ExecutedTransitions>;
  /** insert data into the table: "Group" */
  readonly insert_Group?: Maybe<Group_Mutation_Response>;
  /** insert data into the table: "GroupAttendee" */
  readonly insert_GroupAttendee?: Maybe<GroupAttendee_Mutation_Response>;
  /** insert a single row into the table: "GroupAttendee" */
  readonly insert_GroupAttendee_one?: Maybe<GroupAttendee>;
  /** insert data into the table: "GroupRole" */
  readonly insert_GroupRole?: Maybe<GroupRole_Mutation_Response>;
  /** insert a single row into the table: "GroupRole" */
  readonly insert_GroupRole_one?: Maybe<GroupRole>;
  /** insert a single row into the table: "Group" */
  readonly insert_Group_one?: Maybe<Group>;
  /** insert data into the table: "Hallway" */
  readonly insert_Hallway?: Maybe<Hallway_Mutation_Response>;
  /** insert a single row into the table: "Hallway" */
  readonly insert_Hallway_one?: Maybe<Hallway>;
  /** insert data into the table: "InputType" */
  readonly insert_InputType?: Maybe<InputType_Mutation_Response>;
  /** insert a single row into the table: "InputType" */
  readonly insert_InputType_one?: Maybe<InputType>;
  /** insert data into the table: "Invitation" */
  readonly insert_Invitation?: Maybe<Invitation_Mutation_Response>;
  /** insert a single row into the table: "Invitation" */
  readonly insert_Invitation_one?: Maybe<Invitation>;
  /** insert data into the table: "JobStatus" */
  readonly insert_JobStatus?: Maybe<JobStatus_Mutation_Response>;
  /** insert a single row into the table: "JobStatus" */
  readonly insert_JobStatus_one?: Maybe<JobStatus>;
  /** insert data into the table: "MediaLiveChannel" */
  readonly insert_MediaLiveChannel?: Maybe<MediaLiveChannel_Mutation_Response>;
  /** insert a single row into the table: "MediaLiveChannel" */
  readonly insert_MediaLiveChannel_one?: Maybe<MediaLiveChannel>;
  /** insert data into the table: "OnlineStatus" */
  readonly insert_OnlineStatus?: Maybe<OnlineStatus_Mutation_Response>;
  /** insert a single row into the table: "OnlineStatus" */
  readonly insert_OnlineStatus_one?: Maybe<OnlineStatus>;
  /** insert data into the table: "OriginatingData" */
  readonly insert_OriginatingData?: Maybe<OriginatingData_Mutation_Response>;
  /** insert a single row into the table: "OriginatingData" */
  readonly insert_OriginatingData_one?: Maybe<OriginatingData>;
  /** insert data into the table: "Permission" */
  readonly insert_Permission?: Maybe<Permission_Mutation_Response>;
  /** insert a single row into the table: "Permission" */
  readonly insert_Permission_one?: Maybe<Permission>;
  /** insert data into the table: "PushNotificationSubscription" */
  readonly insert_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** insert a single row into the table: "PushNotificationSubscription" */
  readonly insert_PushNotificationSubscription_one?: Maybe<PushNotificationSubscription>;
  /** insert data into the table: "RequiredContentItem" */
  readonly insert_RequiredContentItem?: Maybe<RequiredContentItem_Mutation_Response>;
  /** insert a single row into the table: "RequiredContentItem" */
  readonly insert_RequiredContentItem_one?: Maybe<RequiredContentItem>;
  /** insert data into the table: "Role" */
  readonly insert_Role?: Maybe<Role_Mutation_Response>;
  /** insert data into the table: "RolePermission" */
  readonly insert_RolePermission?: Maybe<RolePermission_Mutation_Response>;
  /** insert a single row into the table: "RolePermission" */
  readonly insert_RolePermission_one?: Maybe<RolePermission>;
  /** insert a single row into the table: "Role" */
  readonly insert_Role_one?: Maybe<Role>;
  /** insert data into the table: "Room" */
  readonly insert_Room?: Maybe<Room_Mutation_Response>;
  /** insert data into the table: "RoomMode" */
  readonly insert_RoomMode?: Maybe<RoomMode_Mutation_Response>;
  /** insert a single row into the table: "RoomMode" */
  readonly insert_RoomMode_one?: Maybe<RoomMode>;
  /** insert data into the table: "RoomParticipant" */
  readonly insert_RoomParticipant?: Maybe<RoomParticipant_Mutation_Response>;
  /** insert a single row into the table: "RoomParticipant" */
  readonly insert_RoomParticipant_one?: Maybe<RoomParticipant>;
  /** insert data into the table: "RoomPerson" */
  readonly insert_RoomPerson?: Maybe<RoomPerson_Mutation_Response>;
  /** insert data into the table: "RoomPersonRole" */
  readonly insert_RoomPersonRole?: Maybe<RoomPersonRole_Mutation_Response>;
  /** insert a single row into the table: "RoomPersonRole" */
  readonly insert_RoomPersonRole_one?: Maybe<RoomPersonRole>;
  /** insert a single row into the table: "RoomPerson" */
  readonly insert_RoomPerson_one?: Maybe<RoomPerson>;
  /** insert data into the table: "RoomPrivacy" */
  readonly insert_RoomPrivacy?: Maybe<RoomPrivacy_Mutation_Response>;
  /** insert a single row into the table: "RoomPrivacy" */
  readonly insert_RoomPrivacy_one?: Maybe<RoomPrivacy>;
  /** insert a single row into the table: "Room" */
  readonly insert_Room_one?: Maybe<Room>;
  /** insert data into the table: "Tag" */
  readonly insert_Tag?: Maybe<Tag_Mutation_Response>;
  /** insert a single row into the table: "Tag" */
  readonly insert_Tag_one?: Maybe<Tag>;
  /** insert data into the table: "TranscriptionJob" */
  readonly insert_TranscriptionJob?: Maybe<TranscriptionJob_Mutation_Response>;
  /** insert a single row into the table: "TranscriptionJob" */
  readonly insert_TranscriptionJob_one?: Maybe<TranscriptionJob>;
  /** insert data into the table: "Transitions" */
  readonly insert_Transitions?: Maybe<Transitions_Mutation_Response>;
  /** insert a single row into the table: "Transitions" */
  readonly insert_Transitions_one?: Maybe<Transitions>;
  /** insert data into the table: "Uploader" */
  readonly insert_Uploader?: Maybe<Uploader_Mutation_Response>;
  /** insert a single row into the table: "Uploader" */
  readonly insert_Uploader_one?: Maybe<Uploader>;
  /** insert data into the table: "User" */
  readonly insert_User?: Maybe<User_Mutation_Response>;
  /** insert a single row into the table: "User" */
  readonly insert_User_one?: Maybe<User>;
  /** insert data into the table: "VideoRenderJob" */
  readonly insert_VideoRenderJob?: Maybe<VideoRenderJob_Mutation_Response>;
  /** insert a single row into the table: "VideoRenderJob" */
  readonly insert_VideoRenderJob_one?: Maybe<VideoRenderJob>;
  /** insert data into the table: "YouTubeUpload" */
  readonly insert_YouTubeUpload?: Maybe<YouTubeUpload_Mutation_Response>;
  /** insert a single row into the table: "YouTubeUpload" */
  readonly insert_YouTubeUpload_one?: Maybe<YouTubeUpload>;
  /** insert data into the table: "analytics.AppStats" */
  readonly insert_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.AppStats" */
  readonly insert_analytics_AppStats_one?: Maybe<Analytics_AppStats>;
  /** insert data into the table: "analytics.ContentGroupStats" */
  readonly insert_analytics_ContentGroupStats?: Maybe<Analytics_ContentGroupStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.ContentGroupStats" */
  readonly insert_analytics_ContentGroupStats_one?: Maybe<Analytics_ContentGroupStats>;
  /** insert data into the table: "analytics.ContentItemStats" */
  readonly insert_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.ContentItemStats" */
  readonly insert_analytics_ContentItemStats_one?: Maybe<Analytics_ContentItemStats>;
  /** insert data into the table: "analytics.RoomStats" */
  readonly insert_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** insert a single row into the table: "analytics.RoomStats" */
  readonly insert_analytics_RoomStats_one?: Maybe<Analytics_RoomStats>;
  /** insert data into the table: "chat.Chat" */
  readonly insert_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** insert a single row into the table: "chat.Chat" */
  readonly insert_chat_Chat_one?: Maybe<Chat_Chat>;
  /** insert data into the table: "chat.Flag" */
  readonly insert_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** insert data into the table: "chat.FlagType" */
  readonly insert_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** insert a single row into the table: "chat.FlagType" */
  readonly insert_chat_FlagType_one?: Maybe<Chat_FlagType>;
  /** insert a single row into the table: "chat.Flag" */
  readonly insert_chat_Flag_one?: Maybe<Chat_Flag>;
  /** insert data into the table: "chat.Message" */
  readonly insert_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** insert data into the table: "chat.MessageType" */
  readonly insert_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** insert a single row into the table: "chat.MessageType" */
  readonly insert_chat_MessageType_one?: Maybe<Chat_MessageType>;
  /** insert a single row into the table: "chat.Message" */
  readonly insert_chat_Message_one?: Maybe<Chat_Message>;
  /** insert data into the table: "chat.Pin" */
  readonly insert_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** insert a single row into the table: "chat.Pin" */
  readonly insert_chat_Pin_one?: Maybe<Chat_Pin>;
  /** insert data into the table: "chat.Reaction" */
  readonly insert_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** insert data into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** insert a single row into the table: "chat.ReactionType" */
  readonly insert_chat_ReactionType_one?: Maybe<Chat_ReactionType>;
  /** insert a single row into the table: "chat.Reaction" */
  readonly insert_chat_Reaction_one?: Maybe<Chat_Reaction>;
  /** insert data into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** insert a single row into the table: "chat.ReadUpToIndex" */
  readonly insert_chat_ReadUpToIndex_one?: Maybe<Chat_ReadUpToIndex>;
  /** insert data into the table: "chat.Subscription" */
  readonly insert_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** insert a single row into the table: "chat.Subscription" */
  readonly insert_chat_Subscription_one?: Maybe<Chat_Subscription>;
  /** insert data into the table: "job_queues.ChannelStackCreateJob" */
  readonly insert_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.ChannelStackCreateJob" */
  readonly insert_job_queues_ChannelStackCreateJob_one?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** insert data into the table: "job_queues.CombineVideosJob" */
  readonly insert_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.CombineVideosJob" */
  readonly insert_job_queues_CombineVideosJob_one?: Maybe<Job_Queues_CombineVideosJob>;
  /** insert data into the table: "job_queues.CustomEmailJob" */
  readonly insert_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.CustomEmailJob" */
  readonly insert_job_queues_CustomEmailJob_one?: Maybe<Job_Queues_CustomEmailJob>;
  /** insert data into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.InvitationEmailJob" */
  readonly insert_job_queues_InvitationEmailJob_one?: Maybe<Job_Queues_InvitationEmailJob>;
  /** insert data into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.MediaPackageHarvestJob" */
  readonly insert_job_queues_MediaPackageHarvestJob_one?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** insert data into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.PublishVideoJob" */
  readonly insert_job_queues_PublishVideoJob_one?: Maybe<Job_Queues_PublishVideoJob>;
  /** insert data into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.SubmissionRequestEmailJob" */
  readonly insert_job_queues_SubmissionRequestEmailJob_one?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** insert data into the table: "job_queues.UploadYouTubeVideoJob" */
  readonly insert_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** insert a single row into the table: "job_queues.UploadYouTubeVideoJob" */
  readonly insert_job_queues_UploadYouTubeVideoJob_one?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** insert data into the table: "room.RoomChimeMeeting" */
  readonly insert_room_RoomChimeMeeting?: Maybe<Room_RoomChimeMeeting_Mutation_Response>;
  /** insert a single row into the table: "room.RoomChimeMeeting" */
  readonly insert_room_RoomChimeMeeting_one?: Maybe<Room_RoomChimeMeeting>;
  /** insert data into the table: "room.ShuffleAlgorithm" */
  readonly insert_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleAlgorithm" */
  readonly insert_room_ShuffleAlgorithm_one?: Maybe<Room_ShuffleAlgorithm>;
  /** insert data into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** insert a single row into the table: "room.ShufflePeriod" */
  readonly insert_room_ShufflePeriod_one?: Maybe<Room_ShufflePeriod>;
  /** insert data into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleQueueEntry" */
  readonly insert_room_ShuffleQueueEntry_one?: Maybe<Room_ShuffleQueueEntry>;
  /** insert data into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** insert a single row into the table: "room.ShuffleRoom" */
  readonly insert_room_ShuffleRoom_one?: Maybe<Room_ShuffleRoom>;
  /** insert data into the table: "room.VideoRoomBackend" */
  readonly insert_room_VideoRoomBackend?: Maybe<Room_VideoRoomBackend_Mutation_Response>;
  /** insert a single row into the table: "room.VideoRoomBackend" */
  readonly insert_room_VideoRoomBackend_one?: Maybe<Room_VideoRoomBackend>;
  /** insert data into the table: "system.Configuration" */
  readonly insert_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** insert data into the table: "system.ConfigurationKey" */
  readonly insert_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** insert a single row into the table: "system.ConfigurationKey" */
  readonly insert_system_ConfigurationKey_one?: Maybe<System_ConfigurationKey>;
  /** insert a single row into the table: "system.Configuration" */
  readonly insert_system_Configuration_one?: Maybe<System_Configuration>;
  /** perform the action: "invitationConfirmCurrent" */
  readonly invitationConfirmCurrent?: Maybe<ConfirmInvitationOutput>;
  /** perform the action: "invitationConfirmSendInitialEmail" */
  readonly invitationConfirmSendInitialEmail?: Maybe<InvitationConfirmationEmailOutput>;
  /** perform the action: "invitationConfirmSendRepeatEmail" */
  readonly invitationConfirmSendRepeatEmail?: Maybe<InvitationConfirmationEmailOutput>;
  /** perform the action: "invitationConfirmWithCode" */
  readonly invitationConfirmWithCode?: Maybe<ConfirmInvitationOutput>;
  /** perform the action: "joinEventVonageSession" */
  readonly joinEventVonageSession?: Maybe<JoinEventVonageSessionOutput>;
  /** perform the action: "joinRoomChimeSession" */
  readonly joinRoomChimeSession?: Maybe<JoinRoomChimeSessionOutput>;
  /** perform the action: "joinRoomVonageSession" */
  readonly joinRoomVonageSession?: Maybe<JoinRoomVonageSessionOutput>;
  /** perform the action: "presence_Flush" */
  readonly presence_Flush: PresenceFlushOutput;
  /** perform the action: "refreshYouTubeData" */
  readonly refreshYouTubeData?: Maybe<RefreshYouTubeDataOutput>;
  /** perform the action: "stopEventBroadcast" */
  readonly stopEventBroadcast?: Maybe<StopEventBroadcastOutput>;
  /** perform the action: "submitContentItem" */
  readonly submitContentItem?: Maybe<SubmitContentItemOutput>;
  /** perform the action: "submitGoogleOAuthCode" */
  readonly submitGoogleOAuthCode?: Maybe<SubmitGoogleOAuthCodeOutput>;
  /** perform the action: "updateProfilePhoto" */
  readonly updateProfilePhoto?: Maybe<UpdateProfilePhotoResponse>;
  /** perform the action: "updateSubtitles" */
  readonly updateSubtitles?: Maybe<SubmitUpdatedSubtitlesOutput>;
  /** update data of the table: "Attendee" */
  readonly update_Attendee?: Maybe<Attendee_Mutation_Response>;
  /** update data of the table: "AttendeeGoogleAccount" */
  readonly update_AttendeeGoogleAccount?: Maybe<AttendeeGoogleAccount_Mutation_Response>;
  /** update single row of the table: "AttendeeGoogleAccount" */
  readonly update_AttendeeGoogleAccount_by_pk?: Maybe<AttendeeGoogleAccount>;
  /** update data of the table: "AttendeeProfile" */
  readonly update_AttendeeProfile?: Maybe<AttendeeProfile_Mutation_Response>;
  /** update single row of the table: "AttendeeProfile" */
  readonly update_AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** update single row of the table: "Attendee" */
  readonly update_Attendee_by_pk?: Maybe<Attendee>;
  /** update data of the table: "Broadcast" */
  readonly update_Broadcast?: Maybe<Broadcast_Mutation_Response>;
  /** update data of the table: "BroadcastContentItem" */
  readonly update_BroadcastContentItem?: Maybe<BroadcastContentItem_Mutation_Response>;
  /** update single row of the table: "BroadcastContentItem" */
  readonly update_BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** update single row of the table: "Broadcast" */
  readonly update_Broadcast_by_pk?: Maybe<Broadcast>;
  /** update data of the table: "Conference" */
  readonly update_Conference?: Maybe<Conference_Mutation_Response>;
  /** update data of the table: "ConferenceConfiguration" */
  readonly update_ConferenceConfiguration?: Maybe<ConferenceConfiguration_Mutation_Response>;
  /** update single row of the table: "ConferenceConfiguration" */
  readonly update_ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** update data of the table: "ConferenceDemoCode" */
  readonly update_ConferenceDemoCode?: Maybe<ConferenceDemoCode_Mutation_Response>;
  /** update single row of the table: "ConferenceDemoCode" */
  readonly update_ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** update data of the table: "ConferencePrepareJob" */
  readonly update_ConferencePrepareJob?: Maybe<ConferencePrepareJob_Mutation_Response>;
  /** update single row of the table: "ConferencePrepareJob" */
  readonly update_ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** update single row of the table: "Conference" */
  readonly update_Conference_by_pk?: Maybe<Conference>;
  /** update data of the table: "ContentGroup" */
  readonly update_ContentGroup?: Maybe<ContentGroup_Mutation_Response>;
  /** update data of the table: "ContentGroupHallway" */
  readonly update_ContentGroupHallway?: Maybe<ContentGroupHallway_Mutation_Response>;
  /** update single row of the table: "ContentGroupHallway" */
  readonly update_ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** update data of the table: "ContentGroupPerson" */
  readonly update_ContentGroupPerson?: Maybe<ContentGroupPerson_Mutation_Response>;
  /** update single row of the table: "ContentGroupPerson" */
  readonly update_ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** update data of the table: "ContentGroupTag" */
  readonly update_ContentGroupTag?: Maybe<ContentGroupTag_Mutation_Response>;
  /** update single row of the table: "ContentGroupTag" */
  readonly update_ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** update data of the table: "ContentGroupType" */
  readonly update_ContentGroupType?: Maybe<ContentGroupType_Mutation_Response>;
  /** update single row of the table: "ContentGroupType" */
  readonly update_ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** update single row of the table: "ContentGroup" */
  readonly update_ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** update data of the table: "ContentItem" */
  readonly update_ContentItem?: Maybe<ContentItem_Mutation_Response>;
  /** update single row of the table: "ContentItem" */
  readonly update_ContentItem_by_pk?: Maybe<ContentItem>;
  /** update data of the table: "ContentPerson" */
  readonly update_ContentPerson?: Maybe<ContentPerson_Mutation_Response>;
  /** update single row of the table: "ContentPerson" */
  readonly update_ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** update data of the table: "ContentType" */
  readonly update_ContentType?: Maybe<ContentType_Mutation_Response>;
  /** update single row of the table: "ContentType" */
  readonly update_ContentType_by_pk?: Maybe<ContentType>;
  /** update data of the table: "Email" */
  readonly update_Email?: Maybe<Email_Mutation_Response>;
  /** update single row of the table: "Email" */
  readonly update_Email_by_pk?: Maybe<Email>;
  /** update data of the table: "Event" */
  readonly update_Event?: Maybe<Event_Mutation_Response>;
  /** update data of the table: "EventParticipantStream" */
  readonly update_EventParticipantStream?: Maybe<EventParticipantStream_Mutation_Response>;
  /** update single row of the table: "EventParticipantStream" */
  readonly update_EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** update data of the table: "EventPerson" */
  readonly update_EventPerson?: Maybe<EventPerson_Mutation_Response>;
  /** update data of the table: "EventPersonRole" */
  readonly update_EventPersonRole?: Maybe<EventPersonRole_Mutation_Response>;
  /** update single row of the table: "EventPersonRole" */
  readonly update_EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** update single row of the table: "EventPerson" */
  readonly update_EventPerson_by_pk?: Maybe<EventPerson>;
  /** update data of the table: "EventRoomJoinRequest" */
  readonly update_EventRoomJoinRequest?: Maybe<EventRoomJoinRequest_Mutation_Response>;
  /** update single row of the table: "EventRoomJoinRequest" */
  readonly update_EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** update data of the table: "EventTag" */
  readonly update_EventTag?: Maybe<EventTag_Mutation_Response>;
  /** update single row of the table: "EventTag" */
  readonly update_EventTag_by_pk?: Maybe<EventTag>;
  /** update data of the table: "EventVonageSession" */
  readonly update_EventVonageSession?: Maybe<EventVonageSession_Mutation_Response>;
  /** update single row of the table: "EventVonageSession" */
  readonly update_EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** update single row of the table: "Event" */
  readonly update_Event_by_pk?: Maybe<Event>;
  /** update data of the table: "ExecutedTransitions" */
  readonly update_ExecutedTransitions?: Maybe<ExecutedTransitions_Mutation_Response>;
  /** update single row of the table: "ExecutedTransitions" */
  readonly update_ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** update data of the table: "Group" */
  readonly update_Group?: Maybe<Group_Mutation_Response>;
  /** update data of the table: "GroupAttendee" */
  readonly update_GroupAttendee?: Maybe<GroupAttendee_Mutation_Response>;
  /** update single row of the table: "GroupAttendee" */
  readonly update_GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** update data of the table: "GroupRole" */
  readonly update_GroupRole?: Maybe<GroupRole_Mutation_Response>;
  /** update single row of the table: "GroupRole" */
  readonly update_GroupRole_by_pk?: Maybe<GroupRole>;
  /** update single row of the table: "Group" */
  readonly update_Group_by_pk?: Maybe<Group>;
  /** update data of the table: "Hallway" */
  readonly update_Hallway?: Maybe<Hallway_Mutation_Response>;
  /** update single row of the table: "Hallway" */
  readonly update_Hallway_by_pk?: Maybe<Hallway>;
  /** update data of the table: "InputType" */
  readonly update_InputType?: Maybe<InputType_Mutation_Response>;
  /** update single row of the table: "InputType" */
  readonly update_InputType_by_pk?: Maybe<InputType>;
  /** update data of the table: "Invitation" */
  readonly update_Invitation?: Maybe<Invitation_Mutation_Response>;
  /** update single row of the table: "Invitation" */
  readonly update_Invitation_by_pk?: Maybe<Invitation>;
  /** update data of the table: "JobStatus" */
  readonly update_JobStatus?: Maybe<JobStatus_Mutation_Response>;
  /** update single row of the table: "JobStatus" */
  readonly update_JobStatus_by_pk?: Maybe<JobStatus>;
  /** update data of the table: "MediaLiveChannel" */
  readonly update_MediaLiveChannel?: Maybe<MediaLiveChannel_Mutation_Response>;
  /** update single row of the table: "MediaLiveChannel" */
  readonly update_MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** update data of the table: "OnlineStatus" */
  readonly update_OnlineStatus?: Maybe<OnlineStatus_Mutation_Response>;
  /** update single row of the table: "OnlineStatus" */
  readonly update_OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** update data of the table: "OriginatingData" */
  readonly update_OriginatingData?: Maybe<OriginatingData_Mutation_Response>;
  /** update single row of the table: "OriginatingData" */
  readonly update_OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** update data of the table: "Permission" */
  readonly update_Permission?: Maybe<Permission_Mutation_Response>;
  /** update single row of the table: "Permission" */
  readonly update_Permission_by_pk?: Maybe<Permission>;
  /** update data of the table: "PushNotificationSubscription" */
  readonly update_PushNotificationSubscription?: Maybe<PushNotificationSubscription_Mutation_Response>;
  /** update single row of the table: "PushNotificationSubscription" */
  readonly update_PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** update data of the table: "RequiredContentItem" */
  readonly update_RequiredContentItem?: Maybe<RequiredContentItem_Mutation_Response>;
  /** update single row of the table: "RequiredContentItem" */
  readonly update_RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** update data of the table: "Role" */
  readonly update_Role?: Maybe<Role_Mutation_Response>;
  /** update data of the table: "RolePermission" */
  readonly update_RolePermission?: Maybe<RolePermission_Mutation_Response>;
  /** update single row of the table: "RolePermission" */
  readonly update_RolePermission_by_pk?: Maybe<RolePermission>;
  /** update single row of the table: "Role" */
  readonly update_Role_by_pk?: Maybe<Role>;
  /** update data of the table: "Room" */
  readonly update_Room?: Maybe<Room_Mutation_Response>;
  /** update data of the table: "RoomMode" */
  readonly update_RoomMode?: Maybe<RoomMode_Mutation_Response>;
  /** update single row of the table: "RoomMode" */
  readonly update_RoomMode_by_pk?: Maybe<RoomMode>;
  /** update data of the table: "RoomParticipant" */
  readonly update_RoomParticipant?: Maybe<RoomParticipant_Mutation_Response>;
  /** update single row of the table: "RoomParticipant" */
  readonly update_RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** update data of the table: "RoomPerson" */
  readonly update_RoomPerson?: Maybe<RoomPerson_Mutation_Response>;
  /** update data of the table: "RoomPersonRole" */
  readonly update_RoomPersonRole?: Maybe<RoomPersonRole_Mutation_Response>;
  /** update single row of the table: "RoomPersonRole" */
  readonly update_RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** update single row of the table: "RoomPerson" */
  readonly update_RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** update data of the table: "RoomPrivacy" */
  readonly update_RoomPrivacy?: Maybe<RoomPrivacy_Mutation_Response>;
  /** update single row of the table: "RoomPrivacy" */
  readonly update_RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** update single row of the table: "Room" */
  readonly update_Room_by_pk?: Maybe<Room>;
  /** update data of the table: "Tag" */
  readonly update_Tag?: Maybe<Tag_Mutation_Response>;
  /** update single row of the table: "Tag" */
  readonly update_Tag_by_pk?: Maybe<Tag>;
  /** update data of the table: "TranscriptionJob" */
  readonly update_TranscriptionJob?: Maybe<TranscriptionJob_Mutation_Response>;
  /** update single row of the table: "TranscriptionJob" */
  readonly update_TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** update data of the table: "Transitions" */
  readonly update_Transitions?: Maybe<Transitions_Mutation_Response>;
  /** update single row of the table: "Transitions" */
  readonly update_Transitions_by_pk?: Maybe<Transitions>;
  /** update data of the table: "Uploader" */
  readonly update_Uploader?: Maybe<Uploader_Mutation_Response>;
  /** update single row of the table: "Uploader" */
  readonly update_Uploader_by_pk?: Maybe<Uploader>;
  /** update data of the table: "User" */
  readonly update_User?: Maybe<User_Mutation_Response>;
  /** update single row of the table: "User" */
  readonly update_User_by_pk?: Maybe<User>;
  /** update data of the table: "VideoRenderJob" */
  readonly update_VideoRenderJob?: Maybe<VideoRenderJob_Mutation_Response>;
  /** update single row of the table: "VideoRenderJob" */
  readonly update_VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** update data of the table: "YouTubeUpload" */
  readonly update_YouTubeUpload?: Maybe<YouTubeUpload_Mutation_Response>;
  /** update single row of the table: "YouTubeUpload" */
  readonly update_YouTubeUpload_by_pk?: Maybe<YouTubeUpload>;
  /** update data of the table: "analytics.AppStats" */
  readonly update_analytics_AppStats?: Maybe<Analytics_AppStats_Mutation_Response>;
  /** update single row of the table: "analytics.AppStats" */
  readonly update_analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** update data of the table: "analytics.ContentGroupStats" */
  readonly update_analytics_ContentGroupStats?: Maybe<Analytics_ContentGroupStats_Mutation_Response>;
  /** update single row of the table: "analytics.ContentGroupStats" */
  readonly update_analytics_ContentGroupStats_by_pk?: Maybe<Analytics_ContentGroupStats>;
  /** update data of the table: "analytics.ContentItemStats" */
  readonly update_analytics_ContentItemStats?: Maybe<Analytics_ContentItemStats_Mutation_Response>;
  /** update single row of the table: "analytics.ContentItemStats" */
  readonly update_analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** update data of the table: "analytics.RoomStats" */
  readonly update_analytics_RoomStats?: Maybe<Analytics_RoomStats_Mutation_Response>;
  /** update single row of the table: "analytics.RoomStats" */
  readonly update_analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** update data of the table: "chat.Chat" */
  readonly update_chat_Chat?: Maybe<Chat_Chat_Mutation_Response>;
  /** update single row of the table: "chat.Chat" */
  readonly update_chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** update data of the table: "chat.Flag" */
  readonly update_chat_Flag?: Maybe<Chat_Flag_Mutation_Response>;
  /** update data of the table: "chat.FlagType" */
  readonly update_chat_FlagType?: Maybe<Chat_FlagType_Mutation_Response>;
  /** update single row of the table: "chat.FlagType" */
  readonly update_chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** update single row of the table: "chat.Flag" */
  readonly update_chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** update data of the table: "chat.Message" */
  readonly update_chat_Message?: Maybe<Chat_Message_Mutation_Response>;
  /** update data of the table: "chat.MessageType" */
  readonly update_chat_MessageType?: Maybe<Chat_MessageType_Mutation_Response>;
  /** update single row of the table: "chat.MessageType" */
  readonly update_chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** update single row of the table: "chat.Message" */
  readonly update_chat_Message_by_pk?: Maybe<Chat_Message>;
  /** update data of the table: "chat.Pin" */
  readonly update_chat_Pin?: Maybe<Chat_Pin_Mutation_Response>;
  /** update single row of the table: "chat.Pin" */
  readonly update_chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** update data of the table: "chat.Reaction" */
  readonly update_chat_Reaction?: Maybe<Chat_Reaction_Mutation_Response>;
  /** update data of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType?: Maybe<Chat_ReactionType_Mutation_Response>;
  /** update single row of the table: "chat.ReactionType" */
  readonly update_chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** update single row of the table: "chat.Reaction" */
  readonly update_chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** update data of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex?: Maybe<Chat_ReadUpToIndex_Mutation_Response>;
  /** update single row of the table: "chat.ReadUpToIndex" */
  readonly update_chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** update data of the table: "chat.Subscription" */
  readonly update_chat_Subscription?: Maybe<Chat_Subscription_Mutation_Response>;
  /** update single row of the table: "chat.Subscription" */
  readonly update_chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** update data of the table: "job_queues.ChannelStackCreateJob" */
  readonly update_job_queues_ChannelStackCreateJob?: Maybe<Job_Queues_ChannelStackCreateJob_Mutation_Response>;
  /** update single row of the table: "job_queues.ChannelStackCreateJob" */
  readonly update_job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** update data of the table: "job_queues.CombineVideosJob" */
  readonly update_job_queues_CombineVideosJob?: Maybe<Job_Queues_CombineVideosJob_Mutation_Response>;
  /** update single row of the table: "job_queues.CombineVideosJob" */
  readonly update_job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** update data of the table: "job_queues.CustomEmailJob" */
  readonly update_job_queues_CustomEmailJob?: Maybe<Job_Queues_CustomEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.CustomEmailJob" */
  readonly update_job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** update data of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob?: Maybe<Job_Queues_InvitationEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.InvitationEmailJob" */
  readonly update_job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** update data of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob?: Maybe<Job_Queues_MediaPackageHarvestJob_Mutation_Response>;
  /** update single row of the table: "job_queues.MediaPackageHarvestJob" */
  readonly update_job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** update data of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob?: Maybe<Job_Queues_PublishVideoJob_Mutation_Response>;
  /** update single row of the table: "job_queues.PublishVideoJob" */
  readonly update_job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** update data of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob?: Maybe<Job_Queues_SubmissionRequestEmailJob_Mutation_Response>;
  /** update single row of the table: "job_queues.SubmissionRequestEmailJob" */
  readonly update_job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** update data of the table: "job_queues.UploadYouTubeVideoJob" */
  readonly update_job_queues_UploadYouTubeVideoJob?: Maybe<Job_Queues_UploadYouTubeVideoJob_Mutation_Response>;
  /** update single row of the table: "job_queues.UploadYouTubeVideoJob" */
  readonly update_job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** update data of the table: "room.RoomChimeMeeting" */
  readonly update_room_RoomChimeMeeting?: Maybe<Room_RoomChimeMeeting_Mutation_Response>;
  /** update single row of the table: "room.RoomChimeMeeting" */
  readonly update_room_RoomChimeMeeting_by_pk?: Maybe<Room_RoomChimeMeeting>;
  /** update data of the table: "room.ShuffleAlgorithm" */
  readonly update_room_ShuffleAlgorithm?: Maybe<Room_ShuffleAlgorithm_Mutation_Response>;
  /** update single row of the table: "room.ShuffleAlgorithm" */
  readonly update_room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** update data of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod?: Maybe<Room_ShufflePeriod_Mutation_Response>;
  /** update single row of the table: "room.ShufflePeriod" */
  readonly update_room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** update data of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry?: Maybe<Room_ShuffleQueueEntry_Mutation_Response>;
  /** update single row of the table: "room.ShuffleQueueEntry" */
  readonly update_room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** update data of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom?: Maybe<Room_ShuffleRoom_Mutation_Response>;
  /** update single row of the table: "room.ShuffleRoom" */
  readonly update_room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** update data of the table: "room.VideoRoomBackend" */
  readonly update_room_VideoRoomBackend?: Maybe<Room_VideoRoomBackend_Mutation_Response>;
  /** update single row of the table: "room.VideoRoomBackend" */
  readonly update_room_VideoRoomBackend_by_pk?: Maybe<Room_VideoRoomBackend>;
  /** update data of the table: "system.Configuration" */
  readonly update_system_Configuration?: Maybe<System_Configuration_Mutation_Response>;
  /** update data of the table: "system.ConfigurationKey" */
  readonly update_system_ConfigurationKey?: Maybe<System_ConfigurationKey_Mutation_Response>;
  /** update single row of the table: "system.ConfigurationKey" */
  readonly update_system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** update single row of the table: "system.Configuration" */
  readonly update_system_Configuration_by_pk?: Maybe<System_Configuration>;
};


/** mutation root */
export type Mutation_RootCreateContentGroupRoomArgs = {
  conferenceId: Scalars['uuid'];
  contentGroupId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootCreateRoomDmArgs = {
  attendeeIds: ReadonlyArray<Maybe<Scalars['uuid']>>;
  conferenceId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_AttendeeArgs = {
  where: Attendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_AttendeeGoogleAccountArgs = {
  where: AttendeeGoogleAccount_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_AttendeeGoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_AttendeeProfileArgs = {
  where: AttendeeProfile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_AttendeeProfile_By_PkArgs = {
  attendeeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Attendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_BroadcastArgs = {
  where: Broadcast_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_BroadcastContentItemArgs = {
  where: BroadcastContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_BroadcastContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Broadcast_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ConferenceArgs = {
  where: Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferenceConfigurationArgs = {
  where: ConferenceConfiguration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferenceConfiguration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ConferenceDemoCodeArgs = {
  where: ConferenceDemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferenceDemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ConferencePrepareJobArgs = {
  where: ConferencePrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ConferencePrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Conference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupArgs = {
  where: ContentGroup_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupHallwayArgs = {
  where: ContentGroupHallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupPersonArgs = {
  where: ContentGroupPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupTagArgs = {
  where: ContentGroupTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupTypeArgs = {
  where: ContentGroupType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentGroupType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_ContentGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentItemArgs = {
  where: ContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentPersonArgs = {
  where: ContentPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ContentTypeArgs = {
  where: ContentType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ContentType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_EmailArgs = {
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Email_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventArgs = {
  where: Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventParticipantStreamArgs = {
  where: EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventPersonArgs = {
  where: EventPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventPersonRoleArgs = {
  where: EventPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_EventPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventRoomJoinRequestArgs = {
  where: EventRoomJoinRequest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventTagArgs = {
  where: EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_EventVonageSessionArgs = {
  where: EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_EventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Event_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_ExecutedTransitionsArgs = {
  where: ExecutedTransitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_ExecutedTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_GroupArgs = {
  where: Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_GroupAttendeeArgs = {
  where: GroupAttendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_GroupAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_GroupRoleArgs = {
  where: GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_GroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Group_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_HallwayArgs = {
  where: Hallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Hallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_InputTypeArgs = {
  where: InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_InputType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_InvitationArgs = {
  where: Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Invitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_JobStatusArgs = {
  where: JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_JobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_MediaLiveChannelArgs = {
  where: MediaLiveChannel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_MediaLiveChannel_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_OnlineStatusArgs = {
  where: OnlineStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_OnlineStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_OriginatingDataArgs = {
  where: OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_OriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_PermissionArgs = {
  where: Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Permission_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_PushNotificationSubscriptionArgs = {
  where: PushNotificationSubscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_PushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RequiredContentItemArgs = {
  where: RequiredContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RequiredContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoleArgs = {
  where: Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RolePermissionArgs = {
  where: RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Role_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoomArgs = {
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomModeArgs = {
  where: RoomMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomMode_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RoomParticipantArgs = {
  where: RoomParticipant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomParticipant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoomPersonArgs = {
  where: RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomPersonRoleArgs = {
  where: RoomPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_RoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_RoomPrivacyArgs = {
  where: RoomPrivacy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_RoomPrivacy_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_TagArgs = {
  where: Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_TranscriptionJobArgs = {
  where: TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_TranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_TransitionsArgs = {
  where: Transitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Transitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_UploaderArgs = {
  where: Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Uploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_UserArgs = {
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_User_By_PkArgs = {
  id: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_VideoRenderJobArgs = {
  where: VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_VideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_YouTubeUploadArgs = {
  where: YouTubeUpload_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_YouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_AppStatsArgs = {
  where: Analytics_AppStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentGroupStatsArgs = {
  where: Analytics_ContentGroupStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentGroupStats_By_PkArgs = {
  contentGroupId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentItemStatsArgs = {
  where: Analytics_ContentItemStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_ContentItemStats_By_PkArgs = {
  contentItemId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Analytics_RoomStatsArgs = {
  where: Analytics_RoomStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Analytics_RoomStats_By_PkArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ChatArgs = {
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagArgs = {
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagTypeArgs = {
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageArgs = {
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageTypeArgs = {
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_PinArgs = {
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Pin_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionArgs = {
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionTypeArgs = {
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndexArgs = {
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_ReadUpToIndex_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Chat_SubscriptionArgs = {
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Chat_Subscription_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackCreateJobArgs = {
  where: Job_Queues_ChannelStackCreateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CombineVideosJobArgs = {
  where: Job_Queues_CombineVideosJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CustomEmailJobArgs = {
  where: Job_Queues_CustomEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJobArgs = {
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJobArgs = {
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJobArgs = {
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJobArgs = {
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_UploadYouTubeVideoJobArgs = {
  where: Job_Queues_UploadYouTubeVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Job_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomChimeMeetingArgs = {
  where: Room_RoomChimeMeeting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_RoomChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleAlgorithmArgs = {
  where: Room_ShuffleAlgorithm_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriodArgs = {
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntryArgs = {
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoomArgs = {
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Room_VideoRoomBackendArgs = {
  where: Room_VideoRoomBackend_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Room_VideoRoomBackend_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationArgs = {
  where: System_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationKeyArgs = {
  where: System_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_System_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** mutation root */
export type Mutation_RootDelete_System_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};


/** mutation root */
export type Mutation_RootGetGoogleOAuthUrlArgs = {
  attendeeId: Scalars['uuid'];
  scopes: ReadonlyArray<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootInsert_AttendeeArgs = {
  objects: ReadonlyArray<Attendee_Insert_Input>;
  on_conflict?: Maybe<Attendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AttendeeGoogleAccountArgs = {
  objects: ReadonlyArray<AttendeeGoogleAccount_Insert_Input>;
  on_conflict?: Maybe<AttendeeGoogleAccount_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AttendeeGoogleAccount_OneArgs = {
  object: AttendeeGoogleAccount_Insert_Input;
  on_conflict?: Maybe<AttendeeGoogleAccount_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AttendeeProfileArgs = {
  objects: ReadonlyArray<AttendeeProfile_Insert_Input>;
  on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_AttendeeProfile_OneArgs = {
  object: AttendeeProfile_Insert_Input;
  on_conflict?: Maybe<AttendeeProfile_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Attendee_OneArgs = {
  object: Attendee_Insert_Input;
  on_conflict?: Maybe<Attendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BroadcastArgs = {
  objects: ReadonlyArray<Broadcast_Insert_Input>;
  on_conflict?: Maybe<Broadcast_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BroadcastContentItemArgs = {
  objects: ReadonlyArray<BroadcastContentItem_Insert_Input>;
  on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_BroadcastContentItem_OneArgs = {
  object: BroadcastContentItem_Insert_Input;
  on_conflict?: Maybe<BroadcastContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Broadcast_OneArgs = {
  object: Broadcast_Insert_Input;
  on_conflict?: Maybe<Broadcast_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceArgs = {
  objects: ReadonlyArray<Conference_Insert_Input>;
  on_conflict?: Maybe<Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceConfigurationArgs = {
  objects: ReadonlyArray<ConferenceConfiguration_Insert_Input>;
  on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceConfiguration_OneArgs = {
  object: ConferenceConfiguration_Insert_Input;
  on_conflict?: Maybe<ConferenceConfiguration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceDemoCodeArgs = {
  objects: ReadonlyArray<ConferenceDemoCode_Insert_Input>;
  on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferenceDemoCode_OneArgs = {
  object: ConferenceDemoCode_Insert_Input;
  on_conflict?: Maybe<ConferenceDemoCode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferencePrepareJobArgs = {
  objects: ReadonlyArray<ConferencePrepareJob_Insert_Input>;
  on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ConferencePrepareJob_OneArgs = {
  object: ConferencePrepareJob_Insert_Input;
  on_conflict?: Maybe<ConferencePrepareJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Conference_OneArgs = {
  object: Conference_Insert_Input;
  on_conflict?: Maybe<Conference_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupArgs = {
  objects: ReadonlyArray<ContentGroup_Insert_Input>;
  on_conflict?: Maybe<ContentGroup_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupHallwayArgs = {
  objects: ReadonlyArray<ContentGroupHallway_Insert_Input>;
  on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupHallway_OneArgs = {
  object: ContentGroupHallway_Insert_Input;
  on_conflict?: Maybe<ContentGroupHallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupPersonArgs = {
  objects: ReadonlyArray<ContentGroupPerson_Insert_Input>;
  on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupPerson_OneArgs = {
  object: ContentGroupPerson_Insert_Input;
  on_conflict?: Maybe<ContentGroupPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupTagArgs = {
  objects: ReadonlyArray<ContentGroupTag_Insert_Input>;
  on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupTag_OneArgs = {
  object: ContentGroupTag_Insert_Input;
  on_conflict?: Maybe<ContentGroupTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupTypeArgs = {
  objects: ReadonlyArray<ContentGroupType_Insert_Input>;
  on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroupType_OneArgs = {
  object: ContentGroupType_Insert_Input;
  on_conflict?: Maybe<ContentGroupType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentGroup_OneArgs = {
  object: ContentGroup_Insert_Input;
  on_conflict?: Maybe<ContentGroup_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentItemArgs = {
  objects: ReadonlyArray<ContentItem_Insert_Input>;
  on_conflict?: Maybe<ContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentItem_OneArgs = {
  object: ContentItem_Insert_Input;
  on_conflict?: Maybe<ContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentPersonArgs = {
  objects: ReadonlyArray<ContentPerson_Insert_Input>;
  on_conflict?: Maybe<ContentPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentPerson_OneArgs = {
  object: ContentPerson_Insert_Input;
  on_conflict?: Maybe<ContentPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentTypeArgs = {
  objects: ReadonlyArray<ContentType_Insert_Input>;
  on_conflict?: Maybe<ContentType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ContentType_OneArgs = {
  object: ContentType_Insert_Input;
  on_conflict?: Maybe<ContentType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EmailArgs = {
  objects: ReadonlyArray<Email_Insert_Input>;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Email_OneArgs = {
  object: Email_Insert_Input;
  on_conflict?: Maybe<Email_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventArgs = {
  objects: ReadonlyArray<Event_Insert_Input>;
  on_conflict?: Maybe<Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventParticipantStreamArgs = {
  objects: ReadonlyArray<EventParticipantStream_Insert_Input>;
  on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventParticipantStream_OneArgs = {
  object: EventParticipantStream_Insert_Input;
  on_conflict?: Maybe<EventParticipantStream_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPersonArgs = {
  objects: ReadonlyArray<EventPerson_Insert_Input>;
  on_conflict?: Maybe<EventPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPersonRoleArgs = {
  objects: ReadonlyArray<EventPersonRole_Insert_Input>;
  on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPersonRole_OneArgs = {
  object: EventPersonRole_Insert_Input;
  on_conflict?: Maybe<EventPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventPerson_OneArgs = {
  object: EventPerson_Insert_Input;
  on_conflict?: Maybe<EventPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventRoomJoinRequestArgs = {
  objects: ReadonlyArray<EventRoomJoinRequest_Insert_Input>;
  on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventRoomJoinRequest_OneArgs = {
  object: EventRoomJoinRequest_Insert_Input;
  on_conflict?: Maybe<EventRoomJoinRequest_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventTagArgs = {
  objects: ReadonlyArray<EventTag_Insert_Input>;
  on_conflict?: Maybe<EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventTag_OneArgs = {
  object: EventTag_Insert_Input;
  on_conflict?: Maybe<EventTag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventVonageSessionArgs = {
  objects: ReadonlyArray<EventVonageSession_Insert_Input>;
  on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_EventVonageSession_OneArgs = {
  object: EventVonageSession_Insert_Input;
  on_conflict?: Maybe<EventVonageSession_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Event_OneArgs = {
  object: Event_Insert_Input;
  on_conflict?: Maybe<Event_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ExecutedTransitionsArgs = {
  objects: ReadonlyArray<ExecutedTransitions_Insert_Input>;
  on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_ExecutedTransitions_OneArgs = {
  object: ExecutedTransitions_Insert_Input;
  on_conflict?: Maybe<ExecutedTransitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupArgs = {
  objects: ReadonlyArray<Group_Insert_Input>;
  on_conflict?: Maybe<Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupAttendeeArgs = {
  objects: ReadonlyArray<GroupAttendee_Insert_Input>;
  on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupAttendee_OneArgs = {
  object: GroupAttendee_Insert_Input;
  on_conflict?: Maybe<GroupAttendee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupRoleArgs = {
  objects: ReadonlyArray<GroupRole_Insert_Input>;
  on_conflict?: Maybe<GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_GroupRole_OneArgs = {
  object: GroupRole_Insert_Input;
  on_conflict?: Maybe<GroupRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Group_OneArgs = {
  object: Group_Insert_Input;
  on_conflict?: Maybe<Group_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_HallwayArgs = {
  objects: ReadonlyArray<Hallway_Insert_Input>;
  on_conflict?: Maybe<Hallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Hallway_OneArgs = {
  object: Hallway_Insert_Input;
  on_conflict?: Maybe<Hallway_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InputTypeArgs = {
  objects: ReadonlyArray<InputType_Insert_Input>;
  on_conflict?: Maybe<InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InputType_OneArgs = {
  object: InputType_Insert_Input;
  on_conflict?: Maybe<InputType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_InvitationArgs = {
  objects: ReadonlyArray<Invitation_Insert_Input>;
  on_conflict?: Maybe<Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Invitation_OneArgs = {
  object: Invitation_Insert_Input;
  on_conflict?: Maybe<Invitation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_JobStatusArgs = {
  objects: ReadonlyArray<JobStatus_Insert_Input>;
  on_conflict?: Maybe<JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_JobStatus_OneArgs = {
  object: JobStatus_Insert_Input;
  on_conflict?: Maybe<JobStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MediaLiveChannelArgs = {
  objects: ReadonlyArray<MediaLiveChannel_Insert_Input>;
  on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MediaLiveChannel_OneArgs = {
  object: MediaLiveChannel_Insert_Input;
  on_conflict?: Maybe<MediaLiveChannel_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OnlineStatusArgs = {
  objects: ReadonlyArray<OnlineStatus_Insert_Input>;
  on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OnlineStatus_OneArgs = {
  object: OnlineStatus_Insert_Input;
  on_conflict?: Maybe<OnlineStatus_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OriginatingDataArgs = {
  objects: ReadonlyArray<OriginatingData_Insert_Input>;
  on_conflict?: Maybe<OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_OriginatingData_OneArgs = {
  object: OriginatingData_Insert_Input;
  on_conflict?: Maybe<OriginatingData_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PermissionArgs = {
  objects: ReadonlyArray<Permission_Insert_Input>;
  on_conflict?: Maybe<Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Permission_OneArgs = {
  object: Permission_Insert_Input;
  on_conflict?: Maybe<Permission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PushNotificationSubscriptionArgs = {
  objects: ReadonlyArray<PushNotificationSubscription_Insert_Input>;
  on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_PushNotificationSubscription_OneArgs = {
  object: PushNotificationSubscription_Insert_Input;
  on_conflict?: Maybe<PushNotificationSubscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RequiredContentItemArgs = {
  objects: ReadonlyArray<RequiredContentItem_Insert_Input>;
  on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RequiredContentItem_OneArgs = {
  object: RequiredContentItem_Insert_Input;
  on_conflict?: Maybe<RequiredContentItem_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoleArgs = {
  objects: ReadonlyArray<Role_Insert_Input>;
  on_conflict?: Maybe<Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RolePermissionArgs = {
  objects: ReadonlyArray<RolePermission_Insert_Input>;
  on_conflict?: Maybe<RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RolePermission_OneArgs = {
  object: RolePermission_Insert_Input;
  on_conflict?: Maybe<RolePermission_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Role_OneArgs = {
  object: Role_Insert_Input;
  on_conflict?: Maybe<Role_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomArgs = {
  objects: ReadonlyArray<Room_Insert_Input>;
  on_conflict?: Maybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomModeArgs = {
  objects: ReadonlyArray<RoomMode_Insert_Input>;
  on_conflict?: Maybe<RoomMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomMode_OneArgs = {
  object: RoomMode_Insert_Input;
  on_conflict?: Maybe<RoomMode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomParticipantArgs = {
  objects: ReadonlyArray<RoomParticipant_Insert_Input>;
  on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomParticipant_OneArgs = {
  object: RoomParticipant_Insert_Input;
  on_conflict?: Maybe<RoomParticipant_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPersonArgs = {
  objects: ReadonlyArray<RoomPerson_Insert_Input>;
  on_conflict?: Maybe<RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPersonRoleArgs = {
  objects: ReadonlyArray<RoomPersonRole_Insert_Input>;
  on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPersonRole_OneArgs = {
  object: RoomPersonRole_Insert_Input;
  on_conflict?: Maybe<RoomPersonRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPerson_OneArgs = {
  object: RoomPerson_Insert_Input;
  on_conflict?: Maybe<RoomPerson_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPrivacyArgs = {
  objects: ReadonlyArray<RoomPrivacy_Insert_Input>;
  on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RoomPrivacy_OneArgs = {
  object: RoomPrivacy_Insert_Input;
  on_conflict?: Maybe<RoomPrivacy_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_OneArgs = {
  object: Room_Insert_Input;
  on_conflict?: Maybe<Room_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TagArgs = {
  objects: ReadonlyArray<Tag_Insert_Input>;
  on_conflict?: Maybe<Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tag_OneArgs = {
  object: Tag_Insert_Input;
  on_conflict?: Maybe<Tag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TranscriptionJobArgs = {
  objects: ReadonlyArray<TranscriptionJob_Insert_Input>;
  on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TranscriptionJob_OneArgs = {
  object: TranscriptionJob_Insert_Input;
  on_conflict?: Maybe<TranscriptionJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TransitionsArgs = {
  objects: ReadonlyArray<Transitions_Insert_Input>;
  on_conflict?: Maybe<Transitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Transitions_OneArgs = {
  object: Transitions_Insert_Input;
  on_conflict?: Maybe<Transitions_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UploaderArgs = {
  objects: ReadonlyArray<Uploader_Insert_Input>;
  on_conflict?: Maybe<Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Uploader_OneArgs = {
  object: Uploader_Insert_Input;
  on_conflict?: Maybe<Uploader_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserArgs = {
  objects: ReadonlyArray<User_Insert_Input>;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_User_OneArgs = {
  object: User_Insert_Input;
  on_conflict?: Maybe<User_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VideoRenderJobArgs = {
  objects: ReadonlyArray<VideoRenderJob_Insert_Input>;
  on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_VideoRenderJob_OneArgs = {
  object: VideoRenderJob_Insert_Input;
  on_conflict?: Maybe<VideoRenderJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_YouTubeUploadArgs = {
  objects: ReadonlyArray<YouTubeUpload_Insert_Input>;
  on_conflict?: Maybe<YouTubeUpload_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_YouTubeUpload_OneArgs = {
  object: YouTubeUpload_Insert_Input;
  on_conflict?: Maybe<YouTubeUpload_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_AppStatsArgs = {
  objects: ReadonlyArray<Analytics_AppStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_AppStats_OneArgs = {
  object: Analytics_AppStats_Insert_Input;
  on_conflict?: Maybe<Analytics_AppStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentGroupStatsArgs = {
  objects: ReadonlyArray<Analytics_ContentGroupStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_ContentGroupStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentGroupStats_OneArgs = {
  object: Analytics_ContentGroupStats_Insert_Input;
  on_conflict?: Maybe<Analytics_ContentGroupStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentItemStatsArgs = {
  objects: ReadonlyArray<Analytics_ContentItemStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_ContentItemStats_OneArgs = {
  object: Analytics_ContentItemStats_Insert_Input;
  on_conflict?: Maybe<Analytics_ContentItemStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_RoomStatsArgs = {
  objects: ReadonlyArray<Analytics_RoomStats_Insert_Input>;
  on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Analytics_RoomStats_OneArgs = {
  object: Analytics_RoomStats_Insert_Input;
  on_conflict?: Maybe<Analytics_RoomStats_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ChatArgs = {
  objects: ReadonlyArray<Chat_Chat_Insert_Input>;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Chat_OneArgs = {
  object: Chat_Chat_Insert_Input;
  on_conflict?: Maybe<Chat_Chat_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagArgs = {
  objects: ReadonlyArray<Chat_Flag_Insert_Input>;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagTypeArgs = {
  objects: ReadonlyArray<Chat_FlagType_Insert_Input>;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_FlagType_OneArgs = {
  object: Chat_FlagType_Insert_Input;
  on_conflict?: Maybe<Chat_FlagType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Flag_OneArgs = {
  object: Chat_Flag_Insert_Input;
  on_conflict?: Maybe<Chat_Flag_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageArgs = {
  objects: ReadonlyArray<Chat_Message_Insert_Input>;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageTypeArgs = {
  objects: ReadonlyArray<Chat_MessageType_Insert_Input>;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_MessageType_OneArgs = {
  object: Chat_MessageType_Insert_Input;
  on_conflict?: Maybe<Chat_MessageType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Message_OneArgs = {
  object: Chat_Message_Insert_Input;
  on_conflict?: Maybe<Chat_Message_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_PinArgs = {
  objects: ReadonlyArray<Chat_Pin_Insert_Input>;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Pin_OneArgs = {
  object: Chat_Pin_Insert_Input;
  on_conflict?: Maybe<Chat_Pin_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionArgs = {
  objects: ReadonlyArray<Chat_Reaction_Insert_Input>;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionTypeArgs = {
  objects: ReadonlyArray<Chat_ReactionType_Insert_Input>;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReactionType_OneArgs = {
  object: Chat_ReactionType_Insert_Input;
  on_conflict?: Maybe<Chat_ReactionType_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Reaction_OneArgs = {
  object: Chat_Reaction_Insert_Input;
  on_conflict?: Maybe<Chat_Reaction_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndexArgs = {
  objects: ReadonlyArray<Chat_ReadUpToIndex_Insert_Input>;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_ReadUpToIndex_OneArgs = {
  object: Chat_ReadUpToIndex_Insert_Input;
  on_conflict?: Maybe<Chat_ReadUpToIndex_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_SubscriptionArgs = {
  objects: ReadonlyArray<Chat_Subscription_Insert_Input>;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Chat_Subscription_OneArgs = {
  object: Chat_Subscription_Insert_Input;
  on_conflict?: Maybe<Chat_Subscription_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackCreateJobArgs = {
  objects: ReadonlyArray<Job_Queues_ChannelStackCreateJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_ChannelStackCreateJob_OneArgs = {
  object: Job_Queues_ChannelStackCreateJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_ChannelStackCreateJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CombineVideosJobArgs = {
  objects: ReadonlyArray<Job_Queues_CombineVideosJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CombineVideosJob_OneArgs = {
  object: Job_Queues_CombineVideosJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_CombineVideosJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CustomEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_CustomEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_CustomEmailJob_OneArgs = {
  object: Job_Queues_CustomEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_CustomEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_InvitationEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_InvitationEmailJob_OneArgs = {
  object: Job_Queues_InvitationEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_InvitationEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJobArgs = {
  objects: ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_MediaPackageHarvestJob_OneArgs = {
  object: Job_Queues_MediaPackageHarvestJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_MediaPackageHarvestJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJobArgs = {
  objects: ReadonlyArray<Job_Queues_PublishVideoJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_PublishVideoJob_OneArgs = {
  object: Job_Queues_PublishVideoJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_PublishVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJobArgs = {
  objects: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_SubmissionRequestEmailJob_OneArgs = {
  object: Job_Queues_SubmissionRequestEmailJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_SubmissionRequestEmailJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_UploadYouTubeVideoJobArgs = {
  objects: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input>;
  on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Job_Queues_UploadYouTubeVideoJob_OneArgs = {
  object: Job_Queues_UploadYouTubeVideoJob_Insert_Input;
  on_conflict?: Maybe<Job_Queues_UploadYouTubeVideoJob_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomChimeMeetingArgs = {
  objects: ReadonlyArray<Room_RoomChimeMeeting_Insert_Input>;
  on_conflict?: Maybe<Room_RoomChimeMeeting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_RoomChimeMeeting_OneArgs = {
  object: Room_RoomChimeMeeting_Insert_Input;
  on_conflict?: Maybe<Room_RoomChimeMeeting_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleAlgorithmArgs = {
  objects: ReadonlyArray<Room_ShuffleAlgorithm_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleAlgorithm_OneArgs = {
  object: Room_ShuffleAlgorithm_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriodArgs = {
  objects: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShufflePeriod_OneArgs = {
  object: Room_ShufflePeriod_Insert_Input;
  on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntryArgs = {
  objects: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleQueueEntry_OneArgs = {
  object: Room_ShuffleQueueEntry_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoomArgs = {
  objects: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_ShuffleRoom_OneArgs = {
  object: Room_ShuffleRoom_Insert_Input;
  on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_VideoRoomBackendArgs = {
  objects: ReadonlyArray<Room_VideoRoomBackend_Insert_Input>;
  on_conflict?: Maybe<Room_VideoRoomBackend_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Room_VideoRoomBackend_OneArgs = {
  object: Room_VideoRoomBackend_Insert_Input;
  on_conflict?: Maybe<Room_VideoRoomBackend_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationArgs = {
  objects: ReadonlyArray<System_Configuration_Insert_Input>;
  on_conflict?: Maybe<System_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationKeyArgs = {
  objects: ReadonlyArray<System_ConfigurationKey_Insert_Input>;
  on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_ConfigurationKey_OneArgs = {
  object: System_ConfigurationKey_Insert_Input;
  on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_System_Configuration_OneArgs = {
  object: System_Configuration_Insert_Input;
  on_conflict?: Maybe<System_Configuration_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInvitationConfirmCurrentArgs = {
  inviteCode: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootInvitationConfirmSendInitialEmailArgs = {
  inviteInput: InvitationConfirmationEmailInput;
};


/** mutation root */
export type Mutation_RootInvitationConfirmSendRepeatEmailArgs = {
  inviteInput: InvitationConfirmationEmailInput;
};


/** mutation root */
export type Mutation_RootInvitationConfirmWithCodeArgs = {
  inviteInput: ConfirmInvitationInput;
};


/** mutation root */
export type Mutation_RootJoinEventVonageSessionArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinRoomChimeSessionArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootJoinRoomVonageSessionArgs = {
  roomId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootRefreshYouTubeDataArgs = {
  attendeeGoogleAccountId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootStopEventBroadcastArgs = {
  eventId: Scalars['uuid'];
};


/** mutation root */
export type Mutation_RootSubmitContentItemArgs = {
  data: Scalars['jsonb'];
  magicToken: Scalars['String'];
};


/** mutation root */
export type Mutation_RootSubmitGoogleOAuthCodeArgs = {
  code: Scalars['String'];
  state: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdateProfilePhotoArgs = {
  attendeeId: Scalars['uuid'];
  s3URL?: Maybe<Scalars['String']>;
};


/** mutation root */
export type Mutation_RootUpdateSubtitlesArgs = {
  contentItemId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeArgs = {
  _set?: Maybe<Attendee_Set_Input>;
  where: Attendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeGoogleAccountArgs = {
  _append?: Maybe<AttendeeGoogleAccount_Append_Input>;
  _delete_at_path?: Maybe<AttendeeGoogleAccount_Delete_At_Path_Input>;
  _delete_elem?: Maybe<AttendeeGoogleAccount_Delete_Elem_Input>;
  _delete_key?: Maybe<AttendeeGoogleAccount_Delete_Key_Input>;
  _prepend?: Maybe<AttendeeGoogleAccount_Prepend_Input>;
  _set?: Maybe<AttendeeGoogleAccount_Set_Input>;
  where: AttendeeGoogleAccount_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeGoogleAccount_By_PkArgs = {
  _append?: Maybe<AttendeeGoogleAccount_Append_Input>;
  _delete_at_path?: Maybe<AttendeeGoogleAccount_Delete_At_Path_Input>;
  _delete_elem?: Maybe<AttendeeGoogleAccount_Delete_Elem_Input>;
  _delete_key?: Maybe<AttendeeGoogleAccount_Delete_Key_Input>;
  _prepend?: Maybe<AttendeeGoogleAccount_Prepend_Input>;
  _set?: Maybe<AttendeeGoogleAccount_Set_Input>;
  pk_columns: AttendeeGoogleAccount_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeProfileArgs = {
  _append?: Maybe<AttendeeProfile_Append_Input>;
  _delete_at_path?: Maybe<AttendeeProfile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<AttendeeProfile_Delete_Elem_Input>;
  _delete_key?: Maybe<AttendeeProfile_Delete_Key_Input>;
  _inc?: Maybe<AttendeeProfile_Inc_Input>;
  _prepend?: Maybe<AttendeeProfile_Prepend_Input>;
  _set?: Maybe<AttendeeProfile_Set_Input>;
  where: AttendeeProfile_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_AttendeeProfile_By_PkArgs = {
  _append?: Maybe<AttendeeProfile_Append_Input>;
  _delete_at_path?: Maybe<AttendeeProfile_Delete_At_Path_Input>;
  _delete_elem?: Maybe<AttendeeProfile_Delete_Elem_Input>;
  _delete_key?: Maybe<AttendeeProfile_Delete_Key_Input>;
  _inc?: Maybe<AttendeeProfile_Inc_Input>;
  _prepend?: Maybe<AttendeeProfile_Prepend_Input>;
  _set?: Maybe<AttendeeProfile_Set_Input>;
  pk_columns: AttendeeProfile_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Attendee_By_PkArgs = {
  _set?: Maybe<Attendee_Set_Input>;
  pk_columns: Attendee_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_BroadcastArgs = {
  _append?: Maybe<Broadcast_Append_Input>;
  _delete_at_path?: Maybe<Broadcast_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Broadcast_Delete_Elem_Input>;
  _delete_key?: Maybe<Broadcast_Delete_Key_Input>;
  _prepend?: Maybe<Broadcast_Prepend_Input>;
  _set?: Maybe<Broadcast_Set_Input>;
  where: Broadcast_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_BroadcastContentItemArgs = {
  _append?: Maybe<BroadcastContentItem_Append_Input>;
  _delete_at_path?: Maybe<BroadcastContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<BroadcastContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<BroadcastContentItem_Delete_Key_Input>;
  _prepend?: Maybe<BroadcastContentItem_Prepend_Input>;
  _set?: Maybe<BroadcastContentItem_Set_Input>;
  where: BroadcastContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_BroadcastContentItem_By_PkArgs = {
  _append?: Maybe<BroadcastContentItem_Append_Input>;
  _delete_at_path?: Maybe<BroadcastContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<BroadcastContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<BroadcastContentItem_Delete_Key_Input>;
  _prepend?: Maybe<BroadcastContentItem_Prepend_Input>;
  _set?: Maybe<BroadcastContentItem_Set_Input>;
  pk_columns: BroadcastContentItem_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Broadcast_By_PkArgs = {
  _append?: Maybe<Broadcast_Append_Input>;
  _delete_at_path?: Maybe<Broadcast_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Broadcast_Delete_Elem_Input>;
  _delete_key?: Maybe<Broadcast_Delete_Key_Input>;
  _prepend?: Maybe<Broadcast_Prepend_Input>;
  _set?: Maybe<Broadcast_Set_Input>;
  pk_columns: Broadcast_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceArgs = {
  _set?: Maybe<Conference_Set_Input>;
  where: Conference_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceConfigurationArgs = {
  _append?: Maybe<ConferenceConfiguration_Append_Input>;
  _delete_at_path?: Maybe<ConferenceConfiguration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ConferenceConfiguration_Delete_Elem_Input>;
  _delete_key?: Maybe<ConferenceConfiguration_Delete_Key_Input>;
  _prepend?: Maybe<ConferenceConfiguration_Prepend_Input>;
  _set?: Maybe<ConferenceConfiguration_Set_Input>;
  where: ConferenceConfiguration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceConfiguration_By_PkArgs = {
  _append?: Maybe<ConferenceConfiguration_Append_Input>;
  _delete_at_path?: Maybe<ConferenceConfiguration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ConferenceConfiguration_Delete_Elem_Input>;
  _delete_key?: Maybe<ConferenceConfiguration_Delete_Key_Input>;
  _prepend?: Maybe<ConferenceConfiguration_Prepend_Input>;
  _set?: Maybe<ConferenceConfiguration_Set_Input>;
  pk_columns: ConferenceConfiguration_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceDemoCodeArgs = {
  _set?: Maybe<ConferenceDemoCode_Set_Input>;
  where: ConferenceDemoCode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferenceDemoCode_By_PkArgs = {
  _set?: Maybe<ConferenceDemoCode_Set_Input>;
  pk_columns: ConferenceDemoCode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ConferencePrepareJobArgs = {
  _set?: Maybe<ConferencePrepareJob_Set_Input>;
  where: ConferencePrepareJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ConferencePrepareJob_By_PkArgs = {
  _set?: Maybe<ConferencePrepareJob_Set_Input>;
  pk_columns: ConferencePrepareJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Conference_By_PkArgs = {
  _set?: Maybe<Conference_Set_Input>;
  pk_columns: Conference_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupArgs = {
  _set?: Maybe<ContentGroup_Set_Input>;
  where: ContentGroup_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupHallwayArgs = {
  _append?: Maybe<ContentGroupHallway_Append_Input>;
  _delete_at_path?: Maybe<ContentGroupHallway_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentGroupHallway_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentGroupHallway_Delete_Key_Input>;
  _inc?: Maybe<ContentGroupHallway_Inc_Input>;
  _prepend?: Maybe<ContentGroupHallway_Prepend_Input>;
  _set?: Maybe<ContentGroupHallway_Set_Input>;
  where: ContentGroupHallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupHallway_By_PkArgs = {
  _append?: Maybe<ContentGroupHallway_Append_Input>;
  _delete_at_path?: Maybe<ContentGroupHallway_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentGroupHallway_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentGroupHallway_Delete_Key_Input>;
  _inc?: Maybe<ContentGroupHallway_Inc_Input>;
  _prepend?: Maybe<ContentGroupHallway_Prepend_Input>;
  _set?: Maybe<ContentGroupHallway_Set_Input>;
  pk_columns: ContentGroupHallway_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupPersonArgs = {
  _inc?: Maybe<ContentGroupPerson_Inc_Input>;
  _set?: Maybe<ContentGroupPerson_Set_Input>;
  where: ContentGroupPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupPerson_By_PkArgs = {
  _inc?: Maybe<ContentGroupPerson_Inc_Input>;
  _set?: Maybe<ContentGroupPerson_Set_Input>;
  pk_columns: ContentGroupPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupTagArgs = {
  _set?: Maybe<ContentGroupTag_Set_Input>;
  where: ContentGroupTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupTag_By_PkArgs = {
  _set?: Maybe<ContentGroupTag_Set_Input>;
  pk_columns: ContentGroupTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupTypeArgs = {
  _set?: Maybe<ContentGroupType_Set_Input>;
  where: ContentGroupType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroupType_By_PkArgs = {
  _set?: Maybe<ContentGroupType_Set_Input>;
  pk_columns: ContentGroupType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentGroup_By_PkArgs = {
  _set?: Maybe<ContentGroup_Set_Input>;
  pk_columns: ContentGroup_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentItemArgs = {
  _append?: Maybe<ContentItem_Append_Input>;
  _delete_at_path?: Maybe<ContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentItem_Delete_Key_Input>;
  _prepend?: Maybe<ContentItem_Prepend_Input>;
  _set?: Maybe<ContentItem_Set_Input>;
  where: ContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentItem_By_PkArgs = {
  _append?: Maybe<ContentItem_Append_Input>;
  _delete_at_path?: Maybe<ContentItem_Delete_At_Path_Input>;
  _delete_elem?: Maybe<ContentItem_Delete_Elem_Input>;
  _delete_key?: Maybe<ContentItem_Delete_Key_Input>;
  _prepend?: Maybe<ContentItem_Prepend_Input>;
  _set?: Maybe<ContentItem_Set_Input>;
  pk_columns: ContentItem_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentPersonArgs = {
  _set?: Maybe<ContentPerson_Set_Input>;
  where: ContentPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentPerson_By_PkArgs = {
  _set?: Maybe<ContentPerson_Set_Input>;
  pk_columns: ContentPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ContentTypeArgs = {
  _set?: Maybe<ContentType_Set_Input>;
  where: ContentType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ContentType_By_PkArgs = {
  _set?: Maybe<ContentType_Set_Input>;
  pk_columns: ContentType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EmailArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  where: Email_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Email_By_PkArgs = {
  _inc?: Maybe<Email_Inc_Input>;
  _set?: Maybe<Email_Set_Input>;
  pk_columns: Email_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventArgs = {
  _inc?: Maybe<Event_Inc_Input>;
  _set?: Maybe<Event_Set_Input>;
  where: Event_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventParticipantStreamArgs = {
  _set?: Maybe<EventParticipantStream_Set_Input>;
  where: EventParticipantStream_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventParticipantStream_By_PkArgs = {
  _set?: Maybe<EventParticipantStream_Set_Input>;
  pk_columns: EventParticipantStream_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventPersonArgs = {
  _set?: Maybe<EventPerson_Set_Input>;
  where: EventPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventPersonRoleArgs = {
  _set?: Maybe<EventPersonRole_Set_Input>;
  where: EventPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventPersonRole_By_PkArgs = {
  _set?: Maybe<EventPersonRole_Set_Input>;
  pk_columns: EventPersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventPerson_By_PkArgs = {
  _set?: Maybe<EventPerson_Set_Input>;
  pk_columns: EventPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventRoomJoinRequestArgs = {
  _set?: Maybe<EventRoomJoinRequest_Set_Input>;
  where: EventRoomJoinRequest_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventRoomJoinRequest_By_PkArgs = {
  _set?: Maybe<EventRoomJoinRequest_Set_Input>;
  pk_columns: EventRoomJoinRequest_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventTagArgs = {
  _set?: Maybe<EventTag_Set_Input>;
  where: EventTag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventTag_By_PkArgs = {
  _set?: Maybe<EventTag_Set_Input>;
  pk_columns: EventTag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_EventVonageSessionArgs = {
  _append?: Maybe<EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<EventVonageSession_Prepend_Input>;
  _set?: Maybe<EventVonageSession_Set_Input>;
  where: EventVonageSession_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_EventVonageSession_By_PkArgs = {
  _append?: Maybe<EventVonageSession_Append_Input>;
  _delete_at_path?: Maybe<EventVonageSession_Delete_At_Path_Input>;
  _delete_elem?: Maybe<EventVonageSession_Delete_Elem_Input>;
  _delete_key?: Maybe<EventVonageSession_Delete_Key_Input>;
  _prepend?: Maybe<EventVonageSession_Prepend_Input>;
  _set?: Maybe<EventVonageSession_Set_Input>;
  pk_columns: EventVonageSession_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Event_By_PkArgs = {
  _inc?: Maybe<Event_Inc_Input>;
  _set?: Maybe<Event_Set_Input>;
  pk_columns: Event_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ExecutedTransitionsArgs = {
  _set?: Maybe<ExecutedTransitions_Set_Input>;
  where: ExecutedTransitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_ExecutedTransitions_By_PkArgs = {
  _set?: Maybe<ExecutedTransitions_Set_Input>;
  pk_columns: ExecutedTransitions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_GroupArgs = {
  _set?: Maybe<Group_Set_Input>;
  where: Group_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_GroupAttendeeArgs = {
  _set?: Maybe<GroupAttendee_Set_Input>;
  where: GroupAttendee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_GroupAttendee_By_PkArgs = {
  _set?: Maybe<GroupAttendee_Set_Input>;
  pk_columns: GroupAttendee_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_GroupRoleArgs = {
  _set?: Maybe<GroupRole_Set_Input>;
  where: GroupRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_GroupRole_By_PkArgs = {
  _set?: Maybe<GroupRole_Set_Input>;
  pk_columns: GroupRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Group_By_PkArgs = {
  _set?: Maybe<Group_Set_Input>;
  pk_columns: Group_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_HallwayArgs = {
  _inc?: Maybe<Hallway_Inc_Input>;
  _set?: Maybe<Hallway_Set_Input>;
  where: Hallway_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Hallway_By_PkArgs = {
  _inc?: Maybe<Hallway_Inc_Input>;
  _set?: Maybe<Hallway_Set_Input>;
  pk_columns: Hallway_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_InputTypeArgs = {
  _set?: Maybe<InputType_Set_Input>;
  where: InputType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_InputType_By_PkArgs = {
  _set?: Maybe<InputType_Set_Input>;
  pk_columns: InputType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_InvitationArgs = {
  _set?: Maybe<Invitation_Set_Input>;
  where: Invitation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Invitation_By_PkArgs = {
  _set?: Maybe<Invitation_Set_Input>;
  pk_columns: Invitation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_JobStatusArgs = {
  _set?: Maybe<JobStatus_Set_Input>;
  where: JobStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_JobStatus_By_PkArgs = {
  _set?: Maybe<JobStatus_Set_Input>;
  pk_columns: JobStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_MediaLiveChannelArgs = {
  _set?: Maybe<MediaLiveChannel_Set_Input>;
  where: MediaLiveChannel_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_MediaLiveChannel_By_PkArgs = {
  _set?: Maybe<MediaLiveChannel_Set_Input>;
  pk_columns: MediaLiveChannel_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_OnlineStatusArgs = {
  _set?: Maybe<OnlineStatus_Set_Input>;
  where: OnlineStatus_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_OnlineStatus_By_PkArgs = {
  _set?: Maybe<OnlineStatus_Set_Input>;
  pk_columns: OnlineStatus_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_OriginatingDataArgs = {
  _append?: Maybe<OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<OriginatingData_Prepend_Input>;
  _set?: Maybe<OriginatingData_Set_Input>;
  where: OriginatingData_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_OriginatingData_By_PkArgs = {
  _append?: Maybe<OriginatingData_Append_Input>;
  _delete_at_path?: Maybe<OriginatingData_Delete_At_Path_Input>;
  _delete_elem?: Maybe<OriginatingData_Delete_Elem_Input>;
  _delete_key?: Maybe<OriginatingData_Delete_Key_Input>;
  _prepend?: Maybe<OriginatingData_Prepend_Input>;
  _set?: Maybe<OriginatingData_Set_Input>;
  pk_columns: OriginatingData_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PermissionArgs = {
  _set?: Maybe<Permission_Set_Input>;
  where: Permission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Permission_By_PkArgs = {
  _set?: Maybe<Permission_Set_Input>;
  pk_columns: Permission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_PushNotificationSubscriptionArgs = {
  _set?: Maybe<PushNotificationSubscription_Set_Input>;
  where: PushNotificationSubscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_PushNotificationSubscription_By_PkArgs = {
  _set?: Maybe<PushNotificationSubscription_Set_Input>;
  pk_columns: PushNotificationSubscription_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RequiredContentItemArgs = {
  _inc?: Maybe<RequiredContentItem_Inc_Input>;
  _set?: Maybe<RequiredContentItem_Set_Input>;
  where: RequiredContentItem_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RequiredContentItem_By_PkArgs = {
  _inc?: Maybe<RequiredContentItem_Inc_Input>;
  _set?: Maybe<RequiredContentItem_Set_Input>;
  pk_columns: RequiredContentItem_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoleArgs = {
  _set?: Maybe<Role_Set_Input>;
  where: Role_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RolePermissionArgs = {
  _set?: Maybe<RolePermission_Set_Input>;
  where: RolePermission_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RolePermission_By_PkArgs = {
  _set?: Maybe<RolePermission_Set_Input>;
  pk_columns: RolePermission_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Role_By_PkArgs = {
  _set?: Maybe<Role_Set_Input>;
  pk_columns: Role_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomArgs = {
  _inc?: Maybe<Room_Inc_Input>;
  _set?: Maybe<Room_Set_Input>;
  where: Room_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomModeArgs = {
  _set?: Maybe<RoomMode_Set_Input>;
  where: RoomMode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomMode_By_PkArgs = {
  _set?: Maybe<RoomMode_Set_Input>;
  pk_columns: RoomMode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomParticipantArgs = {
  _set?: Maybe<RoomParticipant_Set_Input>;
  where: RoomParticipant_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomParticipant_By_PkArgs = {
  _set?: Maybe<RoomParticipant_Set_Input>;
  pk_columns: RoomParticipant_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPersonArgs = {
  _set?: Maybe<RoomPerson_Set_Input>;
  where: RoomPerson_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPersonRoleArgs = {
  _set?: Maybe<RoomPersonRole_Set_Input>;
  where: RoomPersonRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPersonRole_By_PkArgs = {
  _set?: Maybe<RoomPersonRole_Set_Input>;
  pk_columns: RoomPersonRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPerson_By_PkArgs = {
  _set?: Maybe<RoomPerson_Set_Input>;
  pk_columns: RoomPerson_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPrivacyArgs = {
  _set?: Maybe<RoomPrivacy_Set_Input>;
  where: RoomPrivacy_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_RoomPrivacy_By_PkArgs = {
  _set?: Maybe<RoomPrivacy_Set_Input>;
  pk_columns: RoomPrivacy_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_By_PkArgs = {
  _inc?: Maybe<Room_Inc_Input>;
  _set?: Maybe<Room_Set_Input>;
  pk_columns: Room_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TagArgs = {
  _inc?: Maybe<Tag_Inc_Input>;
  _set?: Maybe<Tag_Set_Input>;
  where: Tag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tag_By_PkArgs = {
  _inc?: Maybe<Tag_Inc_Input>;
  _set?: Maybe<Tag_Set_Input>;
  pk_columns: Tag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TranscriptionJobArgs = {
  _set?: Maybe<TranscriptionJob_Set_Input>;
  where: TranscriptionJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_TranscriptionJob_By_PkArgs = {
  _set?: Maybe<TranscriptionJob_Set_Input>;
  pk_columns: TranscriptionJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_TransitionsArgs = {
  _set?: Maybe<Transitions_Set_Input>;
  where: Transitions_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Transitions_By_PkArgs = {
  _set?: Maybe<Transitions_Set_Input>;
  pk_columns: Transitions_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UploaderArgs = {
  _inc?: Maybe<Uploader_Inc_Input>;
  _set?: Maybe<Uploader_Set_Input>;
  where: Uploader_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Uploader_By_PkArgs = {
  _inc?: Maybe<Uploader_Inc_Input>;
  _set?: Maybe<Uploader_Set_Input>;
  pk_columns: Uploader_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UserArgs = {
  _set?: Maybe<User_Set_Input>;
  where: User_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_User_By_PkArgs = {
  _set?: Maybe<User_Set_Input>;
  pk_columns: User_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_VideoRenderJobArgs = {
  _append?: Maybe<VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<VideoRenderJob_Prepend_Input>;
  _set?: Maybe<VideoRenderJob_Set_Input>;
  where: VideoRenderJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_VideoRenderJob_By_PkArgs = {
  _append?: Maybe<VideoRenderJob_Append_Input>;
  _delete_at_path?: Maybe<VideoRenderJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<VideoRenderJob_Delete_Elem_Input>;
  _delete_key?: Maybe<VideoRenderJob_Delete_Key_Input>;
  _inc?: Maybe<VideoRenderJob_Inc_Input>;
  _prepend?: Maybe<VideoRenderJob_Prepend_Input>;
  _set?: Maybe<VideoRenderJob_Set_Input>;
  pk_columns: VideoRenderJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_YouTubeUploadArgs = {
  _set?: Maybe<YouTubeUpload_Set_Input>;
  where: YouTubeUpload_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_YouTubeUpload_By_PkArgs = {
  _set?: Maybe<YouTubeUpload_Set_Input>;
  pk_columns: YouTubeUpload_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_AppStatsArgs = {
  _append?: Maybe<Analytics_AppStats_Append_Input>;
  _delete_at_path?: Maybe<Analytics_AppStats_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Analytics_AppStats_Delete_Elem_Input>;
  _delete_key?: Maybe<Analytics_AppStats_Delete_Key_Input>;
  _inc?: Maybe<Analytics_AppStats_Inc_Input>;
  _prepend?: Maybe<Analytics_AppStats_Prepend_Input>;
  _set?: Maybe<Analytics_AppStats_Set_Input>;
  where: Analytics_AppStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_AppStats_By_PkArgs = {
  _append?: Maybe<Analytics_AppStats_Append_Input>;
  _delete_at_path?: Maybe<Analytics_AppStats_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Analytics_AppStats_Delete_Elem_Input>;
  _delete_key?: Maybe<Analytics_AppStats_Delete_Key_Input>;
  _inc?: Maybe<Analytics_AppStats_Inc_Input>;
  _prepend?: Maybe<Analytics_AppStats_Prepend_Input>;
  _set?: Maybe<Analytics_AppStats_Set_Input>;
  pk_columns: Analytics_AppStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentGroupStatsArgs = {
  _inc?: Maybe<Analytics_ContentGroupStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentGroupStats_Set_Input>;
  where: Analytics_ContentGroupStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentGroupStats_By_PkArgs = {
  _inc?: Maybe<Analytics_ContentGroupStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentGroupStats_Set_Input>;
  pk_columns: Analytics_ContentGroupStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentItemStatsArgs = {
  _inc?: Maybe<Analytics_ContentItemStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentItemStats_Set_Input>;
  where: Analytics_ContentItemStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_ContentItemStats_By_PkArgs = {
  _inc?: Maybe<Analytics_ContentItemStats_Inc_Input>;
  _set?: Maybe<Analytics_ContentItemStats_Set_Input>;
  pk_columns: Analytics_ContentItemStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_RoomStatsArgs = {
  _inc?: Maybe<Analytics_RoomStats_Inc_Input>;
  _set?: Maybe<Analytics_RoomStats_Set_Input>;
  where: Analytics_RoomStats_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Analytics_RoomStats_By_PkArgs = {
  _inc?: Maybe<Analytics_RoomStats_Inc_Input>;
  _set?: Maybe<Analytics_RoomStats_Set_Input>;
  pk_columns: Analytics_RoomStats_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ChatArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  where: Chat_Chat_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Chat_By_PkArgs = {
  _set?: Maybe<Chat_Chat_Set_Input>;
  pk_columns: Chat_Chat_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  where: Chat_Flag_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagTypeArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  where: Chat_FlagType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_FlagType_By_PkArgs = {
  _set?: Maybe<Chat_FlagType_Set_Input>;
  pk_columns: Chat_FlagType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Flag_By_PkArgs = {
  _inc?: Maybe<Chat_Flag_Inc_Input>;
  _set?: Maybe<Chat_Flag_Set_Input>;
  pk_columns: Chat_Flag_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  where: Chat_Message_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageTypeArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  where: Chat_MessageType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_MessageType_By_PkArgs = {
  _set?: Maybe<Chat_MessageType_Set_Input>;
  pk_columns: Chat_MessageType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Message_By_PkArgs = {
  _append?: Maybe<Chat_Message_Append_Input>;
  _delete_at_path?: Maybe<Chat_Message_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Message_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Message_Delete_Key_Input>;
  _inc?: Maybe<Chat_Message_Inc_Input>;
  _prepend?: Maybe<Chat_Message_Prepend_Input>;
  _set?: Maybe<Chat_Message_Set_Input>;
  pk_columns: Chat_Message_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_PinArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  where: Chat_Pin_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Pin_By_PkArgs = {
  _set?: Maybe<Chat_Pin_Set_Input>;
  pk_columns: Chat_Pin_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  where: Chat_Reaction_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionTypeArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  where: Chat_ReactionType_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReactionType_By_PkArgs = {
  _set?: Maybe<Chat_ReactionType_Set_Input>;
  pk_columns: Chat_ReactionType_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Reaction_By_PkArgs = {
  _append?: Maybe<Chat_Reaction_Append_Input>;
  _delete_at_path?: Maybe<Chat_Reaction_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Chat_Reaction_Delete_Elem_Input>;
  _delete_key?: Maybe<Chat_Reaction_Delete_Key_Input>;
  _prepend?: Maybe<Chat_Reaction_Prepend_Input>;
  _set?: Maybe<Chat_Reaction_Set_Input>;
  pk_columns: Chat_Reaction_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndexArgs = {
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  where: Chat_ReadUpToIndex_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_ReadUpToIndex_By_PkArgs = {
  _set?: Maybe<Chat_ReadUpToIndex_Set_Input>;
  pk_columns: Chat_ReadUpToIndex_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_SubscriptionArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  where: Chat_Subscription_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Chat_Subscription_By_PkArgs = {
  _set?: Maybe<Chat_Subscription_Set_Input>;
  pk_columns: Chat_Subscription_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackCreateJobArgs = {
  _set?: Maybe<Job_Queues_ChannelStackCreateJob_Set_Input>;
  where: Job_Queues_ChannelStackCreateJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_ChannelStackCreateJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_ChannelStackCreateJob_Set_Input>;
  pk_columns: Job_Queues_ChannelStackCreateJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CombineVideosJobArgs = {
  _append?: Maybe<Job_Queues_CombineVideosJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CombineVideosJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CombineVideosJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CombineVideosJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CombineVideosJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CombineVideosJob_Set_Input>;
  where: Job_Queues_CombineVideosJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CombineVideosJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_CombineVideosJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CombineVideosJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CombineVideosJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CombineVideosJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CombineVideosJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CombineVideosJob_Set_Input>;
  pk_columns: Job_Queues_CombineVideosJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CustomEmailJobArgs = {
  _append?: Maybe<Job_Queues_CustomEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CustomEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CustomEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CustomEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CustomEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CustomEmailJob_Set_Input>;
  where: Job_Queues_CustomEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_CustomEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_CustomEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_CustomEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_CustomEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_CustomEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_CustomEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_CustomEmailJob_Set_Input>;
  pk_columns: Job_Queues_CustomEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJobArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  where: Job_Queues_InvitationEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_InvitationEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_InvitationEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_InvitationEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_InvitationEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_InvitationEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_InvitationEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_InvitationEmailJob_Set_Input>;
  pk_columns: Job_Queues_InvitationEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJobArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  where: Job_Queues_MediaPackageHarvestJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_MediaPackageHarvestJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_MediaPackageHarvestJob_Set_Input>;
  pk_columns: Job_Queues_MediaPackageHarvestJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJobArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  where: Job_Queues_PublishVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_PublishVideoJob_By_PkArgs = {
  _set?: Maybe<Job_Queues_PublishVideoJob_Set_Input>;
  pk_columns: Job_Queues_PublishVideoJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJobArgs = {
  _append?: Maybe<Job_Queues_SubmissionRequestEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_SubmissionRequestEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  where: Job_Queues_SubmissionRequestEmailJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  _append?: Maybe<Job_Queues_SubmissionRequestEmailJob_Append_Input>;
  _delete_at_path?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Elem_Input>;
  _delete_key?: Maybe<Job_Queues_SubmissionRequestEmailJob_Delete_Key_Input>;
  _prepend?: Maybe<Job_Queues_SubmissionRequestEmailJob_Prepend_Input>;
  _set?: Maybe<Job_Queues_SubmissionRequestEmailJob_Set_Input>;
  pk_columns: Job_Queues_SubmissionRequestEmailJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_UploadYouTubeVideoJobArgs = {
  _inc?: Maybe<Job_Queues_UploadYouTubeVideoJob_Inc_Input>;
  _set?: Maybe<Job_Queues_UploadYouTubeVideoJob_Set_Input>;
  where: Job_Queues_UploadYouTubeVideoJob_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Job_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  _inc?: Maybe<Job_Queues_UploadYouTubeVideoJob_Inc_Input>;
  _set?: Maybe<Job_Queues_UploadYouTubeVideoJob_Set_Input>;
  pk_columns: Job_Queues_UploadYouTubeVideoJob_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomChimeMeetingArgs = {
  _append?: Maybe<Room_RoomChimeMeeting_Append_Input>;
  _delete_at_path?: Maybe<Room_RoomChimeMeeting_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Room_RoomChimeMeeting_Delete_Elem_Input>;
  _delete_key?: Maybe<Room_RoomChimeMeeting_Delete_Key_Input>;
  _prepend?: Maybe<Room_RoomChimeMeeting_Prepend_Input>;
  _set?: Maybe<Room_RoomChimeMeeting_Set_Input>;
  where: Room_RoomChimeMeeting_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_RoomChimeMeeting_By_PkArgs = {
  _append?: Maybe<Room_RoomChimeMeeting_Append_Input>;
  _delete_at_path?: Maybe<Room_RoomChimeMeeting_Delete_At_Path_Input>;
  _delete_elem?: Maybe<Room_RoomChimeMeeting_Delete_Elem_Input>;
  _delete_key?: Maybe<Room_RoomChimeMeeting_Delete_Key_Input>;
  _prepend?: Maybe<Room_RoomChimeMeeting_Prepend_Input>;
  _set?: Maybe<Room_RoomChimeMeeting_Set_Input>;
  pk_columns: Room_RoomChimeMeeting_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleAlgorithmArgs = {
  _set?: Maybe<Room_ShuffleAlgorithm_Set_Input>;
  where: Room_ShuffleAlgorithm_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleAlgorithm_By_PkArgs = {
  _set?: Maybe<Room_ShuffleAlgorithm_Set_Input>;
  pk_columns: Room_ShuffleAlgorithm_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriodArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  where: Room_ShufflePeriod_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShufflePeriod_By_PkArgs = {
  _inc?: Maybe<Room_ShufflePeriod_Inc_Input>;
  _set?: Maybe<Room_ShufflePeriod_Set_Input>;
  pk_columns: Room_ShufflePeriod_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntryArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  where: Room_ShuffleQueueEntry_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleQueueEntry_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleQueueEntry_Inc_Input>;
  _set?: Maybe<Room_ShuffleQueueEntry_Set_Input>;
  pk_columns: Room_ShuffleQueueEntry_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoomArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  where: Room_ShuffleRoom_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_ShuffleRoom_By_PkArgs = {
  _inc?: Maybe<Room_ShuffleRoom_Inc_Input>;
  _set?: Maybe<Room_ShuffleRoom_Set_Input>;
  pk_columns: Room_ShuffleRoom_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Room_VideoRoomBackendArgs = {
  _set?: Maybe<Room_VideoRoomBackend_Set_Input>;
  where: Room_VideoRoomBackend_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Room_VideoRoomBackend_By_PkArgs = {
  _set?: Maybe<Room_VideoRoomBackend_Set_Input>;
  pk_columns: Room_VideoRoomBackend_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationArgs = {
  _append?: Maybe<System_Configuration_Append_Input>;
  _delete_at_path?: Maybe<System_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<System_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<System_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<System_Configuration_Prepend_Input>;
  _set?: Maybe<System_Configuration_Set_Input>;
  where: System_Configuration_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationKeyArgs = {
  _set?: Maybe<System_ConfigurationKey_Set_Input>;
  where: System_ConfigurationKey_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_System_ConfigurationKey_By_PkArgs = {
  _set?: Maybe<System_ConfigurationKey_Set_Input>;
  pk_columns: System_ConfigurationKey_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_System_Configuration_By_PkArgs = {
  _append?: Maybe<System_Configuration_Append_Input>;
  _delete_at_path?: Maybe<System_Configuration_Delete_At_Path_Input>;
  _delete_elem?: Maybe<System_Configuration_Delete_Elem_Input>;
  _delete_key?: Maybe<System_Configuration_Delete_Key_Input>;
  _prepend?: Maybe<System_Configuration_Prepend_Input>;
  _set?: Maybe<System_Configuration_Set_Input>;
  pk_columns: System_Configuration_Pk_Columns_Input;
};

/** column ordering options */
export enum Order_By {
  /** in the ascending order, nulls last */
  Asc = 'asc',
  /** in the ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in the ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in the descending order, nulls first */
  Desc = 'desc',
  /** in the descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in the descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

/** query root */
export type Query_Root = {
  readonly __typename?: 'query_root';
  /** fetch data from the table: "Attendee" */
  readonly Attendee: ReadonlyArray<Attendee>;
  /** fetch data from the table: "AttendeeGoogleAccount" */
  readonly AttendeeGoogleAccount: ReadonlyArray<AttendeeGoogleAccount>;
  /** fetch aggregated fields from the table: "AttendeeGoogleAccount" */
  readonly AttendeeGoogleAccount_aggregate: AttendeeGoogleAccount_Aggregate;
  /** fetch data from the table: "AttendeeGoogleAccount" using primary key columns */
  readonly AttendeeGoogleAccount_by_pk?: Maybe<AttendeeGoogleAccount>;
  /** fetch data from the table: "AttendeeProfile" */
  readonly AttendeeProfile: ReadonlyArray<AttendeeProfile>;
  /** fetch data from the table: "AttendeeProfileBadges" */
  readonly AttendeeProfileBadges: ReadonlyArray<AttendeeProfileBadges>;
  /** fetch aggregated fields from the table: "AttendeeProfileBadges" */
  readonly AttendeeProfileBadges_aggregate: AttendeeProfileBadges_Aggregate;
  /** fetch aggregated fields from the table: "AttendeeProfile" */
  readonly AttendeeProfile_aggregate: AttendeeProfile_Aggregate;
  /** fetch data from the table: "AttendeeProfile" using primary key columns */
  readonly AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** fetch aggregated fields from the table: "Attendee" */
  readonly Attendee_aggregate: Attendee_Aggregate;
  /** fetch data from the table: "Attendee" using primary key columns */
  readonly Attendee_by_pk?: Maybe<Attendee>;
  /** fetch data from the table: "Broadcast" */
  readonly Broadcast: ReadonlyArray<Broadcast>;
  /** fetch data from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem: ReadonlyArray<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem_aggregate: BroadcastContentItem_Aggregate;
  /** fetch data from the table: "BroadcastContentItem" using primary key columns */
  readonly BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "Broadcast" */
  readonly Broadcast_aggregate: Broadcast_Aggregate;
  /** fetch data from the table: "Broadcast" using primary key columns */
  readonly Broadcast_by_pk?: Maybe<Broadcast>;
  /** fetch data from the table: "Conference" */
  readonly Conference: ReadonlyArray<Conference>;
  /** fetch data from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration: ReadonlyArray<ConferenceConfiguration>;
  /** fetch aggregated fields from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration_aggregate: ConferenceConfiguration_Aggregate;
  /** fetch data from the table: "ConferenceConfiguration" using primary key columns */
  readonly ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** fetch data from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode: ReadonlyArray<ConferenceDemoCode>;
  /** fetch aggregated fields from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode_aggregate: ConferenceDemoCode_Aggregate;
  /** fetch data from the table: "ConferenceDemoCode" using primary key columns */
  readonly ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** fetch data from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob: ReadonlyArray<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob_aggregate: ConferencePrepareJob_Aggregate;
  /** fetch data from the table: "ConferencePrepareJob" using primary key columns */
  readonly ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "Conference" */
  readonly Conference_aggregate: Conference_Aggregate;
  /** fetch data from the table: "Conference" using primary key columns */
  readonly Conference_by_pk?: Maybe<Conference>;
  /** fetch data from the table: "ContentGroup" */
  readonly ContentGroup: ReadonlyArray<ContentGroup>;
  /** fetch data from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway: ReadonlyArray<ContentGroupHallway>;
  /** fetch aggregated fields from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway_aggregate: ContentGroupHallway_Aggregate;
  /** fetch data from the table: "ContentGroupHallway" using primary key columns */
  readonly ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** fetch data from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson: ReadonlyArray<ContentGroupPerson>;
  /** fetch aggregated fields from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson_aggregate: ContentGroupPerson_Aggregate;
  /** fetch data from the table: "ContentGroupPerson" using primary key columns */
  readonly ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** fetch data from the table: "ContentGroupTag" */
  readonly ContentGroupTag: ReadonlyArray<ContentGroupTag>;
  /** fetch aggregated fields from the table: "ContentGroupTag" */
  readonly ContentGroupTag_aggregate: ContentGroupTag_Aggregate;
  /** fetch data from the table: "ContentGroupTag" using primary key columns */
  readonly ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** fetch data from the table: "ContentGroupType" */
  readonly ContentGroupType: ReadonlyArray<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroupType" */
  readonly ContentGroupType_aggregate: ContentGroupType_Aggregate;
  /** fetch data from the table: "ContentGroupType" using primary key columns */
  readonly ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroup" */
  readonly ContentGroup_aggregate: ContentGroup_Aggregate;
  /** fetch data from the table: "ContentGroup" using primary key columns */
  readonly ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** fetch data from the table: "ContentItem" */
  readonly ContentItem: ReadonlyArray<ContentItem>;
  /** fetch aggregated fields from the table: "ContentItem" */
  readonly ContentItem_aggregate: ContentItem_Aggregate;
  /** fetch data from the table: "ContentItem" using primary key columns */
  readonly ContentItem_by_pk?: Maybe<ContentItem>;
  /** fetch data from the table: "ContentPerson" */
  readonly ContentPerson: ReadonlyArray<ContentPerson>;
  /** fetch aggregated fields from the table: "ContentPerson" */
  readonly ContentPerson_aggregate: ContentPerson_Aggregate;
  /** fetch data from the table: "ContentPerson" using primary key columns */
  readonly ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** fetch data from the table: "ContentType" */
  readonly ContentType: ReadonlyArray<ContentType>;
  /** fetch aggregated fields from the table: "ContentType" */
  readonly ContentType_aggregate: ContentType_Aggregate;
  /** fetch data from the table: "ContentType" using primary key columns */
  readonly ContentType_by_pk?: Maybe<ContentType>;
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "Event" */
  readonly Event: ReadonlyArray<Event>;
  /** fetch data from the table: "EventParticipantStream" */
  readonly EventParticipantStream: ReadonlyArray<EventParticipantStream>;
  /** fetch aggregated fields from the table: "EventParticipantStream" */
  readonly EventParticipantStream_aggregate: EventParticipantStream_Aggregate;
  /** fetch data from the table: "EventParticipantStream" using primary key columns */
  readonly EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** fetch data from the table: "EventPerson" */
  readonly EventPerson: ReadonlyArray<EventPerson>;
  /** fetch data from the table: "EventPersonRole" */
  readonly EventPersonRole: ReadonlyArray<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPersonRole" */
  readonly EventPersonRole_aggregate: EventPersonRole_Aggregate;
  /** fetch data from the table: "EventPersonRole" using primary key columns */
  readonly EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPerson" */
  readonly EventPerson_aggregate: EventPerson_Aggregate;
  /** fetch data from the table: "EventPerson" using primary key columns */
  readonly EventPerson_by_pk?: Maybe<EventPerson>;
  /** fetch data from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest: ReadonlyArray<EventRoomJoinRequest>;
  /** fetch aggregated fields from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest_aggregate: EventRoomJoinRequest_Aggregate;
  /** fetch data from the table: "EventRoomJoinRequest" using primary key columns */
  readonly EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** fetch data from the table: "EventTag" */
  readonly EventTag: ReadonlyArray<EventTag>;
  /** fetch aggregated fields from the table: "EventTag" */
  readonly EventTag_aggregate: EventTag_Aggregate;
  /** fetch data from the table: "EventTag" using primary key columns */
  readonly EventTag_by_pk?: Maybe<EventTag>;
  /** fetch data from the table: "EventVonageSession" */
  readonly EventVonageSession: ReadonlyArray<EventVonageSession>;
  /** fetch aggregated fields from the table: "EventVonageSession" */
  readonly EventVonageSession_aggregate: EventVonageSession_Aggregate;
  /** fetch data from the table: "EventVonageSession" using primary key columns */
  readonly EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** fetch aggregated fields from the table: "Event" */
  readonly Event_aggregate: Event_Aggregate;
  /** fetch data from the table: "Event" using primary key columns */
  readonly Event_by_pk?: Maybe<Event>;
  /** fetch data from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** fetch aggregated fields from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions_aggregate: ExecutedTransitions_Aggregate;
  /** fetch data from the table: "ExecutedTransitions" using primary key columns */
  readonly ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "Group" */
  readonly Group: ReadonlyArray<Group>;
  /** fetch data from the table: "GroupAttendee" */
  readonly GroupAttendee: ReadonlyArray<GroupAttendee>;
  /** fetch aggregated fields from the table: "GroupAttendee" */
  readonly GroupAttendee_aggregate: GroupAttendee_Aggregate;
  /** fetch data from the table: "GroupAttendee" using primary key columns */
  readonly GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** fetch data from the table: "GroupRole" */
  readonly GroupRole: ReadonlyArray<GroupRole>;
  /** fetch aggregated fields from the table: "GroupRole" */
  readonly GroupRole_aggregate: GroupRole_Aggregate;
  /** fetch data from the table: "GroupRole" using primary key columns */
  readonly GroupRole_by_pk?: Maybe<GroupRole>;
  /** fetch aggregated fields from the table: "Group" */
  readonly Group_aggregate: Group_Aggregate;
  /** fetch data from the table: "Group" using primary key columns */
  readonly Group_by_pk?: Maybe<Group>;
  /** fetch data from the table: "Hallway" */
  readonly Hallway: ReadonlyArray<Hallway>;
  /** fetch aggregated fields from the table: "Hallway" */
  readonly Hallway_aggregate: Hallway_Aggregate;
  /** fetch data from the table: "Hallway" using primary key columns */
  readonly Hallway_by_pk?: Maybe<Hallway>;
  /** fetch data from the table: "InputType" */
  readonly InputType: ReadonlyArray<InputType>;
  /** fetch aggregated fields from the table: "InputType" */
  readonly InputType_aggregate: InputType_Aggregate;
  /** fetch data from the table: "InputType" using primary key columns */
  readonly InputType_by_pk?: Maybe<InputType>;
  /** fetch data from the table: "Invitation" */
  readonly Invitation: ReadonlyArray<Invitation>;
  /** fetch aggregated fields from the table: "Invitation" */
  readonly Invitation_aggregate: Invitation_Aggregate;
  /** fetch data from the table: "Invitation" using primary key columns */
  readonly Invitation_by_pk?: Maybe<Invitation>;
  /** fetch data from the table: "JobStatus" */
  readonly JobStatus: ReadonlyArray<JobStatus>;
  /** fetch aggregated fields from the table: "JobStatus" */
  readonly JobStatus_aggregate: JobStatus_Aggregate;
  /** fetch data from the table: "JobStatus" using primary key columns */
  readonly JobStatus_by_pk?: Maybe<JobStatus>;
  /** fetch data from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel: ReadonlyArray<MediaLiveChannel>;
  /** fetch aggregated fields from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel_aggregate: MediaLiveChannel_Aggregate;
  /** fetch data from the table: "MediaLiveChannel" using primary key columns */
  readonly MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** fetch data from the table: "OnlineStatus" */
  readonly OnlineStatus: ReadonlyArray<OnlineStatus>;
  /** fetch aggregated fields from the table: "OnlineStatus" */
  readonly OnlineStatus_aggregate: OnlineStatus_Aggregate;
  /** fetch data from the table: "OnlineStatus" using primary key columns */
  readonly OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** fetch data from the table: "OriginatingData" */
  readonly OriginatingData: ReadonlyArray<OriginatingData>;
  /** fetch aggregated fields from the table: "OriginatingData" */
  readonly OriginatingData_aggregate: OriginatingData_Aggregate;
  /** fetch data from the table: "OriginatingData" using primary key columns */
  readonly OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** fetch data from the table: "Permission" */
  readonly Permission: ReadonlyArray<Permission>;
  /** fetch aggregated fields from the table: "Permission" */
  readonly Permission_aggregate: Permission_Aggregate;
  /** fetch data from the table: "Permission" using primary key columns */
  readonly Permission_by_pk?: Maybe<Permission>;
  /** fetch data from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription: ReadonlyArray<PushNotificationSubscription>;
  /** fetch aggregated fields from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription_aggregate: PushNotificationSubscription_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" using primary key columns */
  readonly PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** fetch data from the table: "RequiredContentItem" */
  readonly RequiredContentItem: ReadonlyArray<RequiredContentItem>;
  /** fetch aggregated fields from the table: "RequiredContentItem" */
  readonly RequiredContentItem_aggregate: RequiredContentItem_Aggregate;
  /** fetch data from the table: "RequiredContentItem" using primary key columns */
  readonly RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** fetch data from the table: "Role" */
  readonly Role: ReadonlyArray<Role>;
  /** fetch data from the table: "RolePermission" */
  readonly RolePermission: ReadonlyArray<RolePermission>;
  /** fetch aggregated fields from the table: "RolePermission" */
  readonly RolePermission_aggregate: RolePermission_Aggregate;
  /** fetch data from the table: "RolePermission" using primary key columns */
  readonly RolePermission_by_pk?: Maybe<RolePermission>;
  /** fetch aggregated fields from the table: "Role" */
  readonly Role_aggregate: Role_Aggregate;
  /** fetch data from the table: "Role" using primary key columns */
  readonly Role_by_pk?: Maybe<Role>;
  /** fetch data from the table: "Room" */
  readonly Room: ReadonlyArray<Room>;
  /** fetch data from the table: "RoomMode" */
  readonly RoomMode: ReadonlyArray<RoomMode>;
  /** fetch aggregated fields from the table: "RoomMode" */
  readonly RoomMode_aggregate: RoomMode_Aggregate;
  /** fetch data from the table: "RoomMode" using primary key columns */
  readonly RoomMode_by_pk?: Maybe<RoomMode>;
  /** fetch data from the table: "RoomParticipant" */
  readonly RoomParticipant: ReadonlyArray<RoomParticipant>;
  /** fetch aggregated fields from the table: "RoomParticipant" */
  readonly RoomParticipant_aggregate: RoomParticipant_Aggregate;
  /** fetch data from the table: "RoomParticipant" using primary key columns */
  readonly RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** fetch data from the table: "RoomPerson" */
  readonly RoomPerson: ReadonlyArray<RoomPerson>;
  /** fetch data from the table: "RoomPersonRole" */
  readonly RoomPersonRole: ReadonlyArray<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPersonRole" */
  readonly RoomPersonRole_aggregate: RoomPersonRole_Aggregate;
  /** fetch data from the table: "RoomPersonRole" using primary key columns */
  readonly RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPerson" */
  readonly RoomPerson_aggregate: RoomPerson_Aggregate;
  /** fetch data from the table: "RoomPerson" using primary key columns */
  readonly RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** fetch data from the table: "RoomPrivacy" */
  readonly RoomPrivacy: ReadonlyArray<RoomPrivacy>;
  /** fetch aggregated fields from the table: "RoomPrivacy" */
  readonly RoomPrivacy_aggregate: RoomPrivacy_Aggregate;
  /** fetch data from the table: "RoomPrivacy" using primary key columns */
  readonly RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** fetch aggregated fields from the table: "Room" */
  readonly Room_aggregate: Room_Aggregate;
  /** fetch data from the table: "Room" using primary key columns */
  readonly Room_by_pk?: Maybe<Room>;
  /** fetch data from the table: "Tag" */
  readonly Tag: ReadonlyArray<Tag>;
  /** fetch aggregated fields from the table: "Tag" */
  readonly Tag_aggregate: Tag_Aggregate;
  /** fetch data from the table: "Tag" using primary key columns */
  readonly Tag_by_pk?: Maybe<Tag>;
  /** fetch data from the table: "TranscriptionJob" */
  readonly TranscriptionJob: ReadonlyArray<TranscriptionJob>;
  /** fetch aggregated fields from the table: "TranscriptionJob" */
  readonly TranscriptionJob_aggregate: TranscriptionJob_Aggregate;
  /** fetch data from the table: "TranscriptionJob" using primary key columns */
  readonly TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** fetch data from the table: "Transitions" */
  readonly Transitions: ReadonlyArray<Transitions>;
  /** fetch aggregated fields from the table: "Transitions" */
  readonly Transitions_aggregate: Transitions_Aggregate;
  /** fetch data from the table: "Transitions" using primary key columns */
  readonly Transitions_by_pk?: Maybe<Transitions>;
  /** fetch data from the table: "Uploader" */
  readonly Uploader: ReadonlyArray<Uploader>;
  /** fetch aggregated fields from the table: "Uploader" */
  readonly Uploader_aggregate: Uploader_Aggregate;
  /** fetch data from the table: "Uploader" using primary key columns */
  readonly Uploader_by_pk?: Maybe<Uploader>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "VideoRenderJob" */
  readonly VideoRenderJob: ReadonlyArray<VideoRenderJob>;
  /** fetch aggregated fields from the table: "VideoRenderJob" */
  readonly VideoRenderJob_aggregate: VideoRenderJob_Aggregate;
  /** fetch data from the table: "VideoRenderJob" using primary key columns */
  readonly VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** fetch data from the table: "YouTubeUpload" */
  readonly YouTubeUpload: ReadonlyArray<YouTubeUpload>;
  /** fetch aggregated fields from the table: "YouTubeUpload" */
  readonly YouTubeUpload_aggregate: YouTubeUpload_Aggregate;
  /** fetch data from the table: "YouTubeUpload" using primary key columns */
  readonly YouTubeUpload_by_pk?: Maybe<YouTubeUpload>;
  /** fetch data from the table: "analytics.AppStats" */
  readonly analytics_AppStats: ReadonlyArray<Analytics_AppStats>;
  /** fetch aggregated fields from the table: "analytics.AppStats" */
  readonly analytics_AppStats_aggregate: Analytics_AppStats_Aggregate;
  /** fetch data from the table: "analytics.AppStats" using primary key columns */
  readonly analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** fetch data from the table: "analytics.ContentGroupStats" */
  readonly analytics_ContentGroupStats: ReadonlyArray<Analytics_ContentGroupStats>;
  /** fetch aggregated fields from the table: "analytics.ContentGroupStats" */
  readonly analytics_ContentGroupStats_aggregate: Analytics_ContentGroupStats_Aggregate;
  /** fetch data from the table: "analytics.ContentGroupStats" using primary key columns */
  readonly analytics_ContentGroupStats_by_pk?: Maybe<Analytics_ContentGroupStats>;
  /** fetch data from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats: ReadonlyArray<Analytics_ContentItemStats>;
  /** fetch aggregated fields from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats_aggregate: Analytics_ContentItemStats_Aggregate;
  /** fetch data from the table: "analytics.ContentItemStats" using primary key columns */
  readonly analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** fetch data from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats: ReadonlyArray<Analytics_RoomStats>;
  /** fetch aggregated fields from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats_aggregate: Analytics_RoomStats_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" using primary key columns */
  readonly analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** perform the action: "echo" */
  readonly echo?: Maybe<EchoOutput>;
  /** perform the action: "getContentItem" */
  readonly getContentItem?: Maybe<ReadonlyArray<Maybe<GetContentItemOutput>>>;
  /** perform the action: "getUploadAgreement" */
  readonly getUploadAgreement?: Maybe<GetUploadAgreementOutput>;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" using primary key columns */
  readonly job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** fetch data from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob: ReadonlyArray<Job_Queues_CombineVideosJob>;
  /** fetch aggregated fields from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob_aggregate: Job_Queues_CombineVideosJob_Aggregate;
  /** fetch data from the table: "job_queues.CombineVideosJob" using primary key columns */
  readonly job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** fetch data from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob: ReadonlyArray<Job_Queues_CustomEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob_aggregate: Job_Queues_CustomEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.CustomEmailJob" using primary key columns */
  readonly job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob_aggregate: Job_Queues_UploadYouTubeVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" using primary key columns */
  readonly job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** perform the action: "presence_Summary" */
  readonly presence_Summary?: Maybe<PresenceSummaryOutput>;
  /** perform the action: "protectedEcho" */
  readonly protectedEcho?: Maybe<ProtectedEchoOutput>;
  /** fetch data from the table: "room.RoomChimeMeeting" */
  readonly room_RoomChimeMeeting: ReadonlyArray<Room_RoomChimeMeeting>;
  /** fetch aggregated fields from the table: "room.RoomChimeMeeting" */
  readonly room_RoomChimeMeeting_aggregate: Room_RoomChimeMeeting_Aggregate;
  /** fetch data from the table: "room.RoomChimeMeeting" using primary key columns */
  readonly room_RoomChimeMeeting_by_pk?: Maybe<Room_RoomChimeMeeting>;
  /** fetch data from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm: ReadonlyArray<Room_ShuffleAlgorithm>;
  /** fetch aggregated fields from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm_aggregate: Room_ShuffleAlgorithm_Aggregate;
  /** fetch data from the table: "room.ShuffleAlgorithm" using primary key columns */
  readonly room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** fetch data from the table: "room.VideoRoomBackend" */
  readonly room_VideoRoomBackend: ReadonlyArray<Room_VideoRoomBackend>;
  /** fetch aggregated fields from the table: "room.VideoRoomBackend" */
  readonly room_VideoRoomBackend_aggregate: Room_VideoRoomBackend_Aggregate;
  /** fetch data from the table: "room.VideoRoomBackend" using primary key columns */
  readonly room_VideoRoomBackend_by_pk?: Maybe<Room_VideoRoomBackend>;
  /** fetch data from the table: "system.Configuration" */
  readonly system_Configuration: ReadonlyArray<System_Configuration>;
  /** fetch data from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey: ReadonlyArray<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey_aggregate: System_ConfigurationKey_Aggregate;
  /** fetch data from the table: "system.ConfigurationKey" using primary key columns */
  readonly system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.Configuration" */
  readonly system_Configuration_aggregate: System_Configuration_Aggregate;
  /** fetch data from the table: "system.Configuration" using primary key columns */
  readonly system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** perform the action: "vapidPublicKey" */
  readonly vapidPublicKey: VapidPublicKeyOutput;
};


/** query root */
export type Query_RootAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeGoogleAccountArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Order_By>>;
  where?: Maybe<AttendeeGoogleAccount_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeGoogleAccount_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Order_By>>;
  where?: Maybe<AttendeeGoogleAccount_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeGoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootAttendeeProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeProfileBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfileBadges_Order_By>>;
  where?: Maybe<AttendeeProfileBadges_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeProfileBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfileBadges_Order_By>>;
  where?: Maybe<AttendeeProfileBadges_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeProfile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** query root */
export type Query_RootAttendeeProfile_By_PkArgs = {
  attendeeId: Scalars['uuid'];
};


/** query root */
export type Query_RootAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** query root */
export type Query_RootAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootBroadcastArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcastContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcastContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcastContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootBroadcast_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** query root */
export type Query_RootBroadcast_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceConfiguration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceConfiguration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConferenceDemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceDemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** query root */
export type Query_RootConferenceDemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConferencePrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** query root */
export type Query_RootConferencePrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** query root */
export type Query_RootConferencePrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootConference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** query root */
export type Query_RootConference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentGroupTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroupType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootContentGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** query root */
export type Query_RootContentGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** query root */
export type Query_RootContentPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootContentTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** query root */
export type Query_RootContentType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** query root */
export type Query_RootContentType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** query root */
export type Query_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** query root */
export type Query_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** query root */
export type Query_RootEventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** query root */
export type Query_RootEventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** query root */
export type Query_RootEventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** query root */
export type Query_RootEventPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootEventPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootEventPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootEventPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** query root */
export type Query_RootEventPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventRoomJoinRequestArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** query root */
export type Query_RootEventRoomJoinRequest_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** query root */
export type Query_RootEventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** query root */
export type Query_RootEventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** query root */
export type Query_RootEventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** query root */
export type Query_RootEventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** query root */
export type Query_RootEventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootEvent_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** query root */
export type Query_RootEvent_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** query root */
export type Query_RootExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** query root */
export type Query_RootExecutedTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** query root */
export type Query_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** query root */
export type Query_RootGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** query root */
export type Query_RootGroupAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** query root */
export type Query_RootGroupAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** query root */
export type Query_RootGroupAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootGroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** query root */
export type Query_RootGroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** query root */
export type Query_RootGroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** query root */
export type Query_RootGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** query root */
export type Query_RootHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** query root */
export type Query_RootHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootInputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** query root */
export type Query_RootInputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** query root */
export type Query_RootInputType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootInvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** query root */
export type Query_RootInvitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** query root */
export type Query_RootInvitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** query root */
export type Query_RootJobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** query root */
export type Query_RootJobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootMediaLiveChannelArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** query root */
export type Query_RootMediaLiveChannel_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** query root */
export type Query_RootMediaLiveChannel_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootOnlineStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** query root */
export type Query_RootOnlineStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** query root */
export type Query_RootOnlineStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootOriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** query root */
export type Query_RootOriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** query root */
export type Query_RootOriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** query root */
export type Query_RootPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** query root */
export type Query_RootPermission_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootPushNotificationSubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** query root */
export type Query_RootPushNotificationSubscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** query root */
export type Query_RootPushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


/** query root */
export type Query_RootRequiredContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootRequiredContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** query root */
export type Query_RootRequiredContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** query root */
export type Query_RootRolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** query root */
export type Query_RootRolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** query root */
export type Query_RootRolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** query root */
export type Query_RootRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** query root */
export type Query_RootRoomModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** query root */
export type Query_RootRoomMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** query root */
export type Query_RootRoomMode_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoomParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** query root */
export type Query_RootRoomParticipant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** query root */
export type Query_RootRoomParticipant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoomPrivacyArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPrivacy_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** query root */
export type Query_RootRoomPrivacy_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** query root */
export type Query_RootTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** query root */
export type Query_RootTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootTranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** query root */
export type Query_RootTranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** query root */
export type Query_RootTranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** query root */
export type Query_RootTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** query root */
export type Query_RootTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootUploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** query root */
export type Query_RootUploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** query root */
export type Query_RootUploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** query root */
export type Query_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** query root */
export type Query_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


/** query root */
export type Query_RootVideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** query root */
export type Query_RootVideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootYouTubeUploadArgs = {
  distinct_on?: Maybe<ReadonlyArray<YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<YouTubeUpload_Order_By>>;
  where?: Maybe<YouTubeUpload_Bool_Exp>;
};


/** query root */
export type Query_RootYouTubeUpload_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<YouTubeUpload_Order_By>>;
  where?: Maybe<YouTubeUpload_Bool_Exp>;
};


/** query root */
export type Query_RootYouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootAnalytics_AppStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_AppStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootAnalytics_ContentGroupStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Order_By>>;
  where?: Maybe<Analytics_ContentGroupStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentGroupStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Order_By>>;
  where?: Maybe<Analytics_ContentGroupStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentGroupStats_By_PkArgs = {
  contentGroupId: Scalars['uuid'];
};


/** query root */
export type Query_RootAnalytics_ContentItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_ContentItemStats_By_PkArgs = {
  contentItemId: Scalars['uuid'];
};


/** query root */
export type Query_RootAnalytics_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** query root */
export type Query_RootAnalytics_RoomStats_By_PkArgs = {
  roomId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** query root */
export type Query_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Pin_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** query root */
export type Query_RootChat_ReadUpToIndex_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** query root */
export type Query_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** query root */
export type Query_RootChat_Subscription_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** query root */
export type Query_RootEchoArgs = {
  message: Scalars['String'];
};


/** query root */
export type Query_RootGetContentItemArgs = {
  magicToken: Scalars['String'];
};


/** query root */
export type Query_RootGetUploadAgreementArgs = {
  magicToken: Scalars['String'];
};


/** query root */
export type Query_RootJob_Queues_ChannelStackCreateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_ChannelStackCreateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_CombineVideosJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CombineVideosJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_CustomEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CustomEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootJob_Queues_UploadYouTubeVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_UploadYouTubeVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** query root */
export type Query_RootJob_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootProtectedEchoArgs = {
  message: Scalars['String'];
};


/** query root */
export type Query_RootRoom_RoomChimeMeetingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Order_By>>;
  where?: Maybe<Room_RoomChimeMeeting_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_RoomChimeMeeting_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Order_By>>;
  where?: Maybe<Room_RoomChimeMeeting_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_RoomChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_ShuffleAlgorithmArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleAlgorithm_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** query root */
export type Query_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** query root */
export type Query_RootRoom_VideoRoomBackendArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Order_By>>;
  where?: Maybe<Room_VideoRoomBackend_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_VideoRoomBackend_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Order_By>>;
  where?: Maybe<Room_VideoRoomBackend_Bool_Exp>;
};


/** query root */
export type Query_RootRoom_VideoRoomBackend_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootSystem_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** query root */
export type Query_RootSystem_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** query root */
export type Query_RootSystem_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};

/** columns and relationships of "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting = {
  readonly __typename?: 'room_RoomChimeMeeting';
  readonly chimeMeetingData: Scalars['jsonb'];
  readonly chimeMeetingId: Scalars['String'];
  /** An object relationship */
  readonly conference?: Maybe<Conference>;
  readonly conferenceId: Scalars['uuid'];
  readonly createdAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  /** An object relationship */
  readonly room?: Maybe<Room>;
  readonly roomId: Scalars['uuid'];
  readonly updatedAt: Scalars['timestamptz'];
};


/** columns and relationships of "room.RoomChimeMeeting" */
export type Room_RoomChimeMeetingChimeMeetingDataArgs = {
  path?: Maybe<Scalars['String']>;
};

/** aggregated selection of "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Aggregate = {
  readonly __typename?: 'room_RoomChimeMeeting_aggregate';
  readonly aggregate?: Maybe<Room_RoomChimeMeeting_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_RoomChimeMeeting>;
};

/** aggregate fields of "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Aggregate_Fields = {
  readonly __typename?: 'room_RoomChimeMeeting_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_RoomChimeMeeting_Max_Fields>;
  readonly min?: Maybe<Room_RoomChimeMeeting_Min_Fields>;
};


/** aggregate fields of "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_RoomChimeMeeting_Max_Order_By>;
  readonly min?: Maybe<Room_RoomChimeMeeting_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type Room_RoomChimeMeeting_Append_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_RoomChimeMeeting_Insert_Input>;
  readonly on_conflict?: Maybe<Room_RoomChimeMeeting_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.RoomChimeMeeting". All fields are combined with a logical 'AND'. */
export type Room_RoomChimeMeeting_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_RoomChimeMeeting_Bool_Exp>>>;
  readonly _not?: Maybe<Room_RoomChimeMeeting_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_RoomChimeMeeting_Bool_Exp>>>;
  readonly chimeMeetingData?: Maybe<Jsonb_Comparison_Exp>;
  readonly chimeMeetingId?: Maybe<String_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly createdAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly updatedAt?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.RoomChimeMeeting" */
export enum Room_RoomChimeMeeting_Constraint {
  /** unique or primary key constraint */
  RoomChimeMeetingPkey = 'RoomChimeMeeting_pkey',
  /** unique or primary key constraint */
  RoomChimeMeetingRoomIdKey = 'RoomChimeMeeting_roomId_key'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type Room_RoomChimeMeeting_Delete_At_Path_Input = {
  readonly chimeMeetingData?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type Room_RoomChimeMeeting_Delete_Elem_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type Room_RoomChimeMeeting_Delete_Key_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Insert_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_RoomChimeMeeting_Max_Fields = {
  readonly __typename?: 'room_RoomChimeMeeting_max_fields';
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Max_Order_By = {
  readonly chimeMeetingId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_RoomChimeMeeting_Min_Fields = {
  readonly __typename?: 'room_RoomChimeMeeting_min_fields';
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Min_Order_By = {
  readonly chimeMeetingId?: Maybe<Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Mutation_Response = {
  readonly __typename?: 'room_RoomChimeMeeting_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_RoomChimeMeeting>;
};

/** input type for inserting object relation for remote table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Obj_Rel_Insert_Input = {
  readonly data: Room_RoomChimeMeeting_Insert_Input;
  readonly on_conflict?: Maybe<Room_RoomChimeMeeting_On_Conflict>;
};

/** on conflict condition type for table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_On_Conflict = {
  readonly constraint: Room_RoomChimeMeeting_Constraint;
  readonly update_columns: ReadonlyArray<Room_RoomChimeMeeting_Update_Column>;
  readonly where?: Maybe<Room_RoomChimeMeeting_Bool_Exp>;
};

/** ordering options when selecting data from "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Order_By = {
  readonly chimeMeetingData?: Maybe<Order_By>;
  readonly chimeMeetingId?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly createdAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly updatedAt?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type Room_RoomChimeMeeting_Prepend_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "room.RoomChimeMeeting" */
export enum Room_RoomChimeMeeting_Select_Column {
  /** column name */
  ChimeMeetingData = 'chimeMeetingData',
  /** column name */
  ChimeMeetingId = 'chimeMeetingId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** input type for updating data in table "room.RoomChimeMeeting" */
export type Room_RoomChimeMeeting_Set_Input = {
  readonly chimeMeetingData?: Maybe<Scalars['jsonb']>;
  readonly chimeMeetingId?: Maybe<Scalars['String']>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly createdAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly updatedAt?: Maybe<Scalars['timestamptz']>;
};

/** update columns of table "room.RoomChimeMeeting" */
export enum Room_RoomChimeMeeting_Update_Column {
  /** column name */
  ChimeMeetingData = 'chimeMeetingData',
  /** column name */
  ChimeMeetingId = 'chimeMeetingId',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  Id = 'id',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  UpdatedAt = 'updatedAt'
}

/** columns and relationships of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm = {
  readonly __typename?: 'room_ShuffleAlgorithm';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate = {
  readonly __typename?: 'room_ShuffleAlgorithm_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleAlgorithm_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleAlgorithm>;
};

/** aggregate fields of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleAlgorithm_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleAlgorithm_Min_Fields>;
};


/** aggregate fields of "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleAlgorithm_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleAlgorithm_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleAlgorithm_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.ShuffleAlgorithm". All fields are combined with a logical 'AND'. */
export type Room_ShuffleAlgorithm_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleAlgorithm_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleAlgorithm_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Constraint {
  /** unique or primary key constraint */
  ShuffleAlgorithmPkey = 'ShuffleAlgorithm_pkey'
}

export enum Room_ShuffleAlgorithm_Enum {
  /** First-come, first-served with auto-created rooms. */
  Fcfs = 'fcfs',
  /** First-come, first-served with a fixed set of (manually created) rooms. Limits max participants. */
  FcfsFixedRooms = 'fcfs_fixed_rooms',
  /** No automation. Rooms and allocations controlled manually. */
  None = 'none'
}

/** expression to compare columns of type room_ShuffleAlgorithm_enum. All fields are combined with logical 'AND'. */
export type Room_ShuffleAlgorithm_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Enum>>;
};

/** input type for inserting data into table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_ShuffleAlgorithm_Max_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleAlgorithm_Min_Fields = {
  readonly __typename?: 'room_ShuffleAlgorithm_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Mutation_Response = {
  readonly __typename?: 'room_ShuffleAlgorithm_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleAlgorithm>;
};

/** input type for inserting object relation for remote table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleAlgorithm_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleAlgorithm_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_On_Conflict = {
  readonly constraint: Room_ShuffleAlgorithm_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleAlgorithm_Update_Column>;
  readonly where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.ShuffleAlgorithm" */
export type Room_ShuffleAlgorithm_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.ShuffleAlgorithm" */
export enum Room_ShuffleAlgorithm_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriod = {
  readonly __typename?: 'room_ShufflePeriod';
  readonly algorithm: Room_ShuffleAlgorithm_Enum;
  /** An object relationship */
  readonly conference: Conference;
  readonly conferenceId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly endAt: Scalars['timestamptz'];
  readonly id: Scalars['uuid'];
  readonly maxAttendeesPerRoom: Scalars['Int'];
  readonly name: Scalars['String'];
  /** An object relationship */
  readonly organiser: Attendee;
  readonly organiserId: Scalars['uuid'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregated array relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly roomDurationMinutes: Scalars['Int'];
  /** An array relationship */
  readonly shuffleRooms: ReadonlyArray<Room_ShuffleRoom>;
  /** An aggregated array relationship */
  readonly shuffleRooms_aggregate: Room_ShuffleRoom_Aggregate;
  readonly startAt: Scalars['timestamptz'];
  readonly targetAttendeesPerRoom: Scalars['Int'];
  readonly updated_at: Scalars['timestamptz'];
  readonly waitRoomMaxDurationSeconds: Scalars['Int'];
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRoomsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** columns and relationships of "room.ShufflePeriod" */
export type Room_ShufflePeriodShuffleRooms_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** aggregated selection of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate = {
  readonly __typename?: 'room_ShufflePeriod_aggregate';
  readonly aggregate?: Maybe<Room_ShufflePeriod_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShufflePeriod>;
};

/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Fields = {
  readonly __typename?: 'room_ShufflePeriod_aggregate_fields';
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShufflePeriod_Max_Fields>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Fields>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Fields>;
};


/** aggregate fields of "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShufflePeriod_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShufflePeriod_Max_Order_By>;
  readonly min?: Maybe<Room_ShufflePeriod_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShufflePeriod_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShufflePeriod_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShufflePeriod_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShufflePeriod_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShufflePeriod_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShufflePeriod_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShufflePeriod_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShufflePeriod_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShufflePeriod_Avg_Fields = {
  readonly __typename?: 'room_ShufflePeriod_avg_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Avg_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShufflePeriod". All fields are combined with a logical 'AND'. */
export type Room_ShufflePeriod_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShufflePeriod_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShufflePeriod_Bool_Exp>>>;
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum_Comparison_Exp>;
  readonly conference?: Maybe<Conference_Bool_Exp>;
  readonly conferenceId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly endAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Uuid_Comparison_Exp>;
  readonly maxAttendeesPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
  readonly organiser?: Maybe<Attendee_Bool_Exp>;
  readonly organiserId?: Maybe<Uuid_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly roomDurationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly startAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly targetAttendeesPerRoom?: Maybe<Int_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Constraint {
  /** unique or primary key constraint */
  ShufflePeriodPkey = 'ShufflePeriod_pkey'
}

/** input type for incrementing integer column in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Inc_Input = {
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** input type for inserting data into table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Insert_Input = {
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly conference?: Maybe<Conference_Obj_Rel_Insert_Input>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiser?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly shuffleRooms?: Maybe<Room_ShuffleRoom_Arr_Rel_Insert_Input>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Room_ShufflePeriod_Max_Fields = {
  readonly __typename?: 'room_ShufflePeriod_max_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by max() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Max_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShufflePeriod_Min_Fields = {
  readonly __typename?: 'room_ShufflePeriod_min_fields';
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by min() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Min_Order_By = {
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Mutation_Response = {
  readonly __typename?: 'room_ShufflePeriod_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShufflePeriod>;
};

/** input type for inserting object relation for remote table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Obj_Rel_Insert_Input = {
  readonly data: Room_ShufflePeriod_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShufflePeriod_On_Conflict>;
};

/** on conflict condition type for table "room.ShufflePeriod" */
export type Room_ShufflePeriod_On_Conflict = {
  readonly constraint: Room_ShufflePeriod_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShufflePeriod_Update_Column>;
  readonly where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShufflePeriod" */
export type Room_ShufflePeriod_Order_By = {
  readonly algorithm?: Maybe<Order_By>;
  readonly conference?: Maybe<Conference_Order_By>;
  readonly conferenceId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly endAt?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
  readonly organiser?: Maybe<Attendee_Order_By>;
  readonly organiserId?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly shuffleRooms_aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Order_By>;
  readonly startAt?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShufflePeriod" */
export type Room_ShufflePeriod_Pk_Columns_Input = {
  readonly id: Scalars['uuid'];
};

/** select columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Select_Column {
  /** column name */
  Algorithm = 'algorithm',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxAttendeesPerRoom = 'maxAttendeesPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetAttendeesPerRoom = 'targetAttendeesPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** input type for updating data in table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Set_Input = {
  readonly algorithm?: Maybe<Room_ShuffleAlgorithm_Enum>;
  readonly conferenceId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly endAt?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['uuid']>;
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly name?: Maybe<Scalars['String']>;
  readonly organiserId?: Maybe<Scalars['uuid']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly startAt?: Maybe<Scalars['timestamptz']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Room_ShufflePeriod_Stddev_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShufflePeriod_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_pop_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Pop_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShufflePeriod_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_stddev_samp_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Stddev_Samp_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShufflePeriod_Sum_Fields = {
  readonly __typename?: 'room_ShufflePeriod_sum_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Int']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Int']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Int']>;
};

/** order by sum() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Sum_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** update columns of table "room.ShufflePeriod" */
export enum Room_ShufflePeriod_Update_Column {
  /** column name */
  Algorithm = 'algorithm',
  /** column name */
  ConferenceId = 'conferenceId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  EndAt = 'endAt',
  /** column name */
  Id = 'id',
  /** column name */
  MaxAttendeesPerRoom = 'maxAttendeesPerRoom',
  /** column name */
  Name = 'name',
  /** column name */
  OrganiserId = 'organiserId',
  /** column name */
  RoomDurationMinutes = 'roomDurationMinutes',
  /** column name */
  StartAt = 'startAt',
  /** column name */
  TargetAttendeesPerRoom = 'targetAttendeesPerRoom',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  WaitRoomMaxDurationSeconds = 'waitRoomMaxDurationSeconds'
}

/** aggregate var_pop on columns */
export type Room_ShufflePeriod_Var_Pop_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_pop_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Pop_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShufflePeriod_Var_Samp_Fields = {
  readonly __typename?: 'room_ShufflePeriod_var_samp_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Var_Samp_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShufflePeriod_Variance_Fields = {
  readonly __typename?: 'room_ShufflePeriod_variance_fields';
  readonly maxAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly roomDurationMinutes?: Maybe<Scalars['Float']>;
  readonly targetAttendeesPerRoom?: Maybe<Scalars['Float']>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShufflePeriod" */
export type Room_ShufflePeriod_Variance_Order_By = {
  readonly maxAttendeesPerRoom?: Maybe<Order_By>;
  readonly roomDurationMinutes?: Maybe<Order_By>;
  readonly targetAttendeesPerRoom?: Maybe<Order_By>;
  readonly waitRoomMaxDurationSeconds?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry = {
  readonly __typename?: 'room_ShuffleQueueEntry';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  /** An object relationship */
  readonly attendee: Attendee;
  readonly attendeeId: Scalars['uuid'];
  readonly created_at: Scalars['timestamptz'];
  readonly id: Scalars['bigint'];
  readonly isExpired: Scalars['Boolean'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  /** An object relationship */
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom>;
  readonly updated_at: Scalars['timestamptz'];
};

/** aggregated selection of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleQueueEntry_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleQueueEntry_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleQueueEntry_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleQueueEntry_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleQueueEntry_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleQueueEntry_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleQueueEntry_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleQueueEntry_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleQueueEntry_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleQueueEntry_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleQueueEntry_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleQueueEntry_Avg_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_avg_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Avg_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleQueueEntry". All fields are combined with a logical 'AND'. */
export type Room_ShuffleQueueEntry_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleQueueEntry_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleQueueEntry_Bool_Exp>>>;
  readonly allocatedShuffleRoomId?: Maybe<Int_Comparison_Exp>;
  readonly attendee?: Maybe<Attendee_Bool_Exp>;
  readonly attendeeId?: Maybe<Uuid_Comparison_Exp>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly isExpired?: Maybe<Boolean_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Constraint {
  /** unique or primary key constraint */
  ShuffleQueueEntryPkey = 'ShuffleQueueEntry_pkey',
  /** unique or primary key constraint */
  IndexRoomShufflequeueentryIswaiting = 'index_room_shufflequeueentry_iswaiting'
}

/** input type for incrementing integer column in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Inc_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Insert_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendee?: Maybe<Attendee_Obj_Rel_Insert_Input>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isExpired?: Maybe<Scalars['Boolean']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Obj_Rel_Insert_Input>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleQueueEntry_Max_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_max_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Max_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleQueueEntry_Min_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_min_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Min_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Mutation_Response = {
  readonly __typename?: 'room_ShuffleQueueEntry_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleQueueEntry>;
};

/** input type for inserting object relation for remote table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleQueueEntry_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleQueueEntry_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_On_Conflict = {
  readonly constraint: Room_ShuffleQueueEntry_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleQueueEntry_Update_Column>;
  readonly where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly attendee?: Maybe<Attendee_Order_By>;
  readonly attendeeId?: Maybe<Order_By>;
  readonly created_at?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isExpired?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly shuffleRoom?: Maybe<Room_ShuffleRoom_Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Select_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsExpired = 'isExpired',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Set_Input = {
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly attendeeId?: Maybe<Scalars['uuid']>;
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isExpired?: Maybe<Scalars['Boolean']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleQueueEntry_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleQueueEntry_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleQueueEntry_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_stddev_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Stddev_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleQueueEntry_Sum_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_sum_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Sum_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleQueueEntry" */
export enum Room_ShuffleQueueEntry_Update_Column {
  /** column name */
  AllocatedShuffleRoomId = 'allocatedShuffleRoomId',
  /** column name */
  AttendeeId = 'attendeeId',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  IsExpired = 'isExpired',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleQueueEntry_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_pop_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Pop_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleQueueEntry_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_var_samp_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Var_Samp_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleQueueEntry_Variance_Fields = {
  readonly __typename?: 'room_ShuffleQueueEntry_variance_fields';
  readonly allocatedShuffleRoomId?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleQueueEntry" */
export type Room_ShuffleQueueEntry_Variance_Order_By = {
  readonly allocatedShuffleRoomId?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoom = {
  readonly __typename?: 'room_ShuffleRoom';
  readonly created_at: Scalars['timestamptz'];
  readonly durationMinutes: Scalars['Int'];
  readonly id: Scalars['bigint'];
  readonly isEnded: Scalars['Boolean'];
  /** An array relationship */
  readonly queueEntries: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** An aggregated array relationship */
  readonly queueEntries_aggregate: Room_ShuffleQueueEntry_Aggregate;
  readonly reshuffleUponEnd: Scalars['Boolean'];
  /** An object relationship */
  readonly room: Room;
  readonly roomId: Scalars['uuid'];
  /** An object relationship */
  readonly shufflePeriod: Room_ShufflePeriod;
  readonly shufflePeriodId: Scalars['uuid'];
  readonly startedAt: Scalars['timestamptz'];
  readonly updated_at: Scalars['timestamptz'];
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntriesArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** columns and relationships of "room.ShuffleRoom" */
export type Room_ShuffleRoomQueueEntries_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};

/** aggregated selection of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate = {
  readonly __typename?: 'room_ShuffleRoom_aggregate';
  readonly aggregate?: Maybe<Room_ShuffleRoom_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_ShuffleRoom>;
};

/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Fields = {
  readonly __typename?: 'room_ShuffleRoom_aggregate_fields';
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Fields>;
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_ShuffleRoom_Max_Fields>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Fields>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Fields>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Fields>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Fields>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Fields>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Fields>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Fields>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Fields>;
};


/** aggregate fields of "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Aggregate_Order_By = {
  readonly avg?: Maybe<Room_ShuffleRoom_Avg_Order_By>;
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_ShuffleRoom_Max_Order_By>;
  readonly min?: Maybe<Room_ShuffleRoom_Min_Order_By>;
  readonly stddev?: Maybe<Room_ShuffleRoom_Stddev_Order_By>;
  readonly stddev_pop?: Maybe<Room_ShuffleRoom_Stddev_Pop_Order_By>;
  readonly stddev_samp?: Maybe<Room_ShuffleRoom_Stddev_Samp_Order_By>;
  readonly sum?: Maybe<Room_ShuffleRoom_Sum_Order_By>;
  readonly var_pop?: Maybe<Room_ShuffleRoom_Var_Pop_Order_By>;
  readonly var_samp?: Maybe<Room_ShuffleRoom_Var_Samp_Order_By>;
  readonly variance?: Maybe<Room_ShuffleRoom_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_ShuffleRoom_Insert_Input>;
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** aggregate avg on columns */
export type Room_ShuffleRoom_Avg_Fields = {
  readonly __typename?: 'room_ShuffleRoom_avg_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Avg_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** Boolean expression to filter rows from the table "room.ShuffleRoom". All fields are combined with a logical 'AND'. */
export type Room_ShuffleRoom_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_ShuffleRoom_Bool_Exp>>>;
  readonly _not?: Maybe<Room_ShuffleRoom_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_ShuffleRoom_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly durationMinutes?: Maybe<Int_Comparison_Exp>;
  readonly id?: Maybe<Bigint_Comparison_Exp>;
  readonly isEnded?: Maybe<Boolean_Comparison_Exp>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
  readonly reshuffleUponEnd?: Maybe<Boolean_Comparison_Exp>;
  readonly room?: Maybe<Room_Bool_Exp>;
  readonly roomId?: Maybe<Uuid_Comparison_Exp>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Bool_Exp>;
  readonly shufflePeriodId?: Maybe<Uuid_Comparison_Exp>;
  readonly startedAt?: Maybe<Timestamptz_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Constraint {
  /** unique or primary key constraint */
  ShuffleRoomPkey = 'ShuffleRoom_pkey'
}

/** input type for incrementing integer column in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Inc_Input = {
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** input type for inserting data into table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly queueEntries?: Maybe<Room_ShuffleQueueEntry_Arr_Rel_Insert_Input>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly room?: Maybe<Room_Obj_Rel_Insert_Input>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Obj_Rel_Insert_Input>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate max on columns */
export type Room_ShuffleRoom_Max_Fields = {
  readonly __typename?: 'room_ShuffleRoom_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_ShuffleRoom_Min_Fields = {
  readonly __typename?: 'room_ShuffleRoom_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Mutation_Response = {
  readonly __typename?: 'room_ShuffleRoom_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_ShuffleRoom>;
};

/** input type for inserting object relation for remote table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Obj_Rel_Insert_Input = {
  readonly data: Room_ShuffleRoom_Insert_Input;
  readonly on_conflict?: Maybe<Room_ShuffleRoom_On_Conflict>;
};

/** on conflict condition type for table "room.ShuffleRoom" */
export type Room_ShuffleRoom_On_Conflict = {
  readonly constraint: Room_ShuffleRoom_Constraint;
  readonly update_columns: ReadonlyArray<Room_ShuffleRoom_Update_Column>;
  readonly where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};

/** ordering options when selecting data from "room.ShuffleRoom" */
export type Room_ShuffleRoom_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
  readonly isEnded?: Maybe<Order_By>;
  readonly queueEntries_aggregate?: Maybe<Room_ShuffleQueueEntry_Aggregate_Order_By>;
  readonly reshuffleUponEnd?: Maybe<Order_By>;
  readonly room?: Maybe<Room_Order_By>;
  readonly roomId?: Maybe<Order_By>;
  readonly shufflePeriod?: Maybe<Room_ShufflePeriod_Order_By>;
  readonly shufflePeriodId?: Maybe<Order_By>;
  readonly startedAt?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.ShuffleRoom" */
export type Room_ShuffleRoom_Pk_Columns_Input = {
  readonly id: Scalars['bigint'];
};

/** select columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
  readonly isEnded?: Maybe<Scalars['Boolean']>;
  readonly reshuffleUponEnd?: Maybe<Scalars['Boolean']>;
  readonly roomId?: Maybe<Scalars['uuid']>;
  readonly shufflePeriodId?: Maybe<Scalars['uuid']>;
  readonly startedAt?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** aggregate stddev on columns */
export type Room_ShuffleRoom_Stddev_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Room_ShuffleRoom_Stddev_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Room_ShuffleRoom_Stddev_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_stddev_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Stddev_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate sum on columns */
export type Room_ShuffleRoom_Sum_Fields = {
  readonly __typename?: 'room_ShuffleRoom_sum_fields';
  readonly durationMinutes?: Maybe<Scalars['Int']>;
  readonly id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Sum_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** update columns of table "room.ShuffleRoom" */
export enum Room_ShuffleRoom_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DurationMinutes = 'durationMinutes',
  /** column name */
  Id = 'id',
  /** column name */
  IsEnded = 'isEnded',
  /** column name */
  ReshuffleUponEnd = 'reshuffleUponEnd',
  /** column name */
  RoomId = 'roomId',
  /** column name */
  ShufflePeriodId = 'shufflePeriodId',
  /** column name */
  StartedAt = 'startedAt',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Room_ShuffleRoom_Var_Pop_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_pop_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Pop_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Room_ShuffleRoom_Var_Samp_Fields = {
  readonly __typename?: 'room_ShuffleRoom_var_samp_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Var_Samp_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** aggregate variance on columns */
export type Room_ShuffleRoom_Variance_Fields = {
  readonly __typename?: 'room_ShuffleRoom_variance_fields';
  readonly durationMinutes?: Maybe<Scalars['Float']>;
  readonly id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "room.ShuffleRoom" */
export type Room_ShuffleRoom_Variance_Order_By = {
  readonly durationMinutes?: Maybe<Order_By>;
  readonly id?: Maybe<Order_By>;
};

/** columns and relationships of "room.VideoRoomBackend" */
export type Room_VideoRoomBackend = {
  readonly __typename?: 'room_VideoRoomBackend';
  readonly description: Scalars['String'];
  readonly name: Scalars['String'];
};

/** aggregated selection of "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Aggregate = {
  readonly __typename?: 'room_VideoRoomBackend_aggregate';
  readonly aggregate?: Maybe<Room_VideoRoomBackend_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<Room_VideoRoomBackend>;
};

/** aggregate fields of "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Aggregate_Fields = {
  readonly __typename?: 'room_VideoRoomBackend_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<Room_VideoRoomBackend_Max_Fields>;
  readonly min?: Maybe<Room_VideoRoomBackend_Min_Fields>;
};


/** aggregate fields of "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<Room_VideoRoomBackend_Max_Order_By>;
  readonly min?: Maybe<Room_VideoRoomBackend_Min_Order_By>;
};

/** input type for inserting array relation for remote table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<Room_VideoRoomBackend_Insert_Input>;
  readonly on_conflict?: Maybe<Room_VideoRoomBackend_On_Conflict>;
};

/** Boolean expression to filter rows from the table "room.VideoRoomBackend". All fields are combined with a logical 'AND'. */
export type Room_VideoRoomBackend_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<Room_VideoRoomBackend_Bool_Exp>>>;
  readonly _not?: Maybe<Room_VideoRoomBackend_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<Room_VideoRoomBackend_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "room.VideoRoomBackend" */
export enum Room_VideoRoomBackend_Constraint {
  /** unique or primary key constraint */
  VideoRoomBackendPkey = 'VideoRoomBackend_pkey'
}

export enum Room_VideoRoomBackend_Enum {
  /** AWS Chime SDK */
  Chime = 'CHIME',
  /** Vonage Video API */
  Vonage = 'VONAGE'
}

/** expression to compare columns of type room_VideoRoomBackend_enum. All fields are combined with logical 'AND'. */
export type Room_VideoRoomBackend_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<Room_VideoRoomBackend_Enum>;
  readonly _in?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<Room_VideoRoomBackend_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Enum>>;
};

/** input type for inserting data into table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Room_VideoRoomBackend_Max_Fields = {
  readonly __typename?: 'room_VideoRoomBackend_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type Room_VideoRoomBackend_Min_Fields = {
  readonly __typename?: 'room_VideoRoomBackend_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Mutation_Response = {
  readonly __typename?: 'room_VideoRoomBackend_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<Room_VideoRoomBackend>;
};

/** input type for inserting object relation for remote table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Obj_Rel_Insert_Input = {
  readonly data: Room_VideoRoomBackend_Insert_Input;
  readonly on_conflict?: Maybe<Room_VideoRoomBackend_On_Conflict>;
};

/** on conflict condition type for table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_On_Conflict = {
  readonly constraint: Room_VideoRoomBackend_Constraint;
  readonly update_columns: ReadonlyArray<Room_VideoRoomBackend_Update_Column>;
  readonly where?: Maybe<Room_VideoRoomBackend_Bool_Exp>;
};

/** ordering options when selecting data from "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "room.VideoRoomBackend" */
export enum Room_VideoRoomBackend_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "room.VideoRoomBackend" */
export type Room_VideoRoomBackend_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "room.VideoRoomBackend" */
export enum Room_VideoRoomBackend_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** subscription root */
export type Subscription_Root = {
  readonly __typename?: 'subscription_root';
  /** fetch data from the table: "Attendee" */
  readonly Attendee: ReadonlyArray<Attendee>;
  /** fetch data from the table: "AttendeeGoogleAccount" */
  readonly AttendeeGoogleAccount: ReadonlyArray<AttendeeGoogleAccount>;
  /** fetch aggregated fields from the table: "AttendeeGoogleAccount" */
  readonly AttendeeGoogleAccount_aggregate: AttendeeGoogleAccount_Aggregate;
  /** fetch data from the table: "AttendeeGoogleAccount" using primary key columns */
  readonly AttendeeGoogleAccount_by_pk?: Maybe<AttendeeGoogleAccount>;
  /** fetch data from the table: "AttendeeProfile" */
  readonly AttendeeProfile: ReadonlyArray<AttendeeProfile>;
  /** fetch data from the table: "AttendeeProfileBadges" */
  readonly AttendeeProfileBadges: ReadonlyArray<AttendeeProfileBadges>;
  /** fetch aggregated fields from the table: "AttendeeProfileBadges" */
  readonly AttendeeProfileBadges_aggregate: AttendeeProfileBadges_Aggregate;
  /** fetch aggregated fields from the table: "AttendeeProfile" */
  readonly AttendeeProfile_aggregate: AttendeeProfile_Aggregate;
  /** fetch data from the table: "AttendeeProfile" using primary key columns */
  readonly AttendeeProfile_by_pk?: Maybe<AttendeeProfile>;
  /** fetch aggregated fields from the table: "Attendee" */
  readonly Attendee_aggregate: Attendee_Aggregate;
  /** fetch data from the table: "Attendee" using primary key columns */
  readonly Attendee_by_pk?: Maybe<Attendee>;
  /** fetch data from the table: "Broadcast" */
  readonly Broadcast: ReadonlyArray<Broadcast>;
  /** fetch data from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem: ReadonlyArray<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "BroadcastContentItem" */
  readonly BroadcastContentItem_aggregate: BroadcastContentItem_Aggregate;
  /** fetch data from the table: "BroadcastContentItem" using primary key columns */
  readonly BroadcastContentItem_by_pk?: Maybe<BroadcastContentItem>;
  /** fetch aggregated fields from the table: "Broadcast" */
  readonly Broadcast_aggregate: Broadcast_Aggregate;
  /** fetch data from the table: "Broadcast" using primary key columns */
  readonly Broadcast_by_pk?: Maybe<Broadcast>;
  /** fetch data from the table: "Conference" */
  readonly Conference: ReadonlyArray<Conference>;
  /** fetch data from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration: ReadonlyArray<ConferenceConfiguration>;
  /** fetch aggregated fields from the table: "ConferenceConfiguration" */
  readonly ConferenceConfiguration_aggregate: ConferenceConfiguration_Aggregate;
  /** fetch data from the table: "ConferenceConfiguration" using primary key columns */
  readonly ConferenceConfiguration_by_pk?: Maybe<ConferenceConfiguration>;
  /** fetch data from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode: ReadonlyArray<ConferenceDemoCode>;
  /** fetch aggregated fields from the table: "ConferenceDemoCode" */
  readonly ConferenceDemoCode_aggregate: ConferenceDemoCode_Aggregate;
  /** fetch data from the table: "ConferenceDemoCode" using primary key columns */
  readonly ConferenceDemoCode_by_pk?: Maybe<ConferenceDemoCode>;
  /** fetch data from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob: ReadonlyArray<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "ConferencePrepareJob" */
  readonly ConferencePrepareJob_aggregate: ConferencePrepareJob_Aggregate;
  /** fetch data from the table: "ConferencePrepareJob" using primary key columns */
  readonly ConferencePrepareJob_by_pk?: Maybe<ConferencePrepareJob>;
  /** fetch aggregated fields from the table: "Conference" */
  readonly Conference_aggregate: Conference_Aggregate;
  /** fetch data from the table: "Conference" using primary key columns */
  readonly Conference_by_pk?: Maybe<Conference>;
  /** fetch data from the table: "ContentGroup" */
  readonly ContentGroup: ReadonlyArray<ContentGroup>;
  /** fetch data from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway: ReadonlyArray<ContentGroupHallway>;
  /** fetch aggregated fields from the table: "ContentGroupHallway" */
  readonly ContentGroupHallway_aggregate: ContentGroupHallway_Aggregate;
  /** fetch data from the table: "ContentGroupHallway" using primary key columns */
  readonly ContentGroupHallway_by_pk?: Maybe<ContentGroupHallway>;
  /** fetch data from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson: ReadonlyArray<ContentGroupPerson>;
  /** fetch aggregated fields from the table: "ContentGroupPerson" */
  readonly ContentGroupPerson_aggregate: ContentGroupPerson_Aggregate;
  /** fetch data from the table: "ContentGroupPerson" using primary key columns */
  readonly ContentGroupPerson_by_pk?: Maybe<ContentGroupPerson>;
  /** fetch data from the table: "ContentGroupTag" */
  readonly ContentGroupTag: ReadonlyArray<ContentGroupTag>;
  /** fetch aggregated fields from the table: "ContentGroupTag" */
  readonly ContentGroupTag_aggregate: ContentGroupTag_Aggregate;
  /** fetch data from the table: "ContentGroupTag" using primary key columns */
  readonly ContentGroupTag_by_pk?: Maybe<ContentGroupTag>;
  /** fetch data from the table: "ContentGroupType" */
  readonly ContentGroupType: ReadonlyArray<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroupType" */
  readonly ContentGroupType_aggregate: ContentGroupType_Aggregate;
  /** fetch data from the table: "ContentGroupType" using primary key columns */
  readonly ContentGroupType_by_pk?: Maybe<ContentGroupType>;
  /** fetch aggregated fields from the table: "ContentGroup" */
  readonly ContentGroup_aggregate: ContentGroup_Aggregate;
  /** fetch data from the table: "ContentGroup" using primary key columns */
  readonly ContentGroup_by_pk?: Maybe<ContentGroup>;
  /** fetch data from the table: "ContentItem" */
  readonly ContentItem: ReadonlyArray<ContentItem>;
  /** fetch aggregated fields from the table: "ContentItem" */
  readonly ContentItem_aggregate: ContentItem_Aggregate;
  /** fetch data from the table: "ContentItem" using primary key columns */
  readonly ContentItem_by_pk?: Maybe<ContentItem>;
  /** fetch data from the table: "ContentPerson" */
  readonly ContentPerson: ReadonlyArray<ContentPerson>;
  /** fetch aggregated fields from the table: "ContentPerson" */
  readonly ContentPerson_aggregate: ContentPerson_Aggregate;
  /** fetch data from the table: "ContentPerson" using primary key columns */
  readonly ContentPerson_by_pk?: Maybe<ContentPerson>;
  /** fetch data from the table: "ContentType" */
  readonly ContentType: ReadonlyArray<ContentType>;
  /** fetch aggregated fields from the table: "ContentType" */
  readonly ContentType_aggregate: ContentType_Aggregate;
  /** fetch data from the table: "ContentType" using primary key columns */
  readonly ContentType_by_pk?: Maybe<ContentType>;
  /** fetch data from the table: "Email" */
  readonly Email: ReadonlyArray<Email>;
  /** fetch aggregated fields from the table: "Email" */
  readonly Email_aggregate: Email_Aggregate;
  /** fetch data from the table: "Email" using primary key columns */
  readonly Email_by_pk?: Maybe<Email>;
  /** fetch data from the table: "Event" */
  readonly Event: ReadonlyArray<Event>;
  /** fetch data from the table: "EventParticipantStream" */
  readonly EventParticipantStream: ReadonlyArray<EventParticipantStream>;
  /** fetch aggregated fields from the table: "EventParticipantStream" */
  readonly EventParticipantStream_aggregate: EventParticipantStream_Aggregate;
  /** fetch data from the table: "EventParticipantStream" using primary key columns */
  readonly EventParticipantStream_by_pk?: Maybe<EventParticipantStream>;
  /** fetch data from the table: "EventPerson" */
  readonly EventPerson: ReadonlyArray<EventPerson>;
  /** fetch data from the table: "EventPersonRole" */
  readonly EventPersonRole: ReadonlyArray<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPersonRole" */
  readonly EventPersonRole_aggregate: EventPersonRole_Aggregate;
  /** fetch data from the table: "EventPersonRole" using primary key columns */
  readonly EventPersonRole_by_pk?: Maybe<EventPersonRole>;
  /** fetch aggregated fields from the table: "EventPerson" */
  readonly EventPerson_aggregate: EventPerson_Aggregate;
  /** fetch data from the table: "EventPerson" using primary key columns */
  readonly EventPerson_by_pk?: Maybe<EventPerson>;
  /** fetch data from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest: ReadonlyArray<EventRoomJoinRequest>;
  /** fetch aggregated fields from the table: "EventRoomJoinRequest" */
  readonly EventRoomJoinRequest_aggregate: EventRoomJoinRequest_Aggregate;
  /** fetch data from the table: "EventRoomJoinRequest" using primary key columns */
  readonly EventRoomJoinRequest_by_pk?: Maybe<EventRoomJoinRequest>;
  /** fetch data from the table: "EventTag" */
  readonly EventTag: ReadonlyArray<EventTag>;
  /** fetch aggregated fields from the table: "EventTag" */
  readonly EventTag_aggregate: EventTag_Aggregate;
  /** fetch data from the table: "EventTag" using primary key columns */
  readonly EventTag_by_pk?: Maybe<EventTag>;
  /** fetch data from the table: "EventVonageSession" */
  readonly EventVonageSession: ReadonlyArray<EventVonageSession>;
  /** fetch aggregated fields from the table: "EventVonageSession" */
  readonly EventVonageSession_aggregate: EventVonageSession_Aggregate;
  /** fetch data from the table: "EventVonageSession" using primary key columns */
  readonly EventVonageSession_by_pk?: Maybe<EventVonageSession>;
  /** fetch aggregated fields from the table: "Event" */
  readonly Event_aggregate: Event_Aggregate;
  /** fetch data from the table: "Event" using primary key columns */
  readonly Event_by_pk?: Maybe<Event>;
  /** fetch data from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions: ReadonlyArray<ExecutedTransitions>;
  /** fetch aggregated fields from the table: "ExecutedTransitions" */
  readonly ExecutedTransitions_aggregate: ExecutedTransitions_Aggregate;
  /** fetch data from the table: "ExecutedTransitions" using primary key columns */
  readonly ExecutedTransitions_by_pk?: Maybe<ExecutedTransitions>;
  /** fetch data from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission: ReadonlyArray<FlatUnauthPermission>;
  /** fetch aggregated fields from the table: "FlatUnauthPermission" */
  readonly FlatUnauthPermission_aggregate: FlatUnauthPermission_Aggregate;
  /** fetch data from the table: "FlatUserPermission" */
  readonly FlatUserPermission: ReadonlyArray<FlatUserPermission>;
  /** fetch aggregated fields from the table: "FlatUserPermission" */
  readonly FlatUserPermission_aggregate: FlatUserPermission_Aggregate;
  /** fetch data from the table: "Group" */
  readonly Group: ReadonlyArray<Group>;
  /** fetch data from the table: "GroupAttendee" */
  readonly GroupAttendee: ReadonlyArray<GroupAttendee>;
  /** fetch aggregated fields from the table: "GroupAttendee" */
  readonly GroupAttendee_aggregate: GroupAttendee_Aggregate;
  /** fetch data from the table: "GroupAttendee" using primary key columns */
  readonly GroupAttendee_by_pk?: Maybe<GroupAttendee>;
  /** fetch data from the table: "GroupRole" */
  readonly GroupRole: ReadonlyArray<GroupRole>;
  /** fetch aggregated fields from the table: "GroupRole" */
  readonly GroupRole_aggregate: GroupRole_Aggregate;
  /** fetch data from the table: "GroupRole" using primary key columns */
  readonly GroupRole_by_pk?: Maybe<GroupRole>;
  /** fetch aggregated fields from the table: "Group" */
  readonly Group_aggregate: Group_Aggregate;
  /** fetch data from the table: "Group" using primary key columns */
  readonly Group_by_pk?: Maybe<Group>;
  /** fetch data from the table: "Hallway" */
  readonly Hallway: ReadonlyArray<Hallway>;
  /** fetch aggregated fields from the table: "Hallway" */
  readonly Hallway_aggregate: Hallway_Aggregate;
  /** fetch data from the table: "Hallway" using primary key columns */
  readonly Hallway_by_pk?: Maybe<Hallway>;
  /** fetch data from the table: "InputType" */
  readonly InputType: ReadonlyArray<InputType>;
  /** fetch aggregated fields from the table: "InputType" */
  readonly InputType_aggregate: InputType_Aggregate;
  /** fetch data from the table: "InputType" using primary key columns */
  readonly InputType_by_pk?: Maybe<InputType>;
  /** fetch data from the table: "Invitation" */
  readonly Invitation: ReadonlyArray<Invitation>;
  /** fetch aggregated fields from the table: "Invitation" */
  readonly Invitation_aggregate: Invitation_Aggregate;
  /** fetch data from the table: "Invitation" using primary key columns */
  readonly Invitation_by_pk?: Maybe<Invitation>;
  /** fetch data from the table: "JobStatus" */
  readonly JobStatus: ReadonlyArray<JobStatus>;
  /** fetch aggregated fields from the table: "JobStatus" */
  readonly JobStatus_aggregate: JobStatus_Aggregate;
  /** fetch data from the table: "JobStatus" using primary key columns */
  readonly JobStatus_by_pk?: Maybe<JobStatus>;
  /** fetch data from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel: ReadonlyArray<MediaLiveChannel>;
  /** fetch aggregated fields from the table: "MediaLiveChannel" */
  readonly MediaLiveChannel_aggregate: MediaLiveChannel_Aggregate;
  /** fetch data from the table: "MediaLiveChannel" using primary key columns */
  readonly MediaLiveChannel_by_pk?: Maybe<MediaLiveChannel>;
  /** fetch data from the table: "OnlineStatus" */
  readonly OnlineStatus: ReadonlyArray<OnlineStatus>;
  /** fetch aggregated fields from the table: "OnlineStatus" */
  readonly OnlineStatus_aggregate: OnlineStatus_Aggregate;
  /** fetch data from the table: "OnlineStatus" using primary key columns */
  readonly OnlineStatus_by_pk?: Maybe<OnlineStatus>;
  /** fetch data from the table: "OriginatingData" */
  readonly OriginatingData: ReadonlyArray<OriginatingData>;
  /** fetch aggregated fields from the table: "OriginatingData" */
  readonly OriginatingData_aggregate: OriginatingData_Aggregate;
  /** fetch data from the table: "OriginatingData" using primary key columns */
  readonly OriginatingData_by_pk?: Maybe<OriginatingData>;
  /** fetch data from the table: "Permission" */
  readonly Permission: ReadonlyArray<Permission>;
  /** fetch aggregated fields from the table: "Permission" */
  readonly Permission_aggregate: Permission_Aggregate;
  /** fetch data from the table: "Permission" using primary key columns */
  readonly Permission_by_pk?: Maybe<Permission>;
  /** fetch data from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription: ReadonlyArray<PushNotificationSubscription>;
  /** fetch aggregated fields from the table: "PushNotificationSubscription" */
  readonly PushNotificationSubscription_aggregate: PushNotificationSubscription_Aggregate;
  /** fetch data from the table: "PushNotificationSubscription" using primary key columns */
  readonly PushNotificationSubscription_by_pk?: Maybe<PushNotificationSubscription>;
  /** fetch data from the table: "RequiredContentItem" */
  readonly RequiredContentItem: ReadonlyArray<RequiredContentItem>;
  /** fetch aggregated fields from the table: "RequiredContentItem" */
  readonly RequiredContentItem_aggregate: RequiredContentItem_Aggregate;
  /** fetch data from the table: "RequiredContentItem" using primary key columns */
  readonly RequiredContentItem_by_pk?: Maybe<RequiredContentItem>;
  /** fetch data from the table: "Role" */
  readonly Role: ReadonlyArray<Role>;
  /** fetch data from the table: "RolePermission" */
  readonly RolePermission: ReadonlyArray<RolePermission>;
  /** fetch aggregated fields from the table: "RolePermission" */
  readonly RolePermission_aggregate: RolePermission_Aggregate;
  /** fetch data from the table: "RolePermission" using primary key columns */
  readonly RolePermission_by_pk?: Maybe<RolePermission>;
  /** fetch aggregated fields from the table: "Role" */
  readonly Role_aggregate: Role_Aggregate;
  /** fetch data from the table: "Role" using primary key columns */
  readonly Role_by_pk?: Maybe<Role>;
  /** fetch data from the table: "Room" */
  readonly Room: ReadonlyArray<Room>;
  /** fetch data from the table: "RoomMode" */
  readonly RoomMode: ReadonlyArray<RoomMode>;
  /** fetch aggregated fields from the table: "RoomMode" */
  readonly RoomMode_aggregate: RoomMode_Aggregate;
  /** fetch data from the table: "RoomMode" using primary key columns */
  readonly RoomMode_by_pk?: Maybe<RoomMode>;
  /** fetch data from the table: "RoomParticipant" */
  readonly RoomParticipant: ReadonlyArray<RoomParticipant>;
  /** fetch aggregated fields from the table: "RoomParticipant" */
  readonly RoomParticipant_aggregate: RoomParticipant_Aggregate;
  /** fetch data from the table: "RoomParticipant" using primary key columns */
  readonly RoomParticipant_by_pk?: Maybe<RoomParticipant>;
  /** fetch data from the table: "RoomPerson" */
  readonly RoomPerson: ReadonlyArray<RoomPerson>;
  /** fetch data from the table: "RoomPersonRole" */
  readonly RoomPersonRole: ReadonlyArray<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPersonRole" */
  readonly RoomPersonRole_aggregate: RoomPersonRole_Aggregate;
  /** fetch data from the table: "RoomPersonRole" using primary key columns */
  readonly RoomPersonRole_by_pk?: Maybe<RoomPersonRole>;
  /** fetch aggregated fields from the table: "RoomPerson" */
  readonly RoomPerson_aggregate: RoomPerson_Aggregate;
  /** fetch data from the table: "RoomPerson" using primary key columns */
  readonly RoomPerson_by_pk?: Maybe<RoomPerson>;
  /** fetch data from the table: "RoomPrivacy" */
  readonly RoomPrivacy: ReadonlyArray<RoomPrivacy>;
  /** fetch aggregated fields from the table: "RoomPrivacy" */
  readonly RoomPrivacy_aggregate: RoomPrivacy_Aggregate;
  /** fetch data from the table: "RoomPrivacy" using primary key columns */
  readonly RoomPrivacy_by_pk?: Maybe<RoomPrivacy>;
  /** fetch aggregated fields from the table: "Room" */
  readonly Room_aggregate: Room_Aggregate;
  /** fetch data from the table: "Room" using primary key columns */
  readonly Room_by_pk?: Maybe<Room>;
  /** fetch data from the table: "Tag" */
  readonly Tag: ReadonlyArray<Tag>;
  /** fetch aggregated fields from the table: "Tag" */
  readonly Tag_aggregate: Tag_Aggregate;
  /** fetch data from the table: "Tag" using primary key columns */
  readonly Tag_by_pk?: Maybe<Tag>;
  /** fetch data from the table: "TranscriptionJob" */
  readonly TranscriptionJob: ReadonlyArray<TranscriptionJob>;
  /** fetch aggregated fields from the table: "TranscriptionJob" */
  readonly TranscriptionJob_aggregate: TranscriptionJob_Aggregate;
  /** fetch data from the table: "TranscriptionJob" using primary key columns */
  readonly TranscriptionJob_by_pk?: Maybe<TranscriptionJob>;
  /** fetch data from the table: "Transitions" */
  readonly Transitions: ReadonlyArray<Transitions>;
  /** fetch aggregated fields from the table: "Transitions" */
  readonly Transitions_aggregate: Transitions_Aggregate;
  /** fetch data from the table: "Transitions" using primary key columns */
  readonly Transitions_by_pk?: Maybe<Transitions>;
  /** fetch data from the table: "Uploader" */
  readonly Uploader: ReadonlyArray<Uploader>;
  /** fetch aggregated fields from the table: "Uploader" */
  readonly Uploader_aggregate: Uploader_Aggregate;
  /** fetch data from the table: "Uploader" using primary key columns */
  readonly Uploader_by_pk?: Maybe<Uploader>;
  /** fetch data from the table: "User" */
  readonly User: ReadonlyArray<User>;
  /** fetch aggregated fields from the table: "User" */
  readonly User_aggregate: User_Aggregate;
  /** fetch data from the table: "User" using primary key columns */
  readonly User_by_pk?: Maybe<User>;
  /** fetch data from the table: "VideoRenderJob" */
  readonly VideoRenderJob: ReadonlyArray<VideoRenderJob>;
  /** fetch aggregated fields from the table: "VideoRenderJob" */
  readonly VideoRenderJob_aggregate: VideoRenderJob_Aggregate;
  /** fetch data from the table: "VideoRenderJob" using primary key columns */
  readonly VideoRenderJob_by_pk?: Maybe<VideoRenderJob>;
  /** fetch data from the table: "YouTubeUpload" */
  readonly YouTubeUpload: ReadonlyArray<YouTubeUpload>;
  /** fetch aggregated fields from the table: "YouTubeUpload" */
  readonly YouTubeUpload_aggregate: YouTubeUpload_Aggregate;
  /** fetch data from the table: "YouTubeUpload" using primary key columns */
  readonly YouTubeUpload_by_pk?: Maybe<YouTubeUpload>;
  /** fetch data from the table: "analytics.AppStats" */
  readonly analytics_AppStats: ReadonlyArray<Analytics_AppStats>;
  /** fetch aggregated fields from the table: "analytics.AppStats" */
  readonly analytics_AppStats_aggregate: Analytics_AppStats_Aggregate;
  /** fetch data from the table: "analytics.AppStats" using primary key columns */
  readonly analytics_AppStats_by_pk?: Maybe<Analytics_AppStats>;
  /** fetch data from the table: "analytics.ContentGroupStats" */
  readonly analytics_ContentGroupStats: ReadonlyArray<Analytics_ContentGroupStats>;
  /** fetch aggregated fields from the table: "analytics.ContentGroupStats" */
  readonly analytics_ContentGroupStats_aggregate: Analytics_ContentGroupStats_Aggregate;
  /** fetch data from the table: "analytics.ContentGroupStats" using primary key columns */
  readonly analytics_ContentGroupStats_by_pk?: Maybe<Analytics_ContentGroupStats>;
  /** fetch data from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats: ReadonlyArray<Analytics_ContentItemStats>;
  /** fetch aggregated fields from the table: "analytics.ContentItemStats" */
  readonly analytics_ContentItemStats_aggregate: Analytics_ContentItemStats_Aggregate;
  /** fetch data from the table: "analytics.ContentItemStats" using primary key columns */
  readonly analytics_ContentItemStats_by_pk?: Maybe<Analytics_ContentItemStats>;
  /** fetch data from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats: ReadonlyArray<Analytics_RoomStats>;
  /** fetch aggregated fields from the table: "analytics.RoomStats" */
  readonly analytics_RoomStats_aggregate: Analytics_RoomStats_Aggregate;
  /** fetch data from the table: "analytics.RoomStats" using primary key columns */
  readonly analytics_RoomStats_by_pk?: Maybe<Analytics_RoomStats>;
  /** fetch data from the table: "chat.Chat" */
  readonly chat_Chat: ReadonlyArray<Chat_Chat>;
  /** fetch aggregated fields from the table: "chat.Chat" */
  readonly chat_Chat_aggregate: Chat_Chat_Aggregate;
  /** fetch data from the table: "chat.Chat" using primary key columns */
  readonly chat_Chat_by_pk?: Maybe<Chat_Chat>;
  /** fetch data from the table: "chat.Flag" */
  readonly chat_Flag: ReadonlyArray<Chat_Flag>;
  /** fetch data from the table: "chat.FlagType" */
  readonly chat_FlagType: ReadonlyArray<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.FlagType" */
  readonly chat_FlagType_aggregate: Chat_FlagType_Aggregate;
  /** fetch data from the table: "chat.FlagType" using primary key columns */
  readonly chat_FlagType_by_pk?: Maybe<Chat_FlagType>;
  /** fetch aggregated fields from the table: "chat.Flag" */
  readonly chat_Flag_aggregate: Chat_Flag_Aggregate;
  /** fetch data from the table: "chat.Flag" using primary key columns */
  readonly chat_Flag_by_pk?: Maybe<Chat_Flag>;
  /** fetch data from the table: "chat.Message" */
  readonly chat_Message: ReadonlyArray<Chat_Message>;
  /** fetch data from the table: "chat.MessageType" */
  readonly chat_MessageType: ReadonlyArray<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.MessageType" */
  readonly chat_MessageType_aggregate: Chat_MessageType_Aggregate;
  /** fetch data from the table: "chat.MessageType" using primary key columns */
  readonly chat_MessageType_by_pk?: Maybe<Chat_MessageType>;
  /** fetch aggregated fields from the table: "chat.Message" */
  readonly chat_Message_aggregate: Chat_Message_Aggregate;
  /** fetch data from the table: "chat.Message" using primary key columns */
  readonly chat_Message_by_pk?: Maybe<Chat_Message>;
  /** fetch data from the table: "chat.Pin" */
  readonly chat_Pin: ReadonlyArray<Chat_Pin>;
  /** fetch aggregated fields from the table: "chat.Pin" */
  readonly chat_Pin_aggregate: Chat_Pin_Aggregate;
  /** fetch data from the table: "chat.Pin" using primary key columns */
  readonly chat_Pin_by_pk?: Maybe<Chat_Pin>;
  /** fetch data from the table: "chat.Reaction" */
  readonly chat_Reaction: ReadonlyArray<Chat_Reaction>;
  /** fetch data from the table: "chat.ReactionType" */
  readonly chat_ReactionType: ReadonlyArray<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.ReactionType" */
  readonly chat_ReactionType_aggregate: Chat_ReactionType_Aggregate;
  /** fetch data from the table: "chat.ReactionType" using primary key columns */
  readonly chat_ReactionType_by_pk?: Maybe<Chat_ReactionType>;
  /** fetch aggregated fields from the table: "chat.Reaction" */
  readonly chat_Reaction_aggregate: Chat_Reaction_Aggregate;
  /** fetch data from the table: "chat.Reaction" using primary key columns */
  readonly chat_Reaction_by_pk?: Maybe<Chat_Reaction>;
  /** fetch data from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex: ReadonlyArray<Chat_ReadUpToIndex>;
  /** fetch aggregated fields from the table: "chat.ReadUpToIndex" */
  readonly chat_ReadUpToIndex_aggregate: Chat_ReadUpToIndex_Aggregate;
  /** fetch data from the table: "chat.ReadUpToIndex" using primary key columns */
  readonly chat_ReadUpToIndex_by_pk?: Maybe<Chat_ReadUpToIndex>;
  /** fetch data from the table: "chat.Subscription" */
  readonly chat_Subscription: ReadonlyArray<Chat_Subscription>;
  /** fetch aggregated fields from the table: "chat.Subscription" */
  readonly chat_Subscription_aggregate: Chat_Subscription_Aggregate;
  /** fetch data from the table: "chat.Subscription" using primary key columns */
  readonly chat_Subscription_by_pk?: Maybe<Chat_Subscription>;
  /** perform the action: "echo" */
  readonly echo?: Maybe<EchoOutput>;
  /** perform the action: "getContentItem" */
  readonly getContentItem?: Maybe<ReadonlyArray<Maybe<GetContentItemOutput>>>;
  /** perform the action: "getUploadAgreement" */
  readonly getUploadAgreement?: Maybe<GetUploadAgreementOutput>;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob: ReadonlyArray<Job_Queues_ChannelStackCreateJob>;
  /** fetch aggregated fields from the table: "job_queues.ChannelStackCreateJob" */
  readonly job_queues_ChannelStackCreateJob_aggregate: Job_Queues_ChannelStackCreateJob_Aggregate;
  /** fetch data from the table: "job_queues.ChannelStackCreateJob" using primary key columns */
  readonly job_queues_ChannelStackCreateJob_by_pk?: Maybe<Job_Queues_ChannelStackCreateJob>;
  /** fetch data from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob: ReadonlyArray<Job_Queues_CombineVideosJob>;
  /** fetch aggregated fields from the table: "job_queues.CombineVideosJob" */
  readonly job_queues_CombineVideosJob_aggregate: Job_Queues_CombineVideosJob_Aggregate;
  /** fetch data from the table: "job_queues.CombineVideosJob" using primary key columns */
  readonly job_queues_CombineVideosJob_by_pk?: Maybe<Job_Queues_CombineVideosJob>;
  /** fetch data from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob: ReadonlyArray<Job_Queues_CustomEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.CustomEmailJob" */
  readonly job_queues_CustomEmailJob_aggregate: Job_Queues_CustomEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.CustomEmailJob" using primary key columns */
  readonly job_queues_CustomEmailJob_by_pk?: Maybe<Job_Queues_CustomEmailJob>;
  /** fetch data from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob: ReadonlyArray<Job_Queues_InvitationEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.InvitationEmailJob" */
  readonly job_queues_InvitationEmailJob_aggregate: Job_Queues_InvitationEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.InvitationEmailJob" using primary key columns */
  readonly job_queues_InvitationEmailJob_by_pk?: Maybe<Job_Queues_InvitationEmailJob>;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob: ReadonlyArray<Job_Queues_MediaPackageHarvestJob>;
  /** fetch aggregated fields from the table: "job_queues.MediaPackageHarvestJob" */
  readonly job_queues_MediaPackageHarvestJob_aggregate: Job_Queues_MediaPackageHarvestJob_Aggregate;
  /** fetch data from the table: "job_queues.MediaPackageHarvestJob" using primary key columns */
  readonly job_queues_MediaPackageHarvestJob_by_pk?: Maybe<Job_Queues_MediaPackageHarvestJob>;
  /** fetch data from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob: ReadonlyArray<Job_Queues_PublishVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.PublishVideoJob" */
  readonly job_queues_PublishVideoJob_aggregate: Job_Queues_PublishVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.PublishVideoJob" using primary key columns */
  readonly job_queues_PublishVideoJob_by_pk?: Maybe<Job_Queues_PublishVideoJob>;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch aggregated fields from the table: "job_queues.SubmissionRequestEmailJob" */
  readonly job_queues_SubmissionRequestEmailJob_aggregate: Job_Queues_SubmissionRequestEmailJob_Aggregate;
  /** fetch data from the table: "job_queues.SubmissionRequestEmailJob" using primary key columns */
  readonly job_queues_SubmissionRequestEmailJob_by_pk?: Maybe<Job_Queues_SubmissionRequestEmailJob>;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob>;
  /** fetch aggregated fields from the table: "job_queues.UploadYouTubeVideoJob" */
  readonly job_queues_UploadYouTubeVideoJob_aggregate: Job_Queues_UploadYouTubeVideoJob_Aggregate;
  /** fetch data from the table: "job_queues.UploadYouTubeVideoJob" using primary key columns */
  readonly job_queues_UploadYouTubeVideoJob_by_pk?: Maybe<Job_Queues_UploadYouTubeVideoJob>;
  /** perform the action: "presence_Summary" */
  readonly presence_Summary?: Maybe<PresenceSummaryOutput>;
  /** perform the action: "protectedEcho" */
  readonly protectedEcho?: Maybe<ProtectedEchoOutput>;
  /** fetch data from the table: "room.RoomChimeMeeting" */
  readonly room_RoomChimeMeeting: ReadonlyArray<Room_RoomChimeMeeting>;
  /** fetch aggregated fields from the table: "room.RoomChimeMeeting" */
  readonly room_RoomChimeMeeting_aggregate: Room_RoomChimeMeeting_Aggregate;
  /** fetch data from the table: "room.RoomChimeMeeting" using primary key columns */
  readonly room_RoomChimeMeeting_by_pk?: Maybe<Room_RoomChimeMeeting>;
  /** fetch data from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm: ReadonlyArray<Room_ShuffleAlgorithm>;
  /** fetch aggregated fields from the table: "room.ShuffleAlgorithm" */
  readonly room_ShuffleAlgorithm_aggregate: Room_ShuffleAlgorithm_Aggregate;
  /** fetch data from the table: "room.ShuffleAlgorithm" using primary key columns */
  readonly room_ShuffleAlgorithm_by_pk?: Maybe<Room_ShuffleAlgorithm>;
  /** fetch data from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod: ReadonlyArray<Room_ShufflePeriod>;
  /** fetch aggregated fields from the table: "room.ShufflePeriod" */
  readonly room_ShufflePeriod_aggregate: Room_ShufflePeriod_Aggregate;
  /** fetch data from the table: "room.ShufflePeriod" using primary key columns */
  readonly room_ShufflePeriod_by_pk?: Maybe<Room_ShufflePeriod>;
  /** fetch data from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry: ReadonlyArray<Room_ShuffleQueueEntry>;
  /** fetch aggregated fields from the table: "room.ShuffleQueueEntry" */
  readonly room_ShuffleQueueEntry_aggregate: Room_ShuffleQueueEntry_Aggregate;
  /** fetch data from the table: "room.ShuffleQueueEntry" using primary key columns */
  readonly room_ShuffleQueueEntry_by_pk?: Maybe<Room_ShuffleQueueEntry>;
  /** fetch data from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom: ReadonlyArray<Room_ShuffleRoom>;
  /** fetch aggregated fields from the table: "room.ShuffleRoom" */
  readonly room_ShuffleRoom_aggregate: Room_ShuffleRoom_Aggregate;
  /** fetch data from the table: "room.ShuffleRoom" using primary key columns */
  readonly room_ShuffleRoom_by_pk?: Maybe<Room_ShuffleRoom>;
  /** fetch data from the table: "room.VideoRoomBackend" */
  readonly room_VideoRoomBackend: ReadonlyArray<Room_VideoRoomBackend>;
  /** fetch aggregated fields from the table: "room.VideoRoomBackend" */
  readonly room_VideoRoomBackend_aggregate: Room_VideoRoomBackend_Aggregate;
  /** fetch data from the table: "room.VideoRoomBackend" using primary key columns */
  readonly room_VideoRoomBackend_by_pk?: Maybe<Room_VideoRoomBackend>;
  /** fetch data from the table: "system.Configuration" */
  readonly system_Configuration: ReadonlyArray<System_Configuration>;
  /** fetch data from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey: ReadonlyArray<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.ConfigurationKey" */
  readonly system_ConfigurationKey_aggregate: System_ConfigurationKey_Aggregate;
  /** fetch data from the table: "system.ConfigurationKey" using primary key columns */
  readonly system_ConfigurationKey_by_pk?: Maybe<System_ConfigurationKey>;
  /** fetch aggregated fields from the table: "system.Configuration" */
  readonly system_Configuration_aggregate: System_Configuration_Aggregate;
  /** fetch data from the table: "system.Configuration" using primary key columns */
  readonly system_Configuration_by_pk?: Maybe<System_Configuration>;
  /** perform the action: "vapidPublicKey" */
  readonly vapidPublicKey: VapidPublicKeyOutput;
};


/** subscription root */
export type Subscription_RootAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeGoogleAccountArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Order_By>>;
  where?: Maybe<AttendeeGoogleAccount_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeGoogleAccount_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeGoogleAccount_Order_By>>;
  where?: Maybe<AttendeeGoogleAccount_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeGoogleAccount_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAttendeeProfileArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeProfileBadgesArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfileBadges_Order_By>>;
  where?: Maybe<AttendeeProfileBadges_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeProfileBadges_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfileBadges_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfileBadges_Order_By>>;
  where?: Maybe<AttendeeProfileBadges_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeProfile_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<AttendeeProfile_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<AttendeeProfile_Order_By>>;
  where?: Maybe<AttendeeProfile_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendeeProfile_By_PkArgs = {
  attendeeId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Attendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Attendee_Order_By>>;
  where?: Maybe<Attendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootBroadcastArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcastContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcastContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<BroadcastContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<BroadcastContentItem_Order_By>>;
  where?: Maybe<BroadcastContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcastContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootBroadcast_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Broadcast_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Broadcast_Order_By>>;
  where?: Maybe<Broadcast_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootBroadcast_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConferenceArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceConfiguration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceConfiguration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceConfiguration_Order_By>>;
  where?: Maybe<ConferenceConfiguration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceConfiguration_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConferenceDemoCodeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceDemoCode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferenceDemoCode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferenceDemoCode_Order_By>>;
  where?: Maybe<ConferenceDemoCode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferenceDemoCode_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConferencePrepareJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferencePrepareJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ConferencePrepareJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ConferencePrepareJob_Order_By>>;
  where?: Maybe<ConferencePrepareJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConferencePrepareJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootConference_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Conference_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Conference_Order_By>>;
  where?: Maybe<Conference_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootConference_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupHallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupHallway_Order_By>>;
  where?: Maybe<ContentGroupHallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupPerson_Order_By>>;
  where?: Maybe<ContentGroupPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupTag_Order_By>>;
  where?: Maybe<ContentGroupTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentGroupTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroupType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroupType_Order_By>>;
  where?: Maybe<ContentGroupType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroupType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootContentGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentGroup_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentGroup_Order_By>>;
  where?: Maybe<ContentGroup_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentItem_Order_By>>;
  where?: Maybe<ContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentPerson_Order_By>>;
  where?: Maybe<ContentPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootContentTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ContentType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ContentType_Order_By>>;
  where?: Maybe<ContentType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootContentType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootEmailArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEmail_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Email_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Email_Order_By>>;
  where?: Maybe<Email_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEmail_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventParticipantStreamArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventParticipantStream_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventParticipantStream_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventParticipantStream_Order_By>>;
  where?: Maybe<EventParticipantStream_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventParticipantStream_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPersonRole_Order_By>>;
  where?: Maybe<EventPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootEventPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventPerson_Order_By>>;
  where?: Maybe<EventPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventRoomJoinRequestArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventRoomJoinRequest_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventRoomJoinRequest_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventRoomJoinRequest_Order_By>>;
  where?: Maybe<EventRoomJoinRequest_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventRoomJoinRequest_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventTag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventTag_Order_By>>;
  where?: Maybe<EventTag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEventVonageSessionArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventVonageSession_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<EventVonageSession_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<EventVonageSession_Order_By>>;
  where?: Maybe<EventVonageSession_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEventVonageSession_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEvent_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Event_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Event_Order_By>>;
  where?: Maybe<Event_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootEvent_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootExecutedTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootExecutedTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<ExecutedTransitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<ExecutedTransitions_Order_By>>;
  where?: Maybe<ExecutedTransitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootExecutedTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootFlatUnauthPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUnauthPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUnauthPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUnauthPermission_Order_By>>;
  where?: Maybe<FlatUnauthPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUserPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootFlatUserPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<FlatUserPermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<FlatUserPermission_Order_By>>;
  where?: Maybe<FlatUserPermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupAttendeeArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupAttendee_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupAttendee_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupAttendee_Order_By>>;
  where?: Maybe<GroupAttendee_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupAttendee_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootGroupRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<GroupRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<GroupRole_Order_By>>;
  where?: Maybe<GroupRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroupRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootGroup_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Group_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Group_Order_By>>;
  where?: Maybe<Group_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootGroup_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootHallwayArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootHallway_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Hallway_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Hallway_Order_By>>;
  where?: Maybe<Hallway_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootHallway_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootInputTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInputType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<InputType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<InputType_Order_By>>;
  where?: Maybe<InputType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInputType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootInvitationArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInvitation_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Invitation_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Invitation_Order_By>>;
  where?: Maybe<Invitation_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootInvitation_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJobStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJobStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<JobStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<JobStatus_Order_By>>;
  where?: Maybe<JobStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJobStatus_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootMediaLiveChannelArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootMediaLiveChannel_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<MediaLiveChannel_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<MediaLiveChannel_Order_By>>;
  where?: Maybe<MediaLiveChannel_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootMediaLiveChannel_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootOnlineStatusArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOnlineStatus_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OnlineStatus_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OnlineStatus_Order_By>>;
  where?: Maybe<OnlineStatus_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOnlineStatus_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootOriginatingDataArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOriginatingData_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<OriginatingData_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<OriginatingData_Order_By>>;
  where?: Maybe<OriginatingData_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootOriginatingData_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootPermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Permission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Permission_Order_By>>;
  where?: Maybe<Permission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPermission_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootPushNotificationSubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPushNotificationSubscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<PushNotificationSubscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<PushNotificationSubscription_Order_By>>;
  where?: Maybe<PushNotificationSubscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootPushNotificationSubscription_By_PkArgs = {
  endpoint: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRequiredContentItemArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRequiredContentItem_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RequiredContentItem_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RequiredContentItem_Order_By>>;
  where?: Maybe<RequiredContentItem_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRequiredContentItem_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRolePermissionArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRolePermission_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RolePermission_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RolePermission_Order_By>>;
  where?: Maybe<RolePermission_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRolePermission_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Role_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Role_Order_By>>;
  where?: Maybe<Role_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRole_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomModeArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomMode_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomMode_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomMode_Order_By>>;
  where?: Maybe<RoomMode_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomMode_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoomParticipantArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomParticipant_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomParticipant_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomParticipant_Order_By>>;
  where?: Maybe<RoomParticipant_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomParticipant_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoomPersonArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPersonRoleArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPersonRole_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPersonRole_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPersonRole_Order_By>>;
  where?: Maybe<RoomPersonRole_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPersonRole_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoomPerson_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPerson_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPerson_Order_By>>;
  where?: Maybe<RoomPerson_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPerson_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoomPrivacyArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPrivacy_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<RoomPrivacy_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<RoomPrivacy_Order_By>>;
  where?: Maybe<RoomPrivacy_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoomPrivacy_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_Order_By>>;
  where?: Maybe<Room_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootTagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Tag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Tag_Order_By>>;
  where?: Maybe<Tag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTag_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootTranscriptionJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTranscriptionJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<TranscriptionJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<TranscriptionJob_Order_By>>;
  where?: Maybe<TranscriptionJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTranscriptionJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootTransitionsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTransitions_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Transitions_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Transitions_Order_By>>;
  where?: Maybe<Transitions_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootTransitions_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootUploaderArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUploader_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Uploader_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Uploader_Order_By>>;
  where?: Maybe<Uploader_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUploader_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootUserArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUser_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<User_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<User_Order_By>>;
  where?: Maybe<User_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootUser_By_PkArgs = {
  id: Scalars['String'];
};


/** subscription root */
export type Subscription_RootVideoRenderJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideoRenderJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<VideoRenderJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<VideoRenderJob_Order_By>>;
  where?: Maybe<VideoRenderJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootVideoRenderJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootYouTubeUploadArgs = {
  distinct_on?: Maybe<ReadonlyArray<YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<YouTubeUpload_Order_By>>;
  where?: Maybe<YouTubeUpload_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootYouTubeUpload_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<YouTubeUpload_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<YouTubeUpload_Order_By>>;
  where?: Maybe<YouTubeUpload_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootYouTubeUpload_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAnalytics_AppStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_AppStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_AppStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_AppStats_Order_By>>;
  where?: Maybe<Analytics_AppStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_AppStats_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootAnalytics_ContentGroupStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Order_By>>;
  where?: Maybe<Analytics_ContentGroupStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentGroupStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentGroupStats_Order_By>>;
  where?: Maybe<Analytics_ContentGroupStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentGroupStats_By_PkArgs = {
  contentGroupId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAnalytics_ContentItemStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentItemStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_ContentItemStats_Order_By>>;
  where?: Maybe<Analytics_ContentItemStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_ContentItemStats_By_PkArgs = {
  contentItemId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootAnalytics_RoomStatsArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_RoomStats_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Analytics_RoomStats_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Analytics_RoomStats_Order_By>>;
  where?: Maybe<Analytics_RoomStats_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootAnalytics_RoomStats_By_PkArgs = {
  roomId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ChatArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Chat_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Chat_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Chat_Order_By>>;
  where?: Maybe<Chat_Chat_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Chat_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_FlagArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_FlagType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_FlagType_Order_By>>;
  where?: Maybe<Chat_FlagType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_FlagType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Flag_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Flag_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Flag_Order_By>>;
  where?: Maybe<Chat_Flag_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Flag_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootChat_MessageArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_MessageType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_MessageType_Order_By>>;
  where?: Maybe<Chat_MessageType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_MessageType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Message_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Message_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Message_Order_By>>;
  where?: Maybe<Chat_Message_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Message_By_PkArgs = {
  id: Scalars['Int'];
};


/** subscription root */
export type Subscription_RootChat_PinArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Pin_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Pin_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Pin_Order_By>>;
  where?: Maybe<Chat_Pin_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Pin_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ReactionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionTypeArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionType_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReactionType_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReactionType_Order_By>>;
  where?: Maybe<Chat_ReactionType_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReactionType_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootChat_Reaction_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Reaction_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Reaction_Order_By>>;
  where?: Maybe<Chat_Reaction_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Reaction_By_PkArgs = {
  sId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndexArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndex_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_ReadUpToIndex_Order_By>>;
  where?: Maybe<Chat_ReadUpToIndex_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_ReadUpToIndex_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootChat_SubscriptionArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Subscription_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Chat_Subscription_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Chat_Subscription_Order_By>>;
  where?: Maybe<Chat_Subscription_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootChat_Subscription_By_PkArgs = {
  attendeeId: Scalars['uuid'];
  chatId: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootEchoArgs = {
  message: Scalars['String'];
};


/** subscription root */
export type Subscription_RootGetContentItemArgs = {
  magicToken: Scalars['String'];
};


/** subscription root */
export type Subscription_RootGetUploadAgreementArgs = {
  magicToken: Scalars['String'];
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackCreateJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackCreateJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_ChannelStackCreateJob_Order_By>>;
  where?: Maybe<Job_Queues_ChannelStackCreateJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_ChannelStackCreateJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_CombineVideosJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CombineVideosJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CombineVideosJob_Order_By>>;
  where?: Maybe<Job_Queues_CombineVideosJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CombineVideosJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_CustomEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CustomEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_CustomEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_CustomEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_CustomEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_InvitationEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_InvitationEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_InvitationEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_MediaPackageHarvestJob_Order_By>>;
  where?: Maybe<Job_Queues_MediaPackageHarvestJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_MediaPackageHarvestJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_PublishVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_PublishVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_PublishVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Order_By>>;
  where?: Maybe<Job_Queues_SubmissionRequestEmailJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_SubmissionRequestEmailJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootJob_Queues_UploadYouTubeVideoJobArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_UploadYouTubeVideoJob_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Order_By>>;
  where?: Maybe<Job_Queues_UploadYouTubeVideoJob_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootJob_Queues_UploadYouTubeVideoJob_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootProtectedEchoArgs = {
  message: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_RoomChimeMeetingArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Order_By>>;
  where?: Maybe<Room_RoomChimeMeeting_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_RoomChimeMeeting_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_RoomChimeMeeting_Order_By>>;
  where?: Maybe<Room_RoomChimeMeeting_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_RoomChimeMeeting_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleAlgorithmArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleAlgorithm_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleAlgorithm_Order_By>>;
  where?: Maybe<Room_ShuffleAlgorithm_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleAlgorithm_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriodArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriod_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShufflePeriod_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShufflePeriod_Order_By>>;
  where?: Maybe<Room_ShufflePeriod_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShufflePeriod_By_PkArgs = {
  id: Scalars['uuid'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntryArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntry_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleQueueEntry_Order_By>>;
  where?: Maybe<Room_ShuffleQueueEntry_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleQueueEntry_By_PkArgs = {
  id: Scalars['bigint'];
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoomArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoom_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_ShuffleRoom_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_ShuffleRoom_Order_By>>;
  where?: Maybe<Room_ShuffleRoom_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_ShuffleRoom_By_PkArgs = {
  id: Scalars['bigint'];
};


/** subscription root */
export type Subscription_RootRoom_VideoRoomBackendArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Order_By>>;
  where?: Maybe<Room_VideoRoomBackend_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_VideoRoomBackend_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<Room_VideoRoomBackend_Order_By>>;
  where?: Maybe<Room_VideoRoomBackend_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootRoom_VideoRoomBackend_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationKeyArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationKey_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_ConfigurationKey_Order_By>>;
  where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_ConfigurationKey_By_PkArgs = {
  name: Scalars['String'];
};


/** subscription root */
export type Subscription_RootSystem_Configuration_AggregateArgs = {
  distinct_on?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  limit?: Maybe<Scalars['Int']>;
  offset?: Maybe<Scalars['Int']>;
  order_by?: Maybe<ReadonlyArray<System_Configuration_Order_By>>;
  where?: Maybe<System_Configuration_Bool_Exp>;
};


/** subscription root */
export type Subscription_RootSystem_Configuration_By_PkArgs = {
  key: System_ConfigurationKey_Enum;
};

/** columns and relationships of "system.Configuration" */
export type System_Configuration = {
  readonly __typename?: 'system_Configuration';
  readonly created_at: Scalars['timestamptz'];
  readonly key: System_ConfigurationKey_Enum;
  readonly updated_at: Scalars['timestamptz'];
  readonly value: Scalars['jsonb'];
};


/** columns and relationships of "system.Configuration" */
export type System_ConfigurationValueArgs = {
  path?: Maybe<Scalars['String']>;
};

/** columns and relationships of "system.ConfigurationKey" */
export type System_ConfigurationKey = {
  readonly __typename?: 'system_ConfigurationKey';
  readonly description?: Maybe<Scalars['String']>;
  readonly name: Scalars['String'];
};

/** aggregated selection of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate = {
  readonly __typename?: 'system_ConfigurationKey_aggregate';
  readonly aggregate?: Maybe<System_ConfigurationKey_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<System_ConfigurationKey>;
};

/** aggregate fields of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_Fields = {
  readonly __typename?: 'system_ConfigurationKey_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<System_ConfigurationKey_Max_Fields>;
  readonly min?: Maybe<System_ConfigurationKey_Min_Fields>;
};


/** aggregate fields of "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<System_ConfigurationKey_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "system.ConfigurationKey" */
export type System_ConfigurationKey_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<System_ConfigurationKey_Max_Order_By>;
  readonly min?: Maybe<System_ConfigurationKey_Min_Order_By>;
};

/** input type for inserting array relation for remote table "system.ConfigurationKey" */
export type System_ConfigurationKey_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<System_ConfigurationKey_Insert_Input>;
  readonly on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};

/** Boolean expression to filter rows from the table "system.ConfigurationKey". All fields are combined with a logical 'AND'. */
export type System_ConfigurationKey_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<System_ConfigurationKey_Bool_Exp>>>;
  readonly _not?: Maybe<System_ConfigurationKey_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<System_ConfigurationKey_Bool_Exp>>>;
  readonly description?: Maybe<String_Comparison_Exp>;
  readonly name?: Maybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Constraint {
  /** unique or primary key constraint */
  ConfigurationKeyPkey = 'ConfigurationKey_pkey'
}

export enum System_ConfigurationKey_Enum {
  /** The time of the latest revision of the host cookie policy. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  CookiePolicyLatestRevisionTimestamp = 'COOKIE_POLICY_LATEST_REVISION_TIMESTAMP',
  /** The URL to the host cookie policy. Note: If self hosting Clowdr, this must be your organisation's cookie policy - you cannot legally reuse, rely on or copy Clowdr's cookie policy. */
  CookiePolicyUrl = 'COOKIE_POLICY_URL',
  /** Default backend platform for video rooms */
  DefaultVideoRoomBackend = 'DEFAULT_VIDEO_ROOM_BACKEND',
  /** The name of the organisation legally responsible for hosting this instance of the Clowdr software. */
  HostOrganisationName = 'HOST_ORGANISATION_NAME',
  /** The time of the latest revision of the host Privacy Policy. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  PrivacyPolicyLatestRevisionTimestamp = 'PRIVACY_POLICY_LATEST_REVISION_TIMESTAMP',
  /** URL to the host Privacy Policy. Note: If self hosting Clowdr, this must be your organisation's privacy policy - you cannot legally reuse, rely on or copy Clowdr's privacy policy. */
  PrivacyPolicyUrl = 'PRIVACY_POLICY_URL',
  /** The time of the latest revision of the host T&Cs. The value should be a Number representing the milliseconds elapsed since the UNIX epoch. */
  TermsLatestRevisionTimestamp = 'TERMS_LATEST_REVISION_TIMESTAMP',
  /** URL to the host T&Cs. Note: If self hosting Clowdr, this must be your organisation's terms - you cannot legally reuse, rely on or copy Clowdr's terms. */
  TermsUrl = 'TERMS_URL',
  /** VAPID keys are used for push notifications and are generated automatically by the realtime service on first use. */
  VapidPrivateKey = 'VAPID_PRIVATE_KEY',
  /** VAPID keys are used for push notifications and are generated automatically by the realtime service on first use. */
  VapidPublicKey = 'VAPID_PUBLIC_KEY'
}

/** expression to compare columns of type system_ConfigurationKey_enum. All fields are combined with logical 'AND'. */
export type System_ConfigurationKey_Enum_Comparison_Exp = {
  readonly _eq?: Maybe<System_ConfigurationKey_Enum>;
  readonly _in?: Maybe<ReadonlyArray<System_ConfigurationKey_Enum>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _neq?: Maybe<System_ConfigurationKey_Enum>;
  readonly _nin?: Maybe<ReadonlyArray<System_ConfigurationKey_Enum>>;
};

/** input type for inserting data into table "system.ConfigurationKey" */
export type System_ConfigurationKey_Insert_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** aggregate max on columns */
export type System_ConfigurationKey_Max_Fields = {
  readonly __typename?: 'system_ConfigurationKey_max_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by max() on columns of table "system.ConfigurationKey" */
export type System_ConfigurationKey_Max_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type System_ConfigurationKey_Min_Fields = {
  readonly __typename?: 'system_ConfigurationKey_min_fields';
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** order by min() on columns of table "system.ConfigurationKey" */
export type System_ConfigurationKey_Min_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** response of any mutation on the table "system.ConfigurationKey" */
export type System_ConfigurationKey_Mutation_Response = {
  readonly __typename?: 'system_ConfigurationKey_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<System_ConfigurationKey>;
};

/** input type for inserting object relation for remote table "system.ConfigurationKey" */
export type System_ConfigurationKey_Obj_Rel_Insert_Input = {
  readonly data: System_ConfigurationKey_Insert_Input;
  readonly on_conflict?: Maybe<System_ConfigurationKey_On_Conflict>;
};

/** on conflict condition type for table "system.ConfigurationKey" */
export type System_ConfigurationKey_On_Conflict = {
  readonly constraint: System_ConfigurationKey_Constraint;
  readonly update_columns: ReadonlyArray<System_ConfigurationKey_Update_Column>;
  readonly where?: Maybe<System_ConfigurationKey_Bool_Exp>;
};

/** ordering options when selecting data from "system.ConfigurationKey" */
export type System_ConfigurationKey_Order_By = {
  readonly description?: Maybe<Order_By>;
  readonly name?: Maybe<Order_By>;
};

/** primary key columns input for table: "system.ConfigurationKey" */
export type System_ConfigurationKey_Pk_Columns_Input = {
  readonly name: Scalars['String'];
};

/** select columns of table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Select_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** input type for updating data in table "system.ConfigurationKey" */
export type System_ConfigurationKey_Set_Input = {
  readonly description?: Maybe<Scalars['String']>;
  readonly name?: Maybe<Scalars['String']>;
};

/** update columns of table "system.ConfigurationKey" */
export enum System_ConfigurationKey_Update_Column {
  /** column name */
  Description = 'description',
  /** column name */
  Name = 'name'
}

/** aggregated selection of "system.Configuration" */
export type System_Configuration_Aggregate = {
  readonly __typename?: 'system_Configuration_aggregate';
  readonly aggregate?: Maybe<System_Configuration_Aggregate_Fields>;
  readonly nodes: ReadonlyArray<System_Configuration>;
};

/** aggregate fields of "system.Configuration" */
export type System_Configuration_Aggregate_Fields = {
  readonly __typename?: 'system_Configuration_aggregate_fields';
  readonly count?: Maybe<Scalars['Int']>;
  readonly max?: Maybe<System_Configuration_Max_Fields>;
  readonly min?: Maybe<System_Configuration_Min_Fields>;
};


/** aggregate fields of "system.Configuration" */
export type System_Configuration_Aggregate_FieldsCountArgs = {
  columns?: Maybe<ReadonlyArray<System_Configuration_Select_Column>>;
  distinct?: Maybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "system.Configuration" */
export type System_Configuration_Aggregate_Order_By = {
  readonly count?: Maybe<Order_By>;
  readonly max?: Maybe<System_Configuration_Max_Order_By>;
  readonly min?: Maybe<System_Configuration_Min_Order_By>;
};

/** append existing jsonb value of filtered columns with new jsonb value */
export type System_Configuration_Append_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** input type for inserting array relation for remote table "system.Configuration" */
export type System_Configuration_Arr_Rel_Insert_Input = {
  readonly data: ReadonlyArray<System_Configuration_Insert_Input>;
  readonly on_conflict?: Maybe<System_Configuration_On_Conflict>;
};

/** Boolean expression to filter rows from the table "system.Configuration". All fields are combined with a logical 'AND'. */
export type System_Configuration_Bool_Exp = {
  readonly _and?: Maybe<ReadonlyArray<Maybe<System_Configuration_Bool_Exp>>>;
  readonly _not?: Maybe<System_Configuration_Bool_Exp>;
  readonly _or?: Maybe<ReadonlyArray<Maybe<System_Configuration_Bool_Exp>>>;
  readonly created_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly key?: Maybe<System_ConfigurationKey_Enum_Comparison_Exp>;
  readonly updated_at?: Maybe<Timestamptz_Comparison_Exp>;
  readonly value?: Maybe<Jsonb_Comparison_Exp>;
};

/** unique or primary key constraints on table "system.Configuration" */
export enum System_Configuration_Constraint {
  /** unique or primary key constraint */
  ConfigurationPkey = 'Configuration_pkey'
}

/** delete the field or element with specified path (for JSON arrays, negative integers count from the end) */
export type System_Configuration_Delete_At_Path_Input = {
  readonly value?: Maybe<ReadonlyArray<Maybe<Scalars['String']>>>;
};

/** delete the array element with specified index (negative integers count from the end). throws an error if top level container is not an array */
export type System_Configuration_Delete_Elem_Input = {
  readonly value?: Maybe<Scalars['Int']>;
};

/** delete key/value pair or string element. key/value pairs are matched based on their key value */
export type System_Configuration_Delete_Key_Input = {
  readonly value?: Maybe<Scalars['String']>;
};

/** input type for inserting data into table "system.Configuration" */
export type System_Configuration_Insert_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<System_ConfigurationKey_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** aggregate max on columns */
export type System_Configuration_Max_Fields = {
  readonly __typename?: 'system_Configuration_max_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by max() on columns of table "system.Configuration" */
export type System_Configuration_Max_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** aggregate min on columns */
export type System_Configuration_Min_Fields = {
  readonly __typename?: 'system_Configuration_min_fields';
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
};

/** order by min() on columns of table "system.Configuration" */
export type System_Configuration_Min_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
};

/** response of any mutation on the table "system.Configuration" */
export type System_Configuration_Mutation_Response = {
  readonly __typename?: 'system_Configuration_mutation_response';
  /** number of affected rows by the mutation */
  readonly affected_rows: Scalars['Int'];
  /** data of the affected rows by the mutation */
  readonly returning: ReadonlyArray<System_Configuration>;
};

/** input type for inserting object relation for remote table "system.Configuration" */
export type System_Configuration_Obj_Rel_Insert_Input = {
  readonly data: System_Configuration_Insert_Input;
  readonly on_conflict?: Maybe<System_Configuration_On_Conflict>;
};

/** on conflict condition type for table "system.Configuration" */
export type System_Configuration_On_Conflict = {
  readonly constraint: System_Configuration_Constraint;
  readonly update_columns: ReadonlyArray<System_Configuration_Update_Column>;
  readonly where?: Maybe<System_Configuration_Bool_Exp>;
};

/** ordering options when selecting data from "system.Configuration" */
export type System_Configuration_Order_By = {
  readonly created_at?: Maybe<Order_By>;
  readonly key?: Maybe<Order_By>;
  readonly updated_at?: Maybe<Order_By>;
  readonly value?: Maybe<Order_By>;
};

/** primary key columns input for table: "system.Configuration" */
export type System_Configuration_Pk_Columns_Input = {
  readonly key: System_ConfigurationKey_Enum;
};

/** prepend existing jsonb value of filtered columns with new jsonb value */
export type System_Configuration_Prepend_Input = {
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** select columns of table "system.Configuration" */
export enum System_Configuration_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}

/** input type for updating data in table "system.Configuration" */
export type System_Configuration_Set_Input = {
  readonly created_at?: Maybe<Scalars['timestamptz']>;
  readonly key?: Maybe<System_ConfigurationKey_Enum>;
  readonly updated_at?: Maybe<Scalars['timestamptz']>;
  readonly value?: Maybe<Scalars['jsonb']>;
};

/** update columns of table "system.Configuration" */
export enum System_Configuration_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Key = 'key',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  Value = 'value'
}


/** expression to compare columns of type timestamptz. All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['timestamptz']>;
  readonly _gt?: Maybe<Scalars['timestamptz']>;
  readonly _gte?: Maybe<Scalars['timestamptz']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['timestamptz']>;
  readonly _lte?: Maybe<Scalars['timestamptz']>;
  readonly _neq?: Maybe<Scalars['timestamptz']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['timestamptz']>>;
};


/** expression to compare columns of type uuid. All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  readonly _eq?: Maybe<Scalars['uuid']>;
  readonly _gt?: Maybe<Scalars['uuid']>;
  readonly _gte?: Maybe<Scalars['uuid']>;
  readonly _in?: Maybe<ReadonlyArray<Scalars['uuid']>>;
  readonly _is_null?: Maybe<Scalars['Boolean']>;
  readonly _lt?: Maybe<Scalars['uuid']>;
  readonly _lte?: Maybe<Scalars['uuid']>;
  readonly _neq?: Maybe<Scalars['uuid']>;
  readonly _nin?: Maybe<ReadonlyArray<Scalars['uuid']>>;
};

export type ChatState_SubdMessageFragment = { readonly __typename?: 'chat_Message', readonly id: number, readonly chatId: any, readonly message: string, readonly type: Chat_MessageType_Enum, readonly senderId?: Maybe<any> };

export type InitialChatState_ChatFragment = { readonly __typename?: 'chat_Chat', readonly id: any, readonly enableAutoPin: boolean, readonly enableAutoSubscribe: boolean, readonly enableMandatoryPin: boolean, readonly enableMandatorySubscribe: boolean, readonly contentGroup: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string> }>, readonly nonDMRoom: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly priority: number, readonly roomPrivacyName: RoomPrivacy_Enum }>, readonly DMRoom: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'RoomPerson', readonly id: any, readonly attendee: { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string } }> }>, readonly pins: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly attendeeId: any, readonly chatId: any, readonly wasManuallyPinned: boolean }>, readonly subscriptions: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly attendeeId: any, readonly chatId: any, readonly wasManuallySubscribed: boolean }> };

export type InitialChatStateQueryVariables = Exact<{
  attendeeId: Scalars['uuid'];
}>;


export type InitialChatStateQuery = { readonly __typename?: 'query_root', readonly chat_Pin: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly chatId: any, readonly attendeeId: any, readonly chat: (
      { readonly __typename?: 'chat_Chat' }
      & InitialChatState_ChatFragment
    ) }> };

export type SelectInitialChatStateQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type SelectInitialChatStateQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<(
    { readonly __typename?: 'chat_Chat' }
    & InitialChatState_ChatFragment
  )> };

export type SelectInitialChatStatesQueryVariables = Exact<{
  chatIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type SelectInitialChatStatesQuery = { readonly __typename?: 'query_root', readonly chat_Chat: ReadonlyArray<(
    { readonly __typename?: 'chat_Chat' }
    & InitialChatState_ChatFragment
  )> };

export type SubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type SubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Subscription?: Maybe<{ readonly __typename?: 'chat_Subscription_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Subscription', readonly chatId: any, readonly attendeeId: any }> }> };

export type UnsubscribeChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type UnsubscribeChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Subscription_by_pk?: Maybe<{ readonly __typename?: 'chat_Subscription', readonly attendeeId: any, readonly chatId: any }> };

export type PinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type PinChatMutation = { readonly __typename?: 'mutation_root', readonly insert_chat_Pin?: Maybe<{ readonly __typename?: 'chat_Pin_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'chat_Pin', readonly chatId: any, readonly attendeeId: any }> }> };

export type UnpinChatMutationVariables = Exact<{
  chatId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type UnpinChatMutation = { readonly __typename?: 'mutation_root', readonly delete_chat_Pin_by_pk?: Maybe<{ readonly __typename?: 'chat_Pin', readonly attendeeId: any, readonly chatId: any }> };

export type ChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly sId: any, readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly duplicateSId?: Maybe<any>, readonly created_at: any, readonly updated_at: any, readonly chatId: any };

export type ChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly id: number, readonly sId: any, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly reactions: ReadonlyArray<(
    { readonly __typename?: 'chat_Reaction' }
    & ChatReactionDataFragment
  )> };

export type SelectMessagesPageQueryVariables = Exact<{
  chatId: Scalars['uuid'];
  startAtIndex: Scalars['Int'];
  maxCount: Scalars['Int'];
}>;


export type SelectMessagesPageQuery = { readonly __typename?: 'query_root', readonly chat_Message: ReadonlyArray<(
    { readonly __typename?: 'chat_Message' }
    & ChatMessageDataFragment
  )> };

export type ShortChatMessageDataFragment = { readonly __typename?: 'chat_Message', readonly created_at: any, readonly data: any, readonly duplicatedMessageSId?: Maybe<any>, readonly message: string, readonly senderId?: Maybe<any>, readonly type: Chat_MessageType_Enum, readonly chatId: any, readonly sId: any };

export type ShortChatReactionDataFragment = { readonly __typename?: 'chat_Reaction', readonly data: any, readonly senderId: any, readonly symbol: string, readonly type: Chat_ReactionType_Enum, readonly messageSId: any, readonly sId: any, readonly duplicateSId?: Maybe<any> };

export type GetChatPathQueryVariables = Exact<{
  chatId: Scalars['uuid'];
}>;


export type GetChatPathQuery = { readonly __typename?: 'query_root', readonly chat_Chat_by_pk?: Maybe<{ readonly __typename?: 'chat_Chat', readonly id: any, readonly room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }>, readonly contentGroup: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any }> }> };

export type SelectAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type SearchAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type SearchAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type ConferenceLandingPageContentGroupQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferenceLandingPageContentGroupQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupDataFragment
  )> };

export type ContentPersonDataFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly roleName: string, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly attendeeId?: Maybe<any> } };

export type ContentGroupRoomEventFragment = { readonly __typename?: 'Event', readonly startTime: any, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: RoomMode_Enum, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }> };

export type ContentGroupItems_GetContentGroupQueryVariables = Exact<{
  contentGroupId: Scalars['uuid'];
}>;


export type ContentGroupItems_GetContentGroupQuery = { readonly __typename?: 'query_root', readonly ContentGroup_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupItems_ContentGroupDataFragment
  )> };

export type ContentGroupItems_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly contentGroupTypeName: ContentGroupType_Enum, readonly chatId?: Maybe<any>, readonly chat?: Maybe<{ readonly __typename?: 'chat_Chat', readonly room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any, readonly name: string }> }>, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemDataFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentPersonDataFragment
  )> };

export type ContentGroupList_ContentPersonDataFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly priority?: Maybe<number>, readonly person: { readonly __typename?: 'ContentPerson', readonly id: any, readonly affiliation?: Maybe<string>, readonly name: string } };

export type ContentGroupList_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentGroupList_ContentPersonDataFragment
  )> };

export type ContentGroupList_ContentGroupTagDataFragment = { readonly __typename?: 'ContentGroupTag', readonly contentGroup: (
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupList_ContentGroupDataFragment
  ) };

export type ContentGroupList_TagInfoFragment = { readonly __typename?: 'Tag', readonly id: any, readonly colour: string, readonly name: string, readonly priority: number };

export type ContentOfTagQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type ContentOfTagQuery = { readonly __typename?: 'query_root', readonly ContentGroupTag: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupTag' }
    & ContentGroupList_ContentGroupTagDataFragment
  )> };

export type TagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type TagsQuery = { readonly __typename?: 'query_root', readonly Tag: ReadonlyArray<(
    { readonly __typename?: 'Tag' }
    & ContentGroupList_TagInfoFragment
  )> };

export type GetContentGroupQueryVariables = Exact<{
  contentGroupId: Scalars['uuid'];
}>;


export type GetContentGroupQuery = { readonly __typename?: 'query_root', readonly ContentGroup_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupDataFragment
    & ContentGroupEventsFragment
    & ContentGroupPage_ContentGroupRoomsFragment
  )> };

export type ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly contentGroupTypeName: ContentGroupType_Enum, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemDataFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentPersonDataFragment
  )> };

export type ContentGroupPage_ContentGroupRoomsFragment = { readonly __typename?: 'ContentGroup', readonly rooms: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type ContentGroupEventsFragment = { readonly __typename?: 'ContentGroup', readonly events: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & ContentGroupEventFragment
  )> };

export type ContentGroupEventFragment = { readonly __typename?: 'Event', readonly startTime: any, readonly id: any, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly name: string, readonly intendedRoomModeName: RoomMode_Enum, readonly room: { readonly __typename?: 'Room', readonly name: string, readonly id: any } };

export type ContentItemDataFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly contentTypeName: ContentType_Enum };

export type HallwayContentGroupFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly contentGroupTypeName: ContentGroupType_Enum, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemDataFragment
  )>, readonly events: ReadonlyArray<{ readonly __typename?: 'Event', readonly id: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly roomId: any }>, readonly discussionRoom: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type HallwayWithContentFragment = { readonly __typename?: 'Hallway', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number, readonly conferenceId: any, readonly contentGroups: ReadonlyArray<{ readonly __typename?: 'ContentGroupHallway', readonly id: any, readonly groupId: any, readonly hallwayId: any, readonly layout?: Maybe<any>, readonly priority?: Maybe<number>, readonly contentGroup: (
      { readonly __typename?: 'ContentGroup' }
      & HallwayContentGroupFragment
    ) }> };

export type SelectHallwayQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type SelectHallwayQuery = { readonly __typename?: 'query_root', readonly Hallway_by_pk?: Maybe<(
    { readonly __typename?: 'Hallway' }
    & HallwayWithContentFragment
  )> };

export type HallwaySummaryFragment = { readonly __typename?: 'Hallway', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number };

export type SelectAllHallwaysQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllHallwaysQuery = { readonly __typename?: 'query_root', readonly Hallway: ReadonlyArray<(
    { readonly __typename?: 'Hallway' }
    & HallwaySummaryFragment
  )> };

export type AttendeeByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type AttendeeByIdQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type UpdateAttendeeProfileMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  profile?: Maybe<AttendeeProfile_Set_Input>;
}>;


export type UpdateAttendeeProfileMutation = { readonly __typename?: 'mutation_root', readonly update_AttendeeProfile_by_pk?: Maybe<(
    { readonly __typename?: 'AttendeeProfile' }
    & AttendeeProfileDataFragment
  )> };

export type UpdateAttendeeDisplayNameMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type UpdateAttendeeDisplayNameMutation = { readonly __typename?: 'mutation_root', readonly update_Attendee_by_pk?: Maybe<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type SubmitProfilePhotoMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  s3URL: Scalars['String'];
}>;


export type SubmitProfilePhotoMutation = { readonly __typename?: 'mutation_root', readonly updateProfilePhoto?: Maybe<{ readonly __typename?: 'UpdateProfilePhotoResponse', readonly ok: boolean, readonly photoURL_350x350?: Maybe<string>, readonly photoURL_50x50?: Maybe<string> }> };

export type AttendeeEventsWithBackstagesQueryVariables = Exact<{
  attendeeId: Scalars['uuid'];
}>;


export type AttendeeEventsWithBackstagesQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<{ readonly __typename?: 'Event', readonly id: any, readonly conferenceId: any, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: RoomMode_Enum, readonly name: string, readonly startTime: any, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }>, readonly room: { readonly __typename?: 'Room', readonly id: any, readonly name: string } }> };

export type GetRoomChimeDataMutationVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomChimeDataMutation = { readonly __typename?: 'mutation_root', readonly joinRoomChimeSession?: Maybe<{ readonly __typename?: 'JoinRoomChimeSessionOutput', readonly attendee?: Maybe<any>, readonly meeting?: Maybe<any>, readonly message?: Maybe<string> }> };

export type GetRoomVonageTokenMutationVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinRoomVonageSession?: Maybe<{ readonly __typename?: 'JoinRoomVonageSessionOutput', readonly accessToken?: Maybe<string>, readonly sessionId?: Maybe<string> }> };

export type CreateDmMutationVariables = Exact<{
  attendeeIds: ReadonlyArray<Maybe<Scalars['uuid']>> | Maybe<Scalars['uuid']>;
  conferenceId: Scalars['uuid'];
}>;


export type CreateDmMutation = { readonly __typename?: 'mutation_root', readonly createRoomDm?: Maybe<{ readonly __typename?: 'CreateRoomDmOutput', readonly message?: Maybe<string>, readonly roomId?: Maybe<any>, readonly chatId?: Maybe<any> }> };

export type AttendeeCreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  name: Scalars['String'];
  roomPrivacyName: RoomPrivacy_Enum;
}>;


export type AttendeeCreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_Room_one?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomListRoomDetailsFragment
  )> };

export type UpdateEventVonageSessionLayoutMutationVariables = Exact<{
  eventVonageSessionId: Scalars['uuid'];
  layoutData: Scalars['jsonb'];
}>;


export type UpdateEventVonageSessionLayoutMutation = { readonly __typename?: 'mutation_root', readonly update_EventVonageSession_by_pk?: Maybe<{ readonly __typename?: 'EventVonageSession', readonly id: any }> };

export type DeleteEventPersonMutationVariables = Exact<{
  eventPersonId: Scalars['uuid'];
}>;


export type DeleteEventPersonMutation = { readonly __typename?: 'mutation_root', readonly delete_EventPerson_by_pk?: Maybe<{ readonly __typename?: 'EventPerson', readonly id: any }> };

export type GetEventParticipantStreamsSubscriptionVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventParticipantStreamsSubscription = { readonly __typename?: 'subscription_root', readonly EventParticipantStream: ReadonlyArray<(
    { readonly __typename?: 'EventParticipantStream' }
    & EventParticipantStreamDetailsFragment
  )> };

export type EventParticipantStreamDetailsFragment = { readonly __typename?: 'EventParticipantStream', readonly id: any, readonly conferenceId: any, readonly eventId: any, readonly vonageStreamType: string, readonly vonageStreamId: string, readonly attendeeId: any, readonly attendee: { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string } };

export type UnapprovedEventRoomJoinRequestsSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type UnapprovedEventRoomJoinRequestsSubscription = { readonly __typename?: 'subscription_root', readonly EventRoomJoinRequest: ReadonlyArray<(
    { readonly __typename?: 'EventRoomJoinRequest' }
    & EventRoomJoinRequestDetailsFragment
  )> };

export type EventRoomJoinRequestDetailsFragment = { readonly __typename?: 'EventRoomJoinRequest', readonly id: any, readonly attendeeId: any };

export type GetEventVonageTokenMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageTokenMutation = { readonly __typename?: 'mutation_root', readonly joinEventVonageSession?: Maybe<{ readonly __typename?: 'JoinEventVonageSessionOutput', readonly accessToken?: Maybe<string> }> };

export type GetEventDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventDetailsQuery = { readonly __typename?: 'query_root', readonly Event_by_pk?: Maybe<(
    { readonly __typename?: 'Event' }
    & RoomEventDetailsFragment
  )> };

export type RoomEventDetailsFragment = { readonly __typename?: 'Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly durationSeconds: number, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: RoomMode_Enum, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'EventVonageSession', readonly id: any, readonly sessionId: string }> };

export type ApproveEventRoomJoinRequestMutationVariables = Exact<{
  eventRoomJoinRequestId: Scalars['uuid'];
}>;


export type ApproveEventRoomJoinRequestMutation = { readonly __typename?: 'mutation_root', readonly update_EventRoomJoinRequest_by_pk?: Maybe<{ readonly __typename?: 'EventRoomJoinRequest', readonly id: any }> };

export type GetBreakoutRoomFromEventQueryVariables = Exact<{
  originatingEventId: Scalars['uuid'];
}>;


export type GetBreakoutRoomFromEventQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type MakeEventRoomJoinRequestMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type MakeEventRoomJoinRequestMutation = { readonly __typename?: 'mutation_root', readonly insert_EventRoomJoinRequest_one?: Maybe<{ readonly __typename?: 'EventRoomJoinRequest', readonly id: any }> };

export type MyEventRoomJoinRequestSubscriptionVariables = Exact<{
  attendeeId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  eventId: Scalars['uuid'];
}>;


export type MyEventRoomJoinRequestSubscription = { readonly __typename?: 'subscription_root', readonly EventRoomJoinRequest: ReadonlyArray<{ readonly __typename?: 'EventRoomJoinRequest', readonly id: any, readonly approved: boolean }> };

export type Room_GetEventsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
  now: Scalars['timestamptz'];
  cutoff: Scalars['timestamptz'];
}>;


export type Room_GetEventsQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & Room_EventSummaryFragment
  )> };

export type Room_EventSummaryFragment = { readonly __typename?: 'Event', readonly id: any, readonly conferenceId: any, readonly startTime: any, readonly name: string, readonly endTime?: Maybe<any>, readonly intendedRoomModeName: RoomMode_Enum, readonly contentGroupId?: Maybe<any>, readonly hallwayId?: Maybe<any>, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly contentGroupTypeName: ContentGroupType_Enum, readonly chatId?: Maybe<any>, readonly zoomItems: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly data: any }>, readonly videoItems: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly data: any }> }>, readonly eventPeople: ReadonlyArray<{ readonly __typename?: 'EventPerson', readonly id: any, readonly roleName: EventPersonRole_Enum, readonly person: { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly attendeeId?: Maybe<any> } }> };

export type Room_GetEventBreakoutRoomQueryVariables = Exact<{
  originatingContentGroupId: Scalars['uuid'];
}>;


export type Room_GetEventBreakoutRoomQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type Room_GetDefaultVideoRoomBackendQueryVariables = Exact<{ [key: string]: never; }>;


export type Room_GetDefaultVideoRoomBackendQuery = { readonly __typename?: 'query_root', readonly system_Configuration_by_pk?: Maybe<{ readonly __typename?: 'system_Configuration', readonly value: any }> };

export type AddParticipantToRoomMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  roomId: Scalars['uuid'];
}>;


export type AddParticipantToRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_RoomPerson_one?: Maybe<{ readonly __typename?: 'RoomPerson', readonly id: any }> };

export type GetAllRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetAllRoomsQuery = { readonly __typename?: 'query_root', readonly socialRooms: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomListRoomDetailsFragment
  )>, readonly discussionRooms: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomListRoomDetailsFragment
  )>, readonly programRooms: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomListRoomDetailsFragment
  )> };

export type GetAllTodaysRoomsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  todayStart: Scalars['timestamptz'];
  todayEnd: Scalars['timestamptz'];
}>;


export type GetAllTodaysRoomsQuery = { readonly __typename?: 'query_root', readonly socialOrDiscussionRooms: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomListRoomDetailsFragment
  )>, readonly programRooms: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomListRoomDetailsFragment
  )> };

export type RoomListRoomDetailsFragment = { readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly priority: number, readonly roomPrivacyName: RoomPrivacy_Enum, readonly originatingContentGroupId?: Maybe<any>, readonly originatingEventId?: Maybe<any> };

export type RoomPage_GetRoomDetailsQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type RoomPage_GetRoomDetailsQuery = { readonly __typename?: 'query_root', readonly Room_by_pk?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomPage_RoomDetailsFragment
  )> };

export type RoomPage_RoomDetailsFragment = (
  { readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly currentModeName: RoomMode_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly publicVonageSessionId?: Maybe<string>, readonly chatId?: Maybe<any>, readonly roomPrivacyName: RoomPrivacy_Enum, readonly videoRoomBackendName?: Maybe<Room_VideoRoomBackend_Enum>, readonly mediaLiveChannel?: Maybe<{ readonly __typename?: 'MediaLiveChannel', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }>, readonly originatingContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly contentGroupTypeName: ContentGroupType_Enum, readonly title: string, readonly contentItems: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly data: any }> }>, readonly shuffleRooms: ReadonlyArray<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly durationMinutes: number, readonly reshuffleUponEnd: boolean }> }
  & RoomPage_RoomPeopleFragment
);

export type RoomPage_RoomPeopleFragment = { readonly __typename?: 'Room', readonly roomPeople: ReadonlyArray<{ readonly __typename?: 'RoomPerson', readonly id: any, readonly roomPersonRoleName: RoomPersonRole_Enum, readonly attendeeId: any }> };

export type GetEventVonageDetailsQueryVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type GetEventVonageDetailsQuery = { readonly __typename?: 'query_root', readonly Event_by_pk?: Maybe<{ readonly __typename?: 'Event', readonly id: any, readonly eventVonageSession?: Maybe<{ readonly __typename?: 'EventVonageSession', readonly sessionId: string, readonly id: any }> }> };

export type RoomSponsorContent_GetContentItemsQueryVariables = Exact<{
  contentGroupId: Scalars['uuid'];
}>;


export type RoomSponsorContent_GetContentItemsQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & RoomSponsorContent_ContentGroupDataFragment
  )> };

export type RoomSponsorContent_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & RoomSponsorContent_ContentItemDataFragment
  )> };

export type RoomSponsorContent_ContentItemDataFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly contentTypeName: ContentType_Enum, readonly data: any, readonly layoutData?: Maybe<any> };

export type Schedule_TagFragment = { readonly __typename?: 'Tag', readonly id: any, readonly name: string, readonly colour: string, readonly priority: number };

export type Schedule_EventTagFragment = { readonly __typename?: 'EventTag', readonly id: any, readonly tag: (
    { readonly __typename?: 'Tag' }
    & Schedule_TagFragment
  ) };

export type Schedule_ContentItemFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly contentTypeName: ContentType_Enum, readonly name: string, readonly layoutData?: Maybe<any>, readonly data: any };

export type Schedule_ContentPersonFragment = { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly attendeeId?: Maybe<any> };

export type Schedule_ContentGroupPersonFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly priority?: Maybe<number>, readonly roleName: string, readonly person: (
    { readonly __typename?: 'ContentPerson' }
    & Schedule_ContentPersonFragment
  ) };

export type Schedule_ContentGroupItemsFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly contentGroupTypeName: ContentGroupType_Enum };

export type Schedule_ContentGroupFragment = (
  { readonly __typename?: 'ContentGroup', readonly abstractContentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & Schedule_ContentItemFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & Schedule_ContentGroupPersonFragment
  )> }
  & Schedule_ContentGroupItemsFragment
);

export type Schedule_SelectContentGroupQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type Schedule_SelectContentGroupQuery = { readonly __typename?: 'query_root', readonly ContentGroup_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & Schedule_ContentGroupFragment
  )> };

export type Schedule_EventSummaryFragment = { readonly __typename?: 'Event', readonly id: any, readonly roomId: any, readonly intendedRoomModeName: RoomMode_Enum, readonly name: string, readonly startTime: any, readonly durationSeconds: number, readonly contentGroupId?: Maybe<any> };

export type Schedule_RoomSummaryFragment = { readonly __typename?: 'Room', readonly id: any, readonly name: string, readonly currentModeName: RoomMode_Enum, readonly priority: number, readonly roomPrivacyName: RoomPrivacy_Enum };

export type Schedule_SelectSummariesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type Schedule_SelectSummariesQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & Schedule_RoomSummaryFragment
  )>, readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & Schedule_EventSummaryFragment
  )>, readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & Schedule_ContentGroupItemsFragment
  )> };

export type AttendeesByIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  attendeeIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type AttendeesByIdQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type AttendeesByUserIdQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  userIds: ReadonlyArray<Scalars['String']> | Scalars['String'];
}>;


export type AttendeesByUserIdQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeDataFragment
  )> };

export type GetMediaLiveChannelsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetMediaLiveChannelsQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<{ readonly __typename?: 'Room', readonly name: string, readonly id: any, readonly mediaLiveChannel?: Maybe<{ readonly __typename?: 'MediaLiveChannel', readonly cloudFrontDomain: string, readonly endpointUri: string, readonly id: any }> }> };

export type ConferenceConfiguration_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferenceConfiguration_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly ConferenceConfiguration: ReadonlyArray<(
    { readonly __typename?: 'ConferenceConfiguration' }
    & ConferenceConfiguration_ConferenceConfigurationsFragment
  )> };

export type ConferenceConfiguration_ConferenceConfigurationsFragment = { readonly __typename?: 'ConferenceConfiguration', readonly id: any, readonly key: string, readonly value: any };

export type ConferenceConfiguration_UpdateConferenceConfigurationsMutationVariables = Exact<{
  conferenceConfigurationId: Scalars['uuid'];
  value: Scalars['jsonb'];
}>;


export type ConferenceConfiguration_UpdateConferenceConfigurationsMutation = { readonly __typename?: 'mutation_root', readonly update_ConferenceConfiguration_by_pk?: Maybe<{ readonly __typename?: 'ConferenceConfiguration', readonly id: any }> };

export type EventVonageControls_GetEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type EventVonageControls_GetEventsQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<{ readonly __typename?: 'Event', readonly id: any, readonly name: string, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }> }> };

export type EventVonageControls_StopEventBroadcastMutationVariables = Exact<{
  eventId: Scalars['uuid'];
}>;


export type EventVonageControls_StopEventBroadcastMutation = { readonly __typename?: 'mutation_root', readonly stopEventBroadcast?: Maybe<{ readonly __typename?: 'StopEventBroadcastOutput', readonly broadcastsStopped: number }> };

export type CreateConferencePrepareJobMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type CreateConferencePrepareJobMutation = { readonly __typename?: 'mutation_root', readonly insert_ConferencePrepareJob_one?: Maybe<{ readonly __typename?: 'ConferencePrepareJob', readonly id: any, readonly conferenceId: any }> };

export type ConferencePrepareJobSubscriptionSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConferencePrepareJobSubscriptionSubscription = { readonly __typename?: 'subscription_root', readonly ConferencePrepareJob: ReadonlyArray<{ readonly __typename?: 'ConferencePrepareJob', readonly id: any, readonly jobStatusName: JobStatus_Enum, readonly message?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly videoRenderJobs: ReadonlyArray<{ readonly __typename?: 'VideoRenderJob', readonly id: any, readonly jobStatusName: JobStatus_Enum, readonly updated_at: any, readonly created_at: any }> }> };

export type CombineVideosModal_CreateCombineVideosJobMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  createdByAttendeeId: Scalars['uuid'];
  outputName: Scalars['String'];
  data: Scalars['jsonb'];
}>;


export type CombineVideosModal_CreateCombineVideosJobMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_CombineVideosJob_one?: Maybe<{ readonly __typename?: 'job_queues_CombineVideosJob', readonly id: any }> };

export type CombineVideosModal_GetCombineVideosJobQueryVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type CombineVideosModal_GetCombineVideosJobQuery = { readonly __typename?: 'query_root', readonly job_queues_CombineVideosJob_by_pk?: Maybe<{ readonly __typename?: 'job_queues_CombineVideosJob', readonly id: any, readonly message?: Maybe<string>, readonly jobStatusName: JobStatus_Enum }> };

export type ContentGroup_CreateRoomMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  contentGroupId: Scalars['uuid'];
}>;


export type ContentGroup_CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly createContentGroupRoom?: Maybe<{ readonly __typename?: 'CreateContentGroupRoomOutput', readonly roomId?: Maybe<string>, readonly message?: Maybe<string> }> };

export type SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SubmissionRequestsModal_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly ConferenceConfiguration: ReadonlyArray<(
    { readonly __typename?: 'ConferenceConfiguration' }
    & ConfigureEmailTemplates_ConferenceConfigurationFragment
  )> };

export type SubmissionRequestsModal_ConferenceConfigurationFragment = { readonly __typename?: 'ConferenceConfiguration', readonly id: any, readonly conferenceId: any, readonly key: string, readonly value: any };

export type InsertSubmissionRequestEmailJobsMutationVariables = Exact<{
  objs: ReadonlyArray<Job_Queues_SubmissionRequestEmailJob_Insert_Input> | Job_Queues_SubmissionRequestEmailJob_Insert_Input;
}>;


export type InsertSubmissionRequestEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_SubmissionRequestEmailJob?: Maybe<{ readonly __typename?: 'job_queues_SubmissionRequestEmailJob_mutation_response', readonly affected_rows: number }> };

export type UploaderInfoFragment = { readonly __typename?: 'Uploader', readonly id: any, readonly conferenceId: any, readonly email: string, readonly emailsSentCount: number, readonly name: string, readonly requiredContentItemId: any };

export type RequiredContentItemInfoFragment = { readonly __typename?: 'RequiredContentItem', readonly id: any, readonly name: string, readonly isHidden: boolean, readonly contentTypeName: ContentType_Enum, readonly conferenceId: any, readonly contentGroupId: any, readonly uploadsRemaining?: Maybe<number>, readonly originatingDataId?: Maybe<any>, readonly uploaders: ReadonlyArray<(
    { readonly __typename?: 'Uploader' }
    & UploaderInfoFragment
  )> };

export type ContentItemInfoFragment = { readonly __typename?: 'ContentItem', readonly conferenceId: any, readonly contentGroupId: any, readonly contentTypeName: ContentType_Enum, readonly data: any, readonly id: any, readonly isHidden: boolean, readonly layoutData?: Maybe<any>, readonly name: string, readonly requiredContentId?: Maybe<any>, readonly originatingDataId?: Maybe<any> };

export type OriginatingDataInfoFragment = { readonly __typename?: 'OriginatingData', readonly id: any, readonly conferenceId: any, readonly sourceId: string, readonly data?: Maybe<any> };

export type ContentPersonInfoFragment = { readonly __typename?: 'ContentPerson', readonly id: any, readonly conferenceId: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly attendeeId?: Maybe<any> };

export type ContentGroupTagInfoFragment = { readonly __typename?: 'ContentGroupTag', readonly id: any, readonly tagId: any, readonly contentGroupId: any };

export type ContentGroupHallwayInfoFragment = { readonly __typename?: 'ContentGroupHallway', readonly id: any, readonly groupId: any, readonly hallwayId: any, readonly conferenceId: any, readonly priority?: Maybe<number>, readonly layout?: Maybe<any> };

export type ContentGroupPersonInfoFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly conferenceId: any, readonly groupId: any, readonly personId: any, readonly priority?: Maybe<number>, readonly roleName: string };

export type ContentGroupFullNestedInfoFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly conferenceId: any, readonly contentGroupTypeName: ContentGroupType_Enum, readonly title: string, readonly shortTitle?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly requiredContentItems: ReadonlyArray<(
    { readonly __typename?: 'RequiredContentItem' }
    & RequiredContentItemInfoFragment
  )>, readonly contentItems: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemInfoFragment
  )>, readonly contentGroupTags: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupTag' }
    & ContentGroupTagInfoFragment
  )>, readonly hallways: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupHallway' }
    & ContentGroupHallwayInfoFragment
  )>, readonly people: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentGroupPersonInfoFragment
  )>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> };

export type TagInfoFragment = { readonly __typename?: 'Tag', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly priority: number };

export type HallwayInfoFragment = { readonly __typename?: 'Hallway', readonly id: any, readonly conferenceId: any, readonly colour: string, readonly name: string, readonly priority: number };

export type SelectAllContentQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllContentQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupFullNestedInfoFragment
  )>, readonly ContentPerson: ReadonlyArray<(
    { readonly __typename?: 'ContentPerson' }
    & ContentPersonInfoFragment
  )>, readonly OriginatingData: ReadonlyArray<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly Tag: ReadonlyArray<(
    { readonly __typename?: 'Tag' }
    & TagInfoFragment
  )>, readonly Hallway: ReadonlyArray<(
    { readonly __typename?: 'Hallway' }
    & HallwayInfoFragment
  )> };

export type InsertDeleteContentGroupsMutationVariables = Exact<{
  newGroups: ReadonlyArray<ContentGroup_Insert_Input> | ContentGroup_Insert_Input;
  deleteGroupIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type InsertDeleteContentGroupsMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroup' }
      & ContentGroupFullNestedInfoFragment
    )> }>, readonly delete_ContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any }> }> };

export type InsertOriginatingDatasMutationVariables = Exact<{
  newDatas: ReadonlyArray<OriginatingData_Insert_Input> | OriginatingData_Insert_Input;
}>;


export type InsertOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly insert_OriginatingData?: Maybe<{ readonly __typename?: 'OriginatingData_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'OriginatingData' }
      & OriginatingDataInfoFragment
    )> }> };

export type DeleteOriginatingDatasMutationVariables = Exact<{
  deleteDataIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteOriginatingDatasMutation = { readonly __typename?: 'mutation_root', readonly delete_OriginatingData?: Maybe<{ readonly __typename?: 'OriginatingData_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OriginatingData', readonly id: any }> }> };

export type InsertTagsMutationVariables = Exact<{
  newTags: ReadonlyArray<Tag_Insert_Input> | Tag_Insert_Input;
}>;


export type InsertTagsMutation = { readonly __typename?: 'mutation_root', readonly insert_Tag?: Maybe<{ readonly __typename?: 'Tag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Tag' }
      & TagInfoFragment
    )> }> };

export type InsertHallwaysMutationVariables = Exact<{
  newHallways: ReadonlyArray<Hallway_Insert_Input> | Hallway_Insert_Input;
}>;


export type InsertHallwaysMutation = { readonly __typename?: 'mutation_root', readonly insert_Hallway?: Maybe<{ readonly __typename?: 'Hallway_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Hallway' }
      & HallwayInfoFragment
    )> }> };

export type DeleteTagsMutationVariables = Exact<{
  deleteTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteTagsMutation = { readonly __typename?: 'mutation_root', readonly delete_Tag?: Maybe<{ readonly __typename?: 'Tag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Tag', readonly id: any }> }> };

export type DeleteHallwaysMutationVariables = Exact<{
  deleteHallwayIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteHallwaysMutation = { readonly __typename?: 'mutation_root', readonly delete_Hallway?: Maybe<{ readonly __typename?: 'Hallway_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Hallway', readonly id: any }> }> };

export type InsertContentPeopleMutationVariables = Exact<{
  newPeople: ReadonlyArray<ContentPerson_Insert_Input> | ContentPerson_Insert_Input;
}>;


export type InsertContentPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentPerson?: Maybe<{ readonly __typename?: 'ContentPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentPerson' }
      & ContentPersonInfoFragment
    )> }> };

export type DeleteContentPeopleMutationVariables = Exact<{
  deletePersonIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteContentPeopleMutation = { readonly __typename?: 'mutation_root', readonly delete_ContentPerson?: Maybe<{ readonly __typename?: 'ContentPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentPerson', readonly id: any }> }> };

export type UpdateContentGroupMutationVariables = Exact<{
  newItems: ReadonlyArray<ContentItem_Insert_Input> | ContentItem_Insert_Input;
  newRequiredItems: ReadonlyArray<RequiredContentItem_Insert_Input> | RequiredContentItem_Insert_Input;
  newGroupTags: ReadonlyArray<ContentGroupTag_Insert_Input> | ContentGroupTag_Insert_Input;
  newGroupHallways: ReadonlyArray<ContentGroupHallway_Insert_Input> | ContentGroupHallway_Insert_Input;
  groupId: Scalars['uuid'];
  contentGroupTypeName: ContentGroupType_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  shortTitle?: Maybe<Scalars['String']>;
  title: Scalars['String'];
  deleteItemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteRequiredItemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteGroupTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  deleteGroupHallwayIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  newUploaders: ReadonlyArray<Uploader_Insert_Input> | Uploader_Insert_Input;
  deleteUploaderIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
  newGroupPeople: ReadonlyArray<ContentGroupPerson_Insert_Input> | ContentGroupPerson_Insert_Input;
  deleteGroupPeopleIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UpdateContentGroupMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentItem?: Maybe<{ readonly __typename?: 'ContentItem_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentItem' }
      & ContentItemInfoFragment
    )> }>, readonly insert_RequiredContentItem?: Maybe<{ readonly __typename?: 'RequiredContentItem_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'RequiredContentItem' }
      & RequiredContentItemInfoFragment
    )> }>, readonly insert_ContentGroupTag?: Maybe<{ readonly __typename?: 'ContentGroupTag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroupTag' }
      & ContentGroupTagInfoFragment
    )> }>, readonly insert_ContentGroupHallway?: Maybe<{ readonly __typename?: 'ContentGroupHallway_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroupHallway' }
      & ContentGroupHallwayInfoFragment
    )> }>, readonly insert_Uploader?: Maybe<{ readonly __typename?: 'Uploader_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Uploader' }
      & UploaderInfoFragment
    )> }>, readonly insert_ContentGroupPerson?: Maybe<{ readonly __typename?: 'ContentGroupPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroupPerson' }
      & ContentGroupPersonInfoFragment
    )> }>, readonly update_ContentGroup_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupFullNestedInfoFragment
  )>, readonly delete_ContentItem?: Maybe<{ readonly __typename?: 'ContentItem_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any }> }>, readonly delete_RequiredContentItem?: Maybe<{ readonly __typename?: 'RequiredContentItem_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'RequiredContentItem', readonly id: any }> }>, readonly delete_ContentGroupTag?: Maybe<{ readonly __typename?: 'ContentGroupTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroupTag', readonly id: any }> }>, readonly delete_ContentGroupHallway?: Maybe<{ readonly __typename?: 'ContentGroupHallway_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroupHallway', readonly id: any }> }>, readonly delete_Uploader?: Maybe<{ readonly __typename?: 'Uploader_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Uploader', readonly id: any }> }>, readonly delete_ContentGroupPerson?: Maybe<{ readonly __typename?: 'ContentGroupPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroupPerson', readonly id: any }> }> };

export type UpdateContentItemMutationVariables = Exact<{
  id: Scalars['uuid'];
  contentTypeName: ContentType_Enum;
  layoutData?: Maybe<Scalars['jsonb']>;
  name: Scalars['String'];
  data: Scalars['jsonb'];
  isHidden: Scalars['Boolean'];
  originatingDataId?: Maybe<Scalars['uuid']>;
  requiredContentId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateContentItemMutation = { readonly __typename?: 'mutation_root', readonly update_ContentItem_by_pk?: Maybe<(
    { readonly __typename?: 'ContentItem' }
    & ContentItemInfoFragment
  )> };

export type UpdateRequiredContentItemMutationVariables = Exact<{
  id: Scalars['uuid'];
  contentTypeName: ContentType_Enum;
  name: Scalars['String'];
  isHidden: Scalars['Boolean'];
  uploadsRemaining?: Maybe<Scalars['Int']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateRequiredContentItemMutation = { readonly __typename?: 'mutation_root', readonly update_RequiredContentItem_by_pk?: Maybe<(
    { readonly __typename?: 'RequiredContentItem' }
    & RequiredContentItemInfoFragment
  )> };

export type UpdateUploaderMutationVariables = Exact<{
  id: Scalars['uuid'];
  email: Scalars['String'];
  name: Scalars['String'];
}>;


export type UpdateUploaderMutation = { readonly __typename?: 'mutation_root', readonly update_Uploader_by_pk?: Maybe<(
    { readonly __typename?: 'Uploader' }
    & UploaderInfoFragment
  )> };

export type UpdateGroupPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  roleName: Scalars['String'];
  priority?: Maybe<Scalars['Int']>;
}>;


export type UpdateGroupPersonMutation = { readonly __typename?: 'mutation_root', readonly update_ContentGroupPerson_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroupPerson' }
    & ContentGroupPersonInfoFragment
  )> };

export type UpdateGroupHallwayMutationVariables = Exact<{
  id: Scalars['uuid'];
  priority?: Maybe<Scalars['Int']>;
  layout?: Maybe<Scalars['jsonb']>;
}>;


export type UpdateGroupHallwayMutation = { readonly __typename?: 'mutation_root', readonly update_ContentGroupHallway_by_pk?: Maybe<(
    { readonly __typename?: 'ContentGroupHallway' }
    & ContentGroupHallwayInfoFragment
  )> };

export type UpdatePersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
  attendeeId?: Maybe<Scalars['uuid']>;
}>;


export type UpdatePersonMutation = { readonly __typename?: 'mutation_root', readonly update_ContentPerson_by_pk?: Maybe<(
    { readonly __typename?: 'ContentPerson' }
    & ContentPersonInfoFragment
  )> };

export type UpdateTagMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  originatingDataId?: Maybe<Scalars['uuid']>;
  priority?: Scalars['Int'];
}>;


export type UpdateTagMutation = { readonly __typename?: 'mutation_root', readonly update_Tag_by_pk?: Maybe<(
    { readonly __typename?: 'Tag' }
    & TagInfoFragment
  )> };

export type UpdateHallwayMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  colour: Scalars['String'];
  priority: Scalars['Int'];
}>;


export type UpdateHallwayMutation = { readonly __typename?: 'mutation_root', readonly update_Hallway_by_pk?: Maybe<(
    { readonly __typename?: 'Hallway' }
    & HallwayInfoFragment
  )> };

export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ConfigureEmailTemplates_GetConferenceConfigurationsQuery = { readonly __typename?: 'query_root', readonly ConferenceConfiguration: ReadonlyArray<(
    { readonly __typename?: 'ConferenceConfiguration' }
    & ConfigureEmailTemplates_ConferenceConfigurationFragment
  )> };

export type ConfigureEmailTemplates_ConferenceConfigurationFragment = { readonly __typename?: 'ConferenceConfiguration', readonly id: any, readonly conferenceId: any, readonly key: string, readonly value: any };

export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables = Exact<{
  value: Scalars['jsonb'];
  conferenceId: Scalars['uuid'];
  key: Scalars['String'];
}>;


export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutation = { readonly __typename?: 'mutation_root', readonly insert_ConferenceConfiguration_one?: Maybe<{ readonly __typename?: 'ConferenceConfiguration', readonly id: any }> };

export type ChooseContentItemByTagModal_GetTagsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ChooseContentItemByTagModal_GetTagsQuery = { readonly __typename?: 'query_root', readonly Tag: ReadonlyArray<{ readonly __typename?: 'Tag', readonly id: any, readonly name: string }> };

export type ChooseContentItemByTagModal_GetVideoContentItemsQueryVariables = Exact<{
  tagId: Scalars['uuid'];
  name: Scalars['String'];
}>;


export type ChooseContentItemByTagModal_GetVideoContentItemsQuery = { readonly __typename?: 'query_root', readonly ContentItem: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly contentGroup: { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string } }> };

export type ChooseContentItemModal_GetContentGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ChooseContentItemModal_GetContentGroupsQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }> };

export type ChooseContentItemModal_GetVideoContentItemsQueryVariables = Exact<{
  contentGroupId?: Maybe<Scalars['uuid']>;
}>;


export type ChooseContentItemModal_GetVideoContentItemsQuery = { readonly __typename?: 'query_root', readonly ContentItem: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly name: string }> };

export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  scopes: ReadonlyArray<Scalars['String']> | Scalars['String'];
}>;


export type ManageConferenceExportPage_GetGoogleOAuthUrlMutation = { readonly __typename?: 'mutation_root', readonly getGoogleOAuthUrl?: Maybe<{ readonly __typename?: 'GetGoogleOAuthUrlOutput', readonly url: string }> };

export type ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryVariables = Exact<{
  attendeeId: Scalars['uuid'];
}>;


export type ManageConferenceExportPage_GetAttendeeGoogleAccountsQuery = { readonly __typename?: 'query_root', readonly AttendeeGoogleAccount: ReadonlyArray<(
    { readonly __typename?: 'AttendeeGoogleAccount' }
    & ManageConferenceExportPage_AttendeeGoogleAccountFragment
  )> };

export type ManageConferenceExportPage_AttendeeGoogleAccountFragment = { readonly __typename?: 'AttendeeGoogleAccount', readonly id: any, readonly googleAccountEmail: string };

export type ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationVariables = Exact<{
  attendeeGoogleAccountId: Scalars['uuid'];
}>;


export type ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation = { readonly __typename?: 'mutation_root', readonly delete_AttendeeGoogleAccount_by_pk?: Maybe<{ readonly __typename?: 'AttendeeGoogleAccount', readonly id: any }> };

export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery = { readonly __typename?: 'query_root', readonly job_queues_UploadYouTubeVideoJob: ReadonlyArray<(
    { readonly __typename?: 'job_queues_UploadYouTubeVideoJob' }
    & UploadYouTubeVideos_UploadYouTubeVideoJobFragment
  )> };

export type UploadYouTubeVideos_UploadYouTubeVideoJobFragment = { readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any, readonly jobStatusName: JobStatus_Enum, readonly contentItem: { readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly contentGroup: { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string } } };

export type UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryVariables = Exact<{
  attendeeId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetAttendeeGoogleAccountsQuery = { readonly __typename?: 'query_root', readonly AttendeeGoogleAccount: ReadonlyArray<{ readonly __typename?: 'AttendeeGoogleAccount', readonly id: any, readonly googleAccountEmail: string, readonly youTubeData?: Maybe<any> }> };

export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables = Exact<{
  objects: ReadonlyArray<Job_Queues_UploadYouTubeVideoJob_Insert_Input> | Job_Queues_UploadYouTubeVideoJob_Insert_Input;
}>;


export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_UploadYouTubeVideoJob?: Maybe<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'job_queues_UploadYouTubeVideoJob', readonly id: any }> }> };

export type UploadYouTubeVideos_GetContentItemsQueryVariables = Exact<{
  contentItemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetContentItemsQuery = { readonly __typename?: 'query_root', readonly ContentItem: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly contentGroup: { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string } }> };

export type UploadYouTubeVideos_GetTemplateDataQueryVariables = Exact<{
  contentItemIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetTemplateDataQuery = { readonly __typename?: 'query_root', readonly ContentItem: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly contentGroup: { readonly __typename?: 'ContentGroup', readonly id: any, readonly shortTitle?: Maybe<string>, readonly title: string, readonly contentItems: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly youTubeUploads: ReadonlyArray<{ readonly __typename?: 'YouTubeUpload', readonly id: any, readonly videoTitle: string, readonly videoId: string }> }>, readonly abstractContentItems: ReadonlyArray<(
        { readonly __typename?: 'ContentItem' }
        & UploadYouTubeVideos_ContentItemFragment
      )>, readonly paperLinkContentItems: ReadonlyArray<(
        { readonly __typename?: 'ContentItem' }
        & UploadYouTubeVideos_ContentItemFragment
      )>, readonly paperUrlContentItems: ReadonlyArray<(
        { readonly __typename?: 'ContentItem' }
        & UploadYouTubeVideos_ContentItemFragment
      )>, readonly authors: ReadonlyArray<{ readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly person: { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string> } }> } }> };

export type UploadYouTubeVideos_ContentItemFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly data: any };

export type UploadYouTubeVideos_RefreshYouTubeDataMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  attendeeGoogleAccountId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_RefreshYouTubeDataMutation = { readonly __typename?: 'mutation_root', readonly refreshYouTubeData?: Maybe<{ readonly __typename?: 'RefreshYouTubeDataOutput', readonly message?: Maybe<string>, readonly success: boolean }> };

export type UploadYouTubeVideos_GetYouTubeUploadsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type UploadYouTubeVideos_GetYouTubeUploadsQuery = { readonly __typename?: 'query_root', readonly YouTubeUpload: ReadonlyArray<(
    { readonly __typename?: 'YouTubeUpload' }
    & UploadYouTubeVideos_YouTubeUploadFragment
  )> };

export type UploadYouTubeVideos_YouTubeUploadFragment = { readonly __typename?: 'YouTubeUpload', readonly id: any, readonly videoId: string, readonly videoPrivacyStatus: string, readonly videoStatus: string, readonly videoTitle: string, readonly contentItem?: Maybe<{ readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly contentGroup: { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string } }> };

export type ImportAttendeesMutationVariables = Exact<{
  insertAttendees: ReadonlyArray<Attendee_Insert_Input> | Attendee_Insert_Input;
  insertInvitations: ReadonlyArray<Invitation_Insert_Input> | Invitation_Insert_Input;
  insertGroupAttendees: ReadonlyArray<GroupAttendee_Insert_Input> | GroupAttendee_Insert_Input;
}>;


export type ImportAttendeesMutation = { readonly __typename?: 'mutation_root', readonly insert_Attendee?: Maybe<{ readonly __typename?: 'Attendee_mutation_response', readonly affected_rows: number }>, readonly insert_Invitation?: Maybe<{ readonly __typename?: 'Invitation_mutation_response', readonly affected_rows: number }>, readonly insert_GroupAttendee?: Maybe<{ readonly __typename?: 'GroupAttendee_mutation_response', readonly affected_rows: number }> };

export type ManageGroups_GroupFragment = { readonly __typename?: 'Group', readonly conferenceId: any, readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any }> };

export type SelectAllGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllGroupsQuery = { readonly __typename?: 'query_root', readonly Group: ReadonlyArray<(
    { readonly __typename?: 'Group' }
    & ManageGroups_GroupFragment
  )> };

export type CreateDeleteGroupsMutationVariables = Exact<{
  deleteGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
  insertGroups: ReadonlyArray<Group_Insert_Input> | Group_Insert_Input;
}>;


export type CreateDeleteGroupsMutation = { readonly __typename?: 'mutation_root', readonly delete_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any }> }>, readonly insert_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly includeUnauthenticated: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }> };

export type UpdateGroupMutationVariables = Exact<{
  groupId: Scalars['uuid'];
  groupName: Scalars['String'];
  enabled: Scalars['Boolean'];
  includeUnauthenticated: Scalars['Boolean'];
  insertRoles: ReadonlyArray<GroupRole_Insert_Input> | GroupRole_Insert_Input;
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type UpdateGroupMutation = { readonly __typename?: 'mutation_root', readonly update_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }> }>, readonly insert_GroupRole?: Maybe<{ readonly __typename?: 'GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly groupId: any, readonly roleId: any }> }>, readonly delete_GroupRole?: Maybe<{ readonly __typename?: 'GroupRole_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any }> }> };

export type UpdateConferenceMutationVariables = Exact<{
  id: Scalars['uuid'];
  name?: Maybe<Scalars['String']>;
  shortName?: Maybe<Scalars['String']>;
  slug?: Maybe<Scalars['String']>;
}>;


export type UpdateConferenceMutation = { readonly __typename?: 'mutation_root', readonly update_Conference?: Maybe<{ readonly __typename?: 'Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> }> };

export type ManageContentPeople_AttendeeFragment = { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string, readonly invitation?: Maybe<{ readonly __typename?: 'Invitation', readonly id: any, readonly invitedEmailAddress: string }>, readonly profile?: Maybe<{ readonly __typename?: 'AttendeeProfile', readonly attendeeId: any, readonly affiliation?: Maybe<string> }> };

export type ManageContentPeople_ContentPersonFragment = { readonly __typename?: 'ContentPerson', readonly id: any, readonly conferenceId: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly originatingDataId?: Maybe<any>, readonly attendeeId?: Maybe<any> };

export type ManageContentPeople_SelectAllPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContentPeople_SelectAllPeopleQuery = { readonly __typename?: 'query_root', readonly ContentPerson: ReadonlyArray<(
    { readonly __typename?: 'ContentPerson' }
    & ManageContentPeople_ContentPersonFragment
  )> };

export type ManageContentPeople_SelectAllAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageContentPeople_SelectAllAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & ManageContentPeople_AttendeeFragment
  )> };

export type ManageContentPeople_InsertContentPersonMutationVariables = Exact<{
  person: ContentPerson_Insert_Input;
}>;


export type ManageContentPeople_InsertContentPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentPerson_one?: Maybe<(
    { readonly __typename?: 'ContentPerson' }
    & ManageContentPeople_ContentPersonFragment
  )> };

export type ManageContentPeople_DeleteContentPersonsMutationVariables = Exact<{
  ids?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type ManageContentPeople_DeleteContentPersonsMutation = { readonly __typename?: 'mutation_root', readonly delete_ContentPerson?: Maybe<{ readonly __typename?: 'ContentPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentPerson', readonly id: any }> }> };

export type ManageContentPeople_UpdateContentPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  affiliation?: Maybe<Scalars['String']>;
  email?: Maybe<Scalars['String']>;
  attendeeId?: Maybe<Scalars['uuid']>;
}>;


export type ManageContentPeople_UpdateContentPersonMutation = { readonly __typename?: 'mutation_root', readonly update_ContentPerson_by_pk?: Maybe<(
    { readonly __typename?: 'ContentPerson' }
    & ManageContentPeople_ContentPersonFragment
  )> };

export type InvitationPartsFragment = { readonly __typename?: 'Invitation', readonly attendeeId: any, readonly id: any, readonly inviteCode: any, readonly invitedEmailAddress: string, readonly linkToUserId?: Maybe<string>, readonly createdAt: any, readonly updatedAt: any, readonly hash?: Maybe<string> };

export type AttendeePartsFragment = { readonly __typename?: 'Attendee', readonly conferenceId: any, readonly id: any, readonly userId?: Maybe<string>, readonly updatedAt: any, readonly createdAt: any, readonly displayName: string, readonly inviteSent?: Maybe<boolean>, readonly groupAttendees: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly attendeeId: any, readonly id: any, readonly groupId: any }>, readonly invitation?: Maybe<(
    { readonly __typename?: 'Invitation' }
    & InvitationPartsFragment
  )> };

export type SelectAllAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeePartsFragment
  )> };

export type InsertAttendeeMutationVariables = Exact<{
  attendee: Attendee_Insert_Input;
  invitation: Invitation_Insert_Input;
}>;


export type InsertAttendeeMutation = { readonly __typename?: 'mutation_root', readonly insert_Attendee_one?: Maybe<(
    { readonly __typename?: 'Attendee' }
    & AttendeePartsFragment
  )>, readonly insert_Invitation_one?: Maybe<(
    { readonly __typename?: 'Invitation' }
    & InvitationPartsFragment
  )> };

export type InsertAttendeeWithoutInviteMutationVariables = Exact<{
  attendee: Attendee_Insert_Input;
}>;


export type InsertAttendeeWithoutInviteMutation = { readonly __typename?: 'mutation_root', readonly insert_Attendee_one?: Maybe<(
    { readonly __typename?: 'Attendee' }
    & AttendeePartsFragment
  )> };

export type DeleteAttendeesMutationVariables = Exact<{
  deleteAttendeeIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type DeleteAttendeesMutation = { readonly __typename?: 'mutation_root', readonly delete_Attendee?: Maybe<{ readonly __typename?: 'Attendee_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Attendee', readonly id: any }> }> };

export type UpdateAttendeeMutationVariables = Exact<{
  attendeeId: Scalars['uuid'];
  attendeeName: Scalars['String'];
  upsertGroups: ReadonlyArray<GroupAttendee_Insert_Input> | GroupAttendee_Insert_Input;
  remainingGroupIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
}>;


export type UpdateAttendeeMutation = { readonly __typename?: 'mutation_root', readonly update_Attendee_by_pk?: Maybe<(
    { readonly __typename?: 'Attendee' }
    & AttendeePartsFragment
  )>, readonly insert_GroupAttendee?: Maybe<{ readonly __typename?: 'GroupAttendee_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any, readonly attendeeId: any, readonly groupId: any }> }>, readonly delete_GroupAttendee?: Maybe<{ readonly __typename?: 'GroupAttendee_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any }> }> };

export type InsertInvitationEmailJobsMutationVariables = Exact<{
  attendeeIds: Scalars['jsonb'];
  conferenceId: Scalars['uuid'];
  sendRepeat: Scalars['Boolean'];
}>;


export type InsertInvitationEmailJobsMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_InvitationEmailJob?: Maybe<{ readonly __typename?: 'job_queues_InvitationEmailJob_mutation_response', readonly affected_rows: number }> };

export type ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables = Exact<{
  htmlBody: Scalars['String'];
  subject: Scalars['String'];
  conferenceId: Scalars['uuid'];
  attendeeIds: Scalars['jsonb'];
}>;


export type ManageConferencePeoplePage_InsertCustomEmailJobMutation = { readonly __typename?: 'mutation_root', readonly insert_job_queues_CustomEmailJob?: Maybe<{ readonly __typename?: 'job_queues_CustomEmailJob_mutation_response', readonly affected_rows: number }> };

export type SelectAllPermissionsQueryVariables = Exact<{ [key: string]: never; }>;


export type SelectAllPermissionsQuery = { readonly __typename?: 'query_root', readonly Permission: ReadonlyArray<{ readonly __typename?: 'Permission', readonly name: string, readonly description: string }> };

export type SelectAllRolesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRolesQuery = { readonly __typename?: 'query_root', readonly Role: ReadonlyArray<{ readonly __typename?: 'Role', readonly conferenceId: any, readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }> };

export type CreateDeleteRolesMutationVariables = Exact<{
  deleteRoleIds?: Maybe<ReadonlyArray<Scalars['uuid']> | Scalars['uuid']>;
  insertRoles: ReadonlyArray<Role_Insert_Input> | Role_Insert_Input;
}>;


export type CreateDeleteRolesMutation = { readonly __typename?: 'mutation_root', readonly delete_Role?: Maybe<{ readonly __typename?: 'Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Role', readonly id: any }> }>, readonly insert_Role?: Maybe<{ readonly __typename?: 'Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Role', readonly id: any, readonly conferenceId: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }> }> };

export type UpdateRoleMutationVariables = Exact<{
  roleId: Scalars['uuid'];
  roleName: Scalars['String'];
  insertPermissions: ReadonlyArray<RolePermission_Insert_Input> | RolePermission_Insert_Input;
  deletePermissionNames?: Maybe<ReadonlyArray<Permission_Enum> | Permission_Enum>;
}>;


export type UpdateRoleMutation = { readonly __typename?: 'mutation_root', readonly update_Role?: Maybe<{ readonly __typename?: 'Role_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }> }>, readonly insert_RolePermission?: Maybe<{ readonly __typename?: 'RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum, readonly roleId: any }> }>, readonly delete_RolePermission?: Maybe<{ readonly __typename?: 'RolePermission_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any }> }> };

export type RoomParticipantWithAttendeeInfoFragment = { readonly __typename?: 'RoomParticipant', readonly id: any, readonly conferenceId: any, readonly attendeeId: any, readonly roomId: any, readonly attendee: { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string } };

export type RoomWithParticipantInfoFragment = { readonly __typename?: 'Room', readonly id: any, readonly conferenceId: any, readonly name: string, readonly currentModeName: RoomMode_Enum, readonly capacity?: Maybe<number>, readonly priority: number, readonly originatingEventId?: Maybe<any>, readonly originatingContentGroupId?: Maybe<any>, readonly roomPrivacyName: RoomPrivacy_Enum, readonly isProgramRoom?: Maybe<boolean>, readonly participants: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantWithAttendeeInfoFragment
  )>, readonly originatingData?: Maybe<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )> };

export type SelectAllRoomsWithParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectAllRoomsWithParticipantsQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type ManageRooms_SelectGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageRooms_SelectGroupsQuery = { readonly __typename?: 'query_root', readonly Group: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly name: string }> };

export type ManageRooms_SelectContentGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageRooms_SelectContentGroupsQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }> };

export type ManageRooms_SelectGroupAttendeesQueryVariables = Exact<{
  groupId: Scalars['uuid'];
}>;


export type ManageRooms_SelectGroupAttendeesQuery = { readonly __typename?: 'query_root', readonly GroupAttendee: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any, readonly groupId: any, readonly attendeeId: any }> };

export type RoomPersonInfoFragment = { readonly __typename?: 'RoomPerson', readonly id: any, readonly roomPersonRoleName: RoomPersonRole_Enum, readonly attendee: { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string } };

export type ManageRooms_SelectRoomPeopleQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type ManageRooms_SelectRoomPeopleQuery = { readonly __typename?: 'query_root', readonly RoomPerson: ReadonlyArray<(
    { readonly __typename?: 'RoomPerson' }
    & RoomPersonInfoFragment
  )> };

export type CreateRoomMutationVariables = Exact<{
  room: Room_Insert_Input;
}>;


export type CreateRoomMutation = { readonly __typename?: 'mutation_root', readonly insert_Room_one?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type UpdateRoomsWithParticipantsMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity?: Maybe<Scalars['Int']>;
  priority: Scalars['Int'];
  roomPrivacyName: RoomPrivacy_Enum;
  originatingContentGroupId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateRoomsWithParticipantsMutation = { readonly __typename?: 'mutation_root', readonly update_Room_by_pk?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomWithParticipantInfoFragment
  )> };

export type InsertRoomPeopleMutationVariables = Exact<{
  people: ReadonlyArray<RoomPerson_Insert_Input> | RoomPerson_Insert_Input;
}>;


export type InsertRoomPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_RoomPerson?: Maybe<{ readonly __typename?: 'RoomPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'RoomPerson' }
      & RoomPersonInfoFragment
    )> }> };

export type InsertEventInfoMutationVariables = Exact<{
  id: Scalars['uuid'];
  roomId: Scalars['uuid'];
  conferenceId: Scalars['uuid'];
  intendedRoomModeName: RoomMode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  contentGroupId?: Maybe<Scalars['uuid']>;
  hallwayId?: Maybe<Scalars['uuid']>;
}>;


export type InsertEventInfoMutation = { readonly __typename?: 'mutation_root', readonly insert_Event_one?: Maybe<(
    { readonly __typename?: 'Event' }
    & EventInfoFragment
  )> };

export type UpdateEventInfoMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  roomId: Scalars['uuid'];
  intendedRoomModeName: RoomMode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  contentGroupId?: Maybe<Scalars['uuid']>;
  hallwayId?: Maybe<Scalars['uuid']>;
}>;


export type UpdateEventInfoMutation = { readonly __typename?: 'mutation_root', readonly update_Event_by_pk?: Maybe<(
    { readonly __typename?: 'Event' }
    & EventInfoFragment
  )> };

export type DeleteEventInfosMutationVariables = Exact<{
  eventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventInfosMutation = { readonly __typename?: 'mutation_root', readonly delete_Event?: Maybe<{ readonly __typename?: 'Event_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Event', readonly id: any }> }> };

export type ManageShufflePeriods_ShufflePeriodFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetAttendeesPerRoom: number, readonly maxAttendeesPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum, readonly completedEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count?: Maybe<number> }> }, readonly ongoingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count?: Maybe<number> }> }, readonly waitingEntries: { readonly __typename?: 'room_ShuffleQueueEntry_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'room_ShuffleQueueEntry_aggregate_fields', readonly count?: Maybe<number> }> } };

export type ManageShufflePeriods_SelectAllQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type ManageShufflePeriods_SelectAllQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<(
    { readonly __typename?: 'room_ShufflePeriod' }
    & ManageShufflePeriods_ShufflePeriodFragment
  )> };

export type SendEmail_GetAllGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SendEmail_GetAllGroupsQuery = { readonly __typename?: 'query_root', readonly Group: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly enabled: boolean, readonly name: string }> };

export type AddEventPeople_ContentGroupPersonFragment = { readonly __typename?: 'ContentGroupPerson', readonly id: any, readonly groupId: any, readonly personId: any, readonly roleName: string };

export type AddEventPeople_ContentPersonFragment = { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly email?: Maybe<string>, readonly attendeeId?: Maybe<any> };

export type AddEventPeople_AttendeeFragment = { readonly __typename?: 'Attendee', readonly id: any, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'AttendeeProfile', readonly attendeeId: any, readonly affiliation?: Maybe<string> }>, readonly invitation?: Maybe<{ readonly __typename?: 'Invitation', readonly id: any, readonly invitedEmailAddress: string }> };

export type AddEventPeople_GroupFragment = { readonly __typename?: 'Group', readonly id: any, readonly name: string };

export type AddEventPeople_SelectContentGroupPeopleQueryVariables = Exact<{
  contentGroupIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type AddEventPeople_SelectContentGroupPeopleQuery = { readonly __typename?: 'query_root', readonly ContentGroupPerson: ReadonlyArray<(
    { readonly __typename?: 'ContentGroupPerson' }
    & AddEventPeople_ContentGroupPersonFragment
  )> };

export type AddEventPeople_SelectContentPeopleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectContentPeopleQuery = { readonly __typename?: 'query_root', readonly ContentPerson: ReadonlyArray<(
    { readonly __typename?: 'ContentPerson' }
    & AddEventPeople_ContentPersonFragment
  )> };

export type AddEventPeople_SelectAttendeesQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectAttendeesQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AddEventPeople_AttendeeFragment
  )> };

export type AddEventPeople_SelectContentPeople_ByAttendeeQueryVariables = Exact<{
  attendeeIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type AddEventPeople_SelectContentPeople_ByAttendeeQuery = { readonly __typename?: 'query_root', readonly ContentPerson: ReadonlyArray<(
    { readonly __typename?: 'ContentPerson' }
    & AddEventPeople_ContentPersonFragment
  )> };

export type AddEventPeople_SelectGroupsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectGroupsQuery = { readonly __typename?: 'query_root', readonly Group: ReadonlyArray<(
    { readonly __typename?: 'Group' }
    & AddEventPeople_GroupFragment
  )> };

export type AddEventPeople_SelectAttendees_ByGroupQueryVariables = Exact<{
  groupId: Scalars['uuid'];
}>;


export type AddEventPeople_SelectAttendees_ByGroupQuery = { readonly __typename?: 'query_root', readonly Attendee: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AddEventPeople_AttendeeFragment
  )> };

export type AddEventPeople_InsertContentPeopleMutationVariables = Exact<{
  objects: ReadonlyArray<ContentPerson_Insert_Input> | ContentPerson_Insert_Input;
}>;


export type AddEventPeople_InsertContentPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentPerson?: Maybe<{ readonly __typename?: 'ContentPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentPerson' }
      & AddEventPeople_ContentPersonFragment
    )> }> };

export type AddEventPeople_InsertEventPeopleMutationVariables = Exact<{
  objects: ReadonlyArray<EventPerson_Insert_Input> | EventPerson_Insert_Input;
}>;


export type AddEventPeople_InsertEventPeopleMutation = { readonly __typename?: 'mutation_root', readonly insert_EventPerson?: Maybe<{ readonly __typename?: 'EventPerson_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'EventPerson' }
      & EventPersonInfoFragment
    )> }> };

export type InsertEventPersonMutationVariables = Exact<{
  newEventPerson: EventPerson_Insert_Input;
}>;


export type InsertEventPersonMutation = { readonly __typename?: 'mutation_root', readonly insert_EventPerson_one?: Maybe<(
    { readonly __typename?: 'EventPerson' }
    & EventPersonInfoFragment
  )> };

export type DeleteEventPersonsMutationVariables = Exact<{
  deleteEventPeopleIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventPersonsMutation = { readonly __typename?: 'mutation_root', readonly delete_EventPerson?: Maybe<{ readonly __typename?: 'EventPerson_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'EventPerson', readonly id: any }> }> };

export type UpdateEventPersonMutationVariables = Exact<{
  id: Scalars['uuid'];
  personId: Scalars['uuid'];
  roleName: EventPersonRole_Enum;
}>;


export type UpdateEventPersonMutation = { readonly __typename?: 'mutation_root', readonly update_EventPerson_by_pk?: Maybe<(
    { readonly __typename?: 'EventPerson' }
    & EventPersonInfoFragment
  )> };

export type RoomInfoFragment = { readonly __typename?: 'Room', readonly capacity?: Maybe<number>, readonly conferenceId: any, readonly currentModeName: RoomMode_Enum, readonly id: any, readonly name: string, readonly priority: number, readonly originatingDataId?: Maybe<any>, readonly originatingEventId?: Maybe<any>, readonly originatingContentGroupId?: Maybe<any>, readonly roomPrivacyName: RoomPrivacy_Enum, readonly originatingData?: Maybe<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly participants: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantInfoFragment
  )> };

export type RoomParticipantInfoFragment = { readonly __typename?: 'RoomParticipant', readonly attendeeId: any, readonly conferenceId: any, readonly id: any, readonly roomId: any };

export type EventInfoFragment = { readonly __typename?: 'Event', readonly conferenceId: any, readonly id: any, readonly durationSeconds: number, readonly intendedRoomModeName: RoomMode_Enum, readonly name: string, readonly originatingDataId?: Maybe<any>, readonly roomId: any, readonly startTime: any, readonly endTime?: Maybe<any>, readonly contentGroupId?: Maybe<any>, readonly hallwayId?: Maybe<any>, readonly eventPeople: ReadonlyArray<(
    { readonly __typename?: 'EventPerson' }
    & EventPersonInfoFragment
  )>, readonly eventTags: ReadonlyArray<(
    { readonly __typename?: 'EventTag' }
    & EventTagInfoFragment
  )> };

export type EventPersonInfoFragment = { readonly __typename?: 'EventPerson', readonly id: any, readonly eventId: any, readonly roleName: EventPersonRole_Enum, readonly personId: any };

export type EventTagInfoFragment = { readonly __typename?: 'EventTag', readonly eventId: any, readonly id: any, readonly tagId: any };

export type SelectWholeScheduleQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type SelectWholeScheduleQuery = { readonly __typename?: 'query_root', readonly Room: ReadonlyArray<(
    { readonly __typename?: 'Room' }
    & RoomInfoFragment
  )>, readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & EventInfoFragment
  )>, readonly OriginatingData: ReadonlyArray<(
    { readonly __typename?: 'OriginatingData' }
    & OriginatingDataInfoFragment
  )>, readonly Tag: ReadonlyArray<(
    { readonly __typename?: 'Tag' }
    & TagInfoFragment
  )>, readonly Hallway: ReadonlyArray<(
    { readonly __typename?: 'Hallway' }
    & HallwayInfoFragment
  )>, readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & ContentGroupFullNestedInfoFragment
  )>, readonly ContentPerson: ReadonlyArray<(
    { readonly __typename?: 'ContentPerson' }
    & ContentPersonInfoFragment
  )> };

export type InsertRoomsMutationVariables = Exact<{
  newRooms: ReadonlyArray<Room_Insert_Input> | Room_Insert_Input;
}>;


export type InsertRoomsMutation = { readonly __typename?: 'mutation_root', readonly insert_Room?: Maybe<{ readonly __typename?: 'Room_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'Room' }
      & RoomInfoFragment
    )> }> };

export type DeleteRoomsMutationVariables = Exact<{
  deleteRoomIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteRoomsMutation = { readonly __typename?: 'mutation_root', readonly delete_Room?: Maybe<{ readonly __typename?: 'Room_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }> }> };

export type UpdateRoomMutationVariables = Exact<{
  id: Scalars['uuid'];
  name: Scalars['String'];
  capacity?: Maybe<Scalars['Int']>;
  originatingDataId?: Maybe<Scalars['uuid']>;
  priority: Scalars['Int'];
}>;


export type UpdateRoomMutation = { readonly __typename?: 'mutation_root', readonly update_Room_by_pk?: Maybe<(
    { readonly __typename?: 'Room' }
    & RoomInfoFragment
  )> };

export type DeleteEventsMutationVariables = Exact<{
  deleteEventIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type DeleteEventsMutation = { readonly __typename?: 'mutation_root', readonly delete_Event?: Maybe<{ readonly __typename?: 'Event_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Event', readonly id: any }> }> };

export type InsertEventMutationVariables = Exact<{
  newEvent: Event_Insert_Input;
}>;


export type InsertEventMutation = { readonly __typename?: 'mutation_root', readonly insert_Event_one?: Maybe<(
    { readonly __typename?: 'Event' }
    & EventInfoFragment
  )> };

export type UpdateEventMutationVariables = Exact<{
  eventId: Scalars['uuid'];
  roomId: Scalars['uuid'];
  intendedRoomModeName: RoomMode_Enum;
  originatingDataId?: Maybe<Scalars['uuid']>;
  name: Scalars['String'];
  startTime: Scalars['timestamptz'];
  durationSeconds: Scalars['Int'];
  contentGroupId?: Maybe<Scalars['uuid']>;
  hallwayId?: Maybe<Scalars['uuid']>;
  newEventTags: ReadonlyArray<EventTag_Insert_Input> | EventTag_Insert_Input;
  deleteEventTagIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type UpdateEventMutation = { readonly __typename?: 'mutation_root', readonly insert_EventTag?: Maybe<{ readonly __typename?: 'EventTag_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'EventTag' }
      & EventTagInfoFragment
    )> }>, readonly update_Event_by_pk?: Maybe<(
    { readonly __typename?: 'Event' }
    & EventInfoFragment
  )>, readonly delete_EventTag?: Maybe<{ readonly __typename?: 'EventTag_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'EventTag', readonly id: any }> }> };

export type UpdateShufflePeriodMutationVariables = Exact<{
  id: Scalars['uuid'];
  object: Room_ShufflePeriod_Set_Input;
}>;


export type UpdateShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly update_room_ShufflePeriod_by_pk?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetAttendeesPerRoom: number, readonly maxAttendeesPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum }> };

export type InsertShufflePeriodMutationVariables = Exact<{
  object: Room_ShufflePeriod_Insert_Input;
}>;


export type InsertShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly insert_room_ShufflePeriod_one?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly created_at: any, readonly updated_at: any, readonly conferenceId: any, readonly startAt: any, readonly endAt: any, readonly roomDurationMinutes: number, readonly targetAttendeesPerRoom: number, readonly maxAttendeesPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly name: string, readonly organiserId: any, readonly algorithm: Room_ShuffleAlgorithm_Enum }> };

export type DeleteShufflePeriodMutationVariables = Exact<{
  id: Scalars['uuid'];
}>;


export type DeleteShufflePeriodMutation = { readonly __typename?: 'mutation_root', readonly delete_room_ShufflePeriod_by_pk?: Maybe<{ readonly __typename?: 'room_ShufflePeriod', readonly id: any }> };

export type AddSponsorContentMenu_CreateContentItemMutationVariables = Exact<{
  object: ContentItem_Insert_Input;
}>;


export type AddSponsorContentMenu_CreateContentItemMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentItem_one?: Maybe<{ readonly __typename?: 'ContentItem', readonly id: any }> };

export type EditableSponsorsTable_GetAllSponsorsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type EditableSponsorsTable_GetAllSponsorsQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & EditableSponsorsTable_ContentGroupInfoFragment
  )> };

export type EditableSponsorsTable_InsertSponsorMutationVariables = Exact<{
  contentGroup: ContentGroup_Insert_Input;
}>;


export type EditableSponsorsTable_InsertSponsorMutation = { readonly __typename?: 'mutation_root', readonly insert_ContentGroup_one?: Maybe<(
    { readonly __typename?: 'ContentGroup' }
    & EditableSponsorsTable_ContentGroupInfoFragment
  )> };

export type EditableSponsorsTable_UpdateSponsorMutationVariables = Exact<{
  contentGroupId: Scalars['uuid'];
  object: ContentGroup_Set_Input;
}>;


export type EditableSponsorsTable_UpdateSponsorMutation = { readonly __typename?: 'mutation_root', readonly update_ContentGroup_by_pk?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any }> };

export type EditableSponsorsTable_DeleteSponsorMutationVariables = Exact<{
  contentGroupIds: ReadonlyArray<Scalars['uuid']> | Scalars['uuid'];
}>;


export type EditableSponsorsTable_DeleteSponsorMutation = { readonly __typename?: 'mutation_root', readonly delete_ContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'ContentGroup', readonly id: any }> }> };

export type EditableSponsorsTable_ContentGroupInfoFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly room?: Maybe<{ readonly __typename?: 'Room', readonly id: any }> };

export type SponsorSecondaryEditor_GetSponsorContentItemsQueryVariables = Exact<{
  contentGroupId: Scalars['uuid'];
}>;


export type SponsorSecondaryEditor_GetSponsorContentItemsQuery = { readonly __typename?: 'query_root', readonly ContentItem: ReadonlyArray<(
    { readonly __typename?: 'ContentItem' }
    & SponsorSecondaryEditor_ContentItemFragment
  )> };

export type SponsorSecondaryEditor_ContentItemFragment = { readonly __typename?: 'ContentItem', readonly id: any, readonly name: string, readonly contentTypeName: ContentType_Enum, readonly data: any, readonly layoutData?: Maybe<any>, readonly isHidden: boolean, readonly updatedAt: any };

export type SponsorContentItem_DeleteContentItemMutationVariables = Exact<{
  contentItemId: Scalars['uuid'];
}>;


export type SponsorContentItem_DeleteContentItemMutation = { readonly __typename?: 'mutation_root', readonly delete_ContentItem_by_pk?: Maybe<{ readonly __typename?: 'ContentItem', readonly id: any }> };

export type SponsorContentItem_SetContentItemIsHiddenMutationVariables = Exact<{
  contentItemId: Scalars['uuid'];
  isHidden: Scalars['Boolean'];
}>;


export type SponsorContentItem_SetContentItemIsHiddenMutation = { readonly __typename?: 'mutation_root', readonly update_ContentItem_by_pk?: Maybe<{ readonly __typename?: 'ContentItem', readonly id: any }> };

export type SponsorContentItemInner_UpdateContentItemMutationVariables = Exact<{
  contentItemId: Scalars['uuid'];
  contentItem: ContentItem_Set_Input;
}>;


export type SponsorContentItemInner_UpdateContentItemMutation = { readonly __typename?: 'mutation_root', readonly update_ContentItem_by_pk?: Maybe<{ readonly __typename?: 'ContentItem', readonly id: any }> };

export type ConferenceTakenQueryVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
}>;


export type ConferenceTakenQuery = { readonly __typename?: 'query_root', readonly Conference: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }> };

export type CreateConferenceMutationVariables = Exact<{
  name: Scalars['String'];
  shortName: Scalars['String'];
  slug: Scalars['String'];
  demoCode: Scalars['uuid'];
}>;


export type CreateConferenceMutation = { readonly __typename?: 'mutation_root', readonly insert_Conference?: Maybe<{ readonly __typename?: 'Conference_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Conference', readonly id: any, readonly slug: string }> }>, readonly update_ConferenceDemoCode?: Maybe<{ readonly __typename?: 'ConferenceDemoCode_mutation_response', readonly affected_rows: number }> };

export type CreateNewConferenceMetaStructureMutationVariables = Exact<{
  conferenceId: Scalars['uuid'];
  attendeeDisplayName: Scalars['String'];
  userId: Scalars['String'];
  abstractData: Scalars['jsonb'];
  contentGroupListData: Scalars['jsonb'];
}>;


export type CreateNewConferenceMetaStructureMutation = { readonly __typename?: 'mutation_root', readonly insert_Attendee?: Maybe<{ readonly __typename?: 'Attendee_mutation_response', readonly affected_rows: number }>, readonly insert_Group?: Maybe<{ readonly __typename?: 'Group_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'Group', readonly id: any, readonly conferenceId: any, readonly name: string, readonly enabled: boolean, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly roleId: any, readonly permissionName: Permission_Enum }> } }> }> }>, readonly insert_ContentGroup?: Maybe<{ readonly __typename?: 'ContentGroup_mutation_response', readonly returning: ReadonlyArray<(
      { readonly __typename?: 'ContentGroup' }
      & ContentGroupDataFragment
    )> }> };

export type ConferenceBySlug_WithUserQueryVariables = Exact<{
  slug: Scalars['String'];
  userId: Scalars['String'];
}>;


export type ConferenceBySlug_WithUserQuery = { readonly __typename?: 'query_root', readonly Conference: ReadonlyArray<(
    { readonly __typename?: 'Conference' }
    & PublicConferenceInfoFragment
    & AuthdConferenceInfoFragment
  )> };

export type ConferenceBySlug_WithoutUserQueryVariables = Exact<{
  slug: Scalars['String'];
}>;


export type ConferenceBySlug_WithoutUserQuery = { readonly __typename?: 'query_root', readonly Conference: ReadonlyArray<(
    { readonly __typename?: 'Conference' }
    & PublicConferenceInfoFragment
  )> };

export type AuthdConferenceInfoFragment = { readonly __typename?: 'Conference', readonly attendees: ReadonlyArray<(
    { readonly __typename?: 'Attendee', readonly groupAttendees: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any, readonly groupId: any, readonly attendeeId: any, readonly group: (
        { readonly __typename?: 'Group' }
        & GroupDataFragment
      ) }> }
    & AttendeeDataFragment
  )> };

export type PublicConferenceInfoFragment = { readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string, readonly createdBy: string, readonly publicGroups: ReadonlyArray<(
    { readonly __typename?: 'Group' }
    & GroupDataFragment
  )> };

export type GroupDataFragment = { readonly __typename?: 'Group', readonly enabled: boolean, readonly id: any, readonly includeUnauthenticated: boolean, readonly name: string, readonly conferenceId: any, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly roleId: any, readonly groupId: any, readonly role: { readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly conferenceId: any, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly permissionName: Permission_Enum, readonly id: any, readonly roleId: any }> } }> };

export type AttendeeProfileDataFragment = { readonly __typename?: 'AttendeeProfile', readonly attendeeId: any, readonly badges?: Maybe<any>, readonly affiliation?: Maybe<string>, readonly affiliationURL?: Maybe<string>, readonly country?: Maybe<string>, readonly timezoneUTCOffset?: Maybe<number>, readonly bio?: Maybe<string>, readonly website?: Maybe<string>, readonly github?: Maybe<string>, readonly twitter?: Maybe<string>, readonly pronouns?: Maybe<any>, readonly photoURL_50x50?: Maybe<string>, readonly photoURL_350x350?: Maybe<string>, readonly hasBeenEdited: boolean };

export type AttendeeDataFragment = { readonly __typename?: 'Attendee', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly profile?: Maybe<(
    { readonly __typename?: 'AttendeeProfile' }
    & AttendeeProfileDataFragment
  )> };

export type UpdateSubtitlesMutationVariables = Exact<{
  contentItemId: Scalars['String'];
  magicToken: Scalars['String'];
  subtitleText: Scalars['String'];
}>;


export type UpdateSubtitlesMutation = { readonly __typename?: 'mutation_root', readonly updateSubtitles?: Maybe<{ readonly __typename?: 'SubmitUpdatedSubtitlesOutput', readonly message: string, readonly success: boolean }> };

export type GetContentItemQueryVariables = Exact<{
  magicToken: Scalars['String'];
}>;


export type GetContentItemQuery = { readonly __typename?: 'query_root', readonly getContentItem?: Maybe<ReadonlyArray<Maybe<{ readonly __typename?: 'GetContentItemOutput', readonly contentTypeName: string, readonly data: any, readonly layoutData?: Maybe<any>, readonly name: string, readonly id: string, readonly contentGroupTitle: string }>>> };

export type SelectRequiredItemQueryVariables = Exact<{
  requiredContentItemId: Scalars['uuid'];
}>;


export type SelectRequiredItemQuery = { readonly __typename?: 'query_root', readonly RequiredContentItem: ReadonlyArray<(
    { readonly __typename?: 'RequiredContentItem' }
    & RequiredItemFieldsFragment
  )> };

export type RequiredItemFieldsFragment = { readonly __typename?: 'RequiredContentItem', readonly id: any, readonly contentTypeName: ContentType_Enum, readonly name: string, readonly uploadsRemaining?: Maybe<number>, readonly contentGroupTitle?: Maybe<string>, readonly conference: { readonly __typename?: 'Conference', readonly id: any, readonly name: string } };

export type SubmitContentItemMutationVariables = Exact<{
  contentItemData: Scalars['jsonb'];
  magicToken: Scalars['String'];
}>;


export type SubmitContentItemMutation = { readonly __typename?: 'mutation_root', readonly submitContentItem?: Maybe<{ readonly __typename?: 'SubmitContentItemOutput', readonly message: string, readonly success: boolean }> };

export type GetUploadAgreementQueryVariables = Exact<{
  magicToken: Scalars['String'];
}>;


export type GetUploadAgreementQuery = { readonly __typename?: 'query_root', readonly getUploadAgreement?: Maybe<{ readonly __typename?: 'GetUploadAgreementOutput', readonly agreementText?: Maybe<string> }> };

export type EchoQueryVariables = Exact<{
  message: Scalars['String'];
}>;


export type EchoQuery = { readonly __typename?: 'query_root', readonly echo?: Maybe<{ readonly __typename?: 'EchoOutput', readonly message: string }> };

export type ProtectedEchoQueryVariables = Exact<{
  message: Scalars['String'];
}>;


export type ProtectedEchoQuery = { readonly __typename?: 'query_root', readonly protectedEcho?: Maybe<{ readonly __typename?: 'ProtectedEchoOutput', readonly message: string }> };

export type EventPersonDetailsFragment = { readonly __typename?: 'EventPerson', readonly id: any, readonly roleName: EventPersonRole_Enum, readonly eventId: any, readonly person: { readonly __typename?: 'ContentPerson', readonly id: any, readonly name: string, readonly affiliation?: Maybe<string>, readonly attendeeId?: Maybe<any>, readonly attendee?: Maybe<{ readonly __typename?: 'Attendee', readonly id: any, readonly userId?: Maybe<string>, readonly displayName: string, readonly profile?: Maybe<{ readonly __typename?: 'AttendeeProfile', readonly attendeeId: any, readonly affiliation?: Maybe<string> }> }> } };

export type GetForceUserRefreshConfigQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetForceUserRefreshConfigQuery = { readonly __typename?: 'query_root', readonly ConferenceConfiguration: ReadonlyArray<{ readonly __typename?: 'ConferenceConfiguration', readonly id: any, readonly conferenceId: any, readonly key: string, readonly value: any }> };

export type GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables = Exact<{
  code: Scalars['String'];
  state: Scalars['String'];
}>;


export type GoogleOAuth_SubmitGoogleOAuthCodeMutation = { readonly __typename?: 'mutation_root', readonly submitGoogleOAuthCode?: Maybe<{ readonly __typename?: 'SubmitGoogleOAuthCodeOutput', readonly message?: Maybe<string>, readonly success: boolean }> };

export type SelectInvitationForAcceptQueryVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SelectInvitationForAcceptQuery = { readonly __typename?: 'query_root', readonly Invitation: ReadonlyArray<{ readonly __typename?: 'Invitation', readonly id: any, readonly invitedEmailAddress: string }> };

export type Invitation_ConfirmCurrentMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type Invitation_ConfirmCurrentMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmCurrent?: Maybe<{ readonly __typename?: 'ConfirmInvitationOutput', readonly confSlug?: Maybe<string>, readonly ok: string }> };

export type Invitation_ConfirmWithCodeMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
  confirmationCode: Scalars['String'];
}>;


export type Invitation_ConfirmWithCodeMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmWithCode?: Maybe<{ readonly __typename?: 'ConfirmInvitationOutput', readonly confSlug?: Maybe<string>, readonly ok: string }> };

export type SendInitialConfirmationEmailMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SendInitialConfirmationEmailMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmSendInitialEmail?: Maybe<{ readonly __typename?: 'InvitationConfirmationEmailOutput', readonly sent: boolean }> };

export type SendRepeatConfirmationEmailMutationVariables = Exact<{
  inviteCode: Scalars['uuid'];
}>;


export type SendRepeatConfirmationEmailMutation = { readonly __typename?: 'mutation_root', readonly invitationConfirmSendRepeatEmail?: Maybe<{ readonly __typename?: 'InvitationConfirmationEmailOutput', readonly sent: boolean }> };

export type MenuScheduleQueryVariables = Exact<{
  now: Scalars['timestamptz'];
  inOneHour: Scalars['timestamptz'];
  conferenceId: Scalars['uuid'];
}>;


export type MenuScheduleQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & MenuSchedule_EventFragment
  )> };

export type MenuSchedule_SearchEventsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  search: Scalars['String'];
}>;


export type MenuSchedule_SearchEventsQuery = { readonly __typename?: 'query_root', readonly Event: ReadonlyArray<(
    { readonly __typename?: 'Event' }
    & MenuSchedule_EventFragment
  )> };

export type MenuSchedule_EventFragment = { readonly __typename?: 'Event', readonly id: any, readonly name: string, readonly startTime: any, readonly room: { readonly __typename?: 'Room', readonly id: any, readonly name: string }, readonly eventTags: ReadonlyArray<{ readonly __typename?: 'EventTag', readonly tag: { readonly __typename?: 'Tag', readonly id: any, readonly colour: string, readonly name: string } }>, readonly contentGroup?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string }> };

export type MainMenuSponsors_GetSponsorsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type MainMenuSponsors_GetSponsorsQuery = { readonly __typename?: 'query_root', readonly ContentGroup: ReadonlyArray<(
    { readonly __typename?: 'ContentGroup' }
    & MainMenuSponsors_ContentGroupDataFragment
  )> };

export type MainMenuSponsors_ContentGroupDataFragment = { readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly shortTitle?: Maybe<string>, readonly rooms: ReadonlyArray<{ readonly __typename?: 'Room', readonly id: any }>, readonly logo: ReadonlyArray<{ readonly __typename?: 'ContentItem', readonly id: any, readonly data: any }> };

export type GetRoomChatIdQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomChatIdQuery = { readonly __typename?: 'query_root', readonly Room_by_pk?: Maybe<{ readonly __typename?: 'Room', readonly id: any, readonly chatId?: Maybe<any>, readonly name: string }> };

export type GetContentGroupChatIdQueryVariables = Exact<{
  itemId: Scalars['uuid'];
}>;


export type GetContentGroupChatIdQuery = { readonly __typename?: 'query_root', readonly ContentGroup_by_pk?: Maybe<{ readonly __typename?: 'ContentGroup', readonly id: any, readonly title: string, readonly chatId?: Maybe<any> }> };

export type GetVapidPublicKeyQueryVariables = Exact<{ [key: string]: never; }>;


export type GetVapidPublicKeyQuery = { readonly __typename?: 'query_root', readonly vapidPublicKey: { readonly __typename?: 'VAPIDPublicKeyOutput', readonly key: string } };

export type UpsertPushNotificationSubscriptionMutationVariables = Exact<{
  object: PushNotificationSubscription_Insert_Input;
}>;


export type UpsertPushNotificationSubscriptionMutation = { readonly __typename?: 'mutation_root', readonly insert_PushNotificationSubscription_one?: Maybe<{ readonly __typename?: 'PushNotificationSubscription', readonly endpoint: string }> };

export type DeletePushNotificationSubscriptionMutationVariables = Exact<{
  endpoint: Scalars['String'];
}>;


export type DeletePushNotificationSubscriptionMutation = { readonly __typename?: 'mutation_root', readonly delete_PushNotificationSubscription?: Maybe<{ readonly __typename?: 'PushNotificationSubscription_mutation_response', readonly affected_rows: number }> };

export type GetRoomMembersQueryVariables = Exact<{
  roomId: Scalars['uuid'];
}>;


export type GetRoomMembersQuery = { readonly __typename?: 'query_root', readonly RoomPerson: ReadonlyArray<(
    { readonly __typename?: 'RoomPerson' }
    & RoomMemberFragment
  )> };

export type RoomMemberFragment = { readonly __typename?: 'RoomPerson', readonly id: any, readonly roomId: any, readonly roomPersonRoleName: RoomPersonRole_Enum, readonly attendeeId: any };

export type GetRoomParticipantsSubscriptionVariables = Exact<{
  conferenceId: Scalars['uuid'];
  roomId: Scalars['uuid'];
}>;


export type GetRoomParticipantsSubscription = { readonly __typename?: 'subscription_root', readonly RoomParticipant: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantDetailsFragment
  )> };

export type GetAllRoomParticipantsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetAllRoomParticipantsQuery = { readonly __typename?: 'query_root', readonly RoomParticipant: ReadonlyArray<(
    { readonly __typename?: 'RoomParticipant' }
    & RoomParticipantDetailsFragment
  )> };

export type RoomParticipantDetailsFragment = { readonly __typename?: 'RoomParticipant', readonly conferenceId: any, readonly id: any, readonly roomId: any, readonly attendeeId: any };

export type ShufflePeriodDataFragment = { readonly __typename?: 'room_ShufflePeriod', readonly id: any, readonly conferenceId: any, readonly endAt: any, readonly maxAttendeesPerRoom: number, readonly name: string, readonly roomDurationMinutes: number, readonly startAt: any, readonly targetAttendeesPerRoom: number, readonly waitRoomMaxDurationSeconds: number, readonly queueEntries: ReadonlyArray<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & PrefetchShuffleQueueEntryDataFragment
  )> };

export type PrefetchShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly attendeeId: any, readonly created_at: any, readonly updated_at: any, readonly shuffleRoom?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly startedAt: any, readonly isEnded: boolean, readonly roomId: any }> };

export type SubdShuffleQueueEntryDataFragment = { readonly __typename?: 'room_ShuffleQueueEntry', readonly id: any, readonly allocatedShuffleRoomId?: Maybe<number> };

export type MyShuffleQueueEntrySubscriptionVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type MyShuffleQueueEntrySubscription = { readonly __typename?: 'subscription_root', readonly room_ShuffleQueueEntry_by_pk?: Maybe<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & SubdShuffleQueueEntryDataFragment
  )> };

export type GetShuffleRoomQueryVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type GetShuffleRoomQuery = { readonly __typename?: 'query_root', readonly room_ShuffleRoom_by_pk?: Maybe<{ readonly __typename?: 'room_ShuffleRoom', readonly id: any, readonly roomId: any }> };

export type ShufflePeriodsQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
  end: Scalars['timestamptz'];
}>;


export type ShufflePeriodsQuery = { readonly __typename?: 'query_root', readonly room_ShufflePeriod: ReadonlyArray<(
    { readonly __typename?: 'room_ShufflePeriod' }
    & ShufflePeriodDataFragment
  )> };

export type JoinShuffleQueueMutationVariables = Exact<{
  shufflePeriodId: Scalars['uuid'];
  attendeeId: Scalars['uuid'];
}>;


export type JoinShuffleQueueMutation = { readonly __typename?: 'mutation_root', readonly insert_room_ShuffleQueueEntry_one?: Maybe<(
    { readonly __typename?: 'room_ShuffleQueueEntry' }
    & PrefetchShuffleQueueEntryDataFragment
  )> };

export type GetShuffleRoomsParticipantsCountQueryVariables = Exact<{
  conferenceId: Scalars['uuid'];
}>;


export type GetShuffleRoomsParticipantsCountQuery = { readonly __typename?: 'query_root', readonly RoomParticipant_aggregate: { readonly __typename?: 'RoomParticipant_aggregate', readonly aggregate?: Maybe<{ readonly __typename?: 'RoomParticipant_aggregate_fields', readonly count?: Maybe<number> }> } };

export type AttendeeFieldsFragment = { readonly __typename?: 'Attendee', readonly id: any, readonly userId?: Maybe<string>, readonly conferenceId: any, readonly displayName: string, readonly createdAt: any, readonly updatedAt: any, readonly profile?: Maybe<{ readonly __typename?: 'AttendeeProfile', readonly attendeeId: any, readonly photoURL_50x50?: Maybe<string> }>, readonly conference: { readonly __typename?: 'Conference', readonly id: any, readonly name: string, readonly shortName: string, readonly slug: string }, readonly groupAttendees: ReadonlyArray<{ readonly __typename?: 'GroupAttendee', readonly id: any, readonly group: { readonly __typename?: 'Group', readonly id: any, readonly enabled: boolean, readonly name: string, readonly groupRoles: ReadonlyArray<{ readonly __typename?: 'GroupRole', readonly id: any, readonly role: { readonly __typename?: 'Role', readonly id: any, readonly name: string, readonly rolePermissions: ReadonlyArray<{ readonly __typename?: 'RolePermission', readonly id: any, readonly permissionName: Permission_Enum }> } }> } }> };

export type UserInfoFragment = { readonly __typename?: 'User', readonly id: string, readonly email?: Maybe<string>, readonly lastName: string, readonly firstName: string, readonly acceptedTermsAt?: Maybe<any>, readonly acceptedPrivacyPolicyAt?: Maybe<any>, readonly attendees: ReadonlyArray<(
    { readonly __typename?: 'Attendee' }
    & AttendeeFieldsFragment
  )> };

export type SelectCurrentUserQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type SelectCurrentUserQuery = { readonly __typename?: 'query_root', readonly User_by_pk?: Maybe<(
    { readonly __typename?: 'User' }
    & UserInfoFragment
  )> };

export type TermsConfigsQueryVariables = Exact<{ [key: string]: never; }>;


export type TermsConfigsQuery = { readonly __typename?: 'query_root', readonly hostOrganisationName?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly termsTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly termsURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly ppTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly ppURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly cookiesTimestamp?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }>, readonly cookiesURL?: Maybe<{ readonly __typename?: 'system_Configuration', readonly key: System_ConfigurationKey_Enum, readonly value: any, readonly updated_at: any }> };

export type AgreeToTermsMutationVariables = Exact<{
  userId: Scalars['String'];
  at: Scalars['timestamptz'];
}>;


export type AgreeToTermsMutation = { readonly __typename?: 'mutation_root', readonly update_User_by_pk?: Maybe<{ readonly __typename?: 'User', readonly id: string, readonly acceptedTermsAt?: Maybe<any>, readonly acceptedPrivacyPolicyAt?: Maybe<any> }> };

export type GetCurrentUserIsIncognitoQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type GetCurrentUserIsIncognitoQuery = { readonly __typename?: 'query_root', readonly OnlineStatus: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly isIncognito: boolean }> };

export type UpdateCurrentUserIsIncognitoMutationVariables = Exact<{
  userId: Scalars['String'];
  isIncognito?: Maybe<Scalars['Boolean']>;
}>;


export type UpdateCurrentUserIsIncognitoMutation = { readonly __typename?: 'mutation_root', readonly update_OnlineStatus?: Maybe<{ readonly __typename?: 'OnlineStatus_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly isIncognito: boolean }> }> };

export type GetCurrentUserLastSeenQueryVariables = Exact<{
  userId: Scalars['String'];
}>;


export type GetCurrentUserLastSeenQuery = { readonly __typename?: 'query_root', readonly OnlineStatus: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly lastSeen: any }> };

export type InsertCurrentUserOnlineStatusMutationVariables = Exact<{
  userId: Scalars['String'];
}>;


export type InsertCurrentUserOnlineStatusMutation = { readonly __typename?: 'mutation_root', readonly insert_OnlineStatus?: Maybe<{ readonly __typename?: 'OnlineStatus_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly isIncognito: boolean, readonly lastSeen: any, readonly userId: string }> }> };

export type UpdateCurrentUserLastSeenMutationVariables = Exact<{
  userId: Scalars['String'];
  lastSeen?: Maybe<Scalars['timestamptz']>;
}>;


export type UpdateCurrentUserLastSeenMutation = { readonly __typename?: 'mutation_root', readonly update_OnlineStatus?: Maybe<{ readonly __typename?: 'OnlineStatus_mutation_response', readonly returning: ReadonlyArray<{ readonly __typename?: 'OnlineStatus', readonly id: any, readonly lastSeen: any }> }> };

export const ChatState_SubdMessageFragmentDoc = gql`
    fragment ChatState_SubdMessage on chat_Message {
  id
  chatId
  message
  type
  senderId
}
    `;
export const InitialChatState_ChatFragmentDoc = gql`
    fragment InitialChatState_Chat on chat_Chat {
  id
  contentGroup {
    id
    title
    shortTitle
  }
  nonDMRoom: room(where: {roomPrivacyName: {_neq: DM}}) {
    id
    name
    priority
    roomPrivacyName
  }
  DMRoom: room(where: {roomPrivacyName: {_eq: DM}}) {
    id
    name
    roomPeople {
      id
      attendee {
        id
        displayName
      }
    }
  }
  enableAutoPin
  enableAutoSubscribe
  enableMandatoryPin
  enableMandatorySubscribe
  pins(where: {attendeeId: {_eq: $attendeeId}}) {
    attendeeId
    chatId
    wasManuallyPinned
  }
  subscriptions(where: {attendeeId: {_eq: $attendeeId}}) {
    attendeeId
    chatId
    wasManuallySubscribed
  }
}
    `;
export const ChatReactionDataFragmentDoc = gql`
    fragment ChatReactionData on chat_Reaction {
  sId
  data
  senderId
  symbol
  type
  messageSId
  duplicateSId
  created_at
  updated_at
  chatId
}
    `;
export const ChatMessageDataFragmentDoc = gql`
    fragment ChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageSId
  id
  sId
  message
  reactions {
    ...ChatReactionData
  }
  senderId
  type
  chatId
}
    ${ChatReactionDataFragmentDoc}`;
export const ShortChatMessageDataFragmentDoc = gql`
    fragment ShortChatMessageData on chat_Message {
  created_at
  data
  duplicatedMessageSId
  message
  senderId
  type
  chatId
  sId
}
    `;
export const ShortChatReactionDataFragmentDoc = gql`
    fragment ShortChatReactionData on chat_Reaction {
  data
  senderId
  symbol
  type
  messageSId
  sId
  duplicateSId
}
    `;
export const ContentGroupRoomEventFragmentDoc = gql`
    fragment ContentGroupRoomEvent on Event {
  startTime
  contentGroup {
    id
    title
  }
  id
  durationSeconds
  endTime
  name
  intendedRoomModeName
}
    `;
export const ContentItemDataFragmentDoc = gql`
    fragment ContentItemData on ContentItem {
  id
  data
  layoutData
  name
  contentTypeName
}
    `;
export const ContentPersonDataFragmentDoc = gql`
    fragment ContentPersonData on ContentGroupPerson {
  id
  person {
    id
    name
    affiliation
    attendeeId
  }
  roleName
  priority
}
    `;
export const ContentGroupItems_ContentGroupDataFragmentDoc = gql`
    fragment ContentGroupItems_ContentGroupData on ContentGroup {
  id
  title
  contentGroupTypeName
  chatId
  chat {
    room {
      id
      name
    }
  }
  contentItems(where: {isHidden: {_eq: false}}) {
    ...ContentItemData
  }
  people(order_by: {priority: asc}) {
    ...ContentPersonData
  }
}
    ${ContentItemDataFragmentDoc}
${ContentPersonDataFragmentDoc}`;
export const ContentGroupList_ContentPersonDataFragmentDoc = gql`
    fragment ContentGroupList_ContentPersonData on ContentGroupPerson {
  id
  person {
    id
    affiliation
    name
  }
  priority
}
    `;
export const ContentGroupList_ContentGroupDataFragmentDoc = gql`
    fragment ContentGroupList_ContentGroupData on ContentGroup {
  id
  title
  people(where: {roleName: {_nilike: "chair"}}) {
    ...ContentGroupList_ContentPersonData
  }
}
    ${ContentGroupList_ContentPersonDataFragmentDoc}`;
export const ContentGroupList_ContentGroupTagDataFragmentDoc = gql`
    fragment ContentGroupList_ContentGroupTagData on ContentGroupTag {
  contentGroup {
    ...ContentGroupList_ContentGroupData
  }
}
    ${ContentGroupList_ContentGroupDataFragmentDoc}`;
export const ContentGroupList_TagInfoFragmentDoc = gql`
    fragment ContentGroupList_TagInfo on Tag {
  id
  colour
  name
  priority
}
    `;
export const ContentGroupDataFragmentDoc = gql`
    fragment ContentGroupData on ContentGroup {
  id
  title
  contentGroupTypeName
  contentItems(where: {isHidden: {_eq: false}}) {
    ...ContentItemData
  }
  people(order_by: {priority: asc}) {
    ...ContentPersonData
  }
}
    ${ContentItemDataFragmentDoc}
${ContentPersonDataFragmentDoc}`;
export const ContentGroupPage_ContentGroupRoomsFragmentDoc = gql`
    fragment ContentGroupPage_ContentGroupRooms on ContentGroup {
  rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    `;
export const ContentGroupEventFragmentDoc = gql`
    fragment ContentGroupEvent on Event {
  startTime
  room {
    name
    id
  }
  id
  durationSeconds
  endTime
  name
  intendedRoomModeName
}
    `;
export const ContentGroupEventsFragmentDoc = gql`
    fragment ContentGroupEvents on ContentGroup {
  events {
    ...ContentGroupEvent
  }
}
    ${ContentGroupEventFragmentDoc}`;
export const HallwayContentGroupFragmentDoc = gql`
    fragment HallwayContentGroup on ContentGroup {
  id
  title
  contentGroupTypeName
  contentItems(
    where: {isHidden: {_eq: false}, contentTypeName: {_in: [ABSTRACT, IMAGE_FILE, IMAGE_URL, POSTER_FILE, POSTER_URL, TEXT, VIDEO_BROADCAST, VIDEO_FILE, VIDEO_PREPUBLISH, VIDEO_URL]}}
  ) {
    ...ContentItemData
  }
  events {
    id
    startTime
    endTime
    roomId
  }
  discussionRoom: rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    ${ContentItemDataFragmentDoc}`;
export const HallwayWithContentFragmentDoc = gql`
    fragment HallwayWithContent on Hallway {
  id
  name
  colour
  priority
  conferenceId
  contentGroups {
    id
    groupId
    hallwayId
    layout
    priority
    contentGroup {
      ...HallwayContentGroup
    }
  }
}
    ${HallwayContentGroupFragmentDoc}`;
export const HallwaySummaryFragmentDoc = gql`
    fragment HallwaySummary on Hallway {
  id
  name
  colour
  priority
}
    `;
export const EventParticipantStreamDetailsFragmentDoc = gql`
    fragment EventParticipantStreamDetails on EventParticipantStream {
  id
  attendee {
    id
    displayName
  }
  conferenceId
  eventId
  vonageStreamType
  vonageStreamId
  attendeeId
}
    `;
export const EventRoomJoinRequestDetailsFragmentDoc = gql`
    fragment EventRoomJoinRequestDetails on EventRoomJoinRequest {
  id
  attendeeId
}
    `;
export const RoomEventDetailsFragmentDoc = gql`
    fragment RoomEventDetails on Event {
  id
  conferenceId
  startTime
  name
  durationSeconds
  endTime
  intendedRoomModeName
  eventVonageSession {
    id
    sessionId
  }
}
    `;
export const Room_EventSummaryFragmentDoc = gql`
    fragment Room_EventSummary on Event {
  id
  conferenceId
  startTime
  name
  endTime
  intendedRoomModeName
  contentGroupId
  hallwayId
  contentGroup {
    id
    title
    contentGroupTypeName
    zoomItems: contentItems(where: {contentTypeName: {_eq: ZOOM}}, limit: 1) {
      id
      data
    }
    videoItems: contentItems(
      where: {contentTypeName: {_in: [VIDEO_BROADCAST, VIDEO_FILE]}, isHidden: {_eq: false}}
      limit: 1
      order_by: {createdAt: desc_nulls_last}
    ) {
      id
      data
    }
    chatId
  }
  eventPeople {
    id
    person {
      id
      name
      affiliation
      attendeeId
    }
    roleName
  }
}
    `;
export const RoomListRoomDetailsFragmentDoc = gql`
    fragment RoomListRoomDetails on Room {
  id
  name
  priority
  roomPrivacyName
  originatingContentGroupId
  originatingEventId
}
    `;
export const RoomPage_RoomPeopleFragmentDoc = gql`
    fragment RoomPage_RoomPeople on Room {
  roomPeople {
    id
    roomPersonRoleName
    attendeeId
  }
}
    `;
export const RoomPage_RoomDetailsFragmentDoc = gql`
    fragment RoomPage_RoomDetails on Room {
  id
  name
  currentModeName
  isProgramRoom
  mediaLiveChannel {
    cloudFrontDomain
    endpointUri
    id
  }
  publicVonageSessionId
  chatId
  originatingContentGroup {
    id
    contentGroupTypeName
    contentItems(
      where: {contentTypeName: {_in: [IMAGE_URL, IMAGE_FILE]}, layoutData: {_contains: {isLogo: true}}}
      limit: 1
      order_by: {updatedAt: desc}
    ) {
      id
      data
    }
    title
  }
  roomPrivacyName
  ...RoomPage_RoomPeople
  shuffleRooms(limit: 1, order_by: {id: desc}) {
    id
    startedAt
    durationMinutes
    reshuffleUponEnd
  }
  videoRoomBackendName
}
    ${RoomPage_RoomPeopleFragmentDoc}`;
export const RoomSponsorContent_ContentItemDataFragmentDoc = gql`
    fragment RoomSponsorContent_ContentItemData on ContentItem {
  id
  name
  isHidden
  contentTypeName
  data
  layoutData
}
    `;
export const RoomSponsorContent_ContentGroupDataFragmentDoc = gql`
    fragment RoomSponsorContent_ContentGroupData on ContentGroup {
  id
  contentItems {
    ...RoomSponsorContent_ContentItemData
  }
}
    ${RoomSponsorContent_ContentItemDataFragmentDoc}`;
export const Schedule_TagFragmentDoc = gql`
    fragment Schedule_Tag on Tag {
  id
  name
  colour
  priority
}
    `;
export const Schedule_EventTagFragmentDoc = gql`
    fragment Schedule_EventTag on EventTag {
  id
  tag {
    ...Schedule_Tag
  }
}
    ${Schedule_TagFragmentDoc}`;
export const Schedule_ContentGroupItemsFragmentDoc = gql`
    fragment Schedule_ContentGroupItems on ContentGroup {
  id
  title
  shortTitle
  contentGroupTypeName
}
    `;
export const Schedule_ContentItemFragmentDoc = gql`
    fragment Schedule_ContentItem on ContentItem {
  id
  contentTypeName
  name
  layoutData
  data
}
    `;
export const Schedule_ContentPersonFragmentDoc = gql`
    fragment Schedule_ContentPerson on ContentPerson {
  id
  name
  affiliation
  attendeeId
}
    `;
export const Schedule_ContentGroupPersonFragmentDoc = gql`
    fragment Schedule_ContentGroupPerson on ContentGroupPerson {
  id
  priority
  roleName
  person {
    ...Schedule_ContentPerson
  }
}
    ${Schedule_ContentPersonFragmentDoc}`;
export const Schedule_ContentGroupFragmentDoc = gql`
    fragment Schedule_ContentGroup on ContentGroup {
  ...Schedule_ContentGroupItems
  abstractContentItems: contentItems(
    where: {contentTypeName: {_eq: ABSTRACT}, isHidden: {_eq: false}}
  ) {
    ...Schedule_ContentItem
  }
  people {
    ...Schedule_ContentGroupPerson
  }
}
    ${Schedule_ContentGroupItemsFragmentDoc}
${Schedule_ContentItemFragmentDoc}
${Schedule_ContentGroupPersonFragmentDoc}`;
export const Schedule_EventSummaryFragmentDoc = gql`
    fragment Schedule_EventSummary on Event {
  id
  roomId
  intendedRoomModeName
  name
  startTime
  durationSeconds
  contentGroupId
}
    `;
export const Schedule_RoomSummaryFragmentDoc = gql`
    fragment Schedule_RoomSummary on Room {
  id
  name
  currentModeName
  priority
  roomPrivacyName
}
    `;
export const ConferenceConfiguration_ConferenceConfigurationsFragmentDoc = gql`
    fragment ConferenceConfiguration_ConferenceConfigurations on ConferenceConfiguration {
  id
  key
  value
}
    `;
export const SubmissionRequestsModal_ConferenceConfigurationFragmentDoc = gql`
    fragment SubmissionRequestsModal_ConferenceConfiguration on ConferenceConfiguration {
  id
  conferenceId
  key
  value
}
    `;
export const ContentPersonInfoFragmentDoc = gql`
    fragment ContentPersonInfo on ContentPerson {
  id
  conferenceId
  name
  affiliation
  email
  originatingDataId
  attendeeId
}
    `;
export const UploaderInfoFragmentDoc = gql`
    fragment UploaderInfo on Uploader {
  id
  conferenceId
  email
  emailsSentCount
  name
  requiredContentItemId
}
    `;
export const RequiredContentItemInfoFragmentDoc = gql`
    fragment RequiredContentItemInfo on RequiredContentItem {
  id
  name
  isHidden
  contentTypeName
  conferenceId
  contentGroupId
  uploadsRemaining
  uploaders {
    ...UploaderInfo
  }
  originatingDataId
}
    ${UploaderInfoFragmentDoc}`;
export const ContentItemInfoFragmentDoc = gql`
    fragment ContentItemInfo on ContentItem {
  conferenceId
  contentGroupId
  contentTypeName
  data
  id
  isHidden
  layoutData
  name
  requiredContentId
  originatingDataId
}
    `;
export const ContentGroupTagInfoFragmentDoc = gql`
    fragment ContentGroupTagInfo on ContentGroupTag {
  id
  tagId
  contentGroupId
}
    `;
export const ContentGroupHallwayInfoFragmentDoc = gql`
    fragment ContentGroupHallwayInfo on ContentGroupHallway {
  id
  groupId
  hallwayId
  conferenceId
  priority
  layout
}
    `;
export const ContentGroupPersonInfoFragmentDoc = gql`
    fragment ContentGroupPersonInfo on ContentGroupPerson {
  id
  conferenceId
  groupId
  personId
  priority
  roleName
}
    `;
export const ContentGroupFullNestedInfoFragmentDoc = gql`
    fragment ContentGroupFullNestedInfo on ContentGroup {
  id
  conferenceId
  contentGroupTypeName
  title
  shortTitle
  requiredContentItems {
    ...RequiredContentItemInfo
  }
  contentItems {
    ...ContentItemInfo
  }
  contentGroupTags {
    ...ContentGroupTagInfo
  }
  hallways {
    ...ContentGroupHallwayInfo
  }
  people {
    ...ContentGroupPersonInfo
  }
  originatingDataId
  rooms(
    where: {originatingEventId: {_is_null: true}}
    limit: 1
    order_by: {created_at: asc}
  ) {
    id
  }
}
    ${RequiredContentItemInfoFragmentDoc}
${ContentItemInfoFragmentDoc}
${ContentGroupTagInfoFragmentDoc}
${ContentGroupHallwayInfoFragmentDoc}
${ContentGroupPersonInfoFragmentDoc}`;
export const TagInfoFragmentDoc = gql`
    fragment TagInfo on Tag {
  id
  conferenceId
  colour
  name
  originatingDataId
  priority
}
    `;
export const HallwayInfoFragmentDoc = gql`
    fragment HallwayInfo on Hallway {
  id
  conferenceId
  colour
  name
  priority
}
    `;
export const ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc = gql`
    fragment ConfigureEmailTemplates_ConferenceConfiguration on ConferenceConfiguration {
  id
  conferenceId
  key
  value
}
    `;
export const ManageConferenceExportPage_AttendeeGoogleAccountFragmentDoc = gql`
    fragment ManageConferenceExportPage_AttendeeGoogleAccount on AttendeeGoogleAccount {
  id
  googleAccountEmail
}
    `;
export const UploadYouTubeVideos_UploadYouTubeVideoJobFragmentDoc = gql`
    fragment UploadYouTubeVideos_UploadYouTubeVideoJob on job_queues_UploadYouTubeVideoJob {
  id
  jobStatusName
  contentItem {
    id
    contentGroup {
      id
      title
    }
    name
  }
}
    `;
export const UploadYouTubeVideos_ContentItemFragmentDoc = gql`
    fragment UploadYouTubeVideos_ContentItem on ContentItem {
  id
  data
}
    `;
export const UploadYouTubeVideos_YouTubeUploadFragmentDoc = gql`
    fragment UploadYouTubeVideos_YouTubeUpload on YouTubeUpload {
  id
  videoId
  videoPrivacyStatus
  videoStatus
  videoTitle
  contentItem {
    id
    name
    contentGroup {
      id
      title
    }
  }
}
    `;
export const ManageGroups_GroupFragmentDoc = gql`
    fragment ManageGroups_Group on Group {
  conferenceId
  enabled
  id
  includeUnauthenticated
  name
  groupRoles {
    id
    roleId
    groupId
  }
}
    `;
export const ManageContentPeople_AttendeeFragmentDoc = gql`
    fragment ManageContentPeople_Attendee on Attendee {
  id
  displayName
  invitation {
    id
    invitedEmailAddress
  }
  profile {
    attendeeId
    affiliation
  }
}
    `;
export const ManageContentPeople_ContentPersonFragmentDoc = gql`
    fragment ManageContentPeople_ContentPerson on ContentPerson {
  id
  conferenceId
  name
  affiliation
  email
  originatingDataId
  attendeeId
}
    `;
export const InvitationPartsFragmentDoc = gql`
    fragment InvitationParts on Invitation {
  attendeeId
  id
  inviteCode
  invitedEmailAddress
  linkToUserId
  createdAt
  updatedAt
  hash
}
    `;
export const AttendeePartsFragmentDoc = gql`
    fragment AttendeeParts on Attendee {
  conferenceId
  id
  groupAttendees {
    attendeeId
    id
    groupId
  }
  invitation {
    ...InvitationParts
  }
  userId
  updatedAt
  createdAt
  displayName
  inviteSent
}
    ${InvitationPartsFragmentDoc}`;
export const RoomParticipantWithAttendeeInfoFragmentDoc = gql`
    fragment RoomParticipantWithAttendeeInfo on RoomParticipant {
  id
  conferenceId
  attendeeId
  roomId
  attendee {
    id
    displayName
  }
}
    `;
export const OriginatingDataInfoFragmentDoc = gql`
    fragment OriginatingDataInfo on OriginatingData {
  id
  conferenceId
  sourceId
  data
}
    `;
export const RoomWithParticipantInfoFragmentDoc = gql`
    fragment RoomWithParticipantInfo on Room {
  id
  conferenceId
  name
  currentModeName
  capacity
  priority
  originatingEventId
  originatingContentGroupId
  roomPrivacyName
  isProgramRoom
  participants {
    ...RoomParticipantWithAttendeeInfo
  }
  originatingData {
    ...OriginatingDataInfo
  }
}
    ${RoomParticipantWithAttendeeInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}`;
export const RoomPersonInfoFragmentDoc = gql`
    fragment RoomPersonInfo on RoomPerson {
  id
  attendee {
    id
    displayName
  }
  roomPersonRoleName
}
    `;
export const ManageShufflePeriods_ShufflePeriodFragmentDoc = gql`
    fragment ManageShufflePeriods_ShufflePeriod on room_ShufflePeriod {
  id
  created_at
  updated_at
  conferenceId
  startAt
  endAt
  roomDurationMinutes
  targetAttendeesPerRoom
  maxAttendeesPerRoom
  waitRoomMaxDurationSeconds
  name
  organiserId
  algorithm
  completedEntries: queueEntries_aggregate(
    where: {shuffleRoom: {isEnded: {_eq: true}}}
  ) {
    aggregate {
      count
    }
  }
  ongoingEntries: queueEntries_aggregate(
    where: {shuffleRoom: {isEnded: {_eq: false}}}
  ) {
    aggregate {
      count
    }
  }
  waitingEntries: queueEntries_aggregate(
    where: {allocatedShuffleRoomId: {_is_null: true}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
export const AddEventPeople_ContentGroupPersonFragmentDoc = gql`
    fragment AddEventPeople_ContentGroupPerson on ContentGroupPerson {
  id
  groupId
  personId
  roleName
}
    `;
export const AddEventPeople_ContentPersonFragmentDoc = gql`
    fragment AddEventPeople_ContentPerson on ContentPerson {
  id
  name
  affiliation
  email
  attendeeId
}
    `;
export const AddEventPeople_AttendeeFragmentDoc = gql`
    fragment AddEventPeople_Attendee on Attendee {
  id
  displayName
  profile {
    attendeeId
    affiliation
  }
  invitation {
    id
    invitedEmailAddress
  }
}
    `;
export const AddEventPeople_GroupFragmentDoc = gql`
    fragment AddEventPeople_Group on Group {
  id
  name
}
    `;
export const RoomParticipantInfoFragmentDoc = gql`
    fragment RoomParticipantInfo on RoomParticipant {
  attendeeId
  conferenceId
  id
  roomId
}
    `;
export const RoomInfoFragmentDoc = gql`
    fragment RoomInfo on Room {
  capacity
  conferenceId
  currentModeName
  id
  name
  priority
  originatingDataId
  originatingEventId
  originatingContentGroupId
  roomPrivacyName
  originatingData {
    ...OriginatingDataInfo
  }
  participants {
    ...RoomParticipantInfo
  }
}
    ${OriginatingDataInfoFragmentDoc}
${RoomParticipantInfoFragmentDoc}`;
export const EventPersonInfoFragmentDoc = gql`
    fragment EventPersonInfo on EventPerson {
  id
  eventId
  roleName
  personId
}
    `;
export const EventTagInfoFragmentDoc = gql`
    fragment EventTagInfo on EventTag {
  eventId
  id
  tagId
}
    `;
export const EventInfoFragmentDoc = gql`
    fragment EventInfo on Event {
  conferenceId
  id
  durationSeconds
  eventPeople {
    ...EventPersonInfo
  }
  eventTags {
    ...EventTagInfo
  }
  id
  intendedRoomModeName
  name
  originatingDataId
  roomId
  startTime
  endTime
  contentGroupId
  hallwayId
}
    ${EventPersonInfoFragmentDoc}
${EventTagInfoFragmentDoc}`;
export const EditableSponsorsTable_ContentGroupInfoFragmentDoc = gql`
    fragment EditableSponsorsTable_ContentGroupInfo on ContentGroup {
  id
  title
  shortTitle
  room {
    id
  }
}
    `;
export const SponsorSecondaryEditor_ContentItemFragmentDoc = gql`
    fragment SponsorSecondaryEditor_ContentItem on ContentItem {
  id
  name
  contentTypeName
  data
  layoutData
  isHidden
  updatedAt
}
    `;
export const AttendeeProfileDataFragmentDoc = gql`
    fragment AttendeeProfileData on AttendeeProfile {
  attendeeId
  badges
  affiliation
  affiliationURL
  country
  timezoneUTCOffset
  bio
  website
  github
  twitter
  pronouns
  photoURL_50x50
  photoURL_350x350
  hasBeenEdited
}
    `;
export const AttendeeDataFragmentDoc = gql`
    fragment AttendeeData on Attendee {
  id
  userId
  conferenceId
  displayName
  profile {
    ...AttendeeProfileData
  }
}
    ${AttendeeProfileDataFragmentDoc}`;
export const GroupDataFragmentDoc = gql`
    fragment GroupData on Group {
  groupRoles {
    role {
      rolePermissions {
        permissionName
        id
        roleId
      }
      id
      name
      conferenceId
    }
    id
    roleId
    groupId
  }
  enabled
  id
  includeUnauthenticated
  name
  conferenceId
}
    `;
export const AuthdConferenceInfoFragmentDoc = gql`
    fragment AuthdConferenceInfo on Conference {
  attendees(where: {userId: {_eq: $userId}}) {
    ...AttendeeData
    groupAttendees {
      group {
        ...GroupData
      }
      id
      groupId
      attendeeId
    }
  }
}
    ${AttendeeDataFragmentDoc}
${GroupDataFragmentDoc}`;
export const PublicConferenceInfoFragmentDoc = gql`
    fragment PublicConferenceInfo on Conference {
  id
  name
  shortName
  slug
  createdBy
  publicGroups: groups(
    where: {enabled: {_eq: true}, includeUnauthenticated: {_eq: true}}
  ) {
    ...GroupData
  }
}
    ${GroupDataFragmentDoc}`;
export const RequiredItemFieldsFragmentDoc = gql`
    fragment RequiredItemFields on RequiredContentItem {
  id
  contentTypeName
  name
  uploadsRemaining
  conference {
    id
    name
  }
  contentGroupTitle
}
    `;
export const EventPersonDetailsFragmentDoc = gql`
    fragment EventPersonDetails on EventPerson {
  id
  roleName
  eventId
  person {
    id
    name
    affiliation
    attendeeId
    attendee {
      id
      userId
      displayName
      profile {
        attendeeId
        affiliation
      }
    }
  }
}
    `;
export const MenuSchedule_EventFragmentDoc = gql`
    fragment MenuSchedule_Event on Event {
  id
  name
  startTime
  room {
    id
    name
  }
  eventTags {
    tag {
      id
      colour
      name
    }
  }
  contentGroup {
    id
    title
  }
}
    `;
export const MainMenuSponsors_ContentGroupDataFragmentDoc = gql`
    fragment MainMenuSponsors_ContentGroupData on ContentGroup {
  id
  rooms(
    limit: 1
    order_by: {created_at: asc}
    where: {conferenceId: {_eq: $conferenceId}}
  ) {
    id
  }
  logo: contentItems(
    where: {contentTypeName: {_in: [IMAGE_URL, IMAGE_FILE]}, layoutData: {_contains: {isLogo: true}}}
    order_by: {updatedAt: desc}
    limit: 1
  ) {
    id
    data
  }
  title
  shortTitle
}
    `;
export const RoomMemberFragmentDoc = gql`
    fragment RoomMember on RoomPerson {
  id
  roomId
  roomPersonRoleName
  attendeeId
}
    `;
export const RoomParticipantDetailsFragmentDoc = gql`
    fragment RoomParticipantDetails on RoomParticipant {
  conferenceId
  id
  roomId
  attendeeId
}
    `;
export const PrefetchShuffleQueueEntryDataFragmentDoc = gql`
    fragment PrefetchShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  attendeeId
  created_at
  updated_at
  shuffleRoom {
    id
    startedAt
    isEnded
    roomId
  }
}
    `;
export const ShufflePeriodDataFragmentDoc = gql`
    fragment ShufflePeriodData on room_ShufflePeriod {
  id
  conferenceId
  endAt
  maxAttendeesPerRoom
  name
  queueEntries(distinct_on: [attendeeId], order_by: {attendeeId: asc, id: desc}) {
    ...PrefetchShuffleQueueEntryData
  }
  roomDurationMinutes
  startAt
  targetAttendeesPerRoom
  waitRoomMaxDurationSeconds
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export const SubdShuffleQueueEntryDataFragmentDoc = gql`
    fragment SubdShuffleQueueEntryData on room_ShuffleQueueEntry {
  id
  allocatedShuffleRoomId
}
    `;
export const AttendeeFieldsFragmentDoc = gql`
    fragment AttendeeFields on Attendee {
  id
  userId
  conferenceId
  displayName
  createdAt
  updatedAt
  profile {
    attendeeId
    photoURL_50x50
  }
  conference {
    id
    name
    shortName
    slug
  }
  groupAttendees {
    id
    group {
      id
      enabled
      name
      groupRoles {
        id
        role {
          id
          name
          rolePermissions {
            id
            permissionName
          }
        }
      }
    }
  }
}
    `;
export const UserInfoFragmentDoc = gql`
    fragment UserInfo on User {
  id
  email
  lastName
  firstName
  acceptedTermsAt
  acceptedPrivacyPolicyAt
  attendees {
    ...AttendeeFields
  }
}
    ${AttendeeFieldsFragmentDoc}`;
export const InitialChatStateDocument = gql`
    query InitialChatState($attendeeId: uuid!) {
  chat_Pin(where: {attendeeId: {_eq: $attendeeId}}) {
    chatId
    attendeeId
    chat {
      ...InitialChatState_Chat
    }
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useInitialChatStateQuery__
 *
 * To run a query within a React component, call `useInitialChatStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useInitialChatStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useInitialChatStateQuery({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useInitialChatStateQuery(baseOptions: Apollo.QueryHookOptions<InitialChatStateQuery, InitialChatStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<InitialChatStateQuery, InitialChatStateQueryVariables>(InitialChatStateDocument, options);
      }
export function useInitialChatStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<InitialChatStateQuery, InitialChatStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<InitialChatStateQuery, InitialChatStateQueryVariables>(InitialChatStateDocument, options);
        }
export type InitialChatStateQueryHookResult = ReturnType<typeof useInitialChatStateQuery>;
export type InitialChatStateLazyQueryHookResult = ReturnType<typeof useInitialChatStateLazyQuery>;
export type InitialChatStateQueryResult = Apollo.QueryResult<InitialChatStateQuery, InitialChatStateQueryVariables>;
export const SelectInitialChatStateDocument = gql`
    query SelectInitialChatState($chatId: uuid!, $attendeeId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    ...InitialChatState_Chat
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useSelectInitialChatStateQuery__
 *
 * To run a query within a React component, call `useSelectInitialChatStateQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInitialChatStateQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInitialChatStateQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSelectInitialChatStateQuery(baseOptions: Apollo.QueryHookOptions<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>(SelectInitialChatStateDocument, options);
      }
export function useSelectInitialChatStateLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>(SelectInitialChatStateDocument, options);
        }
export type SelectInitialChatStateQueryHookResult = ReturnType<typeof useSelectInitialChatStateQuery>;
export type SelectInitialChatStateLazyQueryHookResult = ReturnType<typeof useSelectInitialChatStateLazyQuery>;
export type SelectInitialChatStateQueryResult = Apollo.QueryResult<SelectInitialChatStateQuery, SelectInitialChatStateQueryVariables>;
export const SelectInitialChatStatesDocument = gql`
    query SelectInitialChatStates($chatIds: [uuid!]!, $attendeeId: uuid!) {
  chat_Chat(where: {id: {_in: $chatIds}}) {
    ...InitialChatState_Chat
  }
}
    ${InitialChatState_ChatFragmentDoc}`;

/**
 * __useSelectInitialChatStatesQuery__
 *
 * To run a query within a React component, call `useSelectInitialChatStatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInitialChatStatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInitialChatStatesQuery({
 *   variables: {
 *      chatIds: // value for 'chatIds'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSelectInitialChatStatesQuery(baseOptions: Apollo.QueryHookOptions<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>(SelectInitialChatStatesDocument, options);
      }
export function useSelectInitialChatStatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>(SelectInitialChatStatesDocument, options);
        }
export type SelectInitialChatStatesQueryHookResult = ReturnType<typeof useSelectInitialChatStatesQuery>;
export type SelectInitialChatStatesLazyQueryHookResult = ReturnType<typeof useSelectInitialChatStatesLazyQuery>;
export type SelectInitialChatStatesQueryResult = Apollo.QueryResult<SelectInitialChatStatesQuery, SelectInitialChatStatesQueryVariables>;
export const SubscribeChatDocument = gql`
    mutation SubscribeChat($chatId: uuid!, $attendeeId: uuid!) {
  insert_chat_Subscription(
    objects: {chatId: $chatId, attendeeId: $attendeeId}
    on_conflict: {constraint: Subscription_pkey, update_columns: wasManuallySubscribed}
  ) {
    returning {
      chatId
      attendeeId
    }
  }
}
    `;
export type SubscribeChatMutationFn = Apollo.MutationFunction<SubscribeChatMutation, SubscribeChatMutationVariables>;

/**
 * __useSubscribeChatMutation__
 *
 * To run a mutation, you first call `useSubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [subscribeChatMutation, { data, loading, error }] = useSubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useSubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<SubscribeChatMutation, SubscribeChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubscribeChatMutation, SubscribeChatMutationVariables>(SubscribeChatDocument, options);
      }
export type SubscribeChatMutationHookResult = ReturnType<typeof useSubscribeChatMutation>;
export type SubscribeChatMutationResult = Apollo.MutationResult<SubscribeChatMutation>;
export type SubscribeChatMutationOptions = Apollo.BaseMutationOptions<SubscribeChatMutation, SubscribeChatMutationVariables>;
export const UnsubscribeChatDocument = gql`
    mutation UnsubscribeChat($chatId: uuid!, $attendeeId: uuid!) {
  delete_chat_Subscription_by_pk(chatId: $chatId, attendeeId: $attendeeId) {
    attendeeId
    chatId
  }
}
    `;
export type UnsubscribeChatMutationFn = Apollo.MutationFunction<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;

/**
 * __useUnsubscribeChatMutation__
 *
 * To run a mutation, you first call `useUnsubscribeChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnsubscribeChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unsubscribeChatMutation, { data, loading, error }] = useUnsubscribeChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useUnsubscribeChatMutation(baseOptions?: Apollo.MutationHookOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>(UnsubscribeChatDocument, options);
      }
export type UnsubscribeChatMutationHookResult = ReturnType<typeof useUnsubscribeChatMutation>;
export type UnsubscribeChatMutationResult = Apollo.MutationResult<UnsubscribeChatMutation>;
export type UnsubscribeChatMutationOptions = Apollo.BaseMutationOptions<UnsubscribeChatMutation, UnsubscribeChatMutationVariables>;
export const PinChatDocument = gql`
    mutation PinChat($chatId: uuid!, $attendeeId: uuid!) {
  insert_chat_Pin(
    objects: {chatId: $chatId, attendeeId: $attendeeId}
    on_conflict: {constraint: ChatPin_pkey, update_columns: wasManuallyPinned}
  ) {
    returning {
      chatId
      attendeeId
    }
  }
}
    `;
export type PinChatMutationFn = Apollo.MutationFunction<PinChatMutation, PinChatMutationVariables>;

/**
 * __usePinChatMutation__
 *
 * To run a mutation, you first call `usePinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `usePinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [pinChatMutation, { data, loading, error }] = usePinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function usePinChatMutation(baseOptions?: Apollo.MutationHookOptions<PinChatMutation, PinChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<PinChatMutation, PinChatMutationVariables>(PinChatDocument, options);
      }
export type PinChatMutationHookResult = ReturnType<typeof usePinChatMutation>;
export type PinChatMutationResult = Apollo.MutationResult<PinChatMutation>;
export type PinChatMutationOptions = Apollo.BaseMutationOptions<PinChatMutation, PinChatMutationVariables>;
export const UnpinChatDocument = gql`
    mutation UnpinChat($chatId: uuid!, $attendeeId: uuid!) {
  delete_chat_Pin_by_pk(chatId: $chatId, attendeeId: $attendeeId) {
    attendeeId
    chatId
  }
}
    `;
export type UnpinChatMutationFn = Apollo.MutationFunction<UnpinChatMutation, UnpinChatMutationVariables>;

/**
 * __useUnpinChatMutation__
 *
 * To run a mutation, you first call `useUnpinChatMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUnpinChatMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [unpinChatMutation, { data, loading, error }] = useUnpinChatMutation({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useUnpinChatMutation(baseOptions?: Apollo.MutationHookOptions<UnpinChatMutation, UnpinChatMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UnpinChatMutation, UnpinChatMutationVariables>(UnpinChatDocument, options);
      }
export type UnpinChatMutationHookResult = ReturnType<typeof useUnpinChatMutation>;
export type UnpinChatMutationResult = Apollo.MutationResult<UnpinChatMutation>;
export type UnpinChatMutationOptions = Apollo.BaseMutationOptions<UnpinChatMutation, UnpinChatMutationVariables>;
export const SelectMessagesPageDocument = gql`
    query SelectMessagesPage($chatId: uuid!, $startAtIndex: Int!, $maxCount: Int!) {
  chat_Message(
    order_by: {id: desc}
    where: {chatId: {_eq: $chatId}, id: {_lte: $startAtIndex}}
    limit: $maxCount
  ) {
    ...ChatMessageData
  }
}
    ${ChatMessageDataFragmentDoc}`;

/**
 * __useSelectMessagesPageQuery__
 *
 * To run a query within a React component, call `useSelectMessagesPageQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectMessagesPageQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectMessagesPageQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *      startAtIndex: // value for 'startAtIndex'
 *      maxCount: // value for 'maxCount'
 *   },
 * });
 */
export function useSelectMessagesPageQuery(baseOptions: Apollo.QueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, options);
      }
export function useSelectMessagesPageLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>(SelectMessagesPageDocument, options);
        }
export type SelectMessagesPageQueryHookResult = ReturnType<typeof useSelectMessagesPageQuery>;
export type SelectMessagesPageLazyQueryHookResult = ReturnType<typeof useSelectMessagesPageLazyQuery>;
export type SelectMessagesPageQueryResult = Apollo.QueryResult<SelectMessagesPageQuery, SelectMessagesPageQueryVariables>;
export const GetChatPathDocument = gql`
    query GetChatPath($chatId: uuid!) {
  chat_Chat_by_pk(id: $chatId) {
    id
    room {
      id
    }
    contentGroup {
      id
    }
  }
}
    `;

/**
 * __useGetChatPathQuery__
 *
 * To run a query within a React component, call `useGetChatPathQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetChatPathQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetChatPathQuery({
 *   variables: {
 *      chatId: // value for 'chatId'
 *   },
 * });
 */
export function useGetChatPathQuery(baseOptions: Apollo.QueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, options);
      }
export function useGetChatPathLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetChatPathQuery, GetChatPathQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetChatPathQuery, GetChatPathQueryVariables>(GetChatPathDocument, options);
        }
export type GetChatPathQueryHookResult = ReturnType<typeof useGetChatPathQuery>;
export type GetChatPathLazyQueryHookResult = ReturnType<typeof useGetChatPathLazyQuery>;
export type GetChatPathQueryResult = Apollo.QueryResult<GetChatPathQuery, GetChatPathQueryVariables>;
export const SelectAttendeesDocument = gql`
    query SelectAttendees($conferenceId: uuid!) {
  Attendee(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {displayName: asc}
  ) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useSelectAttendeesQuery__
 *
 * To run a query within a React component, call `useSelectAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAttendeesQuery(baseOptions: Apollo.QueryHookOptions<SelectAttendeesQuery, SelectAttendeesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAttendeesQuery, SelectAttendeesQueryVariables>(SelectAttendeesDocument, options);
      }
export function useSelectAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAttendeesQuery, SelectAttendeesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAttendeesQuery, SelectAttendeesQueryVariables>(SelectAttendeesDocument, options);
        }
export type SelectAttendeesQueryHookResult = ReturnType<typeof useSelectAttendeesQuery>;
export type SelectAttendeesLazyQueryHookResult = ReturnType<typeof useSelectAttendeesLazyQuery>;
export type SelectAttendeesQueryResult = Apollo.QueryResult<SelectAttendeesQuery, SelectAttendeesQueryVariables>;
export const SearchAttendeesDocument = gql`
    query SearchAttendees($conferenceId: uuid!, $search: String!) {
  Attendee(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {_or: [{displayName: {_ilike: $search}}, {profile: {_or: [{affiliation: {_ilike: $search}}, {bio: {_ilike: $search}}]}}, {badges: {name: {_ilike: $search}}}]}]}
    order_by: {displayName: asc}
  ) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useSearchAttendeesQuery__
 *
 * To run a query within a React component, call `useSearchAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useSearchAttendeesQuery(baseOptions: Apollo.QueryHookOptions<SearchAttendeesQuery, SearchAttendeesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchAttendeesQuery, SearchAttendeesQueryVariables>(SearchAttendeesDocument, options);
      }
export function useSearchAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchAttendeesQuery, SearchAttendeesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchAttendeesQuery, SearchAttendeesQueryVariables>(SearchAttendeesDocument, options);
        }
export type SearchAttendeesQueryHookResult = ReturnType<typeof useSearchAttendeesQuery>;
export type SearchAttendeesLazyQueryHookResult = ReturnType<typeof useSearchAttendeesLazyQuery>;
export type SearchAttendeesQueryResult = Apollo.QueryResult<SearchAttendeesQuery, SearchAttendeesQueryVariables>;
export const ConferenceLandingPageContentGroupDocument = gql`
    query ConferenceLandingPageContentGroup($conferenceId: uuid!) {
  ContentGroup(
    where: {_and: [{conferenceId: {_eq: $conferenceId}}, {contentGroupTypeName: {_eq: LANDING_PAGE}}]}
  ) {
    ...ContentGroupData
  }
}
    ${ContentGroupDataFragmentDoc}`;

/**
 * __useConferenceLandingPageContentGroupQuery__
 *
 * To run a query within a React component, call `useConferenceLandingPageContentGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceLandingPageContentGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceLandingPageContentGroupQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferenceLandingPageContentGroupQuery(baseOptions: Apollo.QueryHookOptions<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>(ConferenceLandingPageContentGroupDocument, options);
      }
export function useConferenceLandingPageContentGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>(ConferenceLandingPageContentGroupDocument, options);
        }
export type ConferenceLandingPageContentGroupQueryHookResult = ReturnType<typeof useConferenceLandingPageContentGroupQuery>;
export type ConferenceLandingPageContentGroupLazyQueryHookResult = ReturnType<typeof useConferenceLandingPageContentGroupLazyQuery>;
export type ConferenceLandingPageContentGroupQueryResult = Apollo.QueryResult<ConferenceLandingPageContentGroupQuery, ConferenceLandingPageContentGroupQueryVariables>;
export const ContentGroupItems_GetContentGroupDocument = gql`
    query ContentGroupItems_GetContentGroup($contentGroupId: uuid!) {
  ContentGroup_by_pk(id: $contentGroupId) {
    ...ContentGroupItems_ContentGroupData
  }
}
    ${ContentGroupItems_ContentGroupDataFragmentDoc}`;

/**
 * __useContentGroupItems_GetContentGroupQuery__
 *
 * To run a query within a React component, call `useContentGroupItems_GetContentGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentGroupItems_GetContentGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentGroupItems_GetContentGroupQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useContentGroupItems_GetContentGroupQuery(baseOptions: Apollo.QueryHookOptions<ContentGroupItems_GetContentGroupQuery, ContentGroupItems_GetContentGroupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContentGroupItems_GetContentGroupQuery, ContentGroupItems_GetContentGroupQueryVariables>(ContentGroupItems_GetContentGroupDocument, options);
      }
export function useContentGroupItems_GetContentGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentGroupItems_GetContentGroupQuery, ContentGroupItems_GetContentGroupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContentGroupItems_GetContentGroupQuery, ContentGroupItems_GetContentGroupQueryVariables>(ContentGroupItems_GetContentGroupDocument, options);
        }
export type ContentGroupItems_GetContentGroupQueryHookResult = ReturnType<typeof useContentGroupItems_GetContentGroupQuery>;
export type ContentGroupItems_GetContentGroupLazyQueryHookResult = ReturnType<typeof useContentGroupItems_GetContentGroupLazyQuery>;
export type ContentGroupItems_GetContentGroupQueryResult = Apollo.QueryResult<ContentGroupItems_GetContentGroupQuery, ContentGroupItems_GetContentGroupQueryVariables>;
export const ContentOfTagDocument = gql`
    query ContentOfTag($id: uuid!) {
  ContentGroupTag(where: {tagId: {_eq: $id}}) {
    ...ContentGroupList_ContentGroupTagData
  }
}
    ${ContentGroupList_ContentGroupTagDataFragmentDoc}`;

/**
 * __useContentOfTagQuery__
 *
 * To run a query within a React component, call `useContentOfTagQuery` and pass it any options that fit your needs.
 * When your component renders, `useContentOfTagQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useContentOfTagQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useContentOfTagQuery(baseOptions: Apollo.QueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, options);
      }
export function useContentOfTagLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ContentOfTagQuery, ContentOfTagQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ContentOfTagQuery, ContentOfTagQueryVariables>(ContentOfTagDocument, options);
        }
export type ContentOfTagQueryHookResult = ReturnType<typeof useContentOfTagQuery>;
export type ContentOfTagLazyQueryHookResult = ReturnType<typeof useContentOfTagLazyQuery>;
export type ContentOfTagQueryResult = Apollo.QueryResult<ContentOfTagQuery, ContentOfTagQueryVariables>;
export const TagsDocument = gql`
    query Tags($conferenceId: uuid!) {
  Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentGroupList_TagInfo
  }
}
    ${ContentGroupList_TagInfoFragmentDoc}`;

/**
 * __useTagsQuery__
 *
 * To run a query within a React component, call `useTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useTagsQuery(baseOptions: Apollo.QueryHookOptions<TagsQuery, TagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options);
      }
export function useTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TagsQuery, TagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TagsQuery, TagsQueryVariables>(TagsDocument, options);
        }
export type TagsQueryHookResult = ReturnType<typeof useTagsQuery>;
export type TagsLazyQueryHookResult = ReturnType<typeof useTagsLazyQuery>;
export type TagsQueryResult = Apollo.QueryResult<TagsQuery, TagsQueryVariables>;
export const GetContentGroupDocument = gql`
    query GetContentGroup($contentGroupId: uuid!) {
  ContentGroup_by_pk(id: $contentGroupId) {
    ...ContentGroupData
    ...ContentGroupEvents
    ...ContentGroupPage_ContentGroupRooms
  }
}
    ${ContentGroupDataFragmentDoc}
${ContentGroupEventsFragmentDoc}
${ContentGroupPage_ContentGroupRoomsFragmentDoc}`;

/**
 * __useGetContentGroupQuery__
 *
 * To run a query within a React component, call `useGetContentGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetContentGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetContentGroupQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useGetContentGroupQuery(baseOptions: Apollo.QueryHookOptions<GetContentGroupQuery, GetContentGroupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetContentGroupQuery, GetContentGroupQueryVariables>(GetContentGroupDocument, options);
      }
export function useGetContentGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetContentGroupQuery, GetContentGroupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetContentGroupQuery, GetContentGroupQueryVariables>(GetContentGroupDocument, options);
        }
export type GetContentGroupQueryHookResult = ReturnType<typeof useGetContentGroupQuery>;
export type GetContentGroupLazyQueryHookResult = ReturnType<typeof useGetContentGroupLazyQuery>;
export type GetContentGroupQueryResult = Apollo.QueryResult<GetContentGroupQuery, GetContentGroupQueryVariables>;
export const SelectHallwayDocument = gql`
    query SelectHallway($id: uuid!) {
  Hallway_by_pk(id: $id) {
    ...HallwayWithContent
  }
}
    ${HallwayWithContentFragmentDoc}`;

/**
 * __useSelectHallwayQuery__
 *
 * To run a query within a React component, call `useSelectHallwayQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectHallwayQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectHallwayQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSelectHallwayQuery(baseOptions: Apollo.QueryHookOptions<SelectHallwayQuery, SelectHallwayQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectHallwayQuery, SelectHallwayQueryVariables>(SelectHallwayDocument, options);
      }
export function useSelectHallwayLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectHallwayQuery, SelectHallwayQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectHallwayQuery, SelectHallwayQueryVariables>(SelectHallwayDocument, options);
        }
export type SelectHallwayQueryHookResult = ReturnType<typeof useSelectHallwayQuery>;
export type SelectHallwayLazyQueryHookResult = ReturnType<typeof useSelectHallwayLazyQuery>;
export type SelectHallwayQueryResult = Apollo.QueryResult<SelectHallwayQuery, SelectHallwayQueryVariables>;
export const SelectAllHallwaysDocument = gql`
    query SelectAllHallways($conferenceId: uuid!) {
  Hallway(where: {conferenceId: {_eq: $conferenceId}}) {
    ...HallwaySummary
  }
}
    ${HallwaySummaryFragmentDoc}`;

/**
 * __useSelectAllHallwaysQuery__
 *
 * To run a query within a React component, call `useSelectAllHallwaysQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllHallwaysQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllHallwaysQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllHallwaysQuery(baseOptions: Apollo.QueryHookOptions<SelectAllHallwaysQuery, SelectAllHallwaysQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllHallwaysQuery, SelectAllHallwaysQueryVariables>(SelectAllHallwaysDocument, options);
      }
export function useSelectAllHallwaysLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllHallwaysQuery, SelectAllHallwaysQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllHallwaysQuery, SelectAllHallwaysQueryVariables>(SelectAllHallwaysDocument, options);
        }
export type SelectAllHallwaysQueryHookResult = ReturnType<typeof useSelectAllHallwaysQuery>;
export type SelectAllHallwaysLazyQueryHookResult = ReturnType<typeof useSelectAllHallwaysLazyQuery>;
export type SelectAllHallwaysQueryResult = Apollo.QueryResult<SelectAllHallwaysQuery, SelectAllHallwaysQueryVariables>;
export const AttendeeByIdDocument = gql`
    query AttendeeById($conferenceId: uuid!, $attendeeId: uuid!) {
  Attendee(where: {id: {_eq: $attendeeId}, conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useAttendeeByIdQuery__
 *
 * To run a query within a React component, call `useAttendeeByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useAttendeeByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAttendeeByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useAttendeeByIdQuery(baseOptions: Apollo.QueryHookOptions<AttendeeByIdQuery, AttendeeByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AttendeeByIdQuery, AttendeeByIdQueryVariables>(AttendeeByIdDocument, options);
      }
export function useAttendeeByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AttendeeByIdQuery, AttendeeByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AttendeeByIdQuery, AttendeeByIdQueryVariables>(AttendeeByIdDocument, options);
        }
export type AttendeeByIdQueryHookResult = ReturnType<typeof useAttendeeByIdQuery>;
export type AttendeeByIdLazyQueryHookResult = ReturnType<typeof useAttendeeByIdLazyQuery>;
export type AttendeeByIdQueryResult = Apollo.QueryResult<AttendeeByIdQuery, AttendeeByIdQueryVariables>;
export const UpdateAttendeeProfileDocument = gql`
    mutation UpdateAttendeeProfile($attendeeId: uuid!, $profile: AttendeeProfile_set_input = {}) {
  update_AttendeeProfile_by_pk(
    pk_columns: {attendeeId: $attendeeId}
    _set: $profile
  ) {
    ...AttendeeProfileData
  }
}
    ${AttendeeProfileDataFragmentDoc}`;
export type UpdateAttendeeProfileMutationFn = Apollo.MutationFunction<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>;

/**
 * __useUpdateAttendeeProfileMutation__
 *
 * To run a mutation, you first call `useUpdateAttendeeProfileMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAttendeeProfileMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAttendeeProfileMutation, { data, loading, error }] = useUpdateAttendeeProfileMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      profile: // value for 'profile'
 *   },
 * });
 */
export function useUpdateAttendeeProfileMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>(UpdateAttendeeProfileDocument, options);
      }
export type UpdateAttendeeProfileMutationHookResult = ReturnType<typeof useUpdateAttendeeProfileMutation>;
export type UpdateAttendeeProfileMutationResult = Apollo.MutationResult<UpdateAttendeeProfileMutation>;
export type UpdateAttendeeProfileMutationOptions = Apollo.BaseMutationOptions<UpdateAttendeeProfileMutation, UpdateAttendeeProfileMutationVariables>;
export const UpdateAttendeeDisplayNameDocument = gql`
    mutation UpdateAttendeeDisplayName($attendeeId: uuid!, $name: String!) {
  update_Attendee_by_pk(pk_columns: {id: $attendeeId}, _set: {displayName: $name}) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;
export type UpdateAttendeeDisplayNameMutationFn = Apollo.MutationFunction<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>;

/**
 * __useUpdateAttendeeDisplayNameMutation__
 *
 * To run a mutation, you first call `useUpdateAttendeeDisplayNameMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAttendeeDisplayNameMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAttendeeDisplayNameMutation, { data, loading, error }] = useUpdateAttendeeDisplayNameMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateAttendeeDisplayNameMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>(UpdateAttendeeDisplayNameDocument, options);
      }
export type UpdateAttendeeDisplayNameMutationHookResult = ReturnType<typeof useUpdateAttendeeDisplayNameMutation>;
export type UpdateAttendeeDisplayNameMutationResult = Apollo.MutationResult<UpdateAttendeeDisplayNameMutation>;
export type UpdateAttendeeDisplayNameMutationOptions = Apollo.BaseMutationOptions<UpdateAttendeeDisplayNameMutation, UpdateAttendeeDisplayNameMutationVariables>;
export const SubmitProfilePhotoDocument = gql`
    mutation SubmitProfilePhoto($attendeeId: uuid!, $s3URL: String!) {
  updateProfilePhoto(attendeeId: $attendeeId, s3URL: $s3URL) {
    ok
    photoURL_350x350
    photoURL_50x50
  }
}
    `;
export type SubmitProfilePhotoMutationFn = Apollo.MutationFunction<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;

/**
 * __useSubmitProfilePhotoMutation__
 *
 * To run a mutation, you first call `useSubmitProfilePhotoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitProfilePhotoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitProfilePhotoMutation, { data, loading, error }] = useSubmitProfilePhotoMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      s3URL: // value for 's3URL'
 *   },
 * });
 */
export function useSubmitProfilePhotoMutation(baseOptions?: Apollo.MutationHookOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>(SubmitProfilePhotoDocument, options);
      }
export type SubmitProfilePhotoMutationHookResult = ReturnType<typeof useSubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationResult = Apollo.MutationResult<SubmitProfilePhotoMutation>;
export type SubmitProfilePhotoMutationOptions = Apollo.BaseMutationOptions<SubmitProfilePhotoMutation, SubmitProfilePhotoMutationVariables>;
export const AttendeeEventsWithBackstagesDocument = gql`
    query AttendeeEventsWithBackstages($attendeeId: uuid!) {
  Event(
    where: {eventPeople: {person: {attendeeId: {_eq: $attendeeId}}}, intendedRoomModeName: {_in: [PRESENTATION, Q_AND_A]}}
  ) {
    id
    conferenceId
    contentGroup {
      id
      title
    }
    endTime
    intendedRoomModeName
    name
    room {
      id
      name
    }
    startTime
  }
}
    `;

/**
 * __useAttendeeEventsWithBackstagesQuery__
 *
 * To run a query within a React component, call `useAttendeeEventsWithBackstagesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAttendeeEventsWithBackstagesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAttendeeEventsWithBackstagesQuery({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useAttendeeEventsWithBackstagesQuery(baseOptions: Apollo.QueryHookOptions<AttendeeEventsWithBackstagesQuery, AttendeeEventsWithBackstagesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AttendeeEventsWithBackstagesQuery, AttendeeEventsWithBackstagesQueryVariables>(AttendeeEventsWithBackstagesDocument, options);
      }
export function useAttendeeEventsWithBackstagesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AttendeeEventsWithBackstagesQuery, AttendeeEventsWithBackstagesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AttendeeEventsWithBackstagesQuery, AttendeeEventsWithBackstagesQueryVariables>(AttendeeEventsWithBackstagesDocument, options);
        }
export type AttendeeEventsWithBackstagesQueryHookResult = ReturnType<typeof useAttendeeEventsWithBackstagesQuery>;
export type AttendeeEventsWithBackstagesLazyQueryHookResult = ReturnType<typeof useAttendeeEventsWithBackstagesLazyQuery>;
export type AttendeeEventsWithBackstagesQueryResult = Apollo.QueryResult<AttendeeEventsWithBackstagesQuery, AttendeeEventsWithBackstagesQueryVariables>;
export const GetRoomChimeDataDocument = gql`
    mutation GetRoomChimeData($roomId: uuid!) {
  joinRoomChimeSession(roomId: $roomId) {
    attendee
    meeting
    message
  }
}
    `;
export type GetRoomChimeDataMutationFn = Apollo.MutationFunction<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>;

/**
 * __useGetRoomChimeDataMutation__
 *
 * To run a mutation, you first call `useGetRoomChimeDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetRoomChimeDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getRoomChimeDataMutation, { data, loading, error }] = useGetRoomChimeDataMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomChimeDataMutation(baseOptions?: Apollo.MutationHookOptions<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>(GetRoomChimeDataDocument, options);
      }
export type GetRoomChimeDataMutationHookResult = ReturnType<typeof useGetRoomChimeDataMutation>;
export type GetRoomChimeDataMutationResult = Apollo.MutationResult<GetRoomChimeDataMutation>;
export type GetRoomChimeDataMutationOptions = Apollo.BaseMutationOptions<GetRoomChimeDataMutation, GetRoomChimeDataMutationVariables>;
export const GetRoomVonageTokenDocument = gql`
    mutation GetRoomVonageToken($roomId: uuid!) {
  joinRoomVonageSession(roomId: $roomId) {
    accessToken
    sessionId
  }
}
    `;
export type GetRoomVonageTokenMutationFn = Apollo.MutationFunction<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;

/**
 * __useGetRoomVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetRoomVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetRoomVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getRoomVonageTokenMutation, { data, loading, error }] = useGetRoomVonageTokenMutation({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>(GetRoomVonageTokenDocument, options);
      }
export type GetRoomVonageTokenMutationHookResult = ReturnType<typeof useGetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationResult = Apollo.MutationResult<GetRoomVonageTokenMutation>;
export type GetRoomVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetRoomVonageTokenMutation, GetRoomVonageTokenMutationVariables>;
export const CreateDmDocument = gql`
    mutation CreateDm($attendeeIds: [uuid]!, $conferenceId: uuid!) {
  createRoomDm(attendeeIds: $attendeeIds, conferenceId: $conferenceId) {
    message
    roomId
    chatId
  }
}
    `;
export type CreateDmMutationFn = Apollo.MutationFunction<CreateDmMutation, CreateDmMutationVariables>;

/**
 * __useCreateDmMutation__
 *
 * To run a mutation, you first call `useCreateDmMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDmMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDmMutation, { data, loading, error }] = useCreateDmMutation({
 *   variables: {
 *      attendeeIds: // value for 'attendeeIds'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateDmMutation(baseOptions?: Apollo.MutationHookOptions<CreateDmMutation, CreateDmMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDmMutation, CreateDmMutationVariables>(CreateDmDocument, options);
      }
export type CreateDmMutationHookResult = ReturnType<typeof useCreateDmMutation>;
export type CreateDmMutationResult = Apollo.MutationResult<CreateDmMutation>;
export type CreateDmMutationOptions = Apollo.BaseMutationOptions<CreateDmMutation, CreateDmMutationVariables>;
export const AttendeeCreateRoomDocument = gql`
    mutation AttendeeCreateRoom($conferenceId: uuid!, $name: String!, $roomPrivacyName: RoomPrivacy_enum!) {
  insert_Room_one(
    object: {capacity: 50, conferenceId: $conferenceId, currentModeName: BREAKOUT, name: $name, roomPrivacyName: $roomPrivacyName}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;
export type AttendeeCreateRoomMutationFn = Apollo.MutationFunction<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>;

/**
 * __useAttendeeCreateRoomMutation__
 *
 * To run a mutation, you first call `useAttendeeCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAttendeeCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [attendeeCreateRoomMutation, { data, loading, error }] = useAttendeeCreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      name: // value for 'name'
 *      roomPrivacyName: // value for 'roomPrivacyName'
 *   },
 * });
 */
export function useAttendeeCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>(AttendeeCreateRoomDocument, options);
      }
export type AttendeeCreateRoomMutationHookResult = ReturnType<typeof useAttendeeCreateRoomMutation>;
export type AttendeeCreateRoomMutationResult = Apollo.MutationResult<AttendeeCreateRoomMutation>;
export type AttendeeCreateRoomMutationOptions = Apollo.BaseMutationOptions<AttendeeCreateRoomMutation, AttendeeCreateRoomMutationVariables>;
export const UpdateEventVonageSessionLayoutDocument = gql`
    mutation UpdateEventVonageSessionLayout($eventVonageSessionId: uuid!, $layoutData: jsonb!) {
  update_EventVonageSession_by_pk(
    pk_columns: {id: $eventVonageSessionId}
    _set: {layoutData: $layoutData}
  ) {
    id
  }
}
    `;
export type UpdateEventVonageSessionLayoutMutationFn = Apollo.MutationFunction<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;

/**
 * __useUpdateEventVonageSessionLayoutMutation__
 *
 * To run a mutation, you first call `useUpdateEventVonageSessionLayoutMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventVonageSessionLayoutMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventVonageSessionLayoutMutation, { data, loading, error }] = useUpdateEventVonageSessionLayoutMutation({
 *   variables: {
 *      eventVonageSessionId: // value for 'eventVonageSessionId'
 *      layoutData: // value for 'layoutData'
 *   },
 * });
 */
export function useUpdateEventVonageSessionLayoutMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>(UpdateEventVonageSessionLayoutDocument, options);
      }
export type UpdateEventVonageSessionLayoutMutationHookResult = ReturnType<typeof useUpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationResult = Apollo.MutationResult<UpdateEventVonageSessionLayoutMutation>;
export type UpdateEventVonageSessionLayoutMutationOptions = Apollo.BaseMutationOptions<UpdateEventVonageSessionLayoutMutation, UpdateEventVonageSessionLayoutMutationVariables>;
export const DeleteEventPersonDocument = gql`
    mutation DeleteEventPerson($eventPersonId: uuid!) {
  delete_EventPerson_by_pk(id: $eventPersonId) {
    id
  }
}
    `;
export type DeleteEventPersonMutationFn = Apollo.MutationFunction<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>;

/**
 * __useDeleteEventPersonMutation__
 *
 * To run a mutation, you first call `useDeleteEventPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventPersonMutation, { data, loading, error }] = useDeleteEventPersonMutation({
 *   variables: {
 *      eventPersonId: // value for 'eventPersonId'
 *   },
 * });
 */
export function useDeleteEventPersonMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>(DeleteEventPersonDocument, options);
      }
export type DeleteEventPersonMutationHookResult = ReturnType<typeof useDeleteEventPersonMutation>;
export type DeleteEventPersonMutationResult = Apollo.MutationResult<DeleteEventPersonMutation>;
export type DeleteEventPersonMutationOptions = Apollo.BaseMutationOptions<DeleteEventPersonMutation, DeleteEventPersonMutationVariables>;
export const GetEventParticipantStreamsDocument = gql`
    subscription GetEventParticipantStreams($eventId: uuid!) {
  EventParticipantStream(where: {eventId: {_eq: $eventId}}) {
    ...EventParticipantStreamDetails
  }
}
    ${EventParticipantStreamDetailsFragmentDoc}`;

/**
 * __useGetEventParticipantStreamsSubscription__
 *
 * To run a query within a React component, call `useGetEventParticipantStreamsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetEventParticipantStreamsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventParticipantStreamsSubscription({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventParticipantStreamsSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetEventParticipantStreamsSubscription, GetEventParticipantStreamsSubscriptionVariables>(GetEventParticipantStreamsDocument, options);
      }
export type GetEventParticipantStreamsSubscriptionHookResult = ReturnType<typeof useGetEventParticipantStreamsSubscription>;
export type GetEventParticipantStreamsSubscriptionResult = Apollo.SubscriptionResult<GetEventParticipantStreamsSubscription>;
export const UnapprovedEventRoomJoinRequestsDocument = gql`
    subscription UnapprovedEventRoomJoinRequests($conferenceId: uuid!, $eventId: uuid!) {
  EventRoomJoinRequest(
    where: {conferenceId: {_eq: $conferenceId}, eventId: {_eq: $eventId}, approved: {_eq: false}}
  ) {
    ...EventRoomJoinRequestDetails
  }
}
    ${EventRoomJoinRequestDetailsFragmentDoc}`;

/**
 * __useUnapprovedEventRoomJoinRequestsSubscription__
 *
 * To run a query within a React component, call `useUnapprovedEventRoomJoinRequestsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useUnapprovedEventRoomJoinRequestsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUnapprovedEventRoomJoinRequestsSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useUnapprovedEventRoomJoinRequestsSubscription(baseOptions: Apollo.SubscriptionHookOptions<UnapprovedEventRoomJoinRequestsSubscription, UnapprovedEventRoomJoinRequestsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<UnapprovedEventRoomJoinRequestsSubscription, UnapprovedEventRoomJoinRequestsSubscriptionVariables>(UnapprovedEventRoomJoinRequestsDocument, options);
      }
export type UnapprovedEventRoomJoinRequestsSubscriptionHookResult = ReturnType<typeof useUnapprovedEventRoomJoinRequestsSubscription>;
export type UnapprovedEventRoomJoinRequestsSubscriptionResult = Apollo.SubscriptionResult<UnapprovedEventRoomJoinRequestsSubscription>;
export const GetEventVonageTokenDocument = gql`
    mutation GetEventVonageToken($eventId: uuid!) {
  joinEventVonageSession(eventId: $eventId) {
    accessToken
  }
}
    `;
export type GetEventVonageTokenMutationFn = Apollo.MutationFunction<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;

/**
 * __useGetEventVonageTokenMutation__
 *
 * To run a mutation, you first call `useGetEventVonageTokenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageTokenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [getEventVonageTokenMutation, { data, loading, error }] = useGetEventVonageTokenMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageTokenMutation(baseOptions?: Apollo.MutationHookOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>(GetEventVonageTokenDocument, options);
      }
export type GetEventVonageTokenMutationHookResult = ReturnType<typeof useGetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationResult = Apollo.MutationResult<GetEventVonageTokenMutation>;
export type GetEventVonageTokenMutationOptions = Apollo.BaseMutationOptions<GetEventVonageTokenMutation, GetEventVonageTokenMutationVariables>;
export const GetEventDetailsDocument = gql`
    query GetEventDetails($eventId: uuid!) {
  Event_by_pk(id: $eventId) {
    ...RoomEventDetails
  }
}
    ${RoomEventDetailsFragmentDoc}`;

/**
 * __useGetEventDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
      }
export function useGetEventDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventDetailsQuery, GetEventDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventDetailsQuery, GetEventDetailsQueryVariables>(GetEventDetailsDocument, options);
        }
export type GetEventDetailsQueryHookResult = ReturnType<typeof useGetEventDetailsQuery>;
export type GetEventDetailsLazyQueryHookResult = ReturnType<typeof useGetEventDetailsLazyQuery>;
export type GetEventDetailsQueryResult = Apollo.QueryResult<GetEventDetailsQuery, GetEventDetailsQueryVariables>;
export const ApproveEventRoomJoinRequestDocument = gql`
    mutation ApproveEventRoomJoinRequest($eventRoomJoinRequestId: uuid!) {
  update_EventRoomJoinRequest_by_pk(
    pk_columns: {id: $eventRoomJoinRequestId}
    _set: {approved: true}
  ) {
    id
  }
}
    `;
export type ApproveEventRoomJoinRequestMutationFn = Apollo.MutationFunction<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>;

/**
 * __useApproveEventRoomJoinRequestMutation__
 *
 * To run a mutation, you first call `useApproveEventRoomJoinRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useApproveEventRoomJoinRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [approveEventRoomJoinRequestMutation, { data, loading, error }] = useApproveEventRoomJoinRequestMutation({
 *   variables: {
 *      eventRoomJoinRequestId: // value for 'eventRoomJoinRequestId'
 *   },
 * });
 */
export function useApproveEventRoomJoinRequestMutation(baseOptions?: Apollo.MutationHookOptions<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>(ApproveEventRoomJoinRequestDocument, options);
      }
export type ApproveEventRoomJoinRequestMutationHookResult = ReturnType<typeof useApproveEventRoomJoinRequestMutation>;
export type ApproveEventRoomJoinRequestMutationResult = Apollo.MutationResult<ApproveEventRoomJoinRequestMutation>;
export type ApproveEventRoomJoinRequestMutationOptions = Apollo.BaseMutationOptions<ApproveEventRoomJoinRequestMutation, ApproveEventRoomJoinRequestMutationVariables>;
export const GetBreakoutRoomFromEventDocument = gql`
    query GetBreakoutRoomFromEvent($originatingEventId: uuid!) {
  Room(where: {originatingEventId: {_eq: $originatingEventId}}) {
    id
  }
}
    `;

/**
 * __useGetBreakoutRoomFromEventQuery__
 *
 * To run a query within a React component, call `useGetBreakoutRoomFromEventQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetBreakoutRoomFromEventQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetBreakoutRoomFromEventQuery({
 *   variables: {
 *      originatingEventId: // value for 'originatingEventId'
 *   },
 * });
 */
export function useGetBreakoutRoomFromEventQuery(baseOptions: Apollo.QueryHookOptions<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>(GetBreakoutRoomFromEventDocument, options);
      }
export function useGetBreakoutRoomFromEventLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>(GetBreakoutRoomFromEventDocument, options);
        }
export type GetBreakoutRoomFromEventQueryHookResult = ReturnType<typeof useGetBreakoutRoomFromEventQuery>;
export type GetBreakoutRoomFromEventLazyQueryHookResult = ReturnType<typeof useGetBreakoutRoomFromEventLazyQuery>;
export type GetBreakoutRoomFromEventQueryResult = Apollo.QueryResult<GetBreakoutRoomFromEventQuery, GetBreakoutRoomFromEventQueryVariables>;
export const MakeEventRoomJoinRequestDocument = gql`
    mutation MakeEventRoomJoinRequest($attendeeId: uuid!, $conferenceId: uuid!, $eventId: uuid!) {
  insert_EventRoomJoinRequest_one(
    object: {attendeeId: $attendeeId, conferenceId: $conferenceId, eventId: $eventId}
  ) {
    id
  }
}
    `;
export type MakeEventRoomJoinRequestMutationFn = Apollo.MutationFunction<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>;

/**
 * __useMakeEventRoomJoinRequestMutation__
 *
 * To run a mutation, you first call `useMakeEventRoomJoinRequestMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useMakeEventRoomJoinRequestMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [makeEventRoomJoinRequestMutation, { data, loading, error }] = useMakeEventRoomJoinRequestMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useMakeEventRoomJoinRequestMutation(baseOptions?: Apollo.MutationHookOptions<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>(MakeEventRoomJoinRequestDocument, options);
      }
export type MakeEventRoomJoinRequestMutationHookResult = ReturnType<typeof useMakeEventRoomJoinRequestMutation>;
export type MakeEventRoomJoinRequestMutationResult = Apollo.MutationResult<MakeEventRoomJoinRequestMutation>;
export type MakeEventRoomJoinRequestMutationOptions = Apollo.BaseMutationOptions<MakeEventRoomJoinRequestMutation, MakeEventRoomJoinRequestMutationVariables>;
export const MyEventRoomJoinRequestDocument = gql`
    subscription MyEventRoomJoinRequest($attendeeId: uuid!, $conferenceId: uuid!, $eventId: uuid!) {
  EventRoomJoinRequest(
    where: {attendeeId: {_eq: $attendeeId}, conferenceId: {_eq: $conferenceId}, eventId: {_eq: $eventId}}
  ) {
    id
    approved
  }
}
    `;

/**
 * __useMyEventRoomJoinRequestSubscription__
 *
 * To run a query within a React component, call `useMyEventRoomJoinRequestSubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyEventRoomJoinRequestSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyEventRoomJoinRequestSubscription({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      conferenceId: // value for 'conferenceId'
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useMyEventRoomJoinRequestSubscription(baseOptions: Apollo.SubscriptionHookOptions<MyEventRoomJoinRequestSubscription, MyEventRoomJoinRequestSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<MyEventRoomJoinRequestSubscription, MyEventRoomJoinRequestSubscriptionVariables>(MyEventRoomJoinRequestDocument, options);
      }
export type MyEventRoomJoinRequestSubscriptionHookResult = ReturnType<typeof useMyEventRoomJoinRequestSubscription>;
export type MyEventRoomJoinRequestSubscriptionResult = Apollo.SubscriptionResult<MyEventRoomJoinRequestSubscription>;
export const Room_GetEventsDocument = gql`
    query Room_GetEvents($roomId: uuid!, $now: timestamptz!, $cutoff: timestamptz!) {
  Event(
    where: {roomId: {_eq: $roomId}, endTime: {_gte: $now}, startTime: {_lte: $cutoff}}
  ) {
    ...Room_EventSummary
  }
}
    ${Room_EventSummaryFragmentDoc}`;

/**
 * __useRoom_GetEventsQuery__
 *
 * To run a query within a React component, call `useRoom_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetEventsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *      now: // value for 'now'
 *      cutoff: // value for 'cutoff'
 *   },
 * });
 */
export function useRoom_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, options);
      }
export function useRoom_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetEventsQuery, Room_GetEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetEventsQuery, Room_GetEventsQueryVariables>(Room_GetEventsDocument, options);
        }
export type Room_GetEventsQueryHookResult = ReturnType<typeof useRoom_GetEventsQuery>;
export type Room_GetEventsLazyQueryHookResult = ReturnType<typeof useRoom_GetEventsLazyQuery>;
export type Room_GetEventsQueryResult = Apollo.QueryResult<Room_GetEventsQuery, Room_GetEventsQueryVariables>;
export const Room_GetEventBreakoutRoomDocument = gql`
    query Room_GetEventBreakoutRoom($originatingContentGroupId: uuid!) {
  Room(
    where: {originatingEventId: {_is_null: true}, originatingContentGroupId: {_eq: $originatingContentGroupId}}
    order_by: {created_at: asc}
    limit: 1
  ) {
    id
  }
}
    `;

/**
 * __useRoom_GetEventBreakoutRoomQuery__
 *
 * To run a query within a React component, call `useRoom_GetEventBreakoutRoomQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetEventBreakoutRoomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetEventBreakoutRoomQuery({
 *   variables: {
 *      originatingContentGroupId: // value for 'originatingContentGroupId'
 *   },
 * });
 */
export function useRoom_GetEventBreakoutRoomQuery(baseOptions: Apollo.QueryHookOptions<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>(Room_GetEventBreakoutRoomDocument, options);
      }
export function useRoom_GetEventBreakoutRoomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>(Room_GetEventBreakoutRoomDocument, options);
        }
export type Room_GetEventBreakoutRoomQueryHookResult = ReturnType<typeof useRoom_GetEventBreakoutRoomQuery>;
export type Room_GetEventBreakoutRoomLazyQueryHookResult = ReturnType<typeof useRoom_GetEventBreakoutRoomLazyQuery>;
export type Room_GetEventBreakoutRoomQueryResult = Apollo.QueryResult<Room_GetEventBreakoutRoomQuery, Room_GetEventBreakoutRoomQueryVariables>;
export const Room_GetDefaultVideoRoomBackendDocument = gql`
    query Room_GetDefaultVideoRoomBackend {
  system_Configuration_by_pk(key: DEFAULT_VIDEO_ROOM_BACKEND) {
    value
  }
}
    `;

/**
 * __useRoom_GetDefaultVideoRoomBackendQuery__
 *
 * To run a query within a React component, call `useRoom_GetDefaultVideoRoomBackendQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoom_GetDefaultVideoRoomBackendQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoom_GetDefaultVideoRoomBackendQuery({
 *   variables: {
 *   },
 * });
 */
export function useRoom_GetDefaultVideoRoomBackendQuery(baseOptions?: Apollo.QueryHookOptions<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>(Room_GetDefaultVideoRoomBackendDocument, options);
      }
export function useRoom_GetDefaultVideoRoomBackendLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>(Room_GetDefaultVideoRoomBackendDocument, options);
        }
export type Room_GetDefaultVideoRoomBackendQueryHookResult = ReturnType<typeof useRoom_GetDefaultVideoRoomBackendQuery>;
export type Room_GetDefaultVideoRoomBackendLazyQueryHookResult = ReturnType<typeof useRoom_GetDefaultVideoRoomBackendLazyQuery>;
export type Room_GetDefaultVideoRoomBackendQueryResult = Apollo.QueryResult<Room_GetDefaultVideoRoomBackendQuery, Room_GetDefaultVideoRoomBackendQueryVariables>;
export const AddParticipantToRoomDocument = gql`
    mutation AddParticipantToRoom($attendeeId: uuid!, $roomId: uuid!) {
  insert_RoomPerson_one(
    object: {attendeeId: $attendeeId, roomId: $roomId, roomPersonRoleName: PARTICIPANT}
  ) {
    id
  }
}
    `;
export type AddParticipantToRoomMutationFn = Apollo.MutationFunction<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;

/**
 * __useAddParticipantToRoomMutation__
 *
 * To run a mutation, you first call `useAddParticipantToRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddParticipantToRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addParticipantToRoomMutation, { data, loading, error }] = useAddParticipantToRoomMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useAddParticipantToRoomMutation(baseOptions?: Apollo.MutationHookOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>(AddParticipantToRoomDocument, options);
      }
export type AddParticipantToRoomMutationHookResult = ReturnType<typeof useAddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationResult = Apollo.MutationResult<AddParticipantToRoomMutation>;
export type AddParticipantToRoomMutationOptions = Apollo.BaseMutationOptions<AddParticipantToRoomMutation, AddParticipantToRoomMutationVariables>;
export const GetAllRoomsDocument = gql`
    query GetAllRooms($conferenceId: uuid!) {
  socialRooms: Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatoryPin: {_eq: true}}}]}, originatingContentGroupId: {_is_null: true}, originatingEventId: {_is_null: true}, roomPrivacyName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
  discussionRooms: Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatoryPin: {_eq: true}}}]}, _or: [{originatingContentGroupId: {_is_null: false}}, {originatingEventId: {_is_null: false}}], roomPrivacyName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
  programRooms: Room(
    where: {conferenceId: {_eq: $conferenceId}, events: {}, roomPrivacyName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;

/**
 * __useGetAllRoomsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetAllRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, options);
      }
export function useGetAllRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomsQuery, GetAllRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllRoomsQuery, GetAllRoomsQueryVariables>(GetAllRoomsDocument, options);
        }
export type GetAllRoomsQueryHookResult = ReturnType<typeof useGetAllRoomsQuery>;
export type GetAllRoomsLazyQueryHookResult = ReturnType<typeof useGetAllRoomsLazyQuery>;
export type GetAllRoomsQueryResult = Apollo.QueryResult<GetAllRoomsQuery, GetAllRoomsQueryVariables>;
export const GetAllTodaysRoomsDocument = gql`
    query GetAllTodaysRooms($conferenceId: uuid!, $todayStart: timestamptz!, $todayEnd: timestamptz!) {
  socialOrDiscussionRooms: Room(
    where: {conferenceId: {_eq: $conferenceId}, _not: {_or: [{events: {}}, {chat: {enableMandatoryPin: {_eq: true}}}]}, roomPrivacyName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
  programRooms: Room(
    where: {conferenceId: {_eq: $conferenceId}, events: {startTime: {_lte: $todayEnd}, endTime: {_gte: $todayStart}}, roomPrivacyName: {_in: [PUBLIC, PRIVATE]}}
    order_by: {name: asc}
  ) {
    ...RoomListRoomDetails
  }
}
    ${RoomListRoomDetailsFragmentDoc}`;

/**
 * __useGetAllTodaysRoomsQuery__
 *
 * To run a query within a React component, call `useGetAllTodaysRoomsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllTodaysRoomsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllTodaysRoomsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      todayStart: // value for 'todayStart'
 *      todayEnd: // value for 'todayEnd'
 *   },
 * });
 */
export function useGetAllTodaysRoomsQuery(baseOptions: Apollo.QueryHookOptions<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>(GetAllTodaysRoomsDocument, options);
      }
export function useGetAllTodaysRoomsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>(GetAllTodaysRoomsDocument, options);
        }
export type GetAllTodaysRoomsQueryHookResult = ReturnType<typeof useGetAllTodaysRoomsQuery>;
export type GetAllTodaysRoomsLazyQueryHookResult = ReturnType<typeof useGetAllTodaysRoomsLazyQuery>;
export type GetAllTodaysRoomsQueryResult = Apollo.QueryResult<GetAllTodaysRoomsQuery, GetAllTodaysRoomsQueryVariables>;
export const RoomPage_GetRoomDetailsDocument = gql`
    query RoomPage_GetRoomDetails($roomId: uuid!) {
  Room_by_pk(id: $roomId) {
    ...RoomPage_RoomDetails
  }
}
    ${RoomPage_RoomDetailsFragmentDoc}`;

/**
 * __useRoomPage_GetRoomDetailsQuery__
 *
 * To run a query within a React component, call `useRoomPage_GetRoomDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomPage_GetRoomDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomPage_GetRoomDetailsQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useRoomPage_GetRoomDetailsQuery(baseOptions: Apollo.QueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, options);
      }
export function useRoomPage_GetRoomDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>(RoomPage_GetRoomDetailsDocument, options);
        }
export type RoomPage_GetRoomDetailsQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsQuery>;
export type RoomPage_GetRoomDetailsLazyQueryHookResult = ReturnType<typeof useRoomPage_GetRoomDetailsLazyQuery>;
export type RoomPage_GetRoomDetailsQueryResult = Apollo.QueryResult<RoomPage_GetRoomDetailsQuery, RoomPage_GetRoomDetailsQueryVariables>;
export const GetEventVonageDetailsDocument = gql`
    query GetEventVonageDetails($eventId: uuid!) {
  Event_by_pk(id: $eventId) {
    eventVonageSession {
      sessionId
      id
    }
    id
  }
}
    `;

/**
 * __useGetEventVonageDetailsQuery__
 *
 * To run a query within a React component, call `useGetEventVonageDetailsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetEventVonageDetailsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetEventVonageDetailsQuery({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useGetEventVonageDetailsQuery(baseOptions: Apollo.QueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, options);
      }
export function useGetEventVonageDetailsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>(GetEventVonageDetailsDocument, options);
        }
export type GetEventVonageDetailsQueryHookResult = ReturnType<typeof useGetEventVonageDetailsQuery>;
export type GetEventVonageDetailsLazyQueryHookResult = ReturnType<typeof useGetEventVonageDetailsLazyQuery>;
export type GetEventVonageDetailsQueryResult = Apollo.QueryResult<GetEventVonageDetailsQuery, GetEventVonageDetailsQueryVariables>;
export const RoomSponsorContent_GetContentItemsDocument = gql`
    query RoomSponsorContent_GetContentItems($contentGroupId: uuid!) {
  ContentGroup(
    where: {id: {_eq: $contentGroupId}, contentGroupTypeName: {_eq: SPONSOR}}
  ) {
    ...RoomSponsorContent_ContentGroupData
  }
}
    ${RoomSponsorContent_ContentGroupDataFragmentDoc}`;

/**
 * __useRoomSponsorContent_GetContentItemsQuery__
 *
 * To run a query within a React component, call `useRoomSponsorContent_GetContentItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useRoomSponsorContent_GetContentItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRoomSponsorContent_GetContentItemsQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useRoomSponsorContent_GetContentItemsQuery(baseOptions: Apollo.QueryHookOptions<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>(RoomSponsorContent_GetContentItemsDocument, options);
      }
export function useRoomSponsorContent_GetContentItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>(RoomSponsorContent_GetContentItemsDocument, options);
        }
export type RoomSponsorContent_GetContentItemsQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetContentItemsQuery>;
export type RoomSponsorContent_GetContentItemsLazyQueryHookResult = ReturnType<typeof useRoomSponsorContent_GetContentItemsLazyQuery>;
export type RoomSponsorContent_GetContentItemsQueryResult = Apollo.QueryResult<RoomSponsorContent_GetContentItemsQuery, RoomSponsorContent_GetContentItemsQueryVariables>;
export const Schedule_SelectContentGroupDocument = gql`
    query Schedule_SelectContentGroup($id: uuid!) {
  ContentGroup_by_pk(id: $id) {
    ...Schedule_ContentGroup
  }
}
    ${Schedule_ContentGroupFragmentDoc}`;

/**
 * __useSchedule_SelectContentGroupQuery__
 *
 * To run a query within a React component, call `useSchedule_SelectContentGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchedule_SelectContentGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchedule_SelectContentGroupQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useSchedule_SelectContentGroupQuery(baseOptions: Apollo.QueryHookOptions<Schedule_SelectContentGroupQuery, Schedule_SelectContentGroupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Schedule_SelectContentGroupQuery, Schedule_SelectContentGroupQueryVariables>(Schedule_SelectContentGroupDocument, options);
      }
export function useSchedule_SelectContentGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Schedule_SelectContentGroupQuery, Schedule_SelectContentGroupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Schedule_SelectContentGroupQuery, Schedule_SelectContentGroupQueryVariables>(Schedule_SelectContentGroupDocument, options);
        }
export type Schedule_SelectContentGroupQueryHookResult = ReturnType<typeof useSchedule_SelectContentGroupQuery>;
export type Schedule_SelectContentGroupLazyQueryHookResult = ReturnType<typeof useSchedule_SelectContentGroupLazyQuery>;
export type Schedule_SelectContentGroupQueryResult = Apollo.QueryResult<Schedule_SelectContentGroupQuery, Schedule_SelectContentGroupQueryVariables>;
export const Schedule_SelectSummariesDocument = gql`
    query Schedule_SelectSummaries($conferenceId: uuid!) {
  Room(
    where: {conferenceId: {_eq: $conferenceId}, roomPrivacyName: {_in: [PUBLIC, PRIVATE]}, events: {}}
  ) {
    ...Schedule_RoomSummary
  }
  Event(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_EventSummary
  }
  ContentGroup(where: {conferenceId: {_eq: $conferenceId}}) {
    ...Schedule_ContentGroupItems
  }
}
    ${Schedule_RoomSummaryFragmentDoc}
${Schedule_EventSummaryFragmentDoc}
${Schedule_ContentGroupItemsFragmentDoc}`;

/**
 * __useSchedule_SelectSummariesQuery__
 *
 * To run a query within a React component, call `useSchedule_SelectSummariesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSchedule_SelectSummariesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSchedule_SelectSummariesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSchedule_SelectSummariesQuery(baseOptions: Apollo.QueryHookOptions<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>(Schedule_SelectSummariesDocument, options);
      }
export function useSchedule_SelectSummariesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>(Schedule_SelectSummariesDocument, options);
        }
export type Schedule_SelectSummariesQueryHookResult = ReturnType<typeof useSchedule_SelectSummariesQuery>;
export type Schedule_SelectSummariesLazyQueryHookResult = ReturnType<typeof useSchedule_SelectSummariesLazyQuery>;
export type Schedule_SelectSummariesQueryResult = Apollo.QueryResult<Schedule_SelectSummariesQuery, Schedule_SelectSummariesQueryVariables>;
export const AttendeesByIdDocument = gql`
    query AttendeesById($conferenceId: uuid!, $attendeeIds: [uuid!]!) {
  Attendee(where: {id: {_in: $attendeeIds}, conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useAttendeesByIdQuery__
 *
 * To run a query within a React component, call `useAttendeesByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useAttendeesByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAttendeesByIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      attendeeIds: // value for 'attendeeIds'
 *   },
 * });
 */
export function useAttendeesByIdQuery(baseOptions: Apollo.QueryHookOptions<AttendeesByIdQuery, AttendeesByIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AttendeesByIdQuery, AttendeesByIdQueryVariables>(AttendeesByIdDocument, options);
      }
export function useAttendeesByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AttendeesByIdQuery, AttendeesByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AttendeesByIdQuery, AttendeesByIdQueryVariables>(AttendeesByIdDocument, options);
        }
export type AttendeesByIdQueryHookResult = ReturnType<typeof useAttendeesByIdQuery>;
export type AttendeesByIdLazyQueryHookResult = ReturnType<typeof useAttendeesByIdLazyQuery>;
export type AttendeesByIdQueryResult = Apollo.QueryResult<AttendeesByIdQuery, AttendeesByIdQueryVariables>;
export const AttendeesByUserIdDocument = gql`
    query AttendeesByUserId($conferenceId: uuid!, $userIds: [String!]!) {
  Attendee(where: {userId: {_in: $userIds}, conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeData
  }
}
    ${AttendeeDataFragmentDoc}`;

/**
 * __useAttendeesByUserIdQuery__
 *
 * To run a query within a React component, call `useAttendeesByUserIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useAttendeesByUserIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAttendeesByUserIdQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      userIds: // value for 'userIds'
 *   },
 * });
 */
export function useAttendeesByUserIdQuery(baseOptions: Apollo.QueryHookOptions<AttendeesByUserIdQuery, AttendeesByUserIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AttendeesByUserIdQuery, AttendeesByUserIdQueryVariables>(AttendeesByUserIdDocument, options);
      }
export function useAttendeesByUserIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AttendeesByUserIdQuery, AttendeesByUserIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AttendeesByUserIdQuery, AttendeesByUserIdQueryVariables>(AttendeesByUserIdDocument, options);
        }
export type AttendeesByUserIdQueryHookResult = ReturnType<typeof useAttendeesByUserIdQuery>;
export type AttendeesByUserIdLazyQueryHookResult = ReturnType<typeof useAttendeesByUserIdLazyQuery>;
export type AttendeesByUserIdQueryResult = Apollo.QueryResult<AttendeesByUserIdQuery, AttendeesByUserIdQueryVariables>;
export const GetMediaLiveChannelsDocument = gql`
    query GetMediaLiveChannels($conferenceId: uuid!) {
  Room(where: {mediaLiveChannel: {}, conferenceId: {_eq: $conferenceId}}) {
    mediaLiveChannel {
      cloudFrontDomain
      endpointUri
      id
    }
    name
    id
  }
}
    `;

/**
 * __useGetMediaLiveChannelsQuery__
 *
 * To run a query within a React component, call `useGetMediaLiveChannelsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetMediaLiveChannelsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetMediaLiveChannelsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetMediaLiveChannelsQuery(baseOptions: Apollo.QueryHookOptions<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>(GetMediaLiveChannelsDocument, options);
      }
export function useGetMediaLiveChannelsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>(GetMediaLiveChannelsDocument, options);
        }
export type GetMediaLiveChannelsQueryHookResult = ReturnType<typeof useGetMediaLiveChannelsQuery>;
export type GetMediaLiveChannelsLazyQueryHookResult = ReturnType<typeof useGetMediaLiveChannelsLazyQuery>;
export type GetMediaLiveChannelsQueryResult = Apollo.QueryResult<GetMediaLiveChannelsQuery, GetMediaLiveChannelsQueryVariables>;
export const ConferenceConfiguration_GetConferenceConfigurationsDocument = gql`
    query ConferenceConfiguration_GetConferenceConfigurations($conferenceId: uuid!) {
  ConferenceConfiguration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConferenceConfiguration_ConferenceConfigurations
  }
}
    ${ConferenceConfiguration_ConferenceConfigurationsFragmentDoc}`;

/**
 * __useConferenceConfiguration_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useConferenceConfiguration_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceConfiguration_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceConfiguration_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferenceConfiguration_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>(ConferenceConfiguration_GetConferenceConfigurationsDocument, options);
      }
export function useConferenceConfiguration_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>(ConferenceConfiguration_GetConferenceConfigurationsDocument, options);
        }
export type ConferenceConfiguration_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useConferenceConfiguration_GetConferenceConfigurationsQuery>;
export type ConferenceConfiguration_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useConferenceConfiguration_GetConferenceConfigurationsLazyQuery>;
export type ConferenceConfiguration_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<ConferenceConfiguration_GetConferenceConfigurationsQuery, ConferenceConfiguration_GetConferenceConfigurationsQueryVariables>;
export const ConferenceConfiguration_UpdateConferenceConfigurationsDocument = gql`
    mutation ConferenceConfiguration_UpdateConferenceConfigurations($conferenceConfigurationId: uuid!, $value: jsonb!) {
  update_ConferenceConfiguration_by_pk(
    pk_columns: {id: $conferenceConfigurationId}
    _set: {value: $value}
  ) {
    id
  }
}
    `;
export type ConferenceConfiguration_UpdateConferenceConfigurationsMutationFn = Apollo.MutationFunction<ConferenceConfiguration_UpdateConferenceConfigurationsMutation, ConferenceConfiguration_UpdateConferenceConfigurationsMutationVariables>;

/**
 * __useConferenceConfiguration_UpdateConferenceConfigurationsMutation__
 *
 * To run a mutation, you first call `useConferenceConfiguration_UpdateConferenceConfigurationsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConferenceConfiguration_UpdateConferenceConfigurationsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [conferenceConfigurationUpdateConferenceConfigurationsMutation, { data, loading, error }] = useConferenceConfiguration_UpdateConferenceConfigurationsMutation({
 *   variables: {
 *      conferenceConfigurationId: // value for 'conferenceConfigurationId'
 *      value: // value for 'value'
 *   },
 * });
 */
export function useConferenceConfiguration_UpdateConferenceConfigurationsMutation(baseOptions?: Apollo.MutationHookOptions<ConferenceConfiguration_UpdateConferenceConfigurationsMutation, ConferenceConfiguration_UpdateConferenceConfigurationsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConferenceConfiguration_UpdateConferenceConfigurationsMutation, ConferenceConfiguration_UpdateConferenceConfigurationsMutationVariables>(ConferenceConfiguration_UpdateConferenceConfigurationsDocument, options);
      }
export type ConferenceConfiguration_UpdateConferenceConfigurationsMutationHookResult = ReturnType<typeof useConferenceConfiguration_UpdateConferenceConfigurationsMutation>;
export type ConferenceConfiguration_UpdateConferenceConfigurationsMutationResult = Apollo.MutationResult<ConferenceConfiguration_UpdateConferenceConfigurationsMutation>;
export type ConferenceConfiguration_UpdateConferenceConfigurationsMutationOptions = Apollo.BaseMutationOptions<ConferenceConfiguration_UpdateConferenceConfigurationsMutation, ConferenceConfiguration_UpdateConferenceConfigurationsMutationVariables>;
export const EventVonageControls_GetEventsDocument = gql`
    query EventVonageControls_GetEvents($conferenceId: uuid!) {
  Event(
    where: {conferenceId: {_eq: $conferenceId}, intendedRoomModeName: {_in: [Q_AND_A, PRESENTATION]}}
  ) {
    id
    name
    contentGroup {
      id
      title
    }
  }
}
    `;

/**
 * __useEventVonageControls_GetEventsQuery__
 *
 * To run a query within a React component, call `useEventVonageControls_GetEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_GetEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEventVonageControls_GetEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useEventVonageControls_GetEventsQuery(baseOptions: Apollo.QueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, options);
      }
export function useEventVonageControls_GetEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>(EventVonageControls_GetEventsDocument, options);
        }
export type EventVonageControls_GetEventsQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsQuery>;
export type EventVonageControls_GetEventsLazyQueryHookResult = ReturnType<typeof useEventVonageControls_GetEventsLazyQuery>;
export type EventVonageControls_GetEventsQueryResult = Apollo.QueryResult<EventVonageControls_GetEventsQuery, EventVonageControls_GetEventsQueryVariables>;
export const EventVonageControls_StopEventBroadcastDocument = gql`
    mutation EventVonageControls_StopEventBroadcast($eventId: uuid!) {
  stopEventBroadcast(eventId: $eventId) {
    broadcastsStopped
  }
}
    `;
export type EventVonageControls_StopEventBroadcastMutationFn = Apollo.MutationFunction<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;

/**
 * __useEventVonageControls_StopEventBroadcastMutation__
 *
 * To run a mutation, you first call `useEventVonageControls_StopEventBroadcastMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEventVonageControls_StopEventBroadcastMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [eventVonageControlsStopEventBroadcastMutation, { data, loading, error }] = useEventVonageControls_StopEventBroadcastMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *   },
 * });
 */
export function useEventVonageControls_StopEventBroadcastMutation(baseOptions?: Apollo.MutationHookOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>(EventVonageControls_StopEventBroadcastDocument, options);
      }
export type EventVonageControls_StopEventBroadcastMutationHookResult = ReturnType<typeof useEventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationResult = Apollo.MutationResult<EventVonageControls_StopEventBroadcastMutation>;
export type EventVonageControls_StopEventBroadcastMutationOptions = Apollo.BaseMutationOptions<EventVonageControls_StopEventBroadcastMutation, EventVonageControls_StopEventBroadcastMutationVariables>;
export const CreateConferencePrepareJobDocument = gql`
    mutation CreateConferencePrepareJob($conferenceId: uuid!) {
  insert_ConferencePrepareJob_one(object: {conferenceId: $conferenceId}) {
    id
    conferenceId
  }
}
    `;
export type CreateConferencePrepareJobMutationFn = Apollo.MutationFunction<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;

/**
 * __useCreateConferencePrepareJobMutation__
 *
 * To run a mutation, you first call `useCreateConferencePrepareJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferencePrepareJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferencePrepareJobMutation, { data, loading, error }] = useCreateConferencePrepareJobMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useCreateConferencePrepareJobMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>(CreateConferencePrepareJobDocument, options);
      }
export type CreateConferencePrepareJobMutationHookResult = ReturnType<typeof useCreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationResult = Apollo.MutationResult<CreateConferencePrepareJobMutation>;
export type CreateConferencePrepareJobMutationOptions = Apollo.BaseMutationOptions<CreateConferencePrepareJobMutation, CreateConferencePrepareJobMutationVariables>;
export const ConferencePrepareJobSubscriptionDocument = gql`
    subscription ConferencePrepareJobSubscription($conferenceId: uuid!) {
  ConferencePrepareJob(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {createdAt: desc}
    limit: 10
  ) {
    id
    jobStatusName
    message
    updatedAt
    createdAt
    videoRenderJobs {
      id
      jobStatusName
      updated_at
      created_at
    }
  }
}
    `;

/**
 * __useConferencePrepareJobSubscriptionSubscription__
 *
 * To run a query within a React component, call `useConferencePrepareJobSubscriptionSubscription` and pass it any options that fit your needs.
 * When your component renders, `useConferencePrepareJobSubscriptionSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferencePrepareJobSubscriptionSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConferencePrepareJobSubscriptionSubscription(baseOptions: Apollo.SubscriptionHookOptions<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<ConferencePrepareJobSubscriptionSubscription, ConferencePrepareJobSubscriptionSubscriptionVariables>(ConferencePrepareJobSubscriptionDocument, options);
      }
export type ConferencePrepareJobSubscriptionSubscriptionHookResult = ReturnType<typeof useConferencePrepareJobSubscriptionSubscription>;
export type ConferencePrepareJobSubscriptionSubscriptionResult = Apollo.SubscriptionResult<ConferencePrepareJobSubscriptionSubscription>;
export const CombineVideosModal_CreateCombineVideosJobDocument = gql`
    mutation CombineVideosModal_CreateCombineVideosJob($conferenceId: uuid!, $createdByAttendeeId: uuid!, $outputName: String!, $data: jsonb!) {
  insert_job_queues_CombineVideosJob_one(
    object: {conferenceId: $conferenceId, createdByAttendeeId: $createdByAttendeeId, outputName: $outputName, data: $data}
  ) {
    id
  }
}
    `;
export type CombineVideosModal_CreateCombineVideosJobMutationFn = Apollo.MutationFunction<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>;

/**
 * __useCombineVideosModal_CreateCombineVideosJobMutation__
 *
 * To run a mutation, you first call `useCombineVideosModal_CreateCombineVideosJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCombineVideosModal_CreateCombineVideosJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [combineVideosModalCreateCombineVideosJobMutation, { data, loading, error }] = useCombineVideosModal_CreateCombineVideosJobMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      createdByAttendeeId: // value for 'createdByAttendeeId'
 *      outputName: // value for 'outputName'
 *      data: // value for 'data'
 *   },
 * });
 */
export function useCombineVideosModal_CreateCombineVideosJobMutation(baseOptions?: Apollo.MutationHookOptions<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>(CombineVideosModal_CreateCombineVideosJobDocument, options);
      }
export type CombineVideosModal_CreateCombineVideosJobMutationHookResult = ReturnType<typeof useCombineVideosModal_CreateCombineVideosJobMutation>;
export type CombineVideosModal_CreateCombineVideosJobMutationResult = Apollo.MutationResult<CombineVideosModal_CreateCombineVideosJobMutation>;
export type CombineVideosModal_CreateCombineVideosJobMutationOptions = Apollo.BaseMutationOptions<CombineVideosModal_CreateCombineVideosJobMutation, CombineVideosModal_CreateCombineVideosJobMutationVariables>;
export const CombineVideosModal_GetCombineVideosJobDocument = gql`
    query CombineVideosModal_GetCombineVideosJob($id: uuid!) {
  job_queues_CombineVideosJob_by_pk(id: $id) {
    id
    message
    jobStatusName
  }
}
    `;

/**
 * __useCombineVideosModal_GetCombineVideosJobQuery__
 *
 * To run a query within a React component, call `useCombineVideosModal_GetCombineVideosJobQuery` and pass it any options that fit your needs.
 * When your component renders, `useCombineVideosModal_GetCombineVideosJobQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useCombineVideosModal_GetCombineVideosJobQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useCombineVideosModal_GetCombineVideosJobQuery(baseOptions: Apollo.QueryHookOptions<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>(CombineVideosModal_GetCombineVideosJobDocument, options);
      }
export function useCombineVideosModal_GetCombineVideosJobLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>(CombineVideosModal_GetCombineVideosJobDocument, options);
        }
export type CombineVideosModal_GetCombineVideosJobQueryHookResult = ReturnType<typeof useCombineVideosModal_GetCombineVideosJobQuery>;
export type CombineVideosModal_GetCombineVideosJobLazyQueryHookResult = ReturnType<typeof useCombineVideosModal_GetCombineVideosJobLazyQuery>;
export type CombineVideosModal_GetCombineVideosJobQueryResult = Apollo.QueryResult<CombineVideosModal_GetCombineVideosJobQuery, CombineVideosModal_GetCombineVideosJobQueryVariables>;
export const ContentGroup_CreateRoomDocument = gql`
    mutation ContentGroup_CreateRoom($conferenceId: uuid!, $contentGroupId: uuid!) {
  createContentGroupRoom(
    conferenceId: $conferenceId
    contentGroupId: $contentGroupId
  ) {
    roomId
    message
  }
}
    `;
export type ContentGroup_CreateRoomMutationFn = Apollo.MutationFunction<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>;

/**
 * __useContentGroup_CreateRoomMutation__
 *
 * To run a mutation, you first call `useContentGroup_CreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useContentGroup_CreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [contentGroupCreateRoomMutation, { data, loading, error }] = useContentGroup_CreateRoomMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useContentGroup_CreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>(ContentGroup_CreateRoomDocument, options);
      }
export type ContentGroup_CreateRoomMutationHookResult = ReturnType<typeof useContentGroup_CreateRoomMutation>;
export type ContentGroup_CreateRoomMutationResult = Apollo.MutationResult<ContentGroup_CreateRoomMutation>;
export type ContentGroup_CreateRoomMutationOptions = Apollo.BaseMutationOptions<ContentGroup_CreateRoomMutation, ContentGroup_CreateRoomMutationVariables>;
export const SubmissionRequestsModal_GetConferenceConfigurationsDocument = gql`
    query SubmissionRequestsModal_GetConferenceConfigurations($conferenceId: uuid!) {
  ConferenceConfiguration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConfigureEmailTemplates_ConferenceConfiguration
  }
}
    ${ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc}`;

/**
 * __useSubmissionRequestsModal_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useSubmissionRequestsModal_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSubmissionRequestsModal_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSubmissionRequestsModal_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSubmissionRequestsModal_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>(SubmissionRequestsModal_GetConferenceConfigurationsDocument, options);
      }
export function useSubmissionRequestsModal_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>(SubmissionRequestsModal_GetConferenceConfigurationsDocument, options);
        }
export type SubmissionRequestsModal_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useSubmissionRequestsModal_GetConferenceConfigurationsQuery>;
export type SubmissionRequestsModal_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useSubmissionRequestsModal_GetConferenceConfigurationsLazyQuery>;
export type SubmissionRequestsModal_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<SubmissionRequestsModal_GetConferenceConfigurationsQuery, SubmissionRequestsModal_GetConferenceConfigurationsQueryVariables>;
export const InsertSubmissionRequestEmailJobsDocument = gql`
    mutation InsertSubmissionRequestEmailJobs($objs: [job_queues_SubmissionRequestEmailJob_insert_input!]!) {
  insert_job_queues_SubmissionRequestEmailJob(objects: $objs) {
    affected_rows
  }
}
    `;
export type InsertSubmissionRequestEmailJobsMutationFn = Apollo.MutationFunction<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;

/**
 * __useInsertSubmissionRequestEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertSubmissionRequestEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertSubmissionRequestEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertSubmissionRequestEmailJobsMutation, { data, loading, error }] = useInsertSubmissionRequestEmailJobsMutation({
 *   variables: {
 *      objs: // value for 'objs'
 *   },
 * });
 */
export function useInsertSubmissionRequestEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>(InsertSubmissionRequestEmailJobsDocument, options);
      }
export type InsertSubmissionRequestEmailJobsMutationHookResult = ReturnType<typeof useInsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationResult = Apollo.MutationResult<InsertSubmissionRequestEmailJobsMutation>;
export type InsertSubmissionRequestEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertSubmissionRequestEmailJobsMutation, InsertSubmissionRequestEmailJobsMutationVariables>;
export const SelectAllContentDocument = gql`
    query SelectAllContent($conferenceId: uuid!) {
  ContentGroup(
    where: {conferenceId: {_eq: $conferenceId}, contentGroupTypeName: {_neq: SPONSOR}}
  ) {
    ...ContentGroupFullNestedInfo
  }
  ContentPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentPersonInfo
  }
  OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  Hallway(where: {conferenceId: {_eq: $conferenceId}}) {
    ...HallwayInfo
  }
}
    ${ContentGroupFullNestedInfoFragmentDoc}
${ContentPersonInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${HallwayInfoFragmentDoc}`;

/**
 * __useSelectAllContentQuery__
 *
 * To run a query within a React component, call `useSelectAllContentQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllContentQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllContentQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllContentQuery(baseOptions: Apollo.QueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, options);
      }
export function useSelectAllContentLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllContentQuery, SelectAllContentQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllContentQuery, SelectAllContentQueryVariables>(SelectAllContentDocument, options);
        }
export type SelectAllContentQueryHookResult = ReturnType<typeof useSelectAllContentQuery>;
export type SelectAllContentLazyQueryHookResult = ReturnType<typeof useSelectAllContentLazyQuery>;
export type SelectAllContentQueryResult = Apollo.QueryResult<SelectAllContentQuery, SelectAllContentQueryVariables>;
export const InsertDeleteContentGroupsDocument = gql`
    mutation InsertDeleteContentGroups($newGroups: [ContentGroup_insert_input!]!, $deleteGroupIds: [uuid!]!) {
  insert_ContentGroup(objects: $newGroups) {
    returning {
      ...ContentGroupFullNestedInfo
    }
  }
  delete_ContentGroup(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
}
    ${ContentGroupFullNestedInfoFragmentDoc}`;
export type InsertDeleteContentGroupsMutationFn = Apollo.MutationFunction<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>;

/**
 * __useInsertDeleteContentGroupsMutation__
 *
 * To run a mutation, you first call `useInsertDeleteContentGroupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertDeleteContentGroupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertDeleteContentGroupsMutation, { data, loading, error }] = useInsertDeleteContentGroupsMutation({
 *   variables: {
 *      newGroups: // value for 'newGroups'
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *   },
 * });
 */
export function useInsertDeleteContentGroupsMutation(baseOptions?: Apollo.MutationHookOptions<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>(InsertDeleteContentGroupsDocument, options);
      }
export type InsertDeleteContentGroupsMutationHookResult = ReturnType<typeof useInsertDeleteContentGroupsMutation>;
export type InsertDeleteContentGroupsMutationResult = Apollo.MutationResult<InsertDeleteContentGroupsMutation>;
export type InsertDeleteContentGroupsMutationOptions = Apollo.BaseMutationOptions<InsertDeleteContentGroupsMutation, InsertDeleteContentGroupsMutationVariables>;
export const InsertOriginatingDatasDocument = gql`
    mutation InsertOriginatingDatas($newDatas: [OriginatingData_insert_input!]!) {
  insert_OriginatingData(objects: $newDatas) {
    returning {
      ...OriginatingDataInfo
    }
  }
}
    ${OriginatingDataInfoFragmentDoc}`;
export type InsertOriginatingDatasMutationFn = Apollo.MutationFunction<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;

/**
 * __useInsertOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useInsertOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertOriginatingDatasMutation, { data, loading, error }] = useInsertOriginatingDatasMutation({
 *   variables: {
 *      newDatas: // value for 'newDatas'
 *   },
 * });
 */
export function useInsertOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>(InsertOriginatingDatasDocument, options);
      }
export type InsertOriginatingDatasMutationHookResult = ReturnType<typeof useInsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationResult = Apollo.MutationResult<InsertOriginatingDatasMutation>;
export type InsertOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<InsertOriginatingDatasMutation, InsertOriginatingDatasMutationVariables>;
export const DeleteOriginatingDatasDocument = gql`
    mutation DeleteOriginatingDatas($deleteDataIds: [uuid!]!) {
  delete_OriginatingData(where: {id: {_in: $deleteDataIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteOriginatingDatasMutationFn = Apollo.MutationFunction<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;

/**
 * __useDeleteOriginatingDatasMutation__
 *
 * To run a mutation, you first call `useDeleteOriginatingDatasMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteOriginatingDatasMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteOriginatingDatasMutation, { data, loading, error }] = useDeleteOriginatingDatasMutation({
 *   variables: {
 *      deleteDataIds: // value for 'deleteDataIds'
 *   },
 * });
 */
export function useDeleteOriginatingDatasMutation(baseOptions?: Apollo.MutationHookOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>(DeleteOriginatingDatasDocument, options);
      }
export type DeleteOriginatingDatasMutationHookResult = ReturnType<typeof useDeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationResult = Apollo.MutationResult<DeleteOriginatingDatasMutation>;
export type DeleteOriginatingDatasMutationOptions = Apollo.BaseMutationOptions<DeleteOriginatingDatasMutation, DeleteOriginatingDatasMutationVariables>;
export const InsertTagsDocument = gql`
    mutation InsertTags($newTags: [Tag_insert_input!]!) {
  insert_Tag(objects: $newTags) {
    returning {
      ...TagInfo
    }
  }
}
    ${TagInfoFragmentDoc}`;
export type InsertTagsMutationFn = Apollo.MutationFunction<InsertTagsMutation, InsertTagsMutationVariables>;

/**
 * __useInsertTagsMutation__
 *
 * To run a mutation, you first call `useInsertTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertTagsMutation, { data, loading, error }] = useInsertTagsMutation({
 *   variables: {
 *      newTags: // value for 'newTags'
 *   },
 * });
 */
export function useInsertTagsMutation(baseOptions?: Apollo.MutationHookOptions<InsertTagsMutation, InsertTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertTagsMutation, InsertTagsMutationVariables>(InsertTagsDocument, options);
      }
export type InsertTagsMutationHookResult = ReturnType<typeof useInsertTagsMutation>;
export type InsertTagsMutationResult = Apollo.MutationResult<InsertTagsMutation>;
export type InsertTagsMutationOptions = Apollo.BaseMutationOptions<InsertTagsMutation, InsertTagsMutationVariables>;
export const InsertHallwaysDocument = gql`
    mutation InsertHallways($newHallways: [Hallway_insert_input!]!) {
  insert_Hallway(objects: $newHallways) {
    returning {
      ...HallwayInfo
    }
  }
}
    ${HallwayInfoFragmentDoc}`;
export type InsertHallwaysMutationFn = Apollo.MutationFunction<InsertHallwaysMutation, InsertHallwaysMutationVariables>;

/**
 * __useInsertHallwaysMutation__
 *
 * To run a mutation, you first call `useInsertHallwaysMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertHallwaysMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertHallwaysMutation, { data, loading, error }] = useInsertHallwaysMutation({
 *   variables: {
 *      newHallways: // value for 'newHallways'
 *   },
 * });
 */
export function useInsertHallwaysMutation(baseOptions?: Apollo.MutationHookOptions<InsertHallwaysMutation, InsertHallwaysMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertHallwaysMutation, InsertHallwaysMutationVariables>(InsertHallwaysDocument, options);
      }
export type InsertHallwaysMutationHookResult = ReturnType<typeof useInsertHallwaysMutation>;
export type InsertHallwaysMutationResult = Apollo.MutationResult<InsertHallwaysMutation>;
export type InsertHallwaysMutationOptions = Apollo.BaseMutationOptions<InsertHallwaysMutation, InsertHallwaysMutationVariables>;
export const DeleteTagsDocument = gql`
    mutation DeleteTags($deleteTagIds: [uuid!]!) {
  delete_Tag(where: {id: {_in: $deleteTagIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteTagsMutationFn = Apollo.MutationFunction<DeleteTagsMutation, DeleteTagsMutationVariables>;

/**
 * __useDeleteTagsMutation__
 *
 * To run a mutation, you first call `useDeleteTagsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteTagsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteTagsMutation, { data, loading, error }] = useDeleteTagsMutation({
 *   variables: {
 *      deleteTagIds: // value for 'deleteTagIds'
 *   },
 * });
 */
export function useDeleteTagsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteTagsMutation, DeleteTagsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteTagsMutation, DeleteTagsMutationVariables>(DeleteTagsDocument, options);
      }
export type DeleteTagsMutationHookResult = ReturnType<typeof useDeleteTagsMutation>;
export type DeleteTagsMutationResult = Apollo.MutationResult<DeleteTagsMutation>;
export type DeleteTagsMutationOptions = Apollo.BaseMutationOptions<DeleteTagsMutation, DeleteTagsMutationVariables>;
export const DeleteHallwaysDocument = gql`
    mutation DeleteHallways($deleteHallwayIds: [uuid!]!) {
  delete_Hallway(where: {id: {_in: $deleteHallwayIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteHallwaysMutationFn = Apollo.MutationFunction<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>;

/**
 * __useDeleteHallwaysMutation__
 *
 * To run a mutation, you first call `useDeleteHallwaysMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteHallwaysMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteHallwaysMutation, { data, loading, error }] = useDeleteHallwaysMutation({
 *   variables: {
 *      deleteHallwayIds: // value for 'deleteHallwayIds'
 *   },
 * });
 */
export function useDeleteHallwaysMutation(baseOptions?: Apollo.MutationHookOptions<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>(DeleteHallwaysDocument, options);
      }
export type DeleteHallwaysMutationHookResult = ReturnType<typeof useDeleteHallwaysMutation>;
export type DeleteHallwaysMutationResult = Apollo.MutationResult<DeleteHallwaysMutation>;
export type DeleteHallwaysMutationOptions = Apollo.BaseMutationOptions<DeleteHallwaysMutation, DeleteHallwaysMutationVariables>;
export const InsertContentPeopleDocument = gql`
    mutation InsertContentPeople($newPeople: [ContentPerson_insert_input!]!) {
  insert_ContentPerson(objects: $newPeople) {
    returning {
      ...ContentPersonInfo
    }
  }
}
    ${ContentPersonInfoFragmentDoc}`;
export type InsertContentPeopleMutationFn = Apollo.MutationFunction<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>;

/**
 * __useInsertContentPeopleMutation__
 *
 * To run a mutation, you first call `useInsertContentPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertContentPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertContentPeopleMutation, { data, loading, error }] = useInsertContentPeopleMutation({
 *   variables: {
 *      newPeople: // value for 'newPeople'
 *   },
 * });
 */
export function useInsertContentPeopleMutation(baseOptions?: Apollo.MutationHookOptions<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>(InsertContentPeopleDocument, options);
      }
export type InsertContentPeopleMutationHookResult = ReturnType<typeof useInsertContentPeopleMutation>;
export type InsertContentPeopleMutationResult = Apollo.MutationResult<InsertContentPeopleMutation>;
export type InsertContentPeopleMutationOptions = Apollo.BaseMutationOptions<InsertContentPeopleMutation, InsertContentPeopleMutationVariables>;
export const DeleteContentPeopleDocument = gql`
    mutation DeleteContentPeople($deletePersonIds: [uuid!]!) {
  delete_ContentPerson(where: {id: {_in: $deletePersonIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteContentPeopleMutationFn = Apollo.MutationFunction<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>;

/**
 * __useDeleteContentPeopleMutation__
 *
 * To run a mutation, you first call `useDeleteContentPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteContentPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteContentPeopleMutation, { data, loading, error }] = useDeleteContentPeopleMutation({
 *   variables: {
 *      deletePersonIds: // value for 'deletePersonIds'
 *   },
 * });
 */
export function useDeleteContentPeopleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>(DeleteContentPeopleDocument, options);
      }
export type DeleteContentPeopleMutationHookResult = ReturnType<typeof useDeleteContentPeopleMutation>;
export type DeleteContentPeopleMutationResult = Apollo.MutationResult<DeleteContentPeopleMutation>;
export type DeleteContentPeopleMutationOptions = Apollo.BaseMutationOptions<DeleteContentPeopleMutation, DeleteContentPeopleMutationVariables>;
export const UpdateContentGroupDocument = gql`
    mutation UpdateContentGroup($newItems: [ContentItem_insert_input!]!, $newRequiredItems: [RequiredContentItem_insert_input!]!, $newGroupTags: [ContentGroupTag_insert_input!]!, $newGroupHallways: [ContentGroupHallway_insert_input!]!, $groupId: uuid!, $contentGroupTypeName: ContentGroupType_enum!, $originatingDataId: uuid = null, $shortTitle: String = null, $title: String!, $deleteItemIds: [uuid!]!, $deleteRequiredItemIds: [uuid!]!, $deleteGroupTagIds: [uuid!]!, $deleteGroupHallwayIds: [uuid!]!, $newUploaders: [Uploader_insert_input!]!, $deleteUploaderIds: [uuid!]!, $newGroupPeople: [ContentGroupPerson_insert_input!]!, $deleteGroupPeopleIds: [uuid!]!) {
  insert_ContentItem(objects: $newItems) {
    returning {
      ...ContentItemInfo
    }
  }
  insert_RequiredContentItem(objects: $newRequiredItems) {
    returning {
      ...RequiredContentItemInfo
    }
  }
  insert_ContentGroupTag(objects: $newGroupTags) {
    returning {
      ...ContentGroupTagInfo
    }
  }
  insert_ContentGroupHallway(objects: $newGroupHallways) {
    returning {
      ...ContentGroupHallwayInfo
    }
  }
  insert_Uploader(objects: $newUploaders) {
    returning {
      ...UploaderInfo
    }
  }
  insert_ContentGroupPerson(objects: $newGroupPeople) {
    returning {
      ...ContentGroupPersonInfo
    }
  }
  update_ContentGroup_by_pk(
    pk_columns: {id: $groupId}
    _set: {contentGroupTypeName: $contentGroupTypeName, originatingDataId: $originatingDataId, shortTitle: $shortTitle, title: $title}
  ) {
    ...ContentGroupFullNestedInfo
  }
  delete_ContentItem(where: {id: {_in: $deleteItemIds}}) {
    returning {
      id
    }
  }
  delete_RequiredContentItem(where: {id: {_in: $deleteRequiredItemIds}}) {
    returning {
      id
    }
  }
  delete_ContentGroupTag(
    where: {contentGroupId: {_eq: $groupId}, tagId: {_in: $deleteGroupTagIds}}
  ) {
    returning {
      id
    }
  }
  delete_ContentGroupHallway(where: {id: {_in: $deleteGroupHallwayIds}}) {
    returning {
      id
    }
  }
  delete_Uploader(where: {id: {_in: $deleteUploaderIds}}) {
    returning {
      id
    }
  }
  delete_ContentGroupPerson(where: {id: {_in: $deleteGroupPeopleIds}}) {
    returning {
      id
    }
  }
}
    ${ContentItemInfoFragmentDoc}
${RequiredContentItemInfoFragmentDoc}
${ContentGroupTagInfoFragmentDoc}
${ContentGroupHallwayInfoFragmentDoc}
${UploaderInfoFragmentDoc}
${ContentGroupPersonInfoFragmentDoc}
${ContentGroupFullNestedInfoFragmentDoc}`;
export type UpdateContentGroupMutationFn = Apollo.MutationFunction<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>;

/**
 * __useUpdateContentGroupMutation__
 *
 * To run a mutation, you first call `useUpdateContentGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateContentGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateContentGroupMutation, { data, loading, error }] = useUpdateContentGroupMutation({
 *   variables: {
 *      newItems: // value for 'newItems'
 *      newRequiredItems: // value for 'newRequiredItems'
 *      newGroupTags: // value for 'newGroupTags'
 *      newGroupHallways: // value for 'newGroupHallways'
 *      groupId: // value for 'groupId'
 *      contentGroupTypeName: // value for 'contentGroupTypeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      shortTitle: // value for 'shortTitle'
 *      title: // value for 'title'
 *      deleteItemIds: // value for 'deleteItemIds'
 *      deleteRequiredItemIds: // value for 'deleteRequiredItemIds'
 *      deleteGroupTagIds: // value for 'deleteGroupTagIds'
 *      deleteGroupHallwayIds: // value for 'deleteGroupHallwayIds'
 *      newUploaders: // value for 'newUploaders'
 *      deleteUploaderIds: // value for 'deleteUploaderIds'
 *      newGroupPeople: // value for 'newGroupPeople'
 *      deleteGroupPeopleIds: // value for 'deleteGroupPeopleIds'
 *   },
 * });
 */
export function useUpdateContentGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>(UpdateContentGroupDocument, options);
      }
export type UpdateContentGroupMutationHookResult = ReturnType<typeof useUpdateContentGroupMutation>;
export type UpdateContentGroupMutationResult = Apollo.MutationResult<UpdateContentGroupMutation>;
export type UpdateContentGroupMutationOptions = Apollo.BaseMutationOptions<UpdateContentGroupMutation, UpdateContentGroupMutationVariables>;
export const UpdateContentItemDocument = gql`
    mutation UpdateContentItem($id: uuid!, $contentTypeName: ContentType_enum!, $layoutData: jsonb = null, $name: String!, $data: jsonb!, $isHidden: Boolean!, $originatingDataId: uuid = null, $requiredContentId: uuid = null) {
  update_ContentItem_by_pk(
    pk_columns: {id: $id}
    _set: {contentTypeName: $contentTypeName, layoutData: $layoutData, name: $name, data: $data, isHidden: $isHidden, originatingDataId: $originatingDataId, requiredContentId: $requiredContentId}
  ) {
    ...ContentItemInfo
  }
}
    ${ContentItemInfoFragmentDoc}`;
export type UpdateContentItemMutationFn = Apollo.MutationFunction<UpdateContentItemMutation, UpdateContentItemMutationVariables>;

/**
 * __useUpdateContentItemMutation__
 *
 * To run a mutation, you first call `useUpdateContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateContentItemMutation, { data, loading, error }] = useUpdateContentItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *      contentTypeName: // value for 'contentTypeName'
 *      layoutData: // value for 'layoutData'
 *      name: // value for 'name'
 *      data: // value for 'data'
 *      isHidden: // value for 'isHidden'
 *      originatingDataId: // value for 'originatingDataId'
 *      requiredContentId: // value for 'requiredContentId'
 *   },
 * });
 */
export function useUpdateContentItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateContentItemMutation, UpdateContentItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateContentItemMutation, UpdateContentItemMutationVariables>(UpdateContentItemDocument, options);
      }
export type UpdateContentItemMutationHookResult = ReturnType<typeof useUpdateContentItemMutation>;
export type UpdateContentItemMutationResult = Apollo.MutationResult<UpdateContentItemMutation>;
export type UpdateContentItemMutationOptions = Apollo.BaseMutationOptions<UpdateContentItemMutation, UpdateContentItemMutationVariables>;
export const UpdateRequiredContentItemDocument = gql`
    mutation UpdateRequiredContentItem($id: uuid!, $contentTypeName: ContentType_enum!, $name: String!, $isHidden: Boolean!, $uploadsRemaining: Int = null, $originatingDataId: uuid = null) {
  update_RequiredContentItem_by_pk(
    pk_columns: {id: $id}
    _set: {contentTypeName: $contentTypeName, name: $name, isHidden: $isHidden, originatingDataId: $originatingDataId, uploadsRemaining: $uploadsRemaining}
  ) {
    ...RequiredContentItemInfo
  }
}
    ${RequiredContentItemInfoFragmentDoc}`;
export type UpdateRequiredContentItemMutationFn = Apollo.MutationFunction<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>;

/**
 * __useUpdateRequiredContentItemMutation__
 *
 * To run a mutation, you first call `useUpdateRequiredContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRequiredContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRequiredContentItemMutation, { data, loading, error }] = useUpdateRequiredContentItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *      contentTypeName: // value for 'contentTypeName'
 *      name: // value for 'name'
 *      isHidden: // value for 'isHidden'
 *      uploadsRemaining: // value for 'uploadsRemaining'
 *      originatingDataId: // value for 'originatingDataId'
 *   },
 * });
 */
export function useUpdateRequiredContentItemMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>(UpdateRequiredContentItemDocument, options);
      }
export type UpdateRequiredContentItemMutationHookResult = ReturnType<typeof useUpdateRequiredContentItemMutation>;
export type UpdateRequiredContentItemMutationResult = Apollo.MutationResult<UpdateRequiredContentItemMutation>;
export type UpdateRequiredContentItemMutationOptions = Apollo.BaseMutationOptions<UpdateRequiredContentItemMutation, UpdateRequiredContentItemMutationVariables>;
export const UpdateUploaderDocument = gql`
    mutation UpdateUploader($id: uuid!, $email: String!, $name: String!) {
  update_Uploader_by_pk(pk_columns: {id: $id}, _set: {email: $email, name: $name}) {
    ...UploaderInfo
  }
}
    ${UploaderInfoFragmentDoc}`;
export type UpdateUploaderMutationFn = Apollo.MutationFunction<UpdateUploaderMutation, UpdateUploaderMutationVariables>;

/**
 * __useUpdateUploaderMutation__
 *
 * To run a mutation, you first call `useUpdateUploaderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateUploaderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateUploaderMutation, { data, loading, error }] = useUpdateUploaderMutation({
 *   variables: {
 *      id: // value for 'id'
 *      email: // value for 'email'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useUpdateUploaderMutation(baseOptions?: Apollo.MutationHookOptions<UpdateUploaderMutation, UpdateUploaderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateUploaderMutation, UpdateUploaderMutationVariables>(UpdateUploaderDocument, options);
      }
export type UpdateUploaderMutationHookResult = ReturnType<typeof useUpdateUploaderMutation>;
export type UpdateUploaderMutationResult = Apollo.MutationResult<UpdateUploaderMutation>;
export type UpdateUploaderMutationOptions = Apollo.BaseMutationOptions<UpdateUploaderMutation, UpdateUploaderMutationVariables>;
export const UpdateGroupPersonDocument = gql`
    mutation UpdateGroupPerson($id: uuid!, $roleName: String!, $priority: Int = null) {
  update_ContentGroupPerson_by_pk(
    pk_columns: {id: $id}
    _set: {roleName: $roleName, priority: $priority}
  ) {
    ...ContentGroupPersonInfo
  }
}
    ${ContentGroupPersonInfoFragmentDoc}`;
export type UpdateGroupPersonMutationFn = Apollo.MutationFunction<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;

/**
 * __useUpdateGroupPersonMutation__
 *
 * To run a mutation, you first call `useUpdateGroupPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupPersonMutation, { data, loading, error }] = useUpdateGroupPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      roleName: // value for 'roleName'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateGroupPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>(UpdateGroupPersonDocument, options);
      }
export type UpdateGroupPersonMutationHookResult = ReturnType<typeof useUpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationResult = Apollo.MutationResult<UpdateGroupPersonMutation>;
export type UpdateGroupPersonMutationOptions = Apollo.BaseMutationOptions<UpdateGroupPersonMutation, UpdateGroupPersonMutationVariables>;
export const UpdateGroupHallwayDocument = gql`
    mutation UpdateGroupHallway($id: uuid!, $priority: Int = null, $layout: jsonb = null) {
  update_ContentGroupHallway_by_pk(
    pk_columns: {id: $id}
    _set: {layout: $layout, priority: $priority}
  ) {
    ...ContentGroupHallwayInfo
  }
}
    ${ContentGroupHallwayInfoFragmentDoc}`;
export type UpdateGroupHallwayMutationFn = Apollo.MutationFunction<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>;

/**
 * __useUpdateGroupHallwayMutation__
 *
 * To run a mutation, you first call `useUpdateGroupHallwayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupHallwayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupHallwayMutation, { data, loading, error }] = useUpdateGroupHallwayMutation({
 *   variables: {
 *      id: // value for 'id'
 *      priority: // value for 'priority'
 *      layout: // value for 'layout'
 *   },
 * });
 */
export function useUpdateGroupHallwayMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>(UpdateGroupHallwayDocument, options);
      }
export type UpdateGroupHallwayMutationHookResult = ReturnType<typeof useUpdateGroupHallwayMutation>;
export type UpdateGroupHallwayMutationResult = Apollo.MutationResult<UpdateGroupHallwayMutation>;
export type UpdateGroupHallwayMutationOptions = Apollo.BaseMutationOptions<UpdateGroupHallwayMutation, UpdateGroupHallwayMutationVariables>;
export const UpdatePersonDocument = gql`
    mutation UpdatePerson($id: uuid!, $name: String!, $affiliation: String = null, $email: String = null, $originatingDataId: uuid = null, $attendeeId: uuid = null) {
  update_ContentPerson_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, affiliation: $affiliation, email: $email, originatingDataId: $originatingDataId, attendeeId: $attendeeId}
  ) {
    ...ContentPersonInfo
  }
}
    ${ContentPersonInfoFragmentDoc}`;
export type UpdatePersonMutationFn = Apollo.MutationFunction<UpdatePersonMutation, UpdatePersonMutationVariables>;

/**
 * __useUpdatePersonMutation__
 *
 * To run a mutation, you first call `useUpdatePersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePersonMutation, { data, loading, error }] = useUpdatePersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      email: // value for 'email'
 *      originatingDataId: // value for 'originatingDataId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useUpdatePersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePersonMutation, UpdatePersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePersonMutation, UpdatePersonMutationVariables>(UpdatePersonDocument, options);
      }
export type UpdatePersonMutationHookResult = ReturnType<typeof useUpdatePersonMutation>;
export type UpdatePersonMutationResult = Apollo.MutationResult<UpdatePersonMutation>;
export type UpdatePersonMutationOptions = Apollo.BaseMutationOptions<UpdatePersonMutation, UpdatePersonMutationVariables>;
export const UpdateTagDocument = gql`
    mutation UpdateTag($id: uuid!, $name: String!, $colour: String!, $originatingDataId: uuid = null, $priority: Int! = 10) {
  update_Tag_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, originatingDataId: $originatingDataId, priority: $priority}
  ) {
    ...TagInfo
  }
}
    ${TagInfoFragmentDoc}`;
export type UpdateTagMutationFn = Apollo.MutationFunction<UpdateTagMutation, UpdateTagMutationVariables>;

/**
 * __useUpdateTagMutation__
 *
 * To run a mutation, you first call `useUpdateTagMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateTagMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateTagMutation, { data, loading, error }] = useUpdateTagMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      originatingDataId: // value for 'originatingDataId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateTagMutation(baseOptions?: Apollo.MutationHookOptions<UpdateTagMutation, UpdateTagMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateTagMutation, UpdateTagMutationVariables>(UpdateTagDocument, options);
      }
export type UpdateTagMutationHookResult = ReturnType<typeof useUpdateTagMutation>;
export type UpdateTagMutationResult = Apollo.MutationResult<UpdateTagMutation>;
export type UpdateTagMutationOptions = Apollo.BaseMutationOptions<UpdateTagMutation, UpdateTagMutationVariables>;
export const UpdateHallwayDocument = gql`
    mutation UpdateHallway($id: uuid!, $name: String!, $colour: String!, $priority: Int!) {
  update_Hallway_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, colour: $colour, priority: $priority}
  ) {
    ...HallwayInfo
  }
}
    ${HallwayInfoFragmentDoc}`;
export type UpdateHallwayMutationFn = Apollo.MutationFunction<UpdateHallwayMutation, UpdateHallwayMutationVariables>;

/**
 * __useUpdateHallwayMutation__
 *
 * To run a mutation, you first call `useUpdateHallwayMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateHallwayMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateHallwayMutation, { data, loading, error }] = useUpdateHallwayMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      colour: // value for 'colour'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateHallwayMutation(baseOptions?: Apollo.MutationHookOptions<UpdateHallwayMutation, UpdateHallwayMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateHallwayMutation, UpdateHallwayMutationVariables>(UpdateHallwayDocument, options);
      }
export type UpdateHallwayMutationHookResult = ReturnType<typeof useUpdateHallwayMutation>;
export type UpdateHallwayMutationResult = Apollo.MutationResult<UpdateHallwayMutation>;
export type UpdateHallwayMutationOptions = Apollo.BaseMutationOptions<UpdateHallwayMutation, UpdateHallwayMutationVariables>;
export const ConfigureEmailTemplates_GetConferenceConfigurationsDocument = gql`
    query ConfigureEmailTemplates_GetConferenceConfigurations($conferenceId: uuid!) {
  ConferenceConfiguration(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ConfigureEmailTemplates_ConferenceConfiguration
  }
}
    ${ConfigureEmailTemplates_ConferenceConfigurationFragmentDoc}`;

/**
 * __useConfigureEmailTemplates_GetConferenceConfigurationsQuery__
 *
 * To run a query within a React component, call `useConfigureEmailTemplates_GetConferenceConfigurationsQuery` and pass it any options that fit your needs.
 * When your component renders, `useConfigureEmailTemplates_GetConferenceConfigurationsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConfigureEmailTemplates_GetConferenceConfigurationsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useConfigureEmailTemplates_GetConferenceConfigurationsQuery(baseOptions: Apollo.QueryHookOptions<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>(ConfigureEmailTemplates_GetConferenceConfigurationsDocument, options);
      }
export function useConfigureEmailTemplates_GetConferenceConfigurationsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>(ConfigureEmailTemplates_GetConferenceConfigurationsDocument, options);
        }
export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryHookResult = ReturnType<typeof useConfigureEmailTemplates_GetConferenceConfigurationsQuery>;
export type ConfigureEmailTemplates_GetConferenceConfigurationsLazyQueryHookResult = ReturnType<typeof useConfigureEmailTemplates_GetConferenceConfigurationsLazyQuery>;
export type ConfigureEmailTemplates_GetConferenceConfigurationsQueryResult = Apollo.QueryResult<ConfigureEmailTemplates_GetConferenceConfigurationsQuery, ConfigureEmailTemplates_GetConferenceConfigurationsQueryVariables>;
export const ConfigureEmailTemplates_UpdateConferenceConfigurationDocument = gql`
    mutation ConfigureEmailTemplates_UpdateConferenceConfiguration($value: jsonb!, $conferenceId: uuid!, $key: String!) {
  insert_ConferenceConfiguration_one(
    object: {value: $value, conferenceId: $conferenceId, key: $key}
    on_conflict: {constraint: ConferenceConfiguration_conferenceId_key_key, update_columns: value}
  ) {
    id
  }
}
    `;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationFn = Apollo.MutationFunction<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>;

/**
 * __useConfigureEmailTemplates_UpdateConferenceConfigurationMutation__
 *
 * To run a mutation, you first call `useConfigureEmailTemplates_UpdateConferenceConfigurationMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useConfigureEmailTemplates_UpdateConferenceConfigurationMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [configureEmailTemplatesUpdateConferenceConfigurationMutation, { data, loading, error }] = useConfigureEmailTemplates_UpdateConferenceConfigurationMutation({
 *   variables: {
 *      value: // value for 'value'
 *      conferenceId: // value for 'conferenceId'
 *      key: // value for 'key'
 *   },
 * });
 */
export function useConfigureEmailTemplates_UpdateConferenceConfigurationMutation(baseOptions?: Apollo.MutationHookOptions<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>(ConfigureEmailTemplates_UpdateConferenceConfigurationDocument, options);
      }
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationHookResult = ReturnType<typeof useConfigureEmailTemplates_UpdateConferenceConfigurationMutation>;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationResult = Apollo.MutationResult<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation>;
export type ConfigureEmailTemplates_UpdateConferenceConfigurationMutationOptions = Apollo.BaseMutationOptions<ConfigureEmailTemplates_UpdateConferenceConfigurationMutation, ConfigureEmailTemplates_UpdateConferenceConfigurationMutationVariables>;
export const ChooseContentItemByTagModal_GetTagsDocument = gql`
    query ChooseContentItemByTagModal_GetTags($conferenceId: uuid!) {
  Tag(where: {conferenceId: {_eq: $conferenceId}}, order_by: {name: asc}) {
    id
    name
  }
}
    `;

/**
 * __useChooseContentItemByTagModal_GetTagsQuery__
 *
 * To run a query within a React component, call `useChooseContentItemByTagModal_GetTagsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseContentItemByTagModal_GetTagsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseContentItemByTagModal_GetTagsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useChooseContentItemByTagModal_GetTagsQuery(baseOptions: Apollo.QueryHookOptions<ChooseContentItemByTagModal_GetTagsQuery, ChooseContentItemByTagModal_GetTagsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseContentItemByTagModal_GetTagsQuery, ChooseContentItemByTagModal_GetTagsQueryVariables>(ChooseContentItemByTagModal_GetTagsDocument, options);
      }
export function useChooseContentItemByTagModal_GetTagsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseContentItemByTagModal_GetTagsQuery, ChooseContentItemByTagModal_GetTagsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseContentItemByTagModal_GetTagsQuery, ChooseContentItemByTagModal_GetTagsQueryVariables>(ChooseContentItemByTagModal_GetTagsDocument, options);
        }
export type ChooseContentItemByTagModal_GetTagsQueryHookResult = ReturnType<typeof useChooseContentItemByTagModal_GetTagsQuery>;
export type ChooseContentItemByTagModal_GetTagsLazyQueryHookResult = ReturnType<typeof useChooseContentItemByTagModal_GetTagsLazyQuery>;
export type ChooseContentItemByTagModal_GetTagsQueryResult = Apollo.QueryResult<ChooseContentItemByTagModal_GetTagsQuery, ChooseContentItemByTagModal_GetTagsQueryVariables>;
export const ChooseContentItemByTagModal_GetVideoContentItemsDocument = gql`
    query ChooseContentItemByTagModal_GetVideoContentItems($tagId: uuid!, $name: String!) {
  ContentItem(
    where: {contentTypeName: {_in: [VIDEO_FILE, VIDEO_BROADCAST, VIDEO_PREPUBLISH]}, contentGroup: {contentGroupTags: {tag: {id: {_eq: $tagId}}}}, name: {_ilike: $name}}
    order_by: {contentGroup: {title: asc}, name: asc}
  ) {
    id
    name
    contentGroup {
      id
      title
    }
  }
}
    `;

/**
 * __useChooseContentItemByTagModal_GetVideoContentItemsQuery__
 *
 * To run a query within a React component, call `useChooseContentItemByTagModal_GetVideoContentItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseContentItemByTagModal_GetVideoContentItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseContentItemByTagModal_GetVideoContentItemsQuery({
 *   variables: {
 *      tagId: // value for 'tagId'
 *      name: // value for 'name'
 *   },
 * });
 */
export function useChooseContentItemByTagModal_GetVideoContentItemsQuery(baseOptions: Apollo.QueryHookOptions<ChooseContentItemByTagModal_GetVideoContentItemsQuery, ChooseContentItemByTagModal_GetVideoContentItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseContentItemByTagModal_GetVideoContentItemsQuery, ChooseContentItemByTagModal_GetVideoContentItemsQueryVariables>(ChooseContentItemByTagModal_GetVideoContentItemsDocument, options);
      }
export function useChooseContentItemByTagModal_GetVideoContentItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseContentItemByTagModal_GetVideoContentItemsQuery, ChooseContentItemByTagModal_GetVideoContentItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseContentItemByTagModal_GetVideoContentItemsQuery, ChooseContentItemByTagModal_GetVideoContentItemsQueryVariables>(ChooseContentItemByTagModal_GetVideoContentItemsDocument, options);
        }
export type ChooseContentItemByTagModal_GetVideoContentItemsQueryHookResult = ReturnType<typeof useChooseContentItemByTagModal_GetVideoContentItemsQuery>;
export type ChooseContentItemByTagModal_GetVideoContentItemsLazyQueryHookResult = ReturnType<typeof useChooseContentItemByTagModal_GetVideoContentItemsLazyQuery>;
export type ChooseContentItemByTagModal_GetVideoContentItemsQueryResult = Apollo.QueryResult<ChooseContentItemByTagModal_GetVideoContentItemsQuery, ChooseContentItemByTagModal_GetVideoContentItemsQueryVariables>;
export const ChooseContentItemModal_GetContentGroupsDocument = gql`
    query ChooseContentItemModal_GetContentGroups($conferenceId: uuid!) {
  ContentGroup(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {title: asc}
  ) {
    id
    title
  }
}
    `;

/**
 * __useChooseContentItemModal_GetContentGroupsQuery__
 *
 * To run a query within a React component, call `useChooseContentItemModal_GetContentGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseContentItemModal_GetContentGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseContentItemModal_GetContentGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useChooseContentItemModal_GetContentGroupsQuery(baseOptions: Apollo.QueryHookOptions<ChooseContentItemModal_GetContentGroupsQuery, ChooseContentItemModal_GetContentGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseContentItemModal_GetContentGroupsQuery, ChooseContentItemModal_GetContentGroupsQueryVariables>(ChooseContentItemModal_GetContentGroupsDocument, options);
      }
export function useChooseContentItemModal_GetContentGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseContentItemModal_GetContentGroupsQuery, ChooseContentItemModal_GetContentGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseContentItemModal_GetContentGroupsQuery, ChooseContentItemModal_GetContentGroupsQueryVariables>(ChooseContentItemModal_GetContentGroupsDocument, options);
        }
export type ChooseContentItemModal_GetContentGroupsQueryHookResult = ReturnType<typeof useChooseContentItemModal_GetContentGroupsQuery>;
export type ChooseContentItemModal_GetContentGroupsLazyQueryHookResult = ReturnType<typeof useChooseContentItemModal_GetContentGroupsLazyQuery>;
export type ChooseContentItemModal_GetContentGroupsQueryResult = Apollo.QueryResult<ChooseContentItemModal_GetContentGroupsQuery, ChooseContentItemModal_GetContentGroupsQueryVariables>;
export const ChooseContentItemModal_GetVideoContentItemsDocument = gql`
    query ChooseContentItemModal_GetVideoContentItems($contentGroupId: uuid) {
  ContentItem(
    where: {contentGroupId: {_eq: $contentGroupId}, contentTypeName: {_in: [VIDEO_FILE, VIDEO_BROADCAST, VIDEO_PREPUBLISH]}}
    order_by: {name: asc}
  ) {
    id
    name
  }
}
    `;

/**
 * __useChooseContentItemModal_GetVideoContentItemsQuery__
 *
 * To run a query within a React component, call `useChooseContentItemModal_GetVideoContentItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useChooseContentItemModal_GetVideoContentItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useChooseContentItemModal_GetVideoContentItemsQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useChooseContentItemModal_GetVideoContentItemsQuery(baseOptions?: Apollo.QueryHookOptions<ChooseContentItemModal_GetVideoContentItemsQuery, ChooseContentItemModal_GetVideoContentItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ChooseContentItemModal_GetVideoContentItemsQuery, ChooseContentItemModal_GetVideoContentItemsQueryVariables>(ChooseContentItemModal_GetVideoContentItemsDocument, options);
      }
export function useChooseContentItemModal_GetVideoContentItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ChooseContentItemModal_GetVideoContentItemsQuery, ChooseContentItemModal_GetVideoContentItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ChooseContentItemModal_GetVideoContentItemsQuery, ChooseContentItemModal_GetVideoContentItemsQueryVariables>(ChooseContentItemModal_GetVideoContentItemsDocument, options);
        }
export type ChooseContentItemModal_GetVideoContentItemsQueryHookResult = ReturnType<typeof useChooseContentItemModal_GetVideoContentItemsQuery>;
export type ChooseContentItemModal_GetVideoContentItemsLazyQueryHookResult = ReturnType<typeof useChooseContentItemModal_GetVideoContentItemsLazyQuery>;
export type ChooseContentItemModal_GetVideoContentItemsQueryResult = Apollo.QueryResult<ChooseContentItemModal_GetVideoContentItemsQuery, ChooseContentItemModal_GetVideoContentItemsQueryVariables>;
export const ManageConferenceExportPage_GetGoogleOAuthUrlDocument = gql`
    mutation ManageConferenceExportPage_GetGoogleOAuthUrl($attendeeId: uuid!, $scopes: [String!]!) {
  getGoogleOAuthUrl(attendeeId: $attendeeId, scopes: $scopes) {
    url
  }
}
    `;
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationFn = Apollo.MutationFunction<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>;

/**
 * __useManageConferenceExportPage_GetGoogleOAuthUrlMutation__
 *
 * To run a mutation, you first call `useManageConferenceExportPage_GetGoogleOAuthUrlMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageConferenceExportPage_GetGoogleOAuthUrlMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageConferenceExportPageGetGoogleOAuthUrlMutation, { data, loading, error }] = useManageConferenceExportPage_GetGoogleOAuthUrlMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      scopes: // value for 'scopes'
 *   },
 * });
 */
export function useManageConferenceExportPage_GetGoogleOAuthUrlMutation(baseOptions?: Apollo.MutationHookOptions<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>(ManageConferenceExportPage_GetGoogleOAuthUrlDocument, options);
      }
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationHookResult = ReturnType<typeof useManageConferenceExportPage_GetGoogleOAuthUrlMutation>;
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationResult = Apollo.MutationResult<ManageConferenceExportPage_GetGoogleOAuthUrlMutation>;
export type ManageConferenceExportPage_GetGoogleOAuthUrlMutationOptions = Apollo.BaseMutationOptions<ManageConferenceExportPage_GetGoogleOAuthUrlMutation, ManageConferenceExportPage_GetGoogleOAuthUrlMutationVariables>;
export const ManageConferenceExportPage_GetAttendeeGoogleAccountsDocument = gql`
    query ManageConferenceExportPage_GetAttendeeGoogleAccounts($attendeeId: uuid!) {
  AttendeeGoogleAccount(where: {attendeeId: {_eq: $attendeeId}}) {
    ...ManageConferenceExportPage_AttendeeGoogleAccount
  }
}
    ${ManageConferenceExportPage_AttendeeGoogleAccountFragmentDoc}`;

/**
 * __useManageConferenceExportPage_GetAttendeeGoogleAccountsQuery__
 *
 * To run a query within a React component, call `useManageConferenceExportPage_GetAttendeeGoogleAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageConferenceExportPage_GetAttendeeGoogleAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageConferenceExportPage_GetAttendeeGoogleAccountsQuery({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useManageConferenceExportPage_GetAttendeeGoogleAccountsQuery(baseOptions: Apollo.QueryHookOptions<ManageConferenceExportPage_GetAttendeeGoogleAccountsQuery, ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageConferenceExportPage_GetAttendeeGoogleAccountsQuery, ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryVariables>(ManageConferenceExportPage_GetAttendeeGoogleAccountsDocument, options);
      }
export function useManageConferenceExportPage_GetAttendeeGoogleAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageConferenceExportPage_GetAttendeeGoogleAccountsQuery, ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageConferenceExportPage_GetAttendeeGoogleAccountsQuery, ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryVariables>(ManageConferenceExportPage_GetAttendeeGoogleAccountsDocument, options);
        }
export type ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryHookResult = ReturnType<typeof useManageConferenceExportPage_GetAttendeeGoogleAccountsQuery>;
export type ManageConferenceExportPage_GetAttendeeGoogleAccountsLazyQueryHookResult = ReturnType<typeof useManageConferenceExportPage_GetAttendeeGoogleAccountsLazyQuery>;
export type ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryResult = Apollo.QueryResult<ManageConferenceExportPage_GetAttendeeGoogleAccountsQuery, ManageConferenceExportPage_GetAttendeeGoogleAccountsQueryVariables>;
export const ManageConferenceExportPage_DeleteAttendeeGoogleAccountDocument = gql`
    mutation ManageConferenceExportPage_DeleteAttendeeGoogleAccount($attendeeGoogleAccountId: uuid!) {
  delete_AttendeeGoogleAccount_by_pk(id: $attendeeGoogleAccountId) {
    id
  }
}
    `;
export type ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationFn = Apollo.MutationFunction<ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation, ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationVariables>;

/**
 * __useManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation__
 *
 * To run a mutation, you first call `useManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageConferenceExportPageDeleteAttendeeGoogleAccountMutation, { data, loading, error }] = useManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation({
 *   variables: {
 *      attendeeGoogleAccountId: // value for 'attendeeGoogleAccountId'
 *   },
 * });
 */
export function useManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation(baseOptions?: Apollo.MutationHookOptions<ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation, ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation, ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationVariables>(ManageConferenceExportPage_DeleteAttendeeGoogleAccountDocument, options);
      }
export type ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationHookResult = ReturnType<typeof useManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation>;
export type ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationResult = Apollo.MutationResult<ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation>;
export type ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationOptions = Apollo.BaseMutationOptions<ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutation, ManageConferenceExportPage_DeleteAttendeeGoogleAccountMutationVariables>;
export const UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument = gql`
    query UploadYouTubeVideos_GetUploadYouTubeVideoJobs($conferenceId: uuid!) {
  job_queues_UploadYouTubeVideoJob(
    where: {conferenceId: {_eq: $conferenceId}, jobStatusName: {_neq: COMPLETED}}
    order_by: {createdAt: desc}
  ) {
    ...UploadYouTubeVideos_UploadYouTubeVideoJob
  }
}
    ${UploadYouTubeVideos_UploadYouTubeVideoJobFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>(UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument, options);
      }
export function useUploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>(UploadYouTubeVideos_GetUploadYouTubeVideoJobsDocument, options);
        }
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery>;
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetUploadYouTubeVideoJobsLazyQuery>;
export type UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetUploadYouTubeVideoJobsQuery, UploadYouTubeVideos_GetUploadYouTubeVideoJobsQueryVariables>;
export const UploadYouTubeVideos_GetAttendeeGoogleAccountsDocument = gql`
    query UploadYouTubeVideos_GetAttendeeGoogleAccounts($attendeeId: uuid!) {
  AttendeeGoogleAccount(where: {attendeeId: {_eq: $attendeeId}}) {
    id
    googleAccountEmail
    youTubeData
  }
}
    `;

/**
 * __useUploadYouTubeVideos_GetAttendeeGoogleAccountsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetAttendeeGoogleAccountsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetAttendeeGoogleAccountsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetAttendeeGoogleAccountsQuery({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetAttendeeGoogleAccountsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetAttendeeGoogleAccountsQuery, UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetAttendeeGoogleAccountsQuery, UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryVariables>(UploadYouTubeVideos_GetAttendeeGoogleAccountsDocument, options);
      }
export function useUploadYouTubeVideos_GetAttendeeGoogleAccountsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetAttendeeGoogleAccountsQuery, UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetAttendeeGoogleAccountsQuery, UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryVariables>(UploadYouTubeVideos_GetAttendeeGoogleAccountsDocument, options);
        }
export type UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetAttendeeGoogleAccountsQuery>;
export type UploadYouTubeVideos_GetAttendeeGoogleAccountsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetAttendeeGoogleAccountsLazyQuery>;
export type UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetAttendeeGoogleAccountsQuery, UploadYouTubeVideos_GetAttendeeGoogleAccountsQueryVariables>;
export const UploadYouTubeVideos_CreateUploadYouTubeVideoJobsDocument = gql`
    mutation UploadYouTubeVideos_CreateUploadYouTubeVideoJobs($objects: [job_queues_UploadYouTubeVideoJob_insert_input!]!) {
  insert_job_queues_UploadYouTubeVideoJob(objects: $objects) {
    returning {
      id
    }
  }
}
    `;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationFn = Apollo.MutationFunction<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>;

/**
 * __useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation__
 *
 * To run a mutation, you first call `useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadYouTubeVideosCreateUploadYouTubeVideoJobsMutation, { data, loading, error }] = useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation(baseOptions?: Apollo.MutationHookOptions<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>(UploadYouTubeVideos_CreateUploadYouTubeVideoJobsDocument, options);
      }
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationHookResult = ReturnType<typeof useUploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation>;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationResult = Apollo.MutationResult<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation>;
export type UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationOptions = Apollo.BaseMutationOptions<UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutation, UploadYouTubeVideos_CreateUploadYouTubeVideoJobsMutationVariables>;
export const UploadYouTubeVideos_GetContentItemsDocument = gql`
    query UploadYouTubeVideos_GetContentItems($contentItemIds: [uuid!]!) {
  ContentItem(where: {id: {_in: $contentItemIds}}) {
    id
    name
    contentGroup {
      id
      title
    }
  }
}
    `;

/**
 * __useUploadYouTubeVideos_GetContentItemsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetContentItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetContentItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetContentItemsQuery({
 *   variables: {
 *      contentItemIds: // value for 'contentItemIds'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetContentItemsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetContentItemsQuery, UploadYouTubeVideos_GetContentItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetContentItemsQuery, UploadYouTubeVideos_GetContentItemsQueryVariables>(UploadYouTubeVideos_GetContentItemsDocument, options);
      }
export function useUploadYouTubeVideos_GetContentItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetContentItemsQuery, UploadYouTubeVideos_GetContentItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetContentItemsQuery, UploadYouTubeVideos_GetContentItemsQueryVariables>(UploadYouTubeVideos_GetContentItemsDocument, options);
        }
export type UploadYouTubeVideos_GetContentItemsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetContentItemsQuery>;
export type UploadYouTubeVideos_GetContentItemsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetContentItemsLazyQuery>;
export type UploadYouTubeVideos_GetContentItemsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetContentItemsQuery, UploadYouTubeVideos_GetContentItemsQueryVariables>;
export const UploadYouTubeVideos_GetTemplateDataDocument = gql`
    query UploadYouTubeVideos_GetTemplateData($contentItemIds: [uuid!]!) {
  ContentItem(where: {id: {_in: $contentItemIds}}) {
    id
    name
    contentGroup {
      id
      shortTitle
      title
      contentItems {
        id
        youTubeUploads {
          id
          videoTitle
          videoId
        }
      }
      abstractContentItems: contentItems(
        where: {contentTypeName: {_eq: ABSTRACT}}
        order_by: {updatedAt: desc}
        limit: 1
      ) {
        ...UploadYouTubeVideos_ContentItem
      }
      paperLinkContentItems: contentItems(where: {contentTypeName: {_eq: PAPER_LINK}}) {
        ...UploadYouTubeVideos_ContentItem
      }
      paperUrlContentItems: contentItems(where: {contentTypeName: {_eq: PAPER_URL}}) {
        ...UploadYouTubeVideos_ContentItem
      }
      authors: people(where: {roleName: {_eq: "AUTHOR"}}) {
        id
        person {
          id
          name
          affiliation
        }
      }
    }
  }
}
    ${UploadYouTubeVideos_ContentItemFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetTemplateDataQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetTemplateDataQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetTemplateDataQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetTemplateDataQuery({
 *   variables: {
 *      contentItemIds: // value for 'contentItemIds'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetTemplateDataQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>(UploadYouTubeVideos_GetTemplateDataDocument, options);
      }
export function useUploadYouTubeVideos_GetTemplateDataLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>(UploadYouTubeVideos_GetTemplateDataDocument, options);
        }
export type UploadYouTubeVideos_GetTemplateDataQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetTemplateDataQuery>;
export type UploadYouTubeVideos_GetTemplateDataLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetTemplateDataLazyQuery>;
export type UploadYouTubeVideos_GetTemplateDataQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetTemplateDataQuery, UploadYouTubeVideos_GetTemplateDataQueryVariables>;
export const UploadYouTubeVideos_RefreshYouTubeDataDocument = gql`
    mutation UploadYouTubeVideos_RefreshYouTubeData($attendeeId: uuid!, $attendeeGoogleAccountId: uuid!) {
  refreshYouTubeData(
    attendeeId: $attendeeId
    attendeeGoogleAccountId: $attendeeGoogleAccountId
  ) {
    message
    success
  }
}
    `;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationFn = Apollo.MutationFunction<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>;

/**
 * __useUploadYouTubeVideos_RefreshYouTubeDataMutation__
 *
 * To run a mutation, you first call `useUploadYouTubeVideos_RefreshYouTubeDataMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_RefreshYouTubeDataMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [uploadYouTubeVideosRefreshYouTubeDataMutation, { data, loading, error }] = useUploadYouTubeVideos_RefreshYouTubeDataMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      attendeeGoogleAccountId: // value for 'attendeeGoogleAccountId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_RefreshYouTubeDataMutation(baseOptions?: Apollo.MutationHookOptions<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>(UploadYouTubeVideos_RefreshYouTubeDataDocument, options);
      }
export type UploadYouTubeVideos_RefreshYouTubeDataMutationHookResult = ReturnType<typeof useUploadYouTubeVideos_RefreshYouTubeDataMutation>;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationResult = Apollo.MutationResult<UploadYouTubeVideos_RefreshYouTubeDataMutation>;
export type UploadYouTubeVideos_RefreshYouTubeDataMutationOptions = Apollo.BaseMutationOptions<UploadYouTubeVideos_RefreshYouTubeDataMutation, UploadYouTubeVideos_RefreshYouTubeDataMutationVariables>;
export const UploadYouTubeVideos_GetYouTubeUploadsDocument = gql`
    query UploadYouTubeVideos_GetYouTubeUploads($conferenceId: uuid!) {
  YouTubeUpload(where: {conferenceId: {_eq: $conferenceId}}) {
    ...UploadYouTubeVideos_YouTubeUpload
  }
}
    ${UploadYouTubeVideos_YouTubeUploadFragmentDoc}`;

/**
 * __useUploadYouTubeVideos_GetYouTubeUploadsQuery__
 *
 * To run a query within a React component, call `useUploadYouTubeVideos_GetYouTubeUploadsQuery` and pass it any options that fit your needs.
 * When your component renders, `useUploadYouTubeVideos_GetYouTubeUploadsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useUploadYouTubeVideos_GetYouTubeUploadsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useUploadYouTubeVideos_GetYouTubeUploadsQuery(baseOptions: Apollo.QueryHookOptions<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>(UploadYouTubeVideos_GetYouTubeUploadsDocument, options);
      }
export function useUploadYouTubeVideos_GetYouTubeUploadsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>(UploadYouTubeVideos_GetYouTubeUploadsDocument, options);
        }
export type UploadYouTubeVideos_GetYouTubeUploadsQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetYouTubeUploadsQuery>;
export type UploadYouTubeVideos_GetYouTubeUploadsLazyQueryHookResult = ReturnType<typeof useUploadYouTubeVideos_GetYouTubeUploadsLazyQuery>;
export type UploadYouTubeVideos_GetYouTubeUploadsQueryResult = Apollo.QueryResult<UploadYouTubeVideos_GetYouTubeUploadsQuery, UploadYouTubeVideos_GetYouTubeUploadsQueryVariables>;
export const ImportAttendeesDocument = gql`
    mutation ImportAttendees($insertAttendees: [Attendee_insert_input!]!, $insertInvitations: [Invitation_insert_input!]!, $insertGroupAttendees: [GroupAttendee_insert_input!]!) {
  insert_Attendee(objects: $insertAttendees) {
    affected_rows
  }
  insert_Invitation(objects: $insertInvitations) {
    affected_rows
  }
  insert_GroupAttendee(objects: $insertGroupAttendees) {
    affected_rows
  }
}
    `;
export type ImportAttendeesMutationFn = Apollo.MutationFunction<ImportAttendeesMutation, ImportAttendeesMutationVariables>;

/**
 * __useImportAttendeesMutation__
 *
 * To run a mutation, you first call `useImportAttendeesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useImportAttendeesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [importAttendeesMutation, { data, loading, error }] = useImportAttendeesMutation({
 *   variables: {
 *      insertAttendees: // value for 'insertAttendees'
 *      insertInvitations: // value for 'insertInvitations'
 *      insertGroupAttendees: // value for 'insertGroupAttendees'
 *   },
 * });
 */
export function useImportAttendeesMutation(baseOptions?: Apollo.MutationHookOptions<ImportAttendeesMutation, ImportAttendeesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ImportAttendeesMutation, ImportAttendeesMutationVariables>(ImportAttendeesDocument, options);
      }
export type ImportAttendeesMutationHookResult = ReturnType<typeof useImportAttendeesMutation>;
export type ImportAttendeesMutationResult = Apollo.MutationResult<ImportAttendeesMutation>;
export type ImportAttendeesMutationOptions = Apollo.BaseMutationOptions<ImportAttendeesMutation, ImportAttendeesMutationVariables>;
export const SelectAllGroupsDocument = gql`
    query SelectAllGroups($conferenceId: uuid!) {
  Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageGroups_Group
  }
}
    ${ManageGroups_GroupFragmentDoc}`;

/**
 * __useSelectAllGroupsQuery__
 *
 * To run a query within a React component, call `useSelectAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllGroupsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, options);
      }
export function useSelectAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>(SelectAllGroupsDocument, options);
        }
export type SelectAllGroupsQueryHookResult = ReturnType<typeof useSelectAllGroupsQuery>;
export type SelectAllGroupsLazyQueryHookResult = ReturnType<typeof useSelectAllGroupsLazyQuery>;
export type SelectAllGroupsQueryResult = Apollo.QueryResult<SelectAllGroupsQuery, SelectAllGroupsQueryVariables>;
export const CreateDeleteGroupsDocument = gql`
    mutation CreateDeleteGroups($deleteGroupIds: [uuid!] = [], $insertGroups: [Group_insert_input!]!) {
  delete_Group(where: {id: {_in: $deleteGroupIds}}) {
    returning {
      id
    }
  }
  insert_Group(objects: $insertGroups) {
    returning {
      id
      conferenceId
      name
      enabled
      includeUnauthenticated
      groupRoles {
        id
        groupId
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteGroupsMutationFn = Apollo.MutationFunction<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;

/**
 * __useCreateDeleteGroupsMutation__
 *
 * To run a mutation, you first call `useCreateDeleteGroupsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteGroupsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteGroupsMutation, { data, loading, error }] = useCreateDeleteGroupsMutation({
 *   variables: {
 *      deleteGroupIds: // value for 'deleteGroupIds'
 *      insertGroups: // value for 'insertGroups'
 *   },
 * });
 */
export function useCreateDeleteGroupsMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>(CreateDeleteGroupsDocument, options);
      }
export type CreateDeleteGroupsMutationHookResult = ReturnType<typeof useCreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationResult = Apollo.MutationResult<CreateDeleteGroupsMutation>;
export type CreateDeleteGroupsMutationOptions = Apollo.BaseMutationOptions<CreateDeleteGroupsMutation, CreateDeleteGroupsMutationVariables>;
export const UpdateGroupDocument = gql`
    mutation UpdateGroup($groupId: uuid!, $groupName: String!, $enabled: Boolean!, $includeUnauthenticated: Boolean!, $insertRoles: [GroupRole_insert_input!]!, $deleteRoleIds: [uuid!] = []) {
  update_Group(
    where: {id: {_eq: $groupId}}
    _set: {name: $groupName, enabled: $enabled, includeUnauthenticated: $includeUnauthenticated}
  ) {
    returning {
      id
      name
      groupRoles {
        id
        groupId
        roleId
      }
      conferenceId
    }
  }
  insert_GroupRole(objects: $insertRoles) {
    returning {
      id
      groupId
      roleId
    }
  }
  delete_GroupRole(where: {roleId: {_in: $deleteRoleIds}}) {
    returning {
      id
    }
  }
}
    `;
export type UpdateGroupMutationFn = Apollo.MutationFunction<UpdateGroupMutation, UpdateGroupMutationVariables>;

/**
 * __useUpdateGroupMutation__
 *
 * To run a mutation, you first call `useUpdateGroupMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateGroupMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateGroupMutation, { data, loading, error }] = useUpdateGroupMutation({
 *   variables: {
 *      groupId: // value for 'groupId'
 *      groupName: // value for 'groupName'
 *      enabled: // value for 'enabled'
 *      includeUnauthenticated: // value for 'includeUnauthenticated'
 *      insertRoles: // value for 'insertRoles'
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *   },
 * });
 */
export function useUpdateGroupMutation(baseOptions?: Apollo.MutationHookOptions<UpdateGroupMutation, UpdateGroupMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateGroupMutation, UpdateGroupMutationVariables>(UpdateGroupDocument, options);
      }
export type UpdateGroupMutationHookResult = ReturnType<typeof useUpdateGroupMutation>;
export type UpdateGroupMutationResult = Apollo.MutationResult<UpdateGroupMutation>;
export type UpdateGroupMutationOptions = Apollo.BaseMutationOptions<UpdateGroupMutation, UpdateGroupMutationVariables>;
export const UpdateConferenceDocument = gql`
    mutation UpdateConference($id: uuid!, $name: String = "", $shortName: String = "", $slug: String = "") {
  update_Conference(
    where: {id: {_eq: $id}}
    _set: {name: $name, shortName: $shortName, slug: $slug}
  ) {
    returning {
      id
      name
      shortName
      slug
    }
  }
}
    `;
export type UpdateConferenceMutationFn = Apollo.MutationFunction<UpdateConferenceMutation, UpdateConferenceMutationVariables>;

/**
 * __useUpdateConferenceMutation__
 *
 * To run a mutation, you first call `useUpdateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateConferenceMutation, { data, loading, error }] = useUpdateConferenceMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useUpdateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateConferenceMutation, UpdateConferenceMutationVariables>(UpdateConferenceDocument, options);
      }
export type UpdateConferenceMutationHookResult = ReturnType<typeof useUpdateConferenceMutation>;
export type UpdateConferenceMutationResult = Apollo.MutationResult<UpdateConferenceMutation>;
export type UpdateConferenceMutationOptions = Apollo.BaseMutationOptions<UpdateConferenceMutation, UpdateConferenceMutationVariables>;
export const ManageContentPeople_SelectAllPeopleDocument = gql`
    query ManageContentPeople_SelectAllPeople($conferenceId: uuid!) {
  ContentPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContentPeople_ContentPerson
  }
}
    ${ManageContentPeople_ContentPersonFragmentDoc}`;

/**
 * __useManageContentPeople_SelectAllPeopleQuery__
 *
 * To run a query within a React component, call `useManageContentPeople_SelectAllPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContentPeople_SelectAllPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContentPeople_SelectAllPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContentPeople_SelectAllPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageContentPeople_SelectAllPeopleQuery, ManageContentPeople_SelectAllPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContentPeople_SelectAllPeopleQuery, ManageContentPeople_SelectAllPeopleQueryVariables>(ManageContentPeople_SelectAllPeopleDocument, options);
      }
export function useManageContentPeople_SelectAllPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContentPeople_SelectAllPeopleQuery, ManageContentPeople_SelectAllPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContentPeople_SelectAllPeopleQuery, ManageContentPeople_SelectAllPeopleQueryVariables>(ManageContentPeople_SelectAllPeopleDocument, options);
        }
export type ManageContentPeople_SelectAllPeopleQueryHookResult = ReturnType<typeof useManageContentPeople_SelectAllPeopleQuery>;
export type ManageContentPeople_SelectAllPeopleLazyQueryHookResult = ReturnType<typeof useManageContentPeople_SelectAllPeopleLazyQuery>;
export type ManageContentPeople_SelectAllPeopleQueryResult = Apollo.QueryResult<ManageContentPeople_SelectAllPeopleQuery, ManageContentPeople_SelectAllPeopleQueryVariables>;
export const ManageContentPeople_SelectAllAttendeesDocument = gql`
    query ManageContentPeople_SelectAllAttendees($conferenceId: uuid!) {
  Attendee(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageContentPeople_Attendee
  }
}
    ${ManageContentPeople_AttendeeFragmentDoc}`;

/**
 * __useManageContentPeople_SelectAllAttendeesQuery__
 *
 * To run a query within a React component, call `useManageContentPeople_SelectAllAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageContentPeople_SelectAllAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageContentPeople_SelectAllAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageContentPeople_SelectAllAttendeesQuery(baseOptions: Apollo.QueryHookOptions<ManageContentPeople_SelectAllAttendeesQuery, ManageContentPeople_SelectAllAttendeesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageContentPeople_SelectAllAttendeesQuery, ManageContentPeople_SelectAllAttendeesQueryVariables>(ManageContentPeople_SelectAllAttendeesDocument, options);
      }
export function useManageContentPeople_SelectAllAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageContentPeople_SelectAllAttendeesQuery, ManageContentPeople_SelectAllAttendeesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageContentPeople_SelectAllAttendeesQuery, ManageContentPeople_SelectAllAttendeesQueryVariables>(ManageContentPeople_SelectAllAttendeesDocument, options);
        }
export type ManageContentPeople_SelectAllAttendeesQueryHookResult = ReturnType<typeof useManageContentPeople_SelectAllAttendeesQuery>;
export type ManageContentPeople_SelectAllAttendeesLazyQueryHookResult = ReturnType<typeof useManageContentPeople_SelectAllAttendeesLazyQuery>;
export type ManageContentPeople_SelectAllAttendeesQueryResult = Apollo.QueryResult<ManageContentPeople_SelectAllAttendeesQuery, ManageContentPeople_SelectAllAttendeesQueryVariables>;
export const ManageContentPeople_InsertContentPersonDocument = gql`
    mutation ManageContentPeople_InsertContentPerson($person: ContentPerson_insert_input!) {
  insert_ContentPerson_one(object: $person) {
    ...ManageContentPeople_ContentPerson
  }
}
    ${ManageContentPeople_ContentPersonFragmentDoc}`;
export type ManageContentPeople_InsertContentPersonMutationFn = Apollo.MutationFunction<ManageContentPeople_InsertContentPersonMutation, ManageContentPeople_InsertContentPersonMutationVariables>;

/**
 * __useManageContentPeople_InsertContentPersonMutation__
 *
 * To run a mutation, you first call `useManageContentPeople_InsertContentPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContentPeople_InsertContentPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentPeopleInsertContentPersonMutation, { data, loading, error }] = useManageContentPeople_InsertContentPersonMutation({
 *   variables: {
 *      person: // value for 'person'
 *   },
 * });
 */
export function useManageContentPeople_InsertContentPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContentPeople_InsertContentPersonMutation, ManageContentPeople_InsertContentPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContentPeople_InsertContentPersonMutation, ManageContentPeople_InsertContentPersonMutationVariables>(ManageContentPeople_InsertContentPersonDocument, options);
      }
export type ManageContentPeople_InsertContentPersonMutationHookResult = ReturnType<typeof useManageContentPeople_InsertContentPersonMutation>;
export type ManageContentPeople_InsertContentPersonMutationResult = Apollo.MutationResult<ManageContentPeople_InsertContentPersonMutation>;
export type ManageContentPeople_InsertContentPersonMutationOptions = Apollo.BaseMutationOptions<ManageContentPeople_InsertContentPersonMutation, ManageContentPeople_InsertContentPersonMutationVariables>;
export const ManageContentPeople_DeleteContentPersonsDocument = gql`
    mutation ManageContentPeople_DeleteContentPersons($ids: [uuid!] = []) {
  delete_ContentPerson(where: {id: {_in: $ids}}) {
    returning {
      id
    }
  }
}
    `;
export type ManageContentPeople_DeleteContentPersonsMutationFn = Apollo.MutationFunction<ManageContentPeople_DeleteContentPersonsMutation, ManageContentPeople_DeleteContentPersonsMutationVariables>;

/**
 * __useManageContentPeople_DeleteContentPersonsMutation__
 *
 * To run a mutation, you first call `useManageContentPeople_DeleteContentPersonsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContentPeople_DeleteContentPersonsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentPeopleDeleteContentPersonsMutation, { data, loading, error }] = useManageContentPeople_DeleteContentPersonsMutation({
 *   variables: {
 *      ids: // value for 'ids'
 *   },
 * });
 */
export function useManageContentPeople_DeleteContentPersonsMutation(baseOptions?: Apollo.MutationHookOptions<ManageContentPeople_DeleteContentPersonsMutation, ManageContentPeople_DeleteContentPersonsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContentPeople_DeleteContentPersonsMutation, ManageContentPeople_DeleteContentPersonsMutationVariables>(ManageContentPeople_DeleteContentPersonsDocument, options);
      }
export type ManageContentPeople_DeleteContentPersonsMutationHookResult = ReturnType<typeof useManageContentPeople_DeleteContentPersonsMutation>;
export type ManageContentPeople_DeleteContentPersonsMutationResult = Apollo.MutationResult<ManageContentPeople_DeleteContentPersonsMutation>;
export type ManageContentPeople_DeleteContentPersonsMutationOptions = Apollo.BaseMutationOptions<ManageContentPeople_DeleteContentPersonsMutation, ManageContentPeople_DeleteContentPersonsMutationVariables>;
export const ManageContentPeople_UpdateContentPersonDocument = gql`
    mutation ManageContentPeople_UpdateContentPerson($id: uuid!, $name: String!, $affiliation: String, $email: String, $attendeeId: uuid) {
  update_ContentPerson_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, affiliation: $affiliation, email: $email, attendeeId: $attendeeId}
  ) {
    ...ManageContentPeople_ContentPerson
  }
}
    ${ManageContentPeople_ContentPersonFragmentDoc}`;
export type ManageContentPeople_UpdateContentPersonMutationFn = Apollo.MutationFunction<ManageContentPeople_UpdateContentPersonMutation, ManageContentPeople_UpdateContentPersonMutationVariables>;

/**
 * __useManageContentPeople_UpdateContentPersonMutation__
 *
 * To run a mutation, you first call `useManageContentPeople_UpdateContentPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageContentPeople_UpdateContentPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageContentPeopleUpdateContentPersonMutation, { data, loading, error }] = useManageContentPeople_UpdateContentPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      affiliation: // value for 'affiliation'
 *      email: // value for 'email'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useManageContentPeople_UpdateContentPersonMutation(baseOptions?: Apollo.MutationHookOptions<ManageContentPeople_UpdateContentPersonMutation, ManageContentPeople_UpdateContentPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageContentPeople_UpdateContentPersonMutation, ManageContentPeople_UpdateContentPersonMutationVariables>(ManageContentPeople_UpdateContentPersonDocument, options);
      }
export type ManageContentPeople_UpdateContentPersonMutationHookResult = ReturnType<typeof useManageContentPeople_UpdateContentPersonMutation>;
export type ManageContentPeople_UpdateContentPersonMutationResult = Apollo.MutationResult<ManageContentPeople_UpdateContentPersonMutation>;
export type ManageContentPeople_UpdateContentPersonMutationOptions = Apollo.BaseMutationOptions<ManageContentPeople_UpdateContentPersonMutation, ManageContentPeople_UpdateContentPersonMutationVariables>;
export const SelectAllAttendeesDocument = gql`
    query SelectAllAttendees($conferenceId: uuid!) {
  Attendee(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AttendeeParts
  }
}
    ${AttendeePartsFragmentDoc}`;

/**
 * __useSelectAllAttendeesQuery__
 *
 * To run a query within a React component, call `useSelectAllAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllAttendeesQuery(baseOptions: Apollo.QueryHookOptions<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>(SelectAllAttendeesDocument, options);
      }
export function useSelectAllAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>(SelectAllAttendeesDocument, options);
        }
export type SelectAllAttendeesQueryHookResult = ReturnType<typeof useSelectAllAttendeesQuery>;
export type SelectAllAttendeesLazyQueryHookResult = ReturnType<typeof useSelectAllAttendeesLazyQuery>;
export type SelectAllAttendeesQueryResult = Apollo.QueryResult<SelectAllAttendeesQuery, SelectAllAttendeesQueryVariables>;
export const InsertAttendeeDocument = gql`
    mutation InsertAttendee($attendee: Attendee_insert_input!, $invitation: Invitation_insert_input!) {
  insert_Attendee_one(object: $attendee) {
    ...AttendeeParts
  }
  insert_Invitation_one(object: $invitation) {
    ...InvitationParts
  }
}
    ${AttendeePartsFragmentDoc}
${InvitationPartsFragmentDoc}`;
export type InsertAttendeeMutationFn = Apollo.MutationFunction<InsertAttendeeMutation, InsertAttendeeMutationVariables>;

/**
 * __useInsertAttendeeMutation__
 *
 * To run a mutation, you first call `useInsertAttendeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertAttendeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertAttendeeMutation, { data, loading, error }] = useInsertAttendeeMutation({
 *   variables: {
 *      attendee: // value for 'attendee'
 *      invitation: // value for 'invitation'
 *   },
 * });
 */
export function useInsertAttendeeMutation(baseOptions?: Apollo.MutationHookOptions<InsertAttendeeMutation, InsertAttendeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertAttendeeMutation, InsertAttendeeMutationVariables>(InsertAttendeeDocument, options);
      }
export type InsertAttendeeMutationHookResult = ReturnType<typeof useInsertAttendeeMutation>;
export type InsertAttendeeMutationResult = Apollo.MutationResult<InsertAttendeeMutation>;
export type InsertAttendeeMutationOptions = Apollo.BaseMutationOptions<InsertAttendeeMutation, InsertAttendeeMutationVariables>;
export const InsertAttendeeWithoutInviteDocument = gql`
    mutation InsertAttendeeWithoutInvite($attendee: Attendee_insert_input!) {
  insert_Attendee_one(object: $attendee) {
    ...AttendeeParts
  }
}
    ${AttendeePartsFragmentDoc}`;
export type InsertAttendeeWithoutInviteMutationFn = Apollo.MutationFunction<InsertAttendeeWithoutInviteMutation, InsertAttendeeWithoutInviteMutationVariables>;

/**
 * __useInsertAttendeeWithoutInviteMutation__
 *
 * To run a mutation, you first call `useInsertAttendeeWithoutInviteMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertAttendeeWithoutInviteMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertAttendeeWithoutInviteMutation, { data, loading, error }] = useInsertAttendeeWithoutInviteMutation({
 *   variables: {
 *      attendee: // value for 'attendee'
 *   },
 * });
 */
export function useInsertAttendeeWithoutInviteMutation(baseOptions?: Apollo.MutationHookOptions<InsertAttendeeWithoutInviteMutation, InsertAttendeeWithoutInviteMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertAttendeeWithoutInviteMutation, InsertAttendeeWithoutInviteMutationVariables>(InsertAttendeeWithoutInviteDocument, options);
      }
export type InsertAttendeeWithoutInviteMutationHookResult = ReturnType<typeof useInsertAttendeeWithoutInviteMutation>;
export type InsertAttendeeWithoutInviteMutationResult = Apollo.MutationResult<InsertAttendeeWithoutInviteMutation>;
export type InsertAttendeeWithoutInviteMutationOptions = Apollo.BaseMutationOptions<InsertAttendeeWithoutInviteMutation, InsertAttendeeWithoutInviteMutationVariables>;
export const DeleteAttendeesDocument = gql`
    mutation DeleteAttendees($deleteAttendeeIds: [uuid!] = []) {
  delete_Attendee(where: {id: {_in: $deleteAttendeeIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteAttendeesMutationFn = Apollo.MutationFunction<DeleteAttendeesMutation, DeleteAttendeesMutationVariables>;

/**
 * __useDeleteAttendeesMutation__
 *
 * To run a mutation, you first call `useDeleteAttendeesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteAttendeesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteAttendeesMutation, { data, loading, error }] = useDeleteAttendeesMutation({
 *   variables: {
 *      deleteAttendeeIds: // value for 'deleteAttendeeIds'
 *   },
 * });
 */
export function useDeleteAttendeesMutation(baseOptions?: Apollo.MutationHookOptions<DeleteAttendeesMutation, DeleteAttendeesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteAttendeesMutation, DeleteAttendeesMutationVariables>(DeleteAttendeesDocument, options);
      }
export type DeleteAttendeesMutationHookResult = ReturnType<typeof useDeleteAttendeesMutation>;
export type DeleteAttendeesMutationResult = Apollo.MutationResult<DeleteAttendeesMutation>;
export type DeleteAttendeesMutationOptions = Apollo.BaseMutationOptions<DeleteAttendeesMutation, DeleteAttendeesMutationVariables>;
export const UpdateAttendeeDocument = gql`
    mutation UpdateAttendee($attendeeId: uuid!, $attendeeName: String!, $upsertGroups: [GroupAttendee_insert_input!]!, $remainingGroupIds: [uuid!]) {
  update_Attendee_by_pk(
    pk_columns: {id: $attendeeId}
    _set: {displayName: $attendeeName}
  ) {
    ...AttendeeParts
  }
  insert_GroupAttendee(
    objects: $upsertGroups
    on_conflict: {constraint: GroupAttendee_groupId_attendeeId_key, update_columns: []}
  ) {
    returning {
      id
      attendeeId
      groupId
    }
  }
  delete_GroupAttendee(
    where: {attendeeId: {_eq: $attendeeId}, groupId: {_nin: $remainingGroupIds}}
  ) {
    returning {
      id
    }
  }
}
    ${AttendeePartsFragmentDoc}`;
export type UpdateAttendeeMutationFn = Apollo.MutationFunction<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>;

/**
 * __useUpdateAttendeeMutation__
 *
 * To run a mutation, you first call `useUpdateAttendeeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateAttendeeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateAttendeeMutation, { data, loading, error }] = useUpdateAttendeeMutation({
 *   variables: {
 *      attendeeId: // value for 'attendeeId'
 *      attendeeName: // value for 'attendeeName'
 *      upsertGroups: // value for 'upsertGroups'
 *      remainingGroupIds: // value for 'remainingGroupIds'
 *   },
 * });
 */
export function useUpdateAttendeeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>(UpdateAttendeeDocument, options);
      }
export type UpdateAttendeeMutationHookResult = ReturnType<typeof useUpdateAttendeeMutation>;
export type UpdateAttendeeMutationResult = Apollo.MutationResult<UpdateAttendeeMutation>;
export type UpdateAttendeeMutationOptions = Apollo.BaseMutationOptions<UpdateAttendeeMutation, UpdateAttendeeMutationVariables>;
export const InsertInvitationEmailJobsDocument = gql`
    mutation InsertInvitationEmailJobs($attendeeIds: jsonb!, $conferenceId: uuid!, $sendRepeat: Boolean!) {
  insert_job_queues_InvitationEmailJob(
    objects: [{attendeeIds: $attendeeIds, conferenceId: $conferenceId, sendRepeat: $sendRepeat}]
  ) {
    affected_rows
  }
}
    `;
export type InsertInvitationEmailJobsMutationFn = Apollo.MutationFunction<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;

/**
 * __useInsertInvitationEmailJobsMutation__
 *
 * To run a mutation, you first call `useInsertInvitationEmailJobsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertInvitationEmailJobsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertInvitationEmailJobsMutation, { data, loading, error }] = useInsertInvitationEmailJobsMutation({
 *   variables: {
 *      attendeeIds: // value for 'attendeeIds'
 *      conferenceId: // value for 'conferenceId'
 *      sendRepeat: // value for 'sendRepeat'
 *   },
 * });
 */
export function useInsertInvitationEmailJobsMutation(baseOptions?: Apollo.MutationHookOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>(InsertInvitationEmailJobsDocument, options);
      }
export type InsertInvitationEmailJobsMutationHookResult = ReturnType<typeof useInsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationResult = Apollo.MutationResult<InsertInvitationEmailJobsMutation>;
export type InsertInvitationEmailJobsMutationOptions = Apollo.BaseMutationOptions<InsertInvitationEmailJobsMutation, InsertInvitationEmailJobsMutationVariables>;
export const ManageConferencePeoplePage_InsertCustomEmailJobDocument = gql`
    mutation ManageConferencePeoplePage_InsertCustomEmailJob($htmlBody: String!, $subject: String!, $conferenceId: uuid!, $attendeeIds: jsonb!) {
  insert_job_queues_CustomEmailJob(
    objects: {htmlBody: $htmlBody, subject: $subject, conferenceId: $conferenceId, attendeeIds: $attendeeIds}
  ) {
    affected_rows
  }
}
    `;
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationFn = Apollo.MutationFunction<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>;

/**
 * __useManageConferencePeoplePage_InsertCustomEmailJobMutation__
 *
 * To run a mutation, you first call `useManageConferencePeoplePage_InsertCustomEmailJobMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useManageConferencePeoplePage_InsertCustomEmailJobMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [manageConferencePeoplePageInsertCustomEmailJobMutation, { data, loading, error }] = useManageConferencePeoplePage_InsertCustomEmailJobMutation({
 *   variables: {
 *      htmlBody: // value for 'htmlBody'
 *      subject: // value for 'subject'
 *      conferenceId: // value for 'conferenceId'
 *      attendeeIds: // value for 'attendeeIds'
 *   },
 * });
 */
export function useManageConferencePeoplePage_InsertCustomEmailJobMutation(baseOptions?: Apollo.MutationHookOptions<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>(ManageConferencePeoplePage_InsertCustomEmailJobDocument, options);
      }
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationHookResult = ReturnType<typeof useManageConferencePeoplePage_InsertCustomEmailJobMutation>;
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationResult = Apollo.MutationResult<ManageConferencePeoplePage_InsertCustomEmailJobMutation>;
export type ManageConferencePeoplePage_InsertCustomEmailJobMutationOptions = Apollo.BaseMutationOptions<ManageConferencePeoplePage_InsertCustomEmailJobMutation, ManageConferencePeoplePage_InsertCustomEmailJobMutationVariables>;
export const SelectAllPermissionsDocument = gql`
    query SelectAllPermissions {
  Permission {
    name
    description
  }
}
    `;

/**
 * __useSelectAllPermissionsQuery__
 *
 * To run a query within a React component, call `useSelectAllPermissionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllPermissionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllPermissionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useSelectAllPermissionsQuery(baseOptions?: Apollo.QueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, options);
      }
export function useSelectAllPermissionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>(SelectAllPermissionsDocument, options);
        }
export type SelectAllPermissionsQueryHookResult = ReturnType<typeof useSelectAllPermissionsQuery>;
export type SelectAllPermissionsLazyQueryHookResult = ReturnType<typeof useSelectAllPermissionsLazyQuery>;
export type SelectAllPermissionsQueryResult = Apollo.QueryResult<SelectAllPermissionsQuery, SelectAllPermissionsQueryVariables>;
export const SelectAllRolesDocument = gql`
    query SelectAllRoles($conferenceId: uuid!) {
  Role(where: {conferenceId: {_eq: $conferenceId}}) {
    conferenceId
    id
    name
    rolePermissions {
      id
      permissionName
      roleId
    }
  }
}
    `;

/**
 * __useSelectAllRolesQuery__
 *
 * To run a query within a React component, call `useSelectAllRolesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRolesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRolesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRolesQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, options);
      }
export function useSelectAllRolesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRolesQuery, SelectAllRolesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRolesQuery, SelectAllRolesQueryVariables>(SelectAllRolesDocument, options);
        }
export type SelectAllRolesQueryHookResult = ReturnType<typeof useSelectAllRolesQuery>;
export type SelectAllRolesLazyQueryHookResult = ReturnType<typeof useSelectAllRolesLazyQuery>;
export type SelectAllRolesQueryResult = Apollo.QueryResult<SelectAllRolesQuery, SelectAllRolesQueryVariables>;
export const CreateDeleteRolesDocument = gql`
    mutation CreateDeleteRoles($deleteRoleIds: [uuid!] = [], $insertRoles: [Role_insert_input!]!) {
  delete_Role(where: {id: {_in: $deleteRoleIds}}) {
    returning {
      id
    }
  }
  insert_Role(objects: $insertRoles) {
    returning {
      id
      conferenceId
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
    }
  }
}
    `;
export type CreateDeleteRolesMutationFn = Apollo.MutationFunction<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;

/**
 * __useCreateDeleteRolesMutation__
 *
 * To run a mutation, you first call `useCreateDeleteRolesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateDeleteRolesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createDeleteRolesMutation, { data, loading, error }] = useCreateDeleteRolesMutation({
 *   variables: {
 *      deleteRoleIds: // value for 'deleteRoleIds'
 *      insertRoles: // value for 'insertRoles'
 *   },
 * });
 */
export function useCreateDeleteRolesMutation(baseOptions?: Apollo.MutationHookOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>(CreateDeleteRolesDocument, options);
      }
export type CreateDeleteRolesMutationHookResult = ReturnType<typeof useCreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationResult = Apollo.MutationResult<CreateDeleteRolesMutation>;
export type CreateDeleteRolesMutationOptions = Apollo.BaseMutationOptions<CreateDeleteRolesMutation, CreateDeleteRolesMutationVariables>;
export const UpdateRoleDocument = gql`
    mutation UpdateRole($roleId: uuid!, $roleName: String!, $insertPermissions: [RolePermission_insert_input!]!, $deletePermissionNames: [Permission_enum!] = []) {
  update_Role(where: {id: {_eq: $roleId}}, _set: {name: $roleName}) {
    returning {
      id
      name
      rolePermissions {
        id
        permissionName
        roleId
      }
      conferenceId
    }
  }
  insert_RolePermission(objects: $insertPermissions) {
    returning {
      id
      permissionName
      roleId
    }
  }
  delete_RolePermission(where: {permissionName: {_in: $deletePermissionNames}}) {
    returning {
      id
    }
  }
}
    `;
export type UpdateRoleMutationFn = Apollo.MutationFunction<UpdateRoleMutation, UpdateRoleMutationVariables>;

/**
 * __useUpdateRoleMutation__
 *
 * To run a mutation, you first call `useUpdateRoleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoleMutation, { data, loading, error }] = useUpdateRoleMutation({
 *   variables: {
 *      roleId: // value for 'roleId'
 *      roleName: // value for 'roleName'
 *      insertPermissions: // value for 'insertPermissions'
 *      deletePermissionNames: // value for 'deletePermissionNames'
 *   },
 * });
 */
export function useUpdateRoleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoleMutation, UpdateRoleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoleMutation, UpdateRoleMutationVariables>(UpdateRoleDocument, options);
      }
export type UpdateRoleMutationHookResult = ReturnType<typeof useUpdateRoleMutation>;
export type UpdateRoleMutationResult = Apollo.MutationResult<UpdateRoleMutation>;
export type UpdateRoleMutationOptions = Apollo.BaseMutationOptions<UpdateRoleMutation, UpdateRoleMutationVariables>;
export const SelectAllRoomsWithParticipantsDocument = gql`
    query SelectAllRoomsWithParticipants($conferenceId: uuid!) {
  Room(
    where: {conferenceId: {_eq: $conferenceId}, roomPrivacyName: {_in: [PUBLIC, PRIVATE]}}
  ) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;

/**
 * __useSelectAllRoomsWithParticipantsQuery__
 *
 * To run a query within a React component, call `useSelectAllRoomsWithParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectAllRoomsWithParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectAllRoomsWithParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectAllRoomsWithParticipantsQuery(baseOptions: Apollo.QueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, options);
      }
export function useSelectAllRoomsWithParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>(SelectAllRoomsWithParticipantsDocument, options);
        }
export type SelectAllRoomsWithParticipantsQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsQuery>;
export type SelectAllRoomsWithParticipantsLazyQueryHookResult = ReturnType<typeof useSelectAllRoomsWithParticipantsLazyQuery>;
export type SelectAllRoomsWithParticipantsQueryResult = Apollo.QueryResult<SelectAllRoomsWithParticipantsQuery, SelectAllRoomsWithParticipantsQueryVariables>;
export const ManageRooms_SelectGroupsDocument = gql`
    query ManageRooms_SelectGroups($conferenceId: uuid!) {
  Group(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    name
  }
}
    `;

/**
 * __useManageRooms_SelectGroupsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageRooms_SelectGroupsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>(ManageRooms_SelectGroupsDocument, options);
      }
export function useManageRooms_SelectGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>(ManageRooms_SelectGroupsDocument, options);
        }
export type ManageRooms_SelectGroupsQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupsQuery>;
export type ManageRooms_SelectGroupsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupsLazyQuery>;
export type ManageRooms_SelectGroupsQueryResult = Apollo.QueryResult<ManageRooms_SelectGroupsQuery, ManageRooms_SelectGroupsQueryVariables>;
export const ManageRooms_SelectContentGroupsDocument = gql`
    query ManageRooms_SelectContentGroups($conferenceId: uuid!) {
  ContentGroup(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    title
  }
}
    `;

/**
 * __useManageRooms_SelectContentGroupsQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectContentGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectContentGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectContentGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageRooms_SelectContentGroupsQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectContentGroupsQuery, ManageRooms_SelectContentGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectContentGroupsQuery, ManageRooms_SelectContentGroupsQueryVariables>(ManageRooms_SelectContentGroupsDocument, options);
      }
export function useManageRooms_SelectContentGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectContentGroupsQuery, ManageRooms_SelectContentGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectContentGroupsQuery, ManageRooms_SelectContentGroupsQueryVariables>(ManageRooms_SelectContentGroupsDocument, options);
        }
export type ManageRooms_SelectContentGroupsQueryHookResult = ReturnType<typeof useManageRooms_SelectContentGroupsQuery>;
export type ManageRooms_SelectContentGroupsLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectContentGroupsLazyQuery>;
export type ManageRooms_SelectContentGroupsQueryResult = Apollo.QueryResult<ManageRooms_SelectContentGroupsQuery, ManageRooms_SelectContentGroupsQueryVariables>;
export const ManageRooms_SelectGroupAttendeesDocument = gql`
    query ManageRooms_SelectGroupAttendees($groupId: uuid!) {
  GroupAttendee(where: {groupId: {_eq: $groupId}}) {
    id
    groupId
    attendeeId
  }
}
    `;

/**
 * __useManageRooms_SelectGroupAttendeesQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectGroupAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectGroupAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectGroupAttendeesQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useManageRooms_SelectGroupAttendeesQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectGroupAttendeesQuery, ManageRooms_SelectGroupAttendeesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectGroupAttendeesQuery, ManageRooms_SelectGroupAttendeesQueryVariables>(ManageRooms_SelectGroupAttendeesDocument, options);
      }
export function useManageRooms_SelectGroupAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectGroupAttendeesQuery, ManageRooms_SelectGroupAttendeesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectGroupAttendeesQuery, ManageRooms_SelectGroupAttendeesQueryVariables>(ManageRooms_SelectGroupAttendeesDocument, options);
        }
export type ManageRooms_SelectGroupAttendeesQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupAttendeesQuery>;
export type ManageRooms_SelectGroupAttendeesLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectGroupAttendeesLazyQuery>;
export type ManageRooms_SelectGroupAttendeesQueryResult = Apollo.QueryResult<ManageRooms_SelectGroupAttendeesQuery, ManageRooms_SelectGroupAttendeesQueryVariables>;
export const ManageRooms_SelectRoomPeopleDocument = gql`
    query ManageRooms_SelectRoomPeople($roomId: uuid!) {
  RoomPerson(where: {roomId: {_eq: $roomId}}) {
    ...RoomPersonInfo
  }
}
    ${RoomPersonInfoFragmentDoc}`;

/**
 * __useManageRooms_SelectRoomPeopleQuery__
 *
 * To run a query within a React component, call `useManageRooms_SelectRoomPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageRooms_SelectRoomPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageRooms_SelectRoomPeopleQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useManageRooms_SelectRoomPeopleQuery(baseOptions: Apollo.QueryHookOptions<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>(ManageRooms_SelectRoomPeopleDocument, options);
      }
export function useManageRooms_SelectRoomPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>(ManageRooms_SelectRoomPeopleDocument, options);
        }
export type ManageRooms_SelectRoomPeopleQueryHookResult = ReturnType<typeof useManageRooms_SelectRoomPeopleQuery>;
export type ManageRooms_SelectRoomPeopleLazyQueryHookResult = ReturnType<typeof useManageRooms_SelectRoomPeopleLazyQuery>;
export type ManageRooms_SelectRoomPeopleQueryResult = Apollo.QueryResult<ManageRooms_SelectRoomPeopleQuery, ManageRooms_SelectRoomPeopleQueryVariables>;
export const CreateRoomDocument = gql`
    mutation CreateRoom($room: Room_insert_input!) {
  insert_Room_one(object: $room) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type CreateRoomMutationFn = Apollo.MutationFunction<CreateRoomMutation, CreateRoomMutationVariables>;

/**
 * __useCreateRoomMutation__
 *
 * To run a mutation, you first call `useCreateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createRoomMutation, { data, loading, error }] = useCreateRoomMutation({
 *   variables: {
 *      room: // value for 'room'
 *   },
 * });
 */
export function useCreateRoomMutation(baseOptions?: Apollo.MutationHookOptions<CreateRoomMutation, CreateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateRoomMutation, CreateRoomMutationVariables>(CreateRoomDocument, options);
      }
export type CreateRoomMutationHookResult = ReturnType<typeof useCreateRoomMutation>;
export type CreateRoomMutationResult = Apollo.MutationResult<CreateRoomMutation>;
export type CreateRoomMutationOptions = Apollo.BaseMutationOptions<CreateRoomMutation, CreateRoomMutationVariables>;
export const UpdateRoomsWithParticipantsDocument = gql`
    mutation UpdateRoomsWithParticipants($id: uuid!, $name: String!, $capacity: Int, $priority: Int!, $roomPrivacyName: RoomPrivacy_enum!, $originatingContentGroupId: uuid) {
  update_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, priority: $priority, roomPrivacyName: $roomPrivacyName, originatingContentGroupId: $originatingContentGroupId}
  ) {
    ...RoomWithParticipantInfo
  }
}
    ${RoomWithParticipantInfoFragmentDoc}`;
export type UpdateRoomsWithParticipantsMutationFn = Apollo.MutationFunction<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;

/**
 * __useUpdateRoomsWithParticipantsMutation__
 *
 * To run a mutation, you first call `useUpdateRoomsWithParticipantsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomsWithParticipantsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomsWithParticipantsMutation, { data, loading, error }] = useUpdateRoomsWithParticipantsMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      priority: // value for 'priority'
 *      roomPrivacyName: // value for 'roomPrivacyName'
 *      originatingContentGroupId: // value for 'originatingContentGroupId'
 *   },
 * });
 */
export function useUpdateRoomsWithParticipantsMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>(UpdateRoomsWithParticipantsDocument, options);
      }
export type UpdateRoomsWithParticipantsMutationHookResult = ReturnType<typeof useUpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationResult = Apollo.MutationResult<UpdateRoomsWithParticipantsMutation>;
export type UpdateRoomsWithParticipantsMutationOptions = Apollo.BaseMutationOptions<UpdateRoomsWithParticipantsMutation, UpdateRoomsWithParticipantsMutationVariables>;
export const InsertRoomPeopleDocument = gql`
    mutation InsertRoomPeople($people: [RoomPerson_insert_input!]!) {
  insert_RoomPerson(
    objects: $people
    on_conflict: {constraint: RoomPerson_attendeeId_roomId_key, update_columns: []}
  ) {
    returning {
      ...RoomPersonInfo
    }
  }
}
    ${RoomPersonInfoFragmentDoc}`;
export type InsertRoomPeopleMutationFn = Apollo.MutationFunction<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>;

/**
 * __useInsertRoomPeopleMutation__
 *
 * To run a mutation, you first call `useInsertRoomPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomPeopleMutation, { data, loading, error }] = useInsertRoomPeopleMutation({
 *   variables: {
 *      people: // value for 'people'
 *   },
 * });
 */
export function useInsertRoomPeopleMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>(InsertRoomPeopleDocument, options);
      }
export type InsertRoomPeopleMutationHookResult = ReturnType<typeof useInsertRoomPeopleMutation>;
export type InsertRoomPeopleMutationResult = Apollo.MutationResult<InsertRoomPeopleMutation>;
export type InsertRoomPeopleMutationOptions = Apollo.BaseMutationOptions<InsertRoomPeopleMutation, InsertRoomPeopleMutationVariables>;
export const InsertEventInfoDocument = gql`
    mutation InsertEventInfo($id: uuid!, $roomId: uuid!, $conferenceId: uuid!, $intendedRoomModeName: RoomMode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $contentGroupId: uuid = null, $hallwayId: uuid = null) {
  insert_Event_one(
    object: {id: $id, roomId: $roomId, conferenceId: $conferenceId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, contentGroupId: $contentGroupId, hallwayId: $hallwayId}
  ) {
    ...EventInfo
  }
}
    ${EventInfoFragmentDoc}`;
export type InsertEventInfoMutationFn = Apollo.MutationFunction<InsertEventInfoMutation, InsertEventInfoMutationVariables>;

/**
 * __useInsertEventInfoMutation__
 *
 * To run a mutation, you first call `useInsertEventInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventInfoMutation, { data, loading, error }] = useInsertEventInfoMutation({
 *   variables: {
 *      id: // value for 'id'
 *      roomId: // value for 'roomId'
 *      conferenceId: // value for 'conferenceId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      contentGroupId: // value for 'contentGroupId'
 *      hallwayId: // value for 'hallwayId'
 *   },
 * });
 */
export function useInsertEventInfoMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventInfoMutation, InsertEventInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventInfoMutation, InsertEventInfoMutationVariables>(InsertEventInfoDocument, options);
      }
export type InsertEventInfoMutationHookResult = ReturnType<typeof useInsertEventInfoMutation>;
export type InsertEventInfoMutationResult = Apollo.MutationResult<InsertEventInfoMutation>;
export type InsertEventInfoMutationOptions = Apollo.BaseMutationOptions<InsertEventInfoMutation, InsertEventInfoMutationVariables>;
export const UpdateEventInfoDocument = gql`
    mutation UpdateEventInfo($eventId: uuid!, $roomId: uuid!, $intendedRoomModeName: RoomMode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $contentGroupId: uuid = null, $hallwayId: uuid = null) {
  update_Event_by_pk(
    pk_columns: {id: $eventId}
    _set: {roomId: $roomId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, contentGroupId: $contentGroupId, hallwayId: $hallwayId}
  ) {
    ...EventInfo
  }
}
    ${EventInfoFragmentDoc}`;
export type UpdateEventInfoMutationFn = Apollo.MutationFunction<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>;

/**
 * __useUpdateEventInfoMutation__
 *
 * To run a mutation, you first call `useUpdateEventInfoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventInfoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventInfoMutation, { data, loading, error }] = useUpdateEventInfoMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      roomId: // value for 'roomId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      contentGroupId: // value for 'contentGroupId'
 *      hallwayId: // value for 'hallwayId'
 *   },
 * });
 */
export function useUpdateEventInfoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>(UpdateEventInfoDocument, options);
      }
export type UpdateEventInfoMutationHookResult = ReturnType<typeof useUpdateEventInfoMutation>;
export type UpdateEventInfoMutationResult = Apollo.MutationResult<UpdateEventInfoMutation>;
export type UpdateEventInfoMutationOptions = Apollo.BaseMutationOptions<UpdateEventInfoMutation, UpdateEventInfoMutationVariables>;
export const DeleteEventInfosDocument = gql`
    mutation DeleteEventInfos($eventIds: [uuid!]!) {
  delete_Event(where: {id: {_in: $eventIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventInfosMutationFn = Apollo.MutationFunction<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>;

/**
 * __useDeleteEventInfosMutation__
 *
 * To run a mutation, you first call `useDeleteEventInfosMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventInfosMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventInfosMutation, { data, loading, error }] = useDeleteEventInfosMutation({
 *   variables: {
 *      eventIds: // value for 'eventIds'
 *   },
 * });
 */
export function useDeleteEventInfosMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>(DeleteEventInfosDocument, options);
      }
export type DeleteEventInfosMutationHookResult = ReturnType<typeof useDeleteEventInfosMutation>;
export type DeleteEventInfosMutationResult = Apollo.MutationResult<DeleteEventInfosMutation>;
export type DeleteEventInfosMutationOptions = Apollo.BaseMutationOptions<DeleteEventInfosMutation, DeleteEventInfosMutationVariables>;
export const ManageShufflePeriods_SelectAllDocument = gql`
    query ManageShufflePeriods_SelectAll($conferenceId: uuid!) {
  room_ShufflePeriod(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ManageShufflePeriods_ShufflePeriod
  }
}
    ${ManageShufflePeriods_ShufflePeriodFragmentDoc}`;

/**
 * __useManageShufflePeriods_SelectAllQuery__
 *
 * To run a query within a React component, call `useManageShufflePeriods_SelectAllQuery` and pass it any options that fit your needs.
 * When your component renders, `useManageShufflePeriods_SelectAllQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useManageShufflePeriods_SelectAllQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useManageShufflePeriods_SelectAllQuery(baseOptions: Apollo.QueryHookOptions<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>(ManageShufflePeriods_SelectAllDocument, options);
      }
export function useManageShufflePeriods_SelectAllLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>(ManageShufflePeriods_SelectAllDocument, options);
        }
export type ManageShufflePeriods_SelectAllQueryHookResult = ReturnType<typeof useManageShufflePeriods_SelectAllQuery>;
export type ManageShufflePeriods_SelectAllLazyQueryHookResult = ReturnType<typeof useManageShufflePeriods_SelectAllLazyQuery>;
export type ManageShufflePeriods_SelectAllQueryResult = Apollo.QueryResult<ManageShufflePeriods_SelectAllQuery, ManageShufflePeriods_SelectAllQueryVariables>;
export const SendEmail_GetAllGroupsDocument = gql`
    query SendEmail_GetAllGroups($conferenceId: uuid!) {
  Group(where: {conferenceId: {_eq: $conferenceId}}) {
    id
    enabled
    name
  }
}
    `;

/**
 * __useSendEmail_GetAllGroupsQuery__
 *
 * To run a query within a React component, call `useSendEmail_GetAllGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSendEmail_GetAllGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSendEmail_GetAllGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSendEmail_GetAllGroupsQuery(baseOptions: Apollo.QueryHookOptions<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>(SendEmail_GetAllGroupsDocument, options);
      }
export function useSendEmail_GetAllGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>(SendEmail_GetAllGroupsDocument, options);
        }
export type SendEmail_GetAllGroupsQueryHookResult = ReturnType<typeof useSendEmail_GetAllGroupsQuery>;
export type SendEmail_GetAllGroupsLazyQueryHookResult = ReturnType<typeof useSendEmail_GetAllGroupsLazyQuery>;
export type SendEmail_GetAllGroupsQueryResult = Apollo.QueryResult<SendEmail_GetAllGroupsQuery, SendEmail_GetAllGroupsQueryVariables>;
export const AddEventPeople_SelectContentGroupPeopleDocument = gql`
    query AddEventPeople_SelectContentGroupPeople($contentGroupIds: [uuid!]!) {
  ContentGroupPerson(where: {groupId: {_in: $contentGroupIds}}) {
    ...AddEventPeople_ContentGroupPerson
  }
}
    ${AddEventPeople_ContentGroupPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectContentGroupPeopleQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectContentGroupPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectContentGroupPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectContentGroupPeopleQuery({
 *   variables: {
 *      contentGroupIds: // value for 'contentGroupIds'
 *   },
 * });
 */
export function useAddEventPeople_SelectContentGroupPeopleQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectContentGroupPeopleQuery, AddEventPeople_SelectContentGroupPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectContentGroupPeopleQuery, AddEventPeople_SelectContentGroupPeopleQueryVariables>(AddEventPeople_SelectContentGroupPeopleDocument, options);
      }
export function useAddEventPeople_SelectContentGroupPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectContentGroupPeopleQuery, AddEventPeople_SelectContentGroupPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectContentGroupPeopleQuery, AddEventPeople_SelectContentGroupPeopleQueryVariables>(AddEventPeople_SelectContentGroupPeopleDocument, options);
        }
export type AddEventPeople_SelectContentGroupPeopleQueryHookResult = ReturnType<typeof useAddEventPeople_SelectContentGroupPeopleQuery>;
export type AddEventPeople_SelectContentGroupPeopleLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectContentGroupPeopleLazyQuery>;
export type AddEventPeople_SelectContentGroupPeopleQueryResult = Apollo.QueryResult<AddEventPeople_SelectContentGroupPeopleQuery, AddEventPeople_SelectContentGroupPeopleQueryVariables>;
export const AddEventPeople_SelectContentPeopleDocument = gql`
    query AddEventPeople_SelectContentPeople($conferenceId: uuid!) {
  ContentPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_ContentPerson
  }
}
    ${AddEventPeople_ContentPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectContentPeopleQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectContentPeopleQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectContentPeopleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectContentPeopleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectContentPeopleQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectContentPeopleQuery, AddEventPeople_SelectContentPeopleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectContentPeopleQuery, AddEventPeople_SelectContentPeopleQueryVariables>(AddEventPeople_SelectContentPeopleDocument, options);
      }
export function useAddEventPeople_SelectContentPeopleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectContentPeopleQuery, AddEventPeople_SelectContentPeopleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectContentPeopleQuery, AddEventPeople_SelectContentPeopleQueryVariables>(AddEventPeople_SelectContentPeopleDocument, options);
        }
export type AddEventPeople_SelectContentPeopleQueryHookResult = ReturnType<typeof useAddEventPeople_SelectContentPeopleQuery>;
export type AddEventPeople_SelectContentPeopleLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectContentPeopleLazyQuery>;
export type AddEventPeople_SelectContentPeopleQueryResult = Apollo.QueryResult<AddEventPeople_SelectContentPeopleQuery, AddEventPeople_SelectContentPeopleQueryVariables>;
export const AddEventPeople_SelectAttendeesDocument = gql`
    query AddEventPeople_SelectAttendees($conferenceId: uuid!) {
  Attendee(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_Attendee
  }
}
    ${AddEventPeople_AttendeeFragmentDoc}`;

/**
 * __useAddEventPeople_SelectAttendeesQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectAttendeesQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectAttendeesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectAttendeesQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectAttendeesQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectAttendeesQuery, AddEventPeople_SelectAttendeesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectAttendeesQuery, AddEventPeople_SelectAttendeesQueryVariables>(AddEventPeople_SelectAttendeesDocument, options);
      }
export function useAddEventPeople_SelectAttendeesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectAttendeesQuery, AddEventPeople_SelectAttendeesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectAttendeesQuery, AddEventPeople_SelectAttendeesQueryVariables>(AddEventPeople_SelectAttendeesDocument, options);
        }
export type AddEventPeople_SelectAttendeesQueryHookResult = ReturnType<typeof useAddEventPeople_SelectAttendeesQuery>;
export type AddEventPeople_SelectAttendeesLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectAttendeesLazyQuery>;
export type AddEventPeople_SelectAttendeesQueryResult = Apollo.QueryResult<AddEventPeople_SelectAttendeesQuery, AddEventPeople_SelectAttendeesQueryVariables>;
export const AddEventPeople_SelectContentPeople_ByAttendeeDocument = gql`
    query AddEventPeople_SelectContentPeople_ByAttendee($attendeeIds: [uuid!]!) {
  ContentPerson(where: {attendeeId: {_in: $attendeeIds}}) {
    ...AddEventPeople_ContentPerson
  }
}
    ${AddEventPeople_ContentPersonFragmentDoc}`;

/**
 * __useAddEventPeople_SelectContentPeople_ByAttendeeQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectContentPeople_ByAttendeeQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectContentPeople_ByAttendeeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectContentPeople_ByAttendeeQuery({
 *   variables: {
 *      attendeeIds: // value for 'attendeeIds'
 *   },
 * });
 */
export function useAddEventPeople_SelectContentPeople_ByAttendeeQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectContentPeople_ByAttendeeQuery, AddEventPeople_SelectContentPeople_ByAttendeeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectContentPeople_ByAttendeeQuery, AddEventPeople_SelectContentPeople_ByAttendeeQueryVariables>(AddEventPeople_SelectContentPeople_ByAttendeeDocument, options);
      }
export function useAddEventPeople_SelectContentPeople_ByAttendeeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectContentPeople_ByAttendeeQuery, AddEventPeople_SelectContentPeople_ByAttendeeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectContentPeople_ByAttendeeQuery, AddEventPeople_SelectContentPeople_ByAttendeeQueryVariables>(AddEventPeople_SelectContentPeople_ByAttendeeDocument, options);
        }
export type AddEventPeople_SelectContentPeople_ByAttendeeQueryHookResult = ReturnType<typeof useAddEventPeople_SelectContentPeople_ByAttendeeQuery>;
export type AddEventPeople_SelectContentPeople_ByAttendeeLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectContentPeople_ByAttendeeLazyQuery>;
export type AddEventPeople_SelectContentPeople_ByAttendeeQueryResult = Apollo.QueryResult<AddEventPeople_SelectContentPeople_ByAttendeeQuery, AddEventPeople_SelectContentPeople_ByAttendeeQueryVariables>;
export const AddEventPeople_SelectGroupsDocument = gql`
    query AddEventPeople_SelectGroups($conferenceId: uuid!) {
  Group(where: {conferenceId: {_eq: $conferenceId}}) {
    ...AddEventPeople_Group
  }
}
    ${AddEventPeople_GroupFragmentDoc}`;

/**
 * __useAddEventPeople_SelectGroupsQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectGroupsQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectGroupsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectGroupsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useAddEventPeople_SelectGroupsQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>(AddEventPeople_SelectGroupsDocument, options);
      }
export function useAddEventPeople_SelectGroupsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>(AddEventPeople_SelectGroupsDocument, options);
        }
export type AddEventPeople_SelectGroupsQueryHookResult = ReturnType<typeof useAddEventPeople_SelectGroupsQuery>;
export type AddEventPeople_SelectGroupsLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectGroupsLazyQuery>;
export type AddEventPeople_SelectGroupsQueryResult = Apollo.QueryResult<AddEventPeople_SelectGroupsQuery, AddEventPeople_SelectGroupsQueryVariables>;
export const AddEventPeople_SelectAttendees_ByGroupDocument = gql`
    query AddEventPeople_SelectAttendees_ByGroup($groupId: uuid!) {
  Attendee(where: {groupAttendees: {groupId: {_eq: $groupId}}}) {
    ...AddEventPeople_Attendee
  }
}
    ${AddEventPeople_AttendeeFragmentDoc}`;

/**
 * __useAddEventPeople_SelectAttendees_ByGroupQuery__
 *
 * To run a query within a React component, call `useAddEventPeople_SelectAttendees_ByGroupQuery` and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_SelectAttendees_ByGroupQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useAddEventPeople_SelectAttendees_ByGroupQuery({
 *   variables: {
 *      groupId: // value for 'groupId'
 *   },
 * });
 */
export function useAddEventPeople_SelectAttendees_ByGroupQuery(baseOptions: Apollo.QueryHookOptions<AddEventPeople_SelectAttendees_ByGroupQuery, AddEventPeople_SelectAttendees_ByGroupQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<AddEventPeople_SelectAttendees_ByGroupQuery, AddEventPeople_SelectAttendees_ByGroupQueryVariables>(AddEventPeople_SelectAttendees_ByGroupDocument, options);
      }
export function useAddEventPeople_SelectAttendees_ByGroupLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<AddEventPeople_SelectAttendees_ByGroupQuery, AddEventPeople_SelectAttendees_ByGroupQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<AddEventPeople_SelectAttendees_ByGroupQuery, AddEventPeople_SelectAttendees_ByGroupQueryVariables>(AddEventPeople_SelectAttendees_ByGroupDocument, options);
        }
export type AddEventPeople_SelectAttendees_ByGroupQueryHookResult = ReturnType<typeof useAddEventPeople_SelectAttendees_ByGroupQuery>;
export type AddEventPeople_SelectAttendees_ByGroupLazyQueryHookResult = ReturnType<typeof useAddEventPeople_SelectAttendees_ByGroupLazyQuery>;
export type AddEventPeople_SelectAttendees_ByGroupQueryResult = Apollo.QueryResult<AddEventPeople_SelectAttendees_ByGroupQuery, AddEventPeople_SelectAttendees_ByGroupQueryVariables>;
export const AddEventPeople_InsertContentPeopleDocument = gql`
    mutation AddEventPeople_InsertContentPeople($objects: [ContentPerson_insert_input!]!) {
  insert_ContentPerson(objects: $objects) {
    returning {
      ...AddEventPeople_ContentPerson
    }
  }
}
    ${AddEventPeople_ContentPersonFragmentDoc}`;
export type AddEventPeople_InsertContentPeopleMutationFn = Apollo.MutationFunction<AddEventPeople_InsertContentPeopleMutation, AddEventPeople_InsertContentPeopleMutationVariables>;

/**
 * __useAddEventPeople_InsertContentPeopleMutation__
 *
 * To run a mutation, you first call `useAddEventPeople_InsertContentPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_InsertContentPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addEventPeopleInsertContentPeopleMutation, { data, loading, error }] = useAddEventPeople_InsertContentPeopleMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useAddEventPeople_InsertContentPeopleMutation(baseOptions?: Apollo.MutationHookOptions<AddEventPeople_InsertContentPeopleMutation, AddEventPeople_InsertContentPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddEventPeople_InsertContentPeopleMutation, AddEventPeople_InsertContentPeopleMutationVariables>(AddEventPeople_InsertContentPeopleDocument, options);
      }
export type AddEventPeople_InsertContentPeopleMutationHookResult = ReturnType<typeof useAddEventPeople_InsertContentPeopleMutation>;
export type AddEventPeople_InsertContentPeopleMutationResult = Apollo.MutationResult<AddEventPeople_InsertContentPeopleMutation>;
export type AddEventPeople_InsertContentPeopleMutationOptions = Apollo.BaseMutationOptions<AddEventPeople_InsertContentPeopleMutation, AddEventPeople_InsertContentPeopleMutationVariables>;
export const AddEventPeople_InsertEventPeopleDocument = gql`
    mutation AddEventPeople_InsertEventPeople($objects: [EventPerson_insert_input!]!) {
  insert_EventPerson(objects: $objects) {
    returning {
      ...EventPersonInfo
    }
  }
}
    ${EventPersonInfoFragmentDoc}`;
export type AddEventPeople_InsertEventPeopleMutationFn = Apollo.MutationFunction<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>;

/**
 * __useAddEventPeople_InsertEventPeopleMutation__
 *
 * To run a mutation, you first call `useAddEventPeople_InsertEventPeopleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddEventPeople_InsertEventPeopleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addEventPeopleInsertEventPeopleMutation, { data, loading, error }] = useAddEventPeople_InsertEventPeopleMutation({
 *   variables: {
 *      objects: // value for 'objects'
 *   },
 * });
 */
export function useAddEventPeople_InsertEventPeopleMutation(baseOptions?: Apollo.MutationHookOptions<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>(AddEventPeople_InsertEventPeopleDocument, options);
      }
export type AddEventPeople_InsertEventPeopleMutationHookResult = ReturnType<typeof useAddEventPeople_InsertEventPeopleMutation>;
export type AddEventPeople_InsertEventPeopleMutationResult = Apollo.MutationResult<AddEventPeople_InsertEventPeopleMutation>;
export type AddEventPeople_InsertEventPeopleMutationOptions = Apollo.BaseMutationOptions<AddEventPeople_InsertEventPeopleMutation, AddEventPeople_InsertEventPeopleMutationVariables>;
export const InsertEventPersonDocument = gql`
    mutation InsertEventPerson($newEventPerson: EventPerson_insert_input!) {
  insert_EventPerson_one(object: $newEventPerson) {
    ...EventPersonInfo
  }
}
    ${EventPersonInfoFragmentDoc}`;
export type InsertEventPersonMutationFn = Apollo.MutationFunction<InsertEventPersonMutation, InsertEventPersonMutationVariables>;

/**
 * __useInsertEventPersonMutation__
 *
 * To run a mutation, you first call `useInsertEventPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventPersonMutation, { data, loading, error }] = useInsertEventPersonMutation({
 *   variables: {
 *      newEventPerson: // value for 'newEventPerson'
 *   },
 * });
 */
export function useInsertEventPersonMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventPersonMutation, InsertEventPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventPersonMutation, InsertEventPersonMutationVariables>(InsertEventPersonDocument, options);
      }
export type InsertEventPersonMutationHookResult = ReturnType<typeof useInsertEventPersonMutation>;
export type InsertEventPersonMutationResult = Apollo.MutationResult<InsertEventPersonMutation>;
export type InsertEventPersonMutationOptions = Apollo.BaseMutationOptions<InsertEventPersonMutation, InsertEventPersonMutationVariables>;
export const DeleteEventPersonsDocument = gql`
    mutation DeleteEventPersons($deleteEventPeopleIds: [uuid!]!) {
  delete_EventPerson(where: {id: {_in: $deleteEventPeopleIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventPersonsMutationFn = Apollo.MutationFunction<DeleteEventPersonsMutation, DeleteEventPersonsMutationVariables>;

/**
 * __useDeleteEventPersonsMutation__
 *
 * To run a mutation, you first call `useDeleteEventPersonsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventPersonsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventPersonsMutation, { data, loading, error }] = useDeleteEventPersonsMutation({
 *   variables: {
 *      deleteEventPeopleIds: // value for 'deleteEventPeopleIds'
 *   },
 * });
 */
export function useDeleteEventPersonsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventPersonsMutation, DeleteEventPersonsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventPersonsMutation, DeleteEventPersonsMutationVariables>(DeleteEventPersonsDocument, options);
      }
export type DeleteEventPersonsMutationHookResult = ReturnType<typeof useDeleteEventPersonsMutation>;
export type DeleteEventPersonsMutationResult = Apollo.MutationResult<DeleteEventPersonsMutation>;
export type DeleteEventPersonsMutationOptions = Apollo.BaseMutationOptions<DeleteEventPersonsMutation, DeleteEventPersonsMutationVariables>;
export const UpdateEventPersonDocument = gql`
    mutation UpdateEventPerson($id: uuid!, $personId: uuid!, $roleName: EventPersonRole_enum!) {
  update_EventPerson_by_pk(
    pk_columns: {id: $id}
    _set: {personId: $personId, roleName: $roleName}
  ) {
    ...EventPersonInfo
  }
}
    ${EventPersonInfoFragmentDoc}`;
export type UpdateEventPersonMutationFn = Apollo.MutationFunction<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>;

/**
 * __useUpdateEventPersonMutation__
 *
 * To run a mutation, you first call `useUpdateEventPersonMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventPersonMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventPersonMutation, { data, loading, error }] = useUpdateEventPersonMutation({
 *   variables: {
 *      id: // value for 'id'
 *      personId: // value for 'personId'
 *      roleName: // value for 'roleName'
 *   },
 * });
 */
export function useUpdateEventPersonMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>(UpdateEventPersonDocument, options);
      }
export type UpdateEventPersonMutationHookResult = ReturnType<typeof useUpdateEventPersonMutation>;
export type UpdateEventPersonMutationResult = Apollo.MutationResult<UpdateEventPersonMutation>;
export type UpdateEventPersonMutationOptions = Apollo.BaseMutationOptions<UpdateEventPersonMutation, UpdateEventPersonMutationVariables>;
export const SelectWholeScheduleDocument = gql`
    query SelectWholeSchedule($conferenceId: uuid!) {
  Room(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomInfo
  }
  Event(
    where: {conferenceId: {_eq: $conferenceId}}
    order_by: {startTime: asc, endTime: asc}
  ) {
    ...EventInfo
  }
  OriginatingData(where: {conferenceId: {_eq: $conferenceId}}) {
    ...OriginatingDataInfo
  }
  Tag(where: {conferenceId: {_eq: $conferenceId}}) {
    ...TagInfo
  }
  Hallway(where: {conferenceId: {_eq: $conferenceId}}) {
    ...HallwayInfo
  }
  ContentGroup(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentGroupFullNestedInfo
  }
  ContentPerson(where: {conferenceId: {_eq: $conferenceId}}) {
    ...ContentPersonInfo
  }
}
    ${RoomInfoFragmentDoc}
${EventInfoFragmentDoc}
${OriginatingDataInfoFragmentDoc}
${TagInfoFragmentDoc}
${HallwayInfoFragmentDoc}
${ContentGroupFullNestedInfoFragmentDoc}
${ContentPersonInfoFragmentDoc}`;

/**
 * __useSelectWholeScheduleQuery__
 *
 * To run a query within a React component, call `useSelectWholeScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectWholeScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectWholeScheduleQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useSelectWholeScheduleQuery(baseOptions: Apollo.QueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, options);
      }
export function useSelectWholeScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>(SelectWholeScheduleDocument, options);
        }
export type SelectWholeScheduleQueryHookResult = ReturnType<typeof useSelectWholeScheduleQuery>;
export type SelectWholeScheduleLazyQueryHookResult = ReturnType<typeof useSelectWholeScheduleLazyQuery>;
export type SelectWholeScheduleQueryResult = Apollo.QueryResult<SelectWholeScheduleQuery, SelectWholeScheduleQueryVariables>;
export const InsertRoomsDocument = gql`
    mutation InsertRooms($newRooms: [Room_insert_input!]!) {
  insert_Room(objects: $newRooms) {
    returning {
      ...RoomInfo
    }
  }
}
    ${RoomInfoFragmentDoc}`;
export type InsertRoomsMutationFn = Apollo.MutationFunction<InsertRoomsMutation, InsertRoomsMutationVariables>;

/**
 * __useInsertRoomsMutation__
 *
 * To run a mutation, you first call `useInsertRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertRoomsMutation, { data, loading, error }] = useInsertRoomsMutation({
 *   variables: {
 *      newRooms: // value for 'newRooms'
 *   },
 * });
 */
export function useInsertRoomsMutation(baseOptions?: Apollo.MutationHookOptions<InsertRoomsMutation, InsertRoomsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertRoomsMutation, InsertRoomsMutationVariables>(InsertRoomsDocument, options);
      }
export type InsertRoomsMutationHookResult = ReturnType<typeof useInsertRoomsMutation>;
export type InsertRoomsMutationResult = Apollo.MutationResult<InsertRoomsMutation>;
export type InsertRoomsMutationOptions = Apollo.BaseMutationOptions<InsertRoomsMutation, InsertRoomsMutationVariables>;
export const DeleteRoomsDocument = gql`
    mutation DeleteRooms($deleteRoomIds: [uuid!]!) {
  delete_Room(where: {id: {_in: $deleteRoomIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteRoomsMutationFn = Apollo.MutationFunction<DeleteRoomsMutation, DeleteRoomsMutationVariables>;

/**
 * __useDeleteRoomsMutation__
 *
 * To run a mutation, you first call `useDeleteRoomsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteRoomsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteRoomsMutation, { data, loading, error }] = useDeleteRoomsMutation({
 *   variables: {
 *      deleteRoomIds: // value for 'deleteRoomIds'
 *   },
 * });
 */
export function useDeleteRoomsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteRoomsMutation, DeleteRoomsMutationVariables>(DeleteRoomsDocument, options);
      }
export type DeleteRoomsMutationHookResult = ReturnType<typeof useDeleteRoomsMutation>;
export type DeleteRoomsMutationResult = Apollo.MutationResult<DeleteRoomsMutation>;
export type DeleteRoomsMutationOptions = Apollo.BaseMutationOptions<DeleteRoomsMutation, DeleteRoomsMutationVariables>;
export const UpdateRoomDocument = gql`
    mutation UpdateRoom($id: uuid!, $name: String!, $capacity: Int = null, $originatingDataId: uuid = null, $priority: Int!) {
  update_Room_by_pk(
    pk_columns: {id: $id}
    _set: {name: $name, capacity: $capacity, originatingDataId: $originatingDataId, priority: $priority}
  ) {
    ...RoomInfo
  }
}
    ${RoomInfoFragmentDoc}`;
export type UpdateRoomMutationFn = Apollo.MutationFunction<UpdateRoomMutation, UpdateRoomMutationVariables>;

/**
 * __useUpdateRoomMutation__
 *
 * To run a mutation, you first call `useUpdateRoomMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateRoomMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateRoomMutation, { data, loading, error }] = useUpdateRoomMutation({
 *   variables: {
 *      id: // value for 'id'
 *      name: // value for 'name'
 *      capacity: // value for 'capacity'
 *      originatingDataId: // value for 'originatingDataId'
 *      priority: // value for 'priority'
 *   },
 * });
 */
export function useUpdateRoomMutation(baseOptions?: Apollo.MutationHookOptions<UpdateRoomMutation, UpdateRoomMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateRoomMutation, UpdateRoomMutationVariables>(UpdateRoomDocument, options);
      }
export type UpdateRoomMutationHookResult = ReturnType<typeof useUpdateRoomMutation>;
export type UpdateRoomMutationResult = Apollo.MutationResult<UpdateRoomMutation>;
export type UpdateRoomMutationOptions = Apollo.BaseMutationOptions<UpdateRoomMutation, UpdateRoomMutationVariables>;
export const DeleteEventsDocument = gql`
    mutation DeleteEvents($deleteEventIds: [uuid!]!) {
  delete_Event(where: {id: {_in: $deleteEventIds}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteEventsMutationFn = Apollo.MutationFunction<DeleteEventsMutation, DeleteEventsMutationVariables>;

/**
 * __useDeleteEventsMutation__
 *
 * To run a mutation, you first call `useDeleteEventsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteEventsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteEventsMutation, { data, loading, error }] = useDeleteEventsMutation({
 *   variables: {
 *      deleteEventIds: // value for 'deleteEventIds'
 *   },
 * });
 */
export function useDeleteEventsMutation(baseOptions?: Apollo.MutationHookOptions<DeleteEventsMutation, DeleteEventsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteEventsMutation, DeleteEventsMutationVariables>(DeleteEventsDocument, options);
      }
export type DeleteEventsMutationHookResult = ReturnType<typeof useDeleteEventsMutation>;
export type DeleteEventsMutationResult = Apollo.MutationResult<DeleteEventsMutation>;
export type DeleteEventsMutationOptions = Apollo.BaseMutationOptions<DeleteEventsMutation, DeleteEventsMutationVariables>;
export const InsertEventDocument = gql`
    mutation InsertEvent($newEvent: Event_insert_input!) {
  insert_Event_one(object: $newEvent) {
    ...EventInfo
  }
}
    ${EventInfoFragmentDoc}`;
export type InsertEventMutationFn = Apollo.MutationFunction<InsertEventMutation, InsertEventMutationVariables>;

/**
 * __useInsertEventMutation__
 *
 * To run a mutation, you first call `useInsertEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertEventMutation, { data, loading, error }] = useInsertEventMutation({
 *   variables: {
 *      newEvent: // value for 'newEvent'
 *   },
 * });
 */
export function useInsertEventMutation(baseOptions?: Apollo.MutationHookOptions<InsertEventMutation, InsertEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertEventMutation, InsertEventMutationVariables>(InsertEventDocument, options);
      }
export type InsertEventMutationHookResult = ReturnType<typeof useInsertEventMutation>;
export type InsertEventMutationResult = Apollo.MutationResult<InsertEventMutation>;
export type InsertEventMutationOptions = Apollo.BaseMutationOptions<InsertEventMutation, InsertEventMutationVariables>;
export const UpdateEventDocument = gql`
    mutation UpdateEvent($eventId: uuid!, $roomId: uuid!, $intendedRoomModeName: RoomMode_enum!, $originatingDataId: uuid = null, $name: String!, $startTime: timestamptz!, $durationSeconds: Int!, $contentGroupId: uuid = null, $hallwayId: uuid = null, $newEventTags: [EventTag_insert_input!]!, $deleteEventTagIds: [uuid!]!) {
  insert_EventTag(objects: $newEventTags) {
    returning {
      ...EventTagInfo
    }
  }
  update_Event_by_pk(
    pk_columns: {id: $eventId}
    _set: {roomId: $roomId, intendedRoomModeName: $intendedRoomModeName, originatingDataId: $originatingDataId, name: $name, startTime: $startTime, durationSeconds: $durationSeconds, contentGroupId: $contentGroupId, hallwayId: $hallwayId}
  ) {
    ...EventInfo
  }
  delete_EventTag(where: {tag: {id: {_in: $deleteEventTagIds}}}) {
    returning {
      id
    }
  }
}
    ${EventTagInfoFragmentDoc}
${EventInfoFragmentDoc}`;
export type UpdateEventMutationFn = Apollo.MutationFunction<UpdateEventMutation, UpdateEventMutationVariables>;

/**
 * __useUpdateEventMutation__
 *
 * To run a mutation, you first call `useUpdateEventMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateEventMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateEventMutation, { data, loading, error }] = useUpdateEventMutation({
 *   variables: {
 *      eventId: // value for 'eventId'
 *      roomId: // value for 'roomId'
 *      intendedRoomModeName: // value for 'intendedRoomModeName'
 *      originatingDataId: // value for 'originatingDataId'
 *      name: // value for 'name'
 *      startTime: // value for 'startTime'
 *      durationSeconds: // value for 'durationSeconds'
 *      contentGroupId: // value for 'contentGroupId'
 *      hallwayId: // value for 'hallwayId'
 *      newEventTags: // value for 'newEventTags'
 *      deleteEventTagIds: // value for 'deleteEventTagIds'
 *   },
 * });
 */
export function useUpdateEventMutation(baseOptions?: Apollo.MutationHookOptions<UpdateEventMutation, UpdateEventMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateEventMutation, UpdateEventMutationVariables>(UpdateEventDocument, options);
      }
export type UpdateEventMutationHookResult = ReturnType<typeof useUpdateEventMutation>;
export type UpdateEventMutationResult = Apollo.MutationResult<UpdateEventMutation>;
export type UpdateEventMutationOptions = Apollo.BaseMutationOptions<UpdateEventMutation, UpdateEventMutationVariables>;
export const UpdateShufflePeriodDocument = gql`
    mutation UpdateShufflePeriod($id: uuid!, $object: room_ShufflePeriod_set_input!) {
  update_room_ShufflePeriod_by_pk(pk_columns: {id: $id}, _set: $object) {
    id
    created_at
    updated_at
    conferenceId
    startAt
    endAt
    roomDurationMinutes
    targetAttendeesPerRoom
    maxAttendeesPerRoom
    waitRoomMaxDurationSeconds
    name
    organiserId
    algorithm
  }
}
    `;
export type UpdateShufflePeriodMutationFn = Apollo.MutationFunction<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>;

/**
 * __useUpdateShufflePeriodMutation__
 *
 * To run a mutation, you first call `useUpdateShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateShufflePeriodMutation, { data, loading, error }] = useUpdateShufflePeriodMutation({
 *   variables: {
 *      id: // value for 'id'
 *      object: // value for 'object'
 *   },
 * });
 */
export function useUpdateShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>(UpdateShufflePeriodDocument, options);
      }
export type UpdateShufflePeriodMutationHookResult = ReturnType<typeof useUpdateShufflePeriodMutation>;
export type UpdateShufflePeriodMutationResult = Apollo.MutationResult<UpdateShufflePeriodMutation>;
export type UpdateShufflePeriodMutationOptions = Apollo.BaseMutationOptions<UpdateShufflePeriodMutation, UpdateShufflePeriodMutationVariables>;
export const InsertShufflePeriodDocument = gql`
    mutation InsertShufflePeriod($object: room_ShufflePeriod_insert_input!) {
  insert_room_ShufflePeriod_one(object: $object) {
    id
    created_at
    updated_at
    conferenceId
    startAt
    endAt
    roomDurationMinutes
    targetAttendeesPerRoom
    maxAttendeesPerRoom
    waitRoomMaxDurationSeconds
    name
    organiserId
    algorithm
  }
}
    `;
export type InsertShufflePeriodMutationFn = Apollo.MutationFunction<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>;

/**
 * __useInsertShufflePeriodMutation__
 *
 * To run a mutation, you first call `useInsertShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertShufflePeriodMutation, { data, loading, error }] = useInsertShufflePeriodMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useInsertShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>(InsertShufflePeriodDocument, options);
      }
export type InsertShufflePeriodMutationHookResult = ReturnType<typeof useInsertShufflePeriodMutation>;
export type InsertShufflePeriodMutationResult = Apollo.MutationResult<InsertShufflePeriodMutation>;
export type InsertShufflePeriodMutationOptions = Apollo.BaseMutationOptions<InsertShufflePeriodMutation, InsertShufflePeriodMutationVariables>;
export const DeleteShufflePeriodDocument = gql`
    mutation DeleteShufflePeriod($id: uuid!) {
  delete_room_ShufflePeriod_by_pk(id: $id) {
    id
  }
}
    `;
export type DeleteShufflePeriodMutationFn = Apollo.MutationFunction<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>;

/**
 * __useDeleteShufflePeriodMutation__
 *
 * To run a mutation, you first call `useDeleteShufflePeriodMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteShufflePeriodMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteShufflePeriodMutation, { data, loading, error }] = useDeleteShufflePeriodMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteShufflePeriodMutation(baseOptions?: Apollo.MutationHookOptions<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>(DeleteShufflePeriodDocument, options);
      }
export type DeleteShufflePeriodMutationHookResult = ReturnType<typeof useDeleteShufflePeriodMutation>;
export type DeleteShufflePeriodMutationResult = Apollo.MutationResult<DeleteShufflePeriodMutation>;
export type DeleteShufflePeriodMutationOptions = Apollo.BaseMutationOptions<DeleteShufflePeriodMutation, DeleteShufflePeriodMutationVariables>;
export const AddSponsorContentMenu_CreateContentItemDocument = gql`
    mutation AddSponsorContentMenu_CreateContentItem($object: ContentItem_insert_input!) {
  insert_ContentItem_one(object: $object) {
    id
  }
}
    `;
export type AddSponsorContentMenu_CreateContentItemMutationFn = Apollo.MutationFunction<AddSponsorContentMenu_CreateContentItemMutation, AddSponsorContentMenu_CreateContentItemMutationVariables>;

/**
 * __useAddSponsorContentMenu_CreateContentItemMutation__
 *
 * To run a mutation, you first call `useAddSponsorContentMenu_CreateContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddSponsorContentMenu_CreateContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addSponsorContentMenuCreateContentItemMutation, { data, loading, error }] = useAddSponsorContentMenu_CreateContentItemMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useAddSponsorContentMenu_CreateContentItemMutation(baseOptions?: Apollo.MutationHookOptions<AddSponsorContentMenu_CreateContentItemMutation, AddSponsorContentMenu_CreateContentItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddSponsorContentMenu_CreateContentItemMutation, AddSponsorContentMenu_CreateContentItemMutationVariables>(AddSponsorContentMenu_CreateContentItemDocument, options);
      }
export type AddSponsorContentMenu_CreateContentItemMutationHookResult = ReturnType<typeof useAddSponsorContentMenu_CreateContentItemMutation>;
export type AddSponsorContentMenu_CreateContentItemMutationResult = Apollo.MutationResult<AddSponsorContentMenu_CreateContentItemMutation>;
export type AddSponsorContentMenu_CreateContentItemMutationOptions = Apollo.BaseMutationOptions<AddSponsorContentMenu_CreateContentItemMutation, AddSponsorContentMenu_CreateContentItemMutationVariables>;
export const EditableSponsorsTable_GetAllSponsorsDocument = gql`
    query EditableSponsorsTable_GetAllSponsors($conferenceId: uuid!) {
  ContentGroup(
    where: {contentGroupTypeName: {_eq: SPONSOR}, conferenceId: {_eq: $conferenceId}}
  ) {
    ...EditableSponsorsTable_ContentGroupInfo
  }
}
    ${EditableSponsorsTable_ContentGroupInfoFragmentDoc}`;

/**
 * __useEditableSponsorsTable_GetAllSponsorsQuery__
 *
 * To run a query within a React component, call `useEditableSponsorsTable_GetAllSponsorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_GetAllSponsorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEditableSponsorsTable_GetAllSponsorsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useEditableSponsorsTable_GetAllSponsorsQuery(baseOptions: Apollo.QueryHookOptions<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>(EditableSponsorsTable_GetAllSponsorsDocument, options);
      }
export function useEditableSponsorsTable_GetAllSponsorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>(EditableSponsorsTable_GetAllSponsorsDocument, options);
        }
export type EditableSponsorsTable_GetAllSponsorsQueryHookResult = ReturnType<typeof useEditableSponsorsTable_GetAllSponsorsQuery>;
export type EditableSponsorsTable_GetAllSponsorsLazyQueryHookResult = ReturnType<typeof useEditableSponsorsTable_GetAllSponsorsLazyQuery>;
export type EditableSponsorsTable_GetAllSponsorsQueryResult = Apollo.QueryResult<EditableSponsorsTable_GetAllSponsorsQuery, EditableSponsorsTable_GetAllSponsorsQueryVariables>;
export const EditableSponsorsTable_InsertSponsorDocument = gql`
    mutation EditableSponsorsTable_InsertSponsor($contentGroup: ContentGroup_insert_input!) {
  insert_ContentGroup_one(object: $contentGroup) {
    ...EditableSponsorsTable_ContentGroupInfo
  }
}
    ${EditableSponsorsTable_ContentGroupInfoFragmentDoc}`;
export type EditableSponsorsTable_InsertSponsorMutationFn = Apollo.MutationFunction<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>;

/**
 * __useEditableSponsorsTable_InsertSponsorMutation__
 *
 * To run a mutation, you first call `useEditableSponsorsTable_InsertSponsorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_InsertSponsorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editableSponsorsTableInsertSponsorMutation, { data, loading, error }] = useEditableSponsorsTable_InsertSponsorMutation({
 *   variables: {
 *      contentGroup: // value for 'contentGroup'
 *   },
 * });
 */
export function useEditableSponsorsTable_InsertSponsorMutation(baseOptions?: Apollo.MutationHookOptions<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>(EditableSponsorsTable_InsertSponsorDocument, options);
      }
export type EditableSponsorsTable_InsertSponsorMutationHookResult = ReturnType<typeof useEditableSponsorsTable_InsertSponsorMutation>;
export type EditableSponsorsTable_InsertSponsorMutationResult = Apollo.MutationResult<EditableSponsorsTable_InsertSponsorMutation>;
export type EditableSponsorsTable_InsertSponsorMutationOptions = Apollo.BaseMutationOptions<EditableSponsorsTable_InsertSponsorMutation, EditableSponsorsTable_InsertSponsorMutationVariables>;
export const EditableSponsorsTable_UpdateSponsorDocument = gql`
    mutation EditableSponsorsTable_UpdateSponsor($contentGroupId: uuid!, $object: ContentGroup_set_input!) {
  update_ContentGroup_by_pk(pk_columns: {id: $contentGroupId}, _set: $object) {
    id
  }
}
    `;
export type EditableSponsorsTable_UpdateSponsorMutationFn = Apollo.MutationFunction<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>;

/**
 * __useEditableSponsorsTable_UpdateSponsorMutation__
 *
 * To run a mutation, you first call `useEditableSponsorsTable_UpdateSponsorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_UpdateSponsorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editableSponsorsTableUpdateSponsorMutation, { data, loading, error }] = useEditableSponsorsTable_UpdateSponsorMutation({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *      object: // value for 'object'
 *   },
 * });
 */
export function useEditableSponsorsTable_UpdateSponsorMutation(baseOptions?: Apollo.MutationHookOptions<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>(EditableSponsorsTable_UpdateSponsorDocument, options);
      }
export type EditableSponsorsTable_UpdateSponsorMutationHookResult = ReturnType<typeof useEditableSponsorsTable_UpdateSponsorMutation>;
export type EditableSponsorsTable_UpdateSponsorMutationResult = Apollo.MutationResult<EditableSponsorsTable_UpdateSponsorMutation>;
export type EditableSponsorsTable_UpdateSponsorMutationOptions = Apollo.BaseMutationOptions<EditableSponsorsTable_UpdateSponsorMutation, EditableSponsorsTable_UpdateSponsorMutationVariables>;
export const EditableSponsorsTable_DeleteSponsorDocument = gql`
    mutation EditableSponsorsTable_DeleteSponsor($contentGroupIds: [uuid!]!) {
  delete_ContentGroup(where: {id: {_in: $contentGroupIds}}) {
    returning {
      id
    }
  }
}
    `;
export type EditableSponsorsTable_DeleteSponsorMutationFn = Apollo.MutationFunction<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>;

/**
 * __useEditableSponsorsTable_DeleteSponsorMutation__
 *
 * To run a mutation, you first call `useEditableSponsorsTable_DeleteSponsorMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditableSponsorsTable_DeleteSponsorMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editableSponsorsTableDeleteSponsorMutation, { data, loading, error }] = useEditableSponsorsTable_DeleteSponsorMutation({
 *   variables: {
 *      contentGroupIds: // value for 'contentGroupIds'
 *   },
 * });
 */
export function useEditableSponsorsTable_DeleteSponsorMutation(baseOptions?: Apollo.MutationHookOptions<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>(EditableSponsorsTable_DeleteSponsorDocument, options);
      }
export type EditableSponsorsTable_DeleteSponsorMutationHookResult = ReturnType<typeof useEditableSponsorsTable_DeleteSponsorMutation>;
export type EditableSponsorsTable_DeleteSponsorMutationResult = Apollo.MutationResult<EditableSponsorsTable_DeleteSponsorMutation>;
export type EditableSponsorsTable_DeleteSponsorMutationOptions = Apollo.BaseMutationOptions<EditableSponsorsTable_DeleteSponsorMutation, EditableSponsorsTable_DeleteSponsorMutationVariables>;
export const SponsorSecondaryEditor_GetSponsorContentItemsDocument = gql`
    query SponsorSecondaryEditor_GetSponsorContentItems($contentGroupId: uuid!) {
  ContentItem(where: {contentGroupId: {_eq: $contentGroupId}}) {
    ...SponsorSecondaryEditor_ContentItem
  }
}
    ${SponsorSecondaryEditor_ContentItemFragmentDoc}`;

/**
 * __useSponsorSecondaryEditor_GetSponsorContentItemsQuery__
 *
 * To run a query within a React component, call `useSponsorSecondaryEditor_GetSponsorContentItemsQuery` and pass it any options that fit your needs.
 * When your component renders, `useSponsorSecondaryEditor_GetSponsorContentItemsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSponsorSecondaryEditor_GetSponsorContentItemsQuery({
 *   variables: {
 *      contentGroupId: // value for 'contentGroupId'
 *   },
 * });
 */
export function useSponsorSecondaryEditor_GetSponsorContentItemsQuery(baseOptions: Apollo.QueryHookOptions<SponsorSecondaryEditor_GetSponsorContentItemsQuery, SponsorSecondaryEditor_GetSponsorContentItemsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SponsorSecondaryEditor_GetSponsorContentItemsQuery, SponsorSecondaryEditor_GetSponsorContentItemsQueryVariables>(SponsorSecondaryEditor_GetSponsorContentItemsDocument, options);
      }
export function useSponsorSecondaryEditor_GetSponsorContentItemsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SponsorSecondaryEditor_GetSponsorContentItemsQuery, SponsorSecondaryEditor_GetSponsorContentItemsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SponsorSecondaryEditor_GetSponsorContentItemsQuery, SponsorSecondaryEditor_GetSponsorContentItemsQueryVariables>(SponsorSecondaryEditor_GetSponsorContentItemsDocument, options);
        }
export type SponsorSecondaryEditor_GetSponsorContentItemsQueryHookResult = ReturnType<typeof useSponsorSecondaryEditor_GetSponsorContentItemsQuery>;
export type SponsorSecondaryEditor_GetSponsorContentItemsLazyQueryHookResult = ReturnType<typeof useSponsorSecondaryEditor_GetSponsorContentItemsLazyQuery>;
export type SponsorSecondaryEditor_GetSponsorContentItemsQueryResult = Apollo.QueryResult<SponsorSecondaryEditor_GetSponsorContentItemsQuery, SponsorSecondaryEditor_GetSponsorContentItemsQueryVariables>;
export const SponsorContentItem_DeleteContentItemDocument = gql`
    mutation SponsorContentItem_DeleteContentItem($contentItemId: uuid!) {
  delete_ContentItem_by_pk(id: $contentItemId) {
    id
  }
}
    `;
export type SponsorContentItem_DeleteContentItemMutationFn = Apollo.MutationFunction<SponsorContentItem_DeleteContentItemMutation, SponsorContentItem_DeleteContentItemMutationVariables>;

/**
 * __useSponsorContentItem_DeleteContentItemMutation__
 *
 * To run a mutation, you first call `useSponsorContentItem_DeleteContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorContentItem_DeleteContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorContentItemDeleteContentItemMutation, { data, loading, error }] = useSponsorContentItem_DeleteContentItemMutation({
 *   variables: {
 *      contentItemId: // value for 'contentItemId'
 *   },
 * });
 */
export function useSponsorContentItem_DeleteContentItemMutation(baseOptions?: Apollo.MutationHookOptions<SponsorContentItem_DeleteContentItemMutation, SponsorContentItem_DeleteContentItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorContentItem_DeleteContentItemMutation, SponsorContentItem_DeleteContentItemMutationVariables>(SponsorContentItem_DeleteContentItemDocument, options);
      }
export type SponsorContentItem_DeleteContentItemMutationHookResult = ReturnType<typeof useSponsorContentItem_DeleteContentItemMutation>;
export type SponsorContentItem_DeleteContentItemMutationResult = Apollo.MutationResult<SponsorContentItem_DeleteContentItemMutation>;
export type SponsorContentItem_DeleteContentItemMutationOptions = Apollo.BaseMutationOptions<SponsorContentItem_DeleteContentItemMutation, SponsorContentItem_DeleteContentItemMutationVariables>;
export const SponsorContentItem_SetContentItemIsHiddenDocument = gql`
    mutation SponsorContentItem_SetContentItemIsHidden($contentItemId: uuid!, $isHidden: Boolean!) {
  update_ContentItem_by_pk(
    pk_columns: {id: $contentItemId}
    _set: {isHidden: $isHidden}
  ) {
    id
  }
}
    `;
export type SponsorContentItem_SetContentItemIsHiddenMutationFn = Apollo.MutationFunction<SponsorContentItem_SetContentItemIsHiddenMutation, SponsorContentItem_SetContentItemIsHiddenMutationVariables>;

/**
 * __useSponsorContentItem_SetContentItemIsHiddenMutation__
 *
 * To run a mutation, you first call `useSponsorContentItem_SetContentItemIsHiddenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorContentItem_SetContentItemIsHiddenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorContentItemSetContentItemIsHiddenMutation, { data, loading, error }] = useSponsorContentItem_SetContentItemIsHiddenMutation({
 *   variables: {
 *      contentItemId: // value for 'contentItemId'
 *      isHidden: // value for 'isHidden'
 *   },
 * });
 */
export function useSponsorContentItem_SetContentItemIsHiddenMutation(baseOptions?: Apollo.MutationHookOptions<SponsorContentItem_SetContentItemIsHiddenMutation, SponsorContentItem_SetContentItemIsHiddenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorContentItem_SetContentItemIsHiddenMutation, SponsorContentItem_SetContentItemIsHiddenMutationVariables>(SponsorContentItem_SetContentItemIsHiddenDocument, options);
      }
export type SponsorContentItem_SetContentItemIsHiddenMutationHookResult = ReturnType<typeof useSponsorContentItem_SetContentItemIsHiddenMutation>;
export type SponsorContentItem_SetContentItemIsHiddenMutationResult = Apollo.MutationResult<SponsorContentItem_SetContentItemIsHiddenMutation>;
export type SponsorContentItem_SetContentItemIsHiddenMutationOptions = Apollo.BaseMutationOptions<SponsorContentItem_SetContentItemIsHiddenMutation, SponsorContentItem_SetContentItemIsHiddenMutationVariables>;
export const SponsorContentItemInner_UpdateContentItemDocument = gql`
    mutation SponsorContentItemInner_UpdateContentItem($contentItemId: uuid!, $contentItem: ContentItem_set_input!) {
  update_ContentItem_by_pk(pk_columns: {id: $contentItemId}, _set: $contentItem) {
    id
  }
}
    `;
export type SponsorContentItemInner_UpdateContentItemMutationFn = Apollo.MutationFunction<SponsorContentItemInner_UpdateContentItemMutation, SponsorContentItemInner_UpdateContentItemMutationVariables>;

/**
 * __useSponsorContentItemInner_UpdateContentItemMutation__
 *
 * To run a mutation, you first call `useSponsorContentItemInner_UpdateContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSponsorContentItemInner_UpdateContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sponsorContentItemInnerUpdateContentItemMutation, { data, loading, error }] = useSponsorContentItemInner_UpdateContentItemMutation({
 *   variables: {
 *      contentItemId: // value for 'contentItemId'
 *      contentItem: // value for 'contentItem'
 *   },
 * });
 */
export function useSponsorContentItemInner_UpdateContentItemMutation(baseOptions?: Apollo.MutationHookOptions<SponsorContentItemInner_UpdateContentItemMutation, SponsorContentItemInner_UpdateContentItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SponsorContentItemInner_UpdateContentItemMutation, SponsorContentItemInner_UpdateContentItemMutationVariables>(SponsorContentItemInner_UpdateContentItemDocument, options);
      }
export type SponsorContentItemInner_UpdateContentItemMutationHookResult = ReturnType<typeof useSponsorContentItemInner_UpdateContentItemMutation>;
export type SponsorContentItemInner_UpdateContentItemMutationResult = Apollo.MutationResult<SponsorContentItemInner_UpdateContentItemMutation>;
export type SponsorContentItemInner_UpdateContentItemMutationOptions = Apollo.BaseMutationOptions<SponsorContentItemInner_UpdateContentItemMutation, SponsorContentItemInner_UpdateContentItemMutationVariables>;
export const ConferenceTakenDocument = gql`
    query ConferenceTaken($name: String!, $shortName: String!, $slug: String!) {
  Conference(
    where: {_or: [{name: {_eq: $name}}, {shortName: {_eq: $shortName}}, {slug: {_eq: $slug}}]}
  ) {
    id
    name
    shortName
    slug
  }
}
    `;

/**
 * __useConferenceTakenQuery__
 *
 * To run a query within a React component, call `useConferenceTakenQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceTakenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceTakenQuery({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceTakenQuery(baseOptions: Apollo.QueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, options);
      }
export function useConferenceTakenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceTakenQuery, ConferenceTakenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceTakenQuery, ConferenceTakenQueryVariables>(ConferenceTakenDocument, options);
        }
export type ConferenceTakenQueryHookResult = ReturnType<typeof useConferenceTakenQuery>;
export type ConferenceTakenLazyQueryHookResult = ReturnType<typeof useConferenceTakenLazyQuery>;
export type ConferenceTakenQueryResult = Apollo.QueryResult<ConferenceTakenQuery, ConferenceTakenQueryVariables>;
export const CreateConferenceDocument = gql`
    mutation CreateConference($name: String!, $shortName: String!, $slug: String!, $demoCode: uuid!) {
  insert_Conference(
    objects: [{name: $name, shortName: $shortName, slug: $slug, demoCodeId: $demoCode}]
  ) {
    returning {
      id
      slug
    }
  }
  update_ConferenceDemoCode(
    where: {id: {_eq: $demoCode}}
    _set: {note: "Code has been used."}
  ) {
    affected_rows
  }
}
    `;
export type CreateConferenceMutationFn = Apollo.MutationFunction<CreateConferenceMutation, CreateConferenceMutationVariables>;

/**
 * __useCreateConferenceMutation__
 *
 * To run a mutation, you first call `useCreateConferenceMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateConferenceMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createConferenceMutation, { data, loading, error }] = useCreateConferenceMutation({
 *   variables: {
 *      name: // value for 'name'
 *      shortName: // value for 'shortName'
 *      slug: // value for 'slug'
 *      demoCode: // value for 'demoCode'
 *   },
 * });
 */
export function useCreateConferenceMutation(baseOptions?: Apollo.MutationHookOptions<CreateConferenceMutation, CreateConferenceMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateConferenceMutation, CreateConferenceMutationVariables>(CreateConferenceDocument, options);
      }
export type CreateConferenceMutationHookResult = ReturnType<typeof useCreateConferenceMutation>;
export type CreateConferenceMutationResult = Apollo.MutationResult<CreateConferenceMutation>;
export type CreateConferenceMutationOptions = Apollo.BaseMutationOptions<CreateConferenceMutation, CreateConferenceMutationVariables>;
export const CreateNewConferenceMetaStructureDocument = gql`
    mutation CreateNewConferenceMetaStructure($conferenceId: uuid!, $attendeeDisplayName: String!, $userId: String!, $abstractData: jsonb!, $contentGroupListData: jsonb!) {
  insert_Attendee(
    objects: [{displayName: $attendeeDisplayName, userId: $userId, conferenceId: $conferenceId, groupAttendees: {data: {group: {data: {conferenceId: $conferenceId, includeUnauthenticated: false, name: "Organisers", groupRoles: {data: {role: {data: {conferenceId: $conferenceId, name: "Organiser", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_NAME}, {permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_MANAGE_ROLES}, {permissionName: CONFERENCE_MANAGE_GROUPS}, {permissionName: CONFERENCE_MANAGE_CONTENT}, {permissionName: CONFERENCE_MANAGE_SCHEDULE}, {permissionName: CONFERENCE_MANAGE_SHUFFLE}]}}}}}}}}}}]
  ) {
    affected_rows
  }
  insert_Group(
    objects: [{conferenceId: $conferenceId, enabled: false, name: "Attendees", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Attendee", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Public", includeUnauthenticated: true, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Public", rolePermissions: {data: [{permissionName: CONFERENCE_VIEW}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Registrars", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Registrar", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Moderators", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Moderator", rolePermissions: {data: [{permissionName: CONFERENCE_MODERATE_ATTENDEES}, {permissionName: CONFERENCE_VIEW_ATTENDEES}, {permissionName: CONFERENCE_VIEW}]}}}}]}}, {conferenceId: $conferenceId, enabled: false, name: "Social Chairs", includeUnauthenticated: false, groupRoles: {data: [{role: {data: {conferenceId: $conferenceId, name: "Social Chair", rolePermissions: {data: [{permissionName: CONFERENCE_MANAGE_SHUFFLE}]}}}}]}}]
  ) {
    returning {
      id
      conferenceId
      name
      enabled
      groupRoles {
        id
        roleId
        groupId
        role {
          id
          name
          conferenceId
          rolePermissions {
            id
            roleId
            permissionName
          }
        }
      }
    }
  }
  insert_ContentGroup(
    objects: {conferenceId: $conferenceId, contentGroupTypeName: LANDING_PAGE, contentItems: {data: [{conferenceId: $conferenceId, contentTypeName: ABSTRACT, data: $abstractData, isHidden: false, layoutData: null, name: "Welcome text"}, {conferenceId: $conferenceId, contentTypeName: CONTENT_GROUP_LIST, data: $contentGroupListData, isHidden: false, layoutData: null, name: "Content group list"}]}, shortTitle: "Landing", title: "Landing page"}
  ) {
    returning {
      ...ContentGroupData
    }
  }
}
    ${ContentGroupDataFragmentDoc}`;
export type CreateNewConferenceMetaStructureMutationFn = Apollo.MutationFunction<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;

/**
 * __useCreateNewConferenceMetaStructureMutation__
 *
 * To run a mutation, you first call `useCreateNewConferenceMetaStructureMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateNewConferenceMetaStructureMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createNewConferenceMetaStructureMutation, { data, loading, error }] = useCreateNewConferenceMetaStructureMutation({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      attendeeDisplayName: // value for 'attendeeDisplayName'
 *      userId: // value for 'userId'
 *      abstractData: // value for 'abstractData'
 *      contentGroupListData: // value for 'contentGroupListData'
 *   },
 * });
 */
export function useCreateNewConferenceMetaStructureMutation(baseOptions?: Apollo.MutationHookOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>(CreateNewConferenceMetaStructureDocument, options);
      }
export type CreateNewConferenceMetaStructureMutationHookResult = ReturnType<typeof useCreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationResult = Apollo.MutationResult<CreateNewConferenceMetaStructureMutation>;
export type CreateNewConferenceMetaStructureMutationOptions = Apollo.BaseMutationOptions<CreateNewConferenceMetaStructureMutation, CreateNewConferenceMetaStructureMutationVariables>;
export const ConferenceBySlug_WithUserDocument = gql`
    query ConferenceBySlug_WithUser($slug: String!, $userId: String!) {
  Conference(where: {slug: {_eq: $slug}}) {
    ...PublicConferenceInfo
    ...AuthdConferenceInfo
  }
}
    ${PublicConferenceInfoFragmentDoc}
${AuthdConferenceInfoFragmentDoc}`;

/**
 * __useConferenceBySlug_WithUserQuery__
 *
 * To run a query within a React component, call `useConferenceBySlug_WithUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceBySlug_WithUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceBySlug_WithUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useConferenceBySlug_WithUserQuery(baseOptions: Apollo.QueryHookOptions<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>(ConferenceBySlug_WithUserDocument, options);
      }
export function useConferenceBySlug_WithUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>(ConferenceBySlug_WithUserDocument, options);
        }
export type ConferenceBySlug_WithUserQueryHookResult = ReturnType<typeof useConferenceBySlug_WithUserQuery>;
export type ConferenceBySlug_WithUserLazyQueryHookResult = ReturnType<typeof useConferenceBySlug_WithUserLazyQuery>;
export type ConferenceBySlug_WithUserQueryResult = Apollo.QueryResult<ConferenceBySlug_WithUserQuery, ConferenceBySlug_WithUserQueryVariables>;
export const ConferenceBySlug_WithoutUserDocument = gql`
    query ConferenceBySlug_WithoutUser($slug: String!) {
  Conference(where: {slug: {_eq: $slug}}) {
    ...PublicConferenceInfo
  }
}
    ${PublicConferenceInfoFragmentDoc}`;

/**
 * __useConferenceBySlug_WithoutUserQuery__
 *
 * To run a query within a React component, call `useConferenceBySlug_WithoutUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useConferenceBySlug_WithoutUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useConferenceBySlug_WithoutUserQuery({
 *   variables: {
 *      slug: // value for 'slug'
 *   },
 * });
 */
export function useConferenceBySlug_WithoutUserQuery(baseOptions: Apollo.QueryHookOptions<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>(ConferenceBySlug_WithoutUserDocument, options);
      }
export function useConferenceBySlug_WithoutUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>(ConferenceBySlug_WithoutUserDocument, options);
        }
export type ConferenceBySlug_WithoutUserQueryHookResult = ReturnType<typeof useConferenceBySlug_WithoutUserQuery>;
export type ConferenceBySlug_WithoutUserLazyQueryHookResult = ReturnType<typeof useConferenceBySlug_WithoutUserLazyQuery>;
export type ConferenceBySlug_WithoutUserQueryResult = Apollo.QueryResult<ConferenceBySlug_WithoutUserQuery, ConferenceBySlug_WithoutUserQueryVariables>;
export const UpdateSubtitlesDocument = gql`
    mutation UpdateSubtitles($contentItemId: String!, $magicToken: String!, $subtitleText: String!) {
  updateSubtitles(
    contentItemId: $contentItemId
    magicToken: $magicToken
    subtitleText: $subtitleText
  ) {
    message
    success
  }
}
    `;
export type UpdateSubtitlesMutationFn = Apollo.MutationFunction<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;

/**
 * __useUpdateSubtitlesMutation__
 *
 * To run a mutation, you first call `useUpdateSubtitlesMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateSubtitlesMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateSubtitlesMutation, { data, loading, error }] = useUpdateSubtitlesMutation({
 *   variables: {
 *      contentItemId: // value for 'contentItemId'
 *      magicToken: // value for 'magicToken'
 *      subtitleText: // value for 'subtitleText'
 *   },
 * });
 */
export function useUpdateSubtitlesMutation(baseOptions?: Apollo.MutationHookOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>(UpdateSubtitlesDocument, options);
      }
export type UpdateSubtitlesMutationHookResult = ReturnType<typeof useUpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationResult = Apollo.MutationResult<UpdateSubtitlesMutation>;
export type UpdateSubtitlesMutationOptions = Apollo.BaseMutationOptions<UpdateSubtitlesMutation, UpdateSubtitlesMutationVariables>;
export const GetContentItemDocument = gql`
    query GetContentItem($magicToken: String!) {
  getContentItem(magicToken: $magicToken) {
    contentTypeName
    data
    layoutData
    name
    id
    contentGroupTitle
  }
}
    `;

/**
 * __useGetContentItemQuery__
 *
 * To run a query within a React component, call `useGetContentItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetContentItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetContentItemQuery({
 *   variables: {
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useGetContentItemQuery(baseOptions: Apollo.QueryHookOptions<GetContentItemQuery, GetContentItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetContentItemQuery, GetContentItemQueryVariables>(GetContentItemDocument, options);
      }
export function useGetContentItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetContentItemQuery, GetContentItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetContentItemQuery, GetContentItemQueryVariables>(GetContentItemDocument, options);
        }
export type GetContentItemQueryHookResult = ReturnType<typeof useGetContentItemQuery>;
export type GetContentItemLazyQueryHookResult = ReturnType<typeof useGetContentItemLazyQuery>;
export type GetContentItemQueryResult = Apollo.QueryResult<GetContentItemQuery, GetContentItemQueryVariables>;
export const SelectRequiredItemDocument = gql`
    query SelectRequiredItem($requiredContentItemId: uuid!) {
  RequiredContentItem(where: {id: {_eq: $requiredContentItemId}}) {
    ...RequiredItemFields
  }
}
    ${RequiredItemFieldsFragmentDoc}`;

/**
 * __useSelectRequiredItemQuery__
 *
 * To run a query within a React component, call `useSelectRequiredItemQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectRequiredItemQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectRequiredItemQuery({
 *   variables: {
 *      requiredContentItemId: // value for 'requiredContentItemId'
 *   },
 * });
 */
export function useSelectRequiredItemQuery(baseOptions: Apollo.QueryHookOptions<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>(SelectRequiredItemDocument, options);
      }
export function useSelectRequiredItemLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>(SelectRequiredItemDocument, options);
        }
export type SelectRequiredItemQueryHookResult = ReturnType<typeof useSelectRequiredItemQuery>;
export type SelectRequiredItemLazyQueryHookResult = ReturnType<typeof useSelectRequiredItemLazyQuery>;
export type SelectRequiredItemQueryResult = Apollo.QueryResult<SelectRequiredItemQuery, SelectRequiredItemQueryVariables>;
export const SubmitContentItemDocument = gql`
    mutation SubmitContentItem($contentItemData: jsonb!, $magicToken: String!) {
  submitContentItem(data: $contentItemData, magicToken: $magicToken) {
    message
    success
  }
}
    `;
export type SubmitContentItemMutationFn = Apollo.MutationFunction<SubmitContentItemMutation, SubmitContentItemMutationVariables>;

/**
 * __useSubmitContentItemMutation__
 *
 * To run a mutation, you first call `useSubmitContentItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSubmitContentItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [submitContentItemMutation, { data, loading, error }] = useSubmitContentItemMutation({
 *   variables: {
 *      contentItemData: // value for 'contentItemData'
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useSubmitContentItemMutation(baseOptions?: Apollo.MutationHookOptions<SubmitContentItemMutation, SubmitContentItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SubmitContentItemMutation, SubmitContentItemMutationVariables>(SubmitContentItemDocument, options);
      }
export type SubmitContentItemMutationHookResult = ReturnType<typeof useSubmitContentItemMutation>;
export type SubmitContentItemMutationResult = Apollo.MutationResult<SubmitContentItemMutation>;
export type SubmitContentItemMutationOptions = Apollo.BaseMutationOptions<SubmitContentItemMutation, SubmitContentItemMutationVariables>;
export const GetUploadAgreementDocument = gql`
    query GetUploadAgreement($magicToken: String!) {
  getUploadAgreement(magicToken: $magicToken) {
    agreementText
  }
}
    `;

/**
 * __useGetUploadAgreementQuery__
 *
 * To run a query within a React component, call `useGetUploadAgreementQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUploadAgreementQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUploadAgreementQuery({
 *   variables: {
 *      magicToken: // value for 'magicToken'
 *   },
 * });
 */
export function useGetUploadAgreementQuery(baseOptions: Apollo.QueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, options);
      }
export function useGetUploadAgreementLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>(GetUploadAgreementDocument, options);
        }
export type GetUploadAgreementQueryHookResult = ReturnType<typeof useGetUploadAgreementQuery>;
export type GetUploadAgreementLazyQueryHookResult = ReturnType<typeof useGetUploadAgreementLazyQuery>;
export type GetUploadAgreementQueryResult = Apollo.QueryResult<GetUploadAgreementQuery, GetUploadAgreementQueryVariables>;
export const EchoDocument = gql`
    query Echo($message: String!) {
  echo(message: $message) {
    message
  }
}
    `;

/**
 * __useEchoQuery__
 *
 * To run a query within a React component, call `useEchoQuery` and pass it any options that fit your needs.
 * When your component renders, `useEchoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useEchoQuery({
 *   variables: {
 *      message: // value for 'message'
 *   },
 * });
 */
export function useEchoQuery(baseOptions: Apollo.QueryHookOptions<EchoQuery, EchoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<EchoQuery, EchoQueryVariables>(EchoDocument, options);
      }
export function useEchoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<EchoQuery, EchoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<EchoQuery, EchoQueryVariables>(EchoDocument, options);
        }
export type EchoQueryHookResult = ReturnType<typeof useEchoQuery>;
export type EchoLazyQueryHookResult = ReturnType<typeof useEchoLazyQuery>;
export type EchoQueryResult = Apollo.QueryResult<EchoQuery, EchoQueryVariables>;
export const ProtectedEchoDocument = gql`
    query ProtectedEcho($message: String!) {
  protectedEcho(message: $message) {
    message
  }
}
    `;

/**
 * __useProtectedEchoQuery__
 *
 * To run a query within a React component, call `useProtectedEchoQuery` and pass it any options that fit your needs.
 * When your component renders, `useProtectedEchoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useProtectedEchoQuery({
 *   variables: {
 *      message: // value for 'message'
 *   },
 * });
 */
export function useProtectedEchoQuery(baseOptions: Apollo.QueryHookOptions<ProtectedEchoQuery, ProtectedEchoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ProtectedEchoQuery, ProtectedEchoQueryVariables>(ProtectedEchoDocument, options);
      }
export function useProtectedEchoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ProtectedEchoQuery, ProtectedEchoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ProtectedEchoQuery, ProtectedEchoQueryVariables>(ProtectedEchoDocument, options);
        }
export type ProtectedEchoQueryHookResult = ReturnType<typeof useProtectedEchoQuery>;
export type ProtectedEchoLazyQueryHookResult = ReturnType<typeof useProtectedEchoLazyQuery>;
export type ProtectedEchoQueryResult = Apollo.QueryResult<ProtectedEchoQuery, ProtectedEchoQueryVariables>;
export const GetForceUserRefreshConfigDocument = gql`
    query GetForceUserRefreshConfig($conferenceId: uuid!) {
  ConferenceConfiguration(
    where: {conferenceId: {_eq: $conferenceId}, key: {_eq: "CLOWDR_APP_VERSION"}}
  ) {
    id
    conferenceId
    key
    value
  }
}
    `;

/**
 * __useGetForceUserRefreshConfigQuery__
 *
 * To run a query within a React component, call `useGetForceUserRefreshConfigQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetForceUserRefreshConfigQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetForceUserRefreshConfigQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetForceUserRefreshConfigQuery(baseOptions: Apollo.QueryHookOptions<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>(GetForceUserRefreshConfigDocument, options);
      }
export function useGetForceUserRefreshConfigLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>(GetForceUserRefreshConfigDocument, options);
        }
export type GetForceUserRefreshConfigQueryHookResult = ReturnType<typeof useGetForceUserRefreshConfigQuery>;
export type GetForceUserRefreshConfigLazyQueryHookResult = ReturnType<typeof useGetForceUserRefreshConfigLazyQuery>;
export type GetForceUserRefreshConfigQueryResult = Apollo.QueryResult<GetForceUserRefreshConfigQuery, GetForceUserRefreshConfigQueryVariables>;
export const GoogleOAuth_SubmitGoogleOAuthCodeDocument = gql`
    mutation GoogleOAuth_SubmitGoogleOAuthCode($code: String!, $state: String!) {
  submitGoogleOAuthCode(code: $code, state: $state) {
    message
    success
  }
}
    `;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationFn = Apollo.MutationFunction<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>;

/**
 * __useGoogleOAuth_SubmitGoogleOAuthCodeMutation__
 *
 * To run a mutation, you first call `useGoogleOAuth_SubmitGoogleOAuthCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useGoogleOAuth_SubmitGoogleOAuthCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [googleOAuthSubmitGoogleOAuthCodeMutation, { data, loading, error }] = useGoogleOAuth_SubmitGoogleOAuthCodeMutation({
 *   variables: {
 *      code: // value for 'code'
 *      state: // value for 'state'
 *   },
 * });
 */
export function useGoogleOAuth_SubmitGoogleOAuthCodeMutation(baseOptions?: Apollo.MutationHookOptions<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>(GoogleOAuth_SubmitGoogleOAuthCodeDocument, options);
      }
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationHookResult = ReturnType<typeof useGoogleOAuth_SubmitGoogleOAuthCodeMutation>;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationResult = Apollo.MutationResult<GoogleOAuth_SubmitGoogleOAuthCodeMutation>;
export type GoogleOAuth_SubmitGoogleOAuthCodeMutationOptions = Apollo.BaseMutationOptions<GoogleOAuth_SubmitGoogleOAuthCodeMutation, GoogleOAuth_SubmitGoogleOAuthCodeMutationVariables>;
export const SelectInvitationForAcceptDocument = gql`
    query SelectInvitationForAccept($inviteCode: uuid!) {
  Invitation(where: {inviteCode: {_eq: $inviteCode}}) {
    id
    invitedEmailAddress
  }
}
    `;

/**
 * __useSelectInvitationForAcceptQuery__
 *
 * To run a query within a React component, call `useSelectInvitationForAcceptQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectInvitationForAcceptQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectInvitationForAcceptQuery({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSelectInvitationForAcceptQuery(baseOptions: Apollo.QueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, options);
      }
export function useSelectInvitationForAcceptLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>(SelectInvitationForAcceptDocument, options);
        }
export type SelectInvitationForAcceptQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptQuery>;
export type SelectInvitationForAcceptLazyQueryHookResult = ReturnType<typeof useSelectInvitationForAcceptLazyQuery>;
export type SelectInvitationForAcceptQueryResult = Apollo.QueryResult<SelectInvitationForAcceptQuery, SelectInvitationForAcceptQueryVariables>;
export const Invitation_ConfirmCurrentDocument = gql`
    mutation Invitation_ConfirmCurrent($inviteCode: uuid!) {
  invitationConfirmCurrent(inviteCode: $inviteCode) {
    confSlug
    ok
  }
}
    `;
export type Invitation_ConfirmCurrentMutationFn = Apollo.MutationFunction<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;

/**
 * __useInvitation_ConfirmCurrentMutation__
 *
 * To run a mutation, you first call `useInvitation_ConfirmCurrentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvitation_ConfirmCurrentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invitationConfirmCurrentMutation, { data, loading, error }] = useInvitation_ConfirmCurrentMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useInvitation_ConfirmCurrentMutation(baseOptions?: Apollo.MutationHookOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>(Invitation_ConfirmCurrentDocument, options);
      }
export type Invitation_ConfirmCurrentMutationHookResult = ReturnType<typeof useInvitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationResult = Apollo.MutationResult<Invitation_ConfirmCurrentMutation>;
export type Invitation_ConfirmCurrentMutationOptions = Apollo.BaseMutationOptions<Invitation_ConfirmCurrentMutation, Invitation_ConfirmCurrentMutationVariables>;
export const Invitation_ConfirmWithCodeDocument = gql`
    mutation Invitation_ConfirmWithCode($inviteCode: uuid!, $confirmationCode: String!) {
  invitationConfirmWithCode(
    inviteInput: {inviteCode: $inviteCode, confirmationCode: $confirmationCode}
  ) {
    confSlug
    ok
  }
}
    `;
export type Invitation_ConfirmWithCodeMutationFn = Apollo.MutationFunction<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>;

/**
 * __useInvitation_ConfirmWithCodeMutation__
 *
 * To run a mutation, you first call `useInvitation_ConfirmWithCodeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInvitation_ConfirmWithCodeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [invitationConfirmWithCodeMutation, { data, loading, error }] = useInvitation_ConfirmWithCodeMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *      confirmationCode: // value for 'confirmationCode'
 *   },
 * });
 */
export function useInvitation_ConfirmWithCodeMutation(baseOptions?: Apollo.MutationHookOptions<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>(Invitation_ConfirmWithCodeDocument, options);
      }
export type Invitation_ConfirmWithCodeMutationHookResult = ReturnType<typeof useInvitation_ConfirmWithCodeMutation>;
export type Invitation_ConfirmWithCodeMutationResult = Apollo.MutationResult<Invitation_ConfirmWithCodeMutation>;
export type Invitation_ConfirmWithCodeMutationOptions = Apollo.BaseMutationOptions<Invitation_ConfirmWithCodeMutation, Invitation_ConfirmWithCodeMutationVariables>;
export const SendInitialConfirmationEmailDocument = gql`
    mutation SendInitialConfirmationEmail($inviteCode: uuid!) {
  invitationConfirmSendInitialEmail(inviteInput: {inviteCode: $inviteCode}) {
    sent
  }
}
    `;
export type SendInitialConfirmationEmailMutationFn = Apollo.MutationFunction<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>;

/**
 * __useSendInitialConfirmationEmailMutation__
 *
 * To run a mutation, you first call `useSendInitialConfirmationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendInitialConfirmationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendInitialConfirmationEmailMutation, { data, loading, error }] = useSendInitialConfirmationEmailMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSendInitialConfirmationEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>(SendInitialConfirmationEmailDocument, options);
      }
export type SendInitialConfirmationEmailMutationHookResult = ReturnType<typeof useSendInitialConfirmationEmailMutation>;
export type SendInitialConfirmationEmailMutationResult = Apollo.MutationResult<SendInitialConfirmationEmailMutation>;
export type SendInitialConfirmationEmailMutationOptions = Apollo.BaseMutationOptions<SendInitialConfirmationEmailMutation, SendInitialConfirmationEmailMutationVariables>;
export const SendRepeatConfirmationEmailDocument = gql`
    mutation SendRepeatConfirmationEmail($inviteCode: uuid!) {
  invitationConfirmSendRepeatEmail(inviteInput: {inviteCode: $inviteCode}) {
    sent
  }
}
    `;
export type SendRepeatConfirmationEmailMutationFn = Apollo.MutationFunction<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>;

/**
 * __useSendRepeatConfirmationEmailMutation__
 *
 * To run a mutation, you first call `useSendRepeatConfirmationEmailMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSendRepeatConfirmationEmailMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [sendRepeatConfirmationEmailMutation, { data, loading, error }] = useSendRepeatConfirmationEmailMutation({
 *   variables: {
 *      inviteCode: // value for 'inviteCode'
 *   },
 * });
 */
export function useSendRepeatConfirmationEmailMutation(baseOptions?: Apollo.MutationHookOptions<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>(SendRepeatConfirmationEmailDocument, options);
      }
export type SendRepeatConfirmationEmailMutationHookResult = ReturnType<typeof useSendRepeatConfirmationEmailMutation>;
export type SendRepeatConfirmationEmailMutationResult = Apollo.MutationResult<SendRepeatConfirmationEmailMutation>;
export type SendRepeatConfirmationEmailMutationOptions = Apollo.BaseMutationOptions<SendRepeatConfirmationEmailMutation, SendRepeatConfirmationEmailMutationVariables>;
export const MenuScheduleDocument = gql`
    query MenuSchedule($now: timestamptz!, $inOneHour: timestamptz!, $conferenceId: uuid!) {
  Event(
    where: {startTime: {_lte: $inOneHour}, endTime: {_gte: $now}, conferenceId: {_eq: $conferenceId}, room: {}}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuScheduleQuery__
 *
 * To run a query within a React component, call `useMenuScheduleQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuScheduleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuScheduleQuery({
 *   variables: {
 *      now: // value for 'now'
 *      inOneHour: // value for 'inOneHour'
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMenuScheduleQuery(baseOptions: Apollo.QueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, options);
      }
export function useMenuScheduleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuScheduleQuery, MenuScheduleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MenuScheduleQuery, MenuScheduleQueryVariables>(MenuScheduleDocument, options);
        }
export type MenuScheduleQueryHookResult = ReturnType<typeof useMenuScheduleQuery>;
export type MenuScheduleLazyQueryHookResult = ReturnType<typeof useMenuScheduleLazyQuery>;
export type MenuScheduleQueryResult = Apollo.QueryResult<MenuScheduleQuery, MenuScheduleQueryVariables>;
export const MenuSchedule_SearchEventsDocument = gql`
    query MenuSchedule_SearchEvents($conferenceId: uuid!, $search: String!) {
  Event(
    where: {conferenceId: {_eq: $conferenceId}, room: {}, _or: [{name: {_ilike: $search}}, {contentGroup: {_or: [{title: {_ilike: $search}}, {people: {person: {_or: [{name: {_ilike: $search}}, {affiliation: {_ilike: $search}}]}}}]}}, {eventPeople: {person: {_or: [{name: {_ilike: $search}}, {affiliation: {_ilike: $search}}]}}}, {eventTags: {tag: {name: {_ilike: $search}}}}]}
    limit: 10
    order_by: {startTime: asc}
  ) {
    ...MenuSchedule_Event
  }
}
    ${MenuSchedule_EventFragmentDoc}`;

/**
 * __useMenuSchedule_SearchEventsQuery__
 *
 * To run a query within a React component, call `useMenuSchedule_SearchEventsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMenuSchedule_SearchEventsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMenuSchedule_SearchEventsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      search: // value for 'search'
 *   },
 * });
 */
export function useMenuSchedule_SearchEventsQuery(baseOptions: Apollo.QueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, options);
      }
export function useMenuSchedule_SearchEventsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>(MenuSchedule_SearchEventsDocument, options);
        }
export type MenuSchedule_SearchEventsQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsQuery>;
export type MenuSchedule_SearchEventsLazyQueryHookResult = ReturnType<typeof useMenuSchedule_SearchEventsLazyQuery>;
export type MenuSchedule_SearchEventsQueryResult = Apollo.QueryResult<MenuSchedule_SearchEventsQuery, MenuSchedule_SearchEventsQueryVariables>;
export const MainMenuSponsors_GetSponsorsDocument = gql`
    query MainMenuSponsors_GetSponsors($conferenceId: uuid!) {
  ContentGroup(
    where: {conferenceId: {_eq: $conferenceId}, contentGroupTypeName: {_eq: SPONSOR}}
    order_by: {title: asc}
  ) {
    ...MainMenuSponsors_ContentGroupData
  }
}
    ${MainMenuSponsors_ContentGroupDataFragmentDoc}`;

/**
 * __useMainMenuSponsors_GetSponsorsQuery__
 *
 * To run a query within a React component, call `useMainMenuSponsors_GetSponsorsQuery` and pass it any options that fit your needs.
 * When your component renders, `useMainMenuSponsors_GetSponsorsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMainMenuSponsors_GetSponsorsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useMainMenuSponsors_GetSponsorsQuery(baseOptions: Apollo.QueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, options);
      }
export function useMainMenuSponsors_GetSponsorsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>(MainMenuSponsors_GetSponsorsDocument, options);
        }
export type MainMenuSponsors_GetSponsorsQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsQuery>;
export type MainMenuSponsors_GetSponsorsLazyQueryHookResult = ReturnType<typeof useMainMenuSponsors_GetSponsorsLazyQuery>;
export type MainMenuSponsors_GetSponsorsQueryResult = Apollo.QueryResult<MainMenuSponsors_GetSponsorsQuery, MainMenuSponsors_GetSponsorsQueryVariables>;
export const GetRoomChatIdDocument = gql`
    query GetRoomChatId($roomId: uuid!) {
  Room_by_pk(id: $roomId) {
    id
    chatId
    name
  }
}
    `;

/**
 * __useGetRoomChatIdQuery__
 *
 * To run a query within a React component, call `useGetRoomChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomChatIdQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomChatIdQuery(baseOptions: Apollo.QueryHookOptions<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>(GetRoomChatIdDocument, options);
      }
export function useGetRoomChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>(GetRoomChatIdDocument, options);
        }
export type GetRoomChatIdQueryHookResult = ReturnType<typeof useGetRoomChatIdQuery>;
export type GetRoomChatIdLazyQueryHookResult = ReturnType<typeof useGetRoomChatIdLazyQuery>;
export type GetRoomChatIdQueryResult = Apollo.QueryResult<GetRoomChatIdQuery, GetRoomChatIdQueryVariables>;
export const GetContentGroupChatIdDocument = gql`
    query GetContentGroupChatId($itemId: uuid!) {
  ContentGroup_by_pk(id: $itemId) {
    id
    title
    chatId
  }
}
    `;

/**
 * __useGetContentGroupChatIdQuery__
 *
 * To run a query within a React component, call `useGetContentGroupChatIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetContentGroupChatIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetContentGroupChatIdQuery({
 *   variables: {
 *      itemId: // value for 'itemId'
 *   },
 * });
 */
export function useGetContentGroupChatIdQuery(baseOptions: Apollo.QueryHookOptions<GetContentGroupChatIdQuery, GetContentGroupChatIdQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetContentGroupChatIdQuery, GetContentGroupChatIdQueryVariables>(GetContentGroupChatIdDocument, options);
      }
export function useGetContentGroupChatIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetContentGroupChatIdQuery, GetContentGroupChatIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetContentGroupChatIdQuery, GetContentGroupChatIdQueryVariables>(GetContentGroupChatIdDocument, options);
        }
export type GetContentGroupChatIdQueryHookResult = ReturnType<typeof useGetContentGroupChatIdQuery>;
export type GetContentGroupChatIdLazyQueryHookResult = ReturnType<typeof useGetContentGroupChatIdLazyQuery>;
export type GetContentGroupChatIdQueryResult = Apollo.QueryResult<GetContentGroupChatIdQuery, GetContentGroupChatIdQueryVariables>;
export const GetVapidPublicKeyDocument = gql`
    query GetVAPIDPublicKey {
  vapidPublicKey {
    key
  }
}
    `;

/**
 * __useGetVapidPublicKeyQuery__
 *
 * To run a query within a React component, call `useGetVapidPublicKeyQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetVapidPublicKeyQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetVapidPublicKeyQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetVapidPublicKeyQuery(baseOptions?: Apollo.QueryHookOptions<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>(GetVapidPublicKeyDocument, options);
      }
export function useGetVapidPublicKeyLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>(GetVapidPublicKeyDocument, options);
        }
export type GetVapidPublicKeyQueryHookResult = ReturnType<typeof useGetVapidPublicKeyQuery>;
export type GetVapidPublicKeyLazyQueryHookResult = ReturnType<typeof useGetVapidPublicKeyLazyQuery>;
export type GetVapidPublicKeyQueryResult = Apollo.QueryResult<GetVapidPublicKeyQuery, GetVapidPublicKeyQueryVariables>;
export const UpsertPushNotificationSubscriptionDocument = gql`
    mutation UpsertPushNotificationSubscription($object: PushNotificationSubscription_insert_input!) {
  insert_PushNotificationSubscription_one(
    object: $object
    on_conflict: {constraint: PushNotificationSubscription_pkey, update_columns: [auth, endpoint, p256dh]}
  ) {
    endpoint
  }
}
    `;
export type UpsertPushNotificationSubscriptionMutationFn = Apollo.MutationFunction<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>;

/**
 * __useUpsertPushNotificationSubscriptionMutation__
 *
 * To run a mutation, you first call `useUpsertPushNotificationSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpsertPushNotificationSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [upsertPushNotificationSubscriptionMutation, { data, loading, error }] = useUpsertPushNotificationSubscriptionMutation({
 *   variables: {
 *      object: // value for 'object'
 *   },
 * });
 */
export function useUpsertPushNotificationSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>(UpsertPushNotificationSubscriptionDocument, options);
      }
export type UpsertPushNotificationSubscriptionMutationHookResult = ReturnType<typeof useUpsertPushNotificationSubscriptionMutation>;
export type UpsertPushNotificationSubscriptionMutationResult = Apollo.MutationResult<UpsertPushNotificationSubscriptionMutation>;
export type UpsertPushNotificationSubscriptionMutationOptions = Apollo.BaseMutationOptions<UpsertPushNotificationSubscriptionMutation, UpsertPushNotificationSubscriptionMutationVariables>;
export const DeletePushNotificationSubscriptionDocument = gql`
    mutation DeletePushNotificationSubscription($endpoint: String!) {
  delete_PushNotificationSubscription(where: {endpoint: {_eq: $endpoint}}) {
    affected_rows
  }
}
    `;
export type DeletePushNotificationSubscriptionMutationFn = Apollo.MutationFunction<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>;

/**
 * __useDeletePushNotificationSubscriptionMutation__
 *
 * To run a mutation, you first call `useDeletePushNotificationSubscriptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePushNotificationSubscriptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePushNotificationSubscriptionMutation, { data, loading, error }] = useDeletePushNotificationSubscriptionMutation({
 *   variables: {
 *      endpoint: // value for 'endpoint'
 *   },
 * });
 */
export function useDeletePushNotificationSubscriptionMutation(baseOptions?: Apollo.MutationHookOptions<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>(DeletePushNotificationSubscriptionDocument, options);
      }
export type DeletePushNotificationSubscriptionMutationHookResult = ReturnType<typeof useDeletePushNotificationSubscriptionMutation>;
export type DeletePushNotificationSubscriptionMutationResult = Apollo.MutationResult<DeletePushNotificationSubscriptionMutation>;
export type DeletePushNotificationSubscriptionMutationOptions = Apollo.BaseMutationOptions<DeletePushNotificationSubscriptionMutation, DeletePushNotificationSubscriptionMutationVariables>;
export const GetRoomMembersDocument = gql`
    query GetRoomMembers($roomId: uuid!) {
  RoomPerson(where: {roomId: {_eq: $roomId}}) {
    ...RoomMember
  }
}
    ${RoomMemberFragmentDoc}`;

/**
 * __useGetRoomMembersQuery__
 *
 * To run a query within a React component, call `useGetRoomMembersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomMembersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomMembersQuery({
 *   variables: {
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomMembersQuery(baseOptions: Apollo.QueryHookOptions<GetRoomMembersQuery, GetRoomMembersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetRoomMembersQuery, GetRoomMembersQueryVariables>(GetRoomMembersDocument, options);
      }
export function useGetRoomMembersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetRoomMembersQuery, GetRoomMembersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetRoomMembersQuery, GetRoomMembersQueryVariables>(GetRoomMembersDocument, options);
        }
export type GetRoomMembersQueryHookResult = ReturnType<typeof useGetRoomMembersQuery>;
export type GetRoomMembersLazyQueryHookResult = ReturnType<typeof useGetRoomMembersLazyQuery>;
export type GetRoomMembersQueryResult = Apollo.QueryResult<GetRoomMembersQuery, GetRoomMembersQueryVariables>;
export const GetRoomParticipantsDocument = gql`
    subscription GetRoomParticipants($conferenceId: uuid!, $roomId: uuid!) {
  RoomParticipant(
    where: {conferenceId: {_eq: $conferenceId}, roomId: {_eq: $roomId}}
  ) {
    ...RoomParticipantDetails
  }
}
    ${RoomParticipantDetailsFragmentDoc}`;

/**
 * __useGetRoomParticipantsSubscription__
 *
 * To run a query within a React component, call `useGetRoomParticipantsSubscription` and pass it any options that fit your needs.
 * When your component renders, `useGetRoomParticipantsSubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetRoomParticipantsSubscription({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      roomId: // value for 'roomId'
 *   },
 * });
 */
export function useGetRoomParticipantsSubscription(baseOptions: Apollo.SubscriptionHookOptions<GetRoomParticipantsSubscription, GetRoomParticipantsSubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<GetRoomParticipantsSubscription, GetRoomParticipantsSubscriptionVariables>(GetRoomParticipantsDocument, options);
      }
export type GetRoomParticipantsSubscriptionHookResult = ReturnType<typeof useGetRoomParticipantsSubscription>;
export type GetRoomParticipantsSubscriptionResult = Apollo.SubscriptionResult<GetRoomParticipantsSubscription>;
export const GetAllRoomParticipantsDocument = gql`
    query GetAllRoomParticipants($conferenceId: uuid!) {
  RoomParticipant(where: {conferenceId: {_eq: $conferenceId}}) {
    ...RoomParticipantDetails
  }
}
    ${RoomParticipantDetailsFragmentDoc}`;

/**
 * __useGetAllRoomParticipantsQuery__
 *
 * To run a query within a React component, call `useGetAllRoomParticipantsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAllRoomParticipantsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAllRoomParticipantsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetAllRoomParticipantsQuery(baseOptions: Apollo.QueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, options);
      }
export function useGetAllRoomParticipantsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>(GetAllRoomParticipantsDocument, options);
        }
export type GetAllRoomParticipantsQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsQuery>;
export type GetAllRoomParticipantsLazyQueryHookResult = ReturnType<typeof useGetAllRoomParticipantsLazyQuery>;
export type GetAllRoomParticipantsQueryResult = Apollo.QueryResult<GetAllRoomParticipantsQuery, GetAllRoomParticipantsQueryVariables>;
export const MyShuffleQueueEntryDocument = gql`
    subscription MyShuffleQueueEntry($id: bigint!) {
  room_ShuffleQueueEntry_by_pk(id: $id) {
    ...SubdShuffleQueueEntryData
  }
}
    ${SubdShuffleQueueEntryDataFragmentDoc}`;

/**
 * __useMyShuffleQueueEntrySubscription__
 *
 * To run a query within a React component, call `useMyShuffleQueueEntrySubscription` and pass it any options that fit your needs.
 * When your component renders, `useMyShuffleQueueEntrySubscription` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the subscription, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useMyShuffleQueueEntrySubscription({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useMyShuffleQueueEntrySubscription(baseOptions: Apollo.SubscriptionHookOptions<MyShuffleQueueEntrySubscription, MyShuffleQueueEntrySubscriptionVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useSubscription<MyShuffleQueueEntrySubscription, MyShuffleQueueEntrySubscriptionVariables>(MyShuffleQueueEntryDocument, options);
      }
export type MyShuffleQueueEntrySubscriptionHookResult = ReturnType<typeof useMyShuffleQueueEntrySubscription>;
export type MyShuffleQueueEntrySubscriptionResult = Apollo.SubscriptionResult<MyShuffleQueueEntrySubscription>;
export const GetShuffleRoomDocument = gql`
    query GetShuffleRoom($id: bigint!) {
  room_ShuffleRoom_by_pk(id: $id) {
    id
    roomId
  }
}
    `;

/**
 * __useGetShuffleRoomQuery__
 *
 * To run a query within a React component, call `useGetShuffleRoomQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShuffleRoomQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShuffleRoomQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetShuffleRoomQuery(baseOptions: Apollo.QueryHookOptions<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>(GetShuffleRoomDocument, options);
      }
export function useGetShuffleRoomLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>(GetShuffleRoomDocument, options);
        }
export type GetShuffleRoomQueryHookResult = ReturnType<typeof useGetShuffleRoomQuery>;
export type GetShuffleRoomLazyQueryHookResult = ReturnType<typeof useGetShuffleRoomLazyQuery>;
export type GetShuffleRoomQueryResult = Apollo.QueryResult<GetShuffleRoomQuery, GetShuffleRoomQueryVariables>;
export const ShufflePeriodsDocument = gql`
    query ShufflePeriods($conferenceId: uuid!, $end: timestamptz!) {
  room_ShufflePeriod(
    where: {conferenceId: {_eq: $conferenceId}, endAt: {_gte: $end}}
  ) {
    ...ShufflePeriodData
  }
}
    ${ShufflePeriodDataFragmentDoc}`;

/**
 * __useShufflePeriodsQuery__
 *
 * To run a query within a React component, call `useShufflePeriodsQuery` and pass it any options that fit your needs.
 * When your component renders, `useShufflePeriodsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useShufflePeriodsQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *      end: // value for 'end'
 *   },
 * });
 */
export function useShufflePeriodsQuery(baseOptions: Apollo.QueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, options);
      }
export function useShufflePeriodsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>(ShufflePeriodsDocument, options);
        }
export type ShufflePeriodsQueryHookResult = ReturnType<typeof useShufflePeriodsQuery>;
export type ShufflePeriodsLazyQueryHookResult = ReturnType<typeof useShufflePeriodsLazyQuery>;
export type ShufflePeriodsQueryResult = Apollo.QueryResult<ShufflePeriodsQuery, ShufflePeriodsQueryVariables>;
export const JoinShuffleQueueDocument = gql`
    mutation JoinShuffleQueue($shufflePeriodId: uuid!, $attendeeId: uuid!) {
  insert_room_ShuffleQueueEntry_one(
    object: {attendeeId: $attendeeId, shufflePeriodId: $shufflePeriodId}
  ) {
    ...PrefetchShuffleQueueEntryData
  }
}
    ${PrefetchShuffleQueueEntryDataFragmentDoc}`;
export type JoinShuffleQueueMutationFn = Apollo.MutationFunction<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;

/**
 * __useJoinShuffleQueueMutation__
 *
 * To run a mutation, you first call `useJoinShuffleQueueMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useJoinShuffleQueueMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [joinShuffleQueueMutation, { data, loading, error }] = useJoinShuffleQueueMutation({
 *   variables: {
 *      shufflePeriodId: // value for 'shufflePeriodId'
 *      attendeeId: // value for 'attendeeId'
 *   },
 * });
 */
export function useJoinShuffleQueueMutation(baseOptions?: Apollo.MutationHookOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>(JoinShuffleQueueDocument, options);
      }
export type JoinShuffleQueueMutationHookResult = ReturnType<typeof useJoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationResult = Apollo.MutationResult<JoinShuffleQueueMutation>;
export type JoinShuffleQueueMutationOptions = Apollo.BaseMutationOptions<JoinShuffleQueueMutation, JoinShuffleQueueMutationVariables>;
export const GetShuffleRoomsParticipantsCountDocument = gql`
    query GetShuffleRoomsParticipantsCount($conferenceId: uuid!) {
  RoomParticipant_aggregate(
    where: {conferenceId: {_eq: $conferenceId}, room: {shuffleRooms: {isEnded: {_eq: false}}}}
  ) {
    aggregate {
      count
    }
  }
}
    `;

/**
 * __useGetShuffleRoomsParticipantsCountQuery__
 *
 * To run a query within a React component, call `useGetShuffleRoomsParticipantsCountQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShuffleRoomsParticipantsCountQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShuffleRoomsParticipantsCountQuery({
 *   variables: {
 *      conferenceId: // value for 'conferenceId'
 *   },
 * });
 */
export function useGetShuffleRoomsParticipantsCountQuery(baseOptions: Apollo.QueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, options);
      }
export function useGetShuffleRoomsParticipantsCountLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>(GetShuffleRoomsParticipantsCountDocument, options);
        }
export type GetShuffleRoomsParticipantsCountQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountQuery>;
export type GetShuffleRoomsParticipantsCountLazyQueryHookResult = ReturnType<typeof useGetShuffleRoomsParticipantsCountLazyQuery>;
export type GetShuffleRoomsParticipantsCountQueryResult = Apollo.QueryResult<GetShuffleRoomsParticipantsCountQuery, GetShuffleRoomsParticipantsCountQueryVariables>;
export const SelectCurrentUserDocument = gql`
    query SelectCurrentUser($userId: String!) {
  User_by_pk(id: $userId) {
    ...UserInfo
  }
}
    ${UserInfoFragmentDoc}`;

/**
 * __useSelectCurrentUserQuery__
 *
 * To run a query within a React component, call `useSelectCurrentUserQuery` and pass it any options that fit your needs.
 * When your component renders, `useSelectCurrentUserQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSelectCurrentUserQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useSelectCurrentUserQuery(baseOptions: Apollo.QueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, options);
      }
export function useSelectCurrentUserLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>(SelectCurrentUserDocument, options);
        }
export type SelectCurrentUserQueryHookResult = ReturnType<typeof useSelectCurrentUserQuery>;
export type SelectCurrentUserLazyQueryHookResult = ReturnType<typeof useSelectCurrentUserLazyQuery>;
export type SelectCurrentUserQueryResult = Apollo.QueryResult<SelectCurrentUserQuery, SelectCurrentUserQueryVariables>;
export const TermsConfigsDocument = gql`
    query TermsConfigs {
  hostOrganisationName: system_Configuration_by_pk(key: HOST_ORGANISATION_NAME) {
    key
    value
    updated_at
  }
  termsTimestamp: system_Configuration_by_pk(key: TERMS_LATEST_REVISION_TIMESTAMP) {
    key
    value
    updated_at
  }
  termsURL: system_Configuration_by_pk(key: TERMS_URL) {
    key
    value
    updated_at
  }
  ppTimestamp: system_Configuration_by_pk(
    key: PRIVACY_POLICY_LATEST_REVISION_TIMESTAMP
  ) {
    key
    value
    updated_at
  }
  ppURL: system_Configuration_by_pk(key: PRIVACY_POLICY_URL) {
    key
    value
    updated_at
  }
  cookiesTimestamp: system_Configuration_by_pk(
    key: COOKIE_POLICY_LATEST_REVISION_TIMESTAMP
  ) {
    key
    value
    updated_at
  }
  cookiesURL: system_Configuration_by_pk(key: COOKIE_POLICY_URL) {
    key
    value
    updated_at
  }
}
    `;

/**
 * __useTermsConfigsQuery__
 *
 * To run a query within a React component, call `useTermsConfigsQuery` and pass it any options that fit your needs.
 * When your component renders, `useTermsConfigsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useTermsConfigsQuery({
 *   variables: {
 *   },
 * });
 */
export function useTermsConfigsQuery(baseOptions?: Apollo.QueryHookOptions<TermsConfigsQuery, TermsConfigsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<TermsConfigsQuery, TermsConfigsQueryVariables>(TermsConfigsDocument, options);
      }
export function useTermsConfigsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<TermsConfigsQuery, TermsConfigsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<TermsConfigsQuery, TermsConfigsQueryVariables>(TermsConfigsDocument, options);
        }
export type TermsConfigsQueryHookResult = ReturnType<typeof useTermsConfigsQuery>;
export type TermsConfigsLazyQueryHookResult = ReturnType<typeof useTermsConfigsLazyQuery>;
export type TermsConfigsQueryResult = Apollo.QueryResult<TermsConfigsQuery, TermsConfigsQueryVariables>;
export const AgreeToTermsDocument = gql`
    mutation AgreeToTerms($userId: String!, $at: timestamptz!) {
  update_User_by_pk(
    pk_columns: {id: $userId}
    _set: {acceptedTermsAt: $at, acceptedPrivacyPolicyAt: $at}
  ) {
    id
    acceptedTermsAt
    acceptedPrivacyPolicyAt
  }
}
    `;
export type AgreeToTermsMutationFn = Apollo.MutationFunction<AgreeToTermsMutation, AgreeToTermsMutationVariables>;

/**
 * __useAgreeToTermsMutation__
 *
 * To run a mutation, you first call `useAgreeToTermsMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAgreeToTermsMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [agreeToTermsMutation, { data, loading, error }] = useAgreeToTermsMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      at: // value for 'at'
 *   },
 * });
 */
export function useAgreeToTermsMutation(baseOptions?: Apollo.MutationHookOptions<AgreeToTermsMutation, AgreeToTermsMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AgreeToTermsMutation, AgreeToTermsMutationVariables>(AgreeToTermsDocument, options);
      }
export type AgreeToTermsMutationHookResult = ReturnType<typeof useAgreeToTermsMutation>;
export type AgreeToTermsMutationResult = Apollo.MutationResult<AgreeToTermsMutation>;
export type AgreeToTermsMutationOptions = Apollo.BaseMutationOptions<AgreeToTermsMutation, AgreeToTermsMutationVariables>;
export const GetCurrentUserIsIncognitoDocument = gql`
    query getCurrentUserIsIncognito($userId: String!) {
  OnlineStatus(where: {userId: {_eq: $userId}}) {
    id
    isIncognito
  }
}
    `;

/**
 * __useGetCurrentUserIsIncognitoQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserIsIncognitoQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserIsIncognitoQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserIsIncognitoQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetCurrentUserIsIncognitoQuery(baseOptions: Apollo.QueryHookOptions<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>(GetCurrentUserIsIncognitoDocument, options);
      }
export function useGetCurrentUserIsIncognitoLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>(GetCurrentUserIsIncognitoDocument, options);
        }
export type GetCurrentUserIsIncognitoQueryHookResult = ReturnType<typeof useGetCurrentUserIsIncognitoQuery>;
export type GetCurrentUserIsIncognitoLazyQueryHookResult = ReturnType<typeof useGetCurrentUserIsIncognitoLazyQuery>;
export type GetCurrentUserIsIncognitoQueryResult = Apollo.QueryResult<GetCurrentUserIsIncognitoQuery, GetCurrentUserIsIncognitoQueryVariables>;
export const UpdateCurrentUserIsIncognitoDocument = gql`
    mutation updateCurrentUserIsIncognito($userId: String!, $isIncognito: Boolean = false) {
  update_OnlineStatus(
    _set: {isIncognito: $isIncognito}
    where: {userId: {_eq: $userId}}
  ) {
    returning {
      id
      isIncognito
    }
  }
}
    `;
export type UpdateCurrentUserIsIncognitoMutationFn = Apollo.MutationFunction<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>;

/**
 * __useUpdateCurrentUserIsIncognitoMutation__
 *
 * To run a mutation, you first call `useUpdateCurrentUserIsIncognitoMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCurrentUserIsIncognitoMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCurrentUserIsIncognitoMutation, { data, loading, error }] = useUpdateCurrentUserIsIncognitoMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      isIncognito: // value for 'isIncognito'
 *   },
 * });
 */
export function useUpdateCurrentUserIsIncognitoMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>(UpdateCurrentUserIsIncognitoDocument, options);
      }
export type UpdateCurrentUserIsIncognitoMutationHookResult = ReturnType<typeof useUpdateCurrentUserIsIncognitoMutation>;
export type UpdateCurrentUserIsIncognitoMutationResult = Apollo.MutationResult<UpdateCurrentUserIsIncognitoMutation>;
export type UpdateCurrentUserIsIncognitoMutationOptions = Apollo.BaseMutationOptions<UpdateCurrentUserIsIncognitoMutation, UpdateCurrentUserIsIncognitoMutationVariables>;
export const GetCurrentUserLastSeenDocument = gql`
    query getCurrentUserLastSeen($userId: String!) {
  OnlineStatus(where: {userId: {_eq: $userId}}) {
    id
    lastSeen
  }
}
    `;

/**
 * __useGetCurrentUserLastSeenQuery__
 *
 * To run a query within a React component, call `useGetCurrentUserLastSeenQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCurrentUserLastSeenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCurrentUserLastSeenQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetCurrentUserLastSeenQuery(baseOptions: Apollo.QueryHookOptions<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>(GetCurrentUserLastSeenDocument, options);
      }
export function useGetCurrentUserLastSeenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>(GetCurrentUserLastSeenDocument, options);
        }
export type GetCurrentUserLastSeenQueryHookResult = ReturnType<typeof useGetCurrentUserLastSeenQuery>;
export type GetCurrentUserLastSeenLazyQueryHookResult = ReturnType<typeof useGetCurrentUserLastSeenLazyQuery>;
export type GetCurrentUserLastSeenQueryResult = Apollo.QueryResult<GetCurrentUserLastSeenQuery, GetCurrentUserLastSeenQueryVariables>;
export const InsertCurrentUserOnlineStatusDocument = gql`
    mutation insertCurrentUserOnlineStatus($userId: String!) {
  insert_OnlineStatus(objects: {userId: $userId, isIncognito: false}) {
    returning {
      id
      isIncognito
      lastSeen
      userId
    }
  }
}
    `;
export type InsertCurrentUserOnlineStatusMutationFn = Apollo.MutationFunction<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>;

/**
 * __useInsertCurrentUserOnlineStatusMutation__
 *
 * To run a mutation, you first call `useInsertCurrentUserOnlineStatusMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useInsertCurrentUserOnlineStatusMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [insertCurrentUserOnlineStatusMutation, { data, loading, error }] = useInsertCurrentUserOnlineStatusMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useInsertCurrentUserOnlineStatusMutation(baseOptions?: Apollo.MutationHookOptions<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>(InsertCurrentUserOnlineStatusDocument, options);
      }
export type InsertCurrentUserOnlineStatusMutationHookResult = ReturnType<typeof useInsertCurrentUserOnlineStatusMutation>;
export type InsertCurrentUserOnlineStatusMutationResult = Apollo.MutationResult<InsertCurrentUserOnlineStatusMutation>;
export type InsertCurrentUserOnlineStatusMutationOptions = Apollo.BaseMutationOptions<InsertCurrentUserOnlineStatusMutation, InsertCurrentUserOnlineStatusMutationVariables>;
export const UpdateCurrentUserLastSeenDocument = gql`
    mutation updateCurrentUserLastSeen($userId: String!, $lastSeen: timestamptz) {
  update_OnlineStatus(
    _set: {lastSeen: $lastSeen}
    where: {userId: {_eq: $userId}}
  ) {
    returning {
      id
      lastSeen
    }
  }
}
    `;
export type UpdateCurrentUserLastSeenMutationFn = Apollo.MutationFunction<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>;

/**
 * __useUpdateCurrentUserLastSeenMutation__
 *
 * To run a mutation, you first call `useUpdateCurrentUserLastSeenMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCurrentUserLastSeenMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCurrentUserLastSeenMutation, { data, loading, error }] = useUpdateCurrentUserLastSeenMutation({
 *   variables: {
 *      userId: // value for 'userId'
 *      lastSeen: // value for 'lastSeen'
 *   },
 * });
 */
export function useUpdateCurrentUserLastSeenMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>(UpdateCurrentUserLastSeenDocument, options);
      }
export type UpdateCurrentUserLastSeenMutationHookResult = ReturnType<typeof useUpdateCurrentUserLastSeenMutation>;
export type UpdateCurrentUserLastSeenMutationResult = Apollo.MutationResult<UpdateCurrentUserLastSeenMutation>;
export type UpdateCurrentUserLastSeenMutationOptions = Apollo.BaseMutationOptions<UpdateCurrentUserLastSeenMutation, UpdateCurrentUserLastSeenMutationVariables>;